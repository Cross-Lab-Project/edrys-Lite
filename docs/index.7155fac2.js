// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kbofY":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "42036d7a98ade5a7";
module.bundle.HMR_BUNDLE_ID = "655d34367155fac2";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"57jqn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "navigateTo", ()=>navigateTo);
var _vue = require("vue");
var _indexVue = require("./views/Index.vue");
var _indexVueDefault = parcelHelpers.interopDefault(_indexVue);
var _classroomVue = require("./views/Classroom.vue");
var _classroomVueDefault = parcelHelpers.interopDefault(_classroomVue);
// Vuetify
var _vuetifyMinCss = require("vuetify/dist/vuetify.min.css");
var _vuetify = require("vuetify");
var _mdiMjs = require("../node_modules/vuetify/lib/iconsets/mdi.mjs");
var _components = require("../node_modules/vuetify/lib/components");
var _directives = require("../node_modules/vuetify/lib/directives");
var _mainScss = require("./assets/scss/main.scss");
var _database = require("./ts/Database");
var _databaseDefault = parcelHelpers.interopDefault(_database);
var _comm = require("./ts/Comm");
var _commDefault = parcelHelpers.interopDefault(_comm);
var app;
var peers = {};
const init = ()=>{
    const database = new (0, _databaseDefault.default)();
    window["edrys"] = {
        database,
        index: []
    };
};
const load = async ()=>{
    window["edrys"].index = await window["edrys"].database.getAll();
};
const seed = ()=>{
    for (const item of window["edrys"].index)if (!peers[item.id]) {
        console.warn("client does not exists", item.id);
        const comm = new (0, _commDefault.default)(item);
        peers[item.id] = comm;
    }
};
const pathToRegex = (path)=>new RegExp("^" + path.replace(/\//g, "\\/").replace(/:\w+/g, "(.+)") + "$");
const getParams = (match)=>{
    const values = match.result.slice(1);
    const keys = Array.from(match.route.path.matchAll(/:(\w+)/g)).map((result)=>result[1]);
    let params = Object.fromEntries(keys.map((key, i)=>{
        return [
            key,
            values[i]
        ];
    }));
    if (match.params) params = {
        ...params,
        ...match.params
    };
    return params;
};
const navigateTo = (url, replace)=>{
    if (replace) history.replaceState(null, "", url);
    else history.pushState(null, "", url);
    router();
};
const router = async ()=>{
    if (!window["edrys"]) init();
    await load();
    seed();
    const routes = [
        {
            path: "/",
            view: (0, _indexVueDefault.default)
        },
        {
            path: "/classroom/:id",
            view: (0, _classroomVueDefault.default),
            params: {
                station: false
            }
        },
        {
            path: "/station/:id",
            view: (0, _classroomVueDefault.default),
            params: {
                station: true
            }
        }
    ];
    const potentialMatches = routes.map((route)=>{
        return {
            route: route,
            result: location.search.slice(1).match(pathToRegex(route.path)),
            redirect: route.redirect,
            params: route.params
        };
    });
    let match = potentialMatches.find((potentialMatches)=>potentialMatches.result !== null);
    if (!match) match = {
        route: routes[0],
        result: [
            location.search
        ]
    };
    if (match.redirect) {
        navigateTo(match.redirect, true);
        return;
    }
    const params = getParams(match);
    const view = match.route.view;
    const vuetify = (0, _vuetify.createVuetify)({
        components: _components,
        directives: _directives,
        icons: {
            defaultSet: "mdi",
            aliases: (0, _mdiMjs.aliases),
            sets: {
                mdi: (0, _mdiMjs.mdi)
            }
        }
    });
    if (params.id) params.comm = peers[params.id];
    app?.unmount();
    app = (0, _vue.createApp)(view, params);
    app.use(vuetify);
    app.mount(document.body);
};
window.addEventListener("popstate", router);
document.addEventListener("DOMContentLoaded", ()=>{
    document.body.addEventListener("click", (e)=>{
        if (e.target && e.target.matches("[data-link]")) {
            e.preventDefault();
            navigateTo(e.target.href);
        }
    });
    router();
});

},{"vue":"ff77s","./views/Index.vue":"3XNOl","./views/Classroom.vue":"7eaj4","vuetify/dist/vuetify.min.css":"451o5","vuetify":"fBTzQ","../node_modules/vuetify/lib/iconsets/mdi.mjs":"hVW1u","../node_modules/vuetify/lib/components":"4RJCr","../node_modules/vuetify/lib/directives":"eAmda","./assets/scss/main.scss":"bfPBV","./ts/Database":"hn5oJ","./ts/Comm":"6TTUj","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ff77s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compile", ()=>compile);
var _runtimeDom = require("@vue/runtime-dom");
parcelHelpers.exportAll(_runtimeDom, exports);
function initDev() {
    (0, _runtimeDom.initCustomFormatter)();
}
initDev();
const compile = ()=>{
    (0, _runtimeDom.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
};

},{"@vue/runtime-dom":"65Nbr","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"65Nbr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Transition", ()=>Transition);
parcelHelpers.export(exports, "TransitionGroup", ()=>TransitionGroup);
parcelHelpers.export(exports, "VueElement", ()=>VueElement);
parcelHelpers.export(exports, "createApp", ()=>createApp);
parcelHelpers.export(exports, "createSSRApp", ()=>createSSRApp);
parcelHelpers.export(exports, "defineCustomElement", ()=>defineCustomElement);
parcelHelpers.export(exports, "defineSSRCustomElement", ()=>defineSSRCustomElement);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "initDirectivesForSSR", ()=>initDirectivesForSSR);
parcelHelpers.export(exports, "render", ()=>render);
parcelHelpers.export(exports, "useCssModule", ()=>useCssModule);
parcelHelpers.export(exports, "useCssVars", ()=>useCssVars);
parcelHelpers.export(exports, "vModelCheckbox", ()=>vModelCheckbox);
parcelHelpers.export(exports, "vModelDynamic", ()=>vModelDynamic);
parcelHelpers.export(exports, "vModelRadio", ()=>vModelRadio);
parcelHelpers.export(exports, "vModelSelect", ()=>vModelSelect);
parcelHelpers.export(exports, "vModelText", ()=>vModelText);
parcelHelpers.export(exports, "vShow", ()=>vShow);
parcelHelpers.export(exports, "withKeys", ()=>withKeys);
parcelHelpers.export(exports, "withModifiers", ()=>withModifiers);
var _runtimeCore = require("@vue/runtime-core");
parcelHelpers.exportAll(_runtimeCore, exports);
var _shared = require("@vue/shared");
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
    insert: (child, parent, anchor)=>{
        parent.insertBefore(child, anchor || null);
    },
    remove: (child)=>{
        const parent = child.parentNode;
        if (parent) parent.removeChild(child);
    },
    createElement: (tag, isSVG, is, props)=>{
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
            is
        } : void 0);
        if (tag === "select" && props && props.multiple != null) el.setAttribute("multiple", props.multiple);
        return el;
    },
    createText: (text)=>doc.createTextNode(text),
    createComment: (text)=>doc.createComment(text),
    setText: (node, text)=>{
        node.nodeValue = text;
    },
    setElementText: (el, text)=>{
        el.textContent = text;
    },
    parentNode: (node)=>node.parentNode,
    nextSibling: (node)=>node.nextSibling,
    querySelector: (selector)=>doc.querySelector(selector),
    setScopeId (el, id) {
        el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent (content, parent, anchor, isSVG, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) while(true){
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling)) break;
        }
        else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                const wrapper = template.firstChild;
                while(wrapper.firstChild)template.appendChild(wrapper.firstChild);
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};
function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) value = (value ? [
        value,
        ...transitionClasses
    ] : [
        ...transitionClasses
    ]).join(" ");
    if (value == null) el.removeAttribute("class");
    else if (isSVG) el.setAttribute("class", value);
    else el.className = value;
}
function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = (0, _shared.isString)(next);
    if (next && !isCssString) {
        if (prev && !(0, _shared.isString)(prev)) {
            for(const key in prev)if (next[key] == null) setStyle(style, key, "");
        }
        for(const key in next)setStyle(style, key, next[key]);
    } else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) style.cssText = next;
        } else if (prev) el.removeAttribute("style");
        if ("_vod" in el) style.display = currentDisplay;
    }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0, _shared.isArray)(val)) val.forEach((v)=>setStyle(style, name, v));
    else {
        if (val == null) val = "";
        if (semicolonRE.test(val)) (0, _runtimeCore.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
        if (name.startsWith("--")) style.setProperty(name, val);
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) style.setProperty((0, _shared.hyphenate)(prefixed), val.replace(importantRE, ""), "important");
            else style[prefixed] = val;
        }
    }
}
const prefixes = [
    "Webkit",
    "Moz",
    "ms"
];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) return cached;
    let name = (0, _runtimeCore.camelize)(rawName);
    if (name !== "filter" && name in style) return prefixCache[rawName] = name;
    name = (0, _shared.capitalize)(name);
    for(let i = 0; i < prefixes.length; i++){
        const prefixed = prefixes[i] + name;
        if (prefixed in style) return prefixCache[rawName] = prefixed;
    }
    return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
        if (value == null) el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        else el.setAttributeNS(xlinkNS, key, value);
    } else {
        const isBoolean = (0, _shared.isSpecialBooleanAttr)(key);
        if (value == null || isBoolean && !(0, _shared.includeBooleanAttr)(value)) el.removeAttribute(key);
        else el.setAttribute(key, isBoolean ? "" : value);
    }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) unmountChildren(prevChildren, parentComponent, parentSuspense);
        el[key] = value == null ? "" : value;
        return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) el.value = newValue;
        if (value == null) el.removeAttribute(key);
        return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") value = (0, _shared.includeBooleanAttr)(value);
        else if (value == null && type === "string") {
            value = "";
            needRemove = true;
        } else if (type === "number") {
            value = 0;
            needRemove = true;
        }
    }
    try {
        el[key] = value;
    } catch (e) {
        if (!needRemove) (0, _runtimeCore.warn)(`Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);
    }
    needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) existingInvoker.value = nextValue;
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while(m = name.match(optionsModifierRE)){
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    const event = name[2] === ":" ? name.slice(3) : (0, _shared.hyphenate)(name.slice(2));
    return [
        event,
        options
    ];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = ()=>cachedNow || (p.then(()=>cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
    const invoker = (e)=>{
        if (!e._vts) e._vts = Date.now();
        else if (e._vts <= invoker.attached) return;
        (0, _runtimeCore.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
            e
        ]);
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0, _shared.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = ()=>{
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
    } else return value;
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren)=>{
    if (key === "class") patchClass(el, nextValue, isSVG);
    else if (key === "style") patchStyle(el, prevValue, nextValue);
    else if ((0, _shared.isOn)(key)) {
        if (!(0, _shared.isModelListener)(key)) patchEvent(el, key, prevValue, nextValue, parentComponent);
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    else {
        if (key === "true-value") el._trueValue = nextValue;
        else if (key === "false-value") el._falseValue = nextValue;
        patchAttr(el, key, nextValue, isSVG);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        if (key === "innerHTML" || key === "textContent") return true;
        if (key in el && nativeOnRE.test(key) && (0, _shared.isFunction)(value)) return true;
        return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") return false;
    if (key === "form") return false;
    if (key === "list" && el.tagName === "INPUT") return false;
    if (key === "type" && el.tagName === "TEXTAREA") return false;
    if (nativeOnRE.test(key) && (0, _shared.isString)(value)) return false;
    return key in el;
}
function defineCustomElement(options, hydrate2) {
    const Comp = (0, _runtimeCore.defineComponent)(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps){
            super(Comp, initialProps, hydrate2);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = (options)=>{
    return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2){
        super();
        this._def = _def;
        this._props = _props;
        /**
     * @internal
     */ this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate2) hydrate2(this._createVNode(), this.shadowRoot);
        else {
            if (0, this.shadowRoot) (0, _runtimeCore.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            this.attachShadow({
                mode: "open"
            });
            if (!this._def.__asyncLoader) this._resolveProps(this._def);
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            if (this._resolved) this._update();
            else this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        (0, _runtimeCore.nextTick)(()=>{
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
   * resolve inner component definition (handle possible async component)
   */ _resolveDef() {
        this._resolved = true;
        for(let i = 0; i < this.attributes.length; i++)this._setAttr(this.attributes[i].name);
        new MutationObserver((mutations)=>{
            for (const m of mutations)this._setAttr(m.attributeName);
        }).observe(this, {
            attributes: true
        });
        const resolve = (def, isAsync = false)=>{
            const { props, styles } = def;
            let numberProps;
            if (props && !(0, _shared.isArray)(props)) for(const key in props){
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                    if (key in this._props) this._props[key] = (0, _shared.toNumber)(this._props[key]);
                    (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0, _shared.camelize)(key)] = true;
                }
            }
            this._numberProps = numberProps;
            if (isAsync) this._resolveProps(def);
            this._applyStyles(styles);
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) asyncDef().then((def)=>resolve(def, true));
        else resolve(this._def);
    }
    _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = (0, _shared.isArray)(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this))if (key[0] !== "_" && declaredPropKeys.includes(key)) this._setProp(key, this[key], true, false);
        for (const key of declaredPropKeys.map((0, _shared.camelize)))Object.defineProperty(this, key, {
            get () {
                return this._getProp(key);
            },
            set (val) {
                this._setProp(key, val);
            }
        });
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        const camelKey = (0, _shared.camelize)(key);
        if (this._numberProps && this._numberProps[camelKey]) value = (0, _shared.toNumber)(value);
        this._setProp(camelKey, value, false);
    }
    /**
   * @internal
   */ _getProp(key) {
        return this._props[key];
    }
    /**
   * @internal
   */ _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) this._update();
            if (shouldReflect) {
                if (val === true) this.setAttribute((0, _shared.hyphenate)(key), "");
                else if (typeof val === "string" || typeof val === "number") this.setAttribute((0, _shared.hyphenate)(key), val + "");
                else if (!val) this.removeAttribute((0, _shared.hyphenate)(key));
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = (0, _runtimeCore.createVNode)(this._def, (0, _shared.extend)({}, this._props));
        if (!this._instance) vnode.ce = (instance)=>{
            this._instance = instance;
            instance.isCE = true;
            instance.ceReload = (newStyles)=>{
                if (this._styles) {
                    this._styles.forEach((s)=>this.shadowRoot.removeChild(s));
                    this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
            };
            const dispatch = (event, args)=>{
                this.dispatchEvent(new CustomEvent(event, {
                    detail: args
                }));
            };
            instance.emit = (event, ...args)=>{
                dispatch(event, args);
                if ((0, _shared.hyphenate)(event) !== event) dispatch((0, _shared.hyphenate)(event), args);
            };
            let parent = this;
            while(parent = parent && (parent.parentNode || parent.host))if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
            }
        };
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) styles.forEach((css)=>{
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            (this._styles || (this._styles = [])).push(s);
        });
    }
}
function useCssModule(name = "$style") {
    {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        if (!instance) {
            (0, _runtimeCore.warn)(`useCssModule must be called inside setup()`);
            return 0, _shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS modules injected.`);
            return 0, _shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            (0, _runtimeCore.warn)(`Current instance does not have CSS module named "${name}".`);
            return 0, _shared.EMPTY_OBJ;
        }
        return mod;
    }
}
function useCssVars(getter) {
    const instance = (0, _runtimeCore.getCurrentInstance)();
    if (!instance) {
        (0, _runtimeCore.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy))=>{
        Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node)=>setVarsOnNode(node, vars));
    };
    const setVars = ()=>{
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
    };
    (0, _runtimeCore.watchPostEffect)(setVars);
    (0, _runtimeCore.onMounted)(()=>{
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, {
            childList: true
        });
        (0, _runtimeCore.onUnmounted)(()=>ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) suspense.effects.push(()=>{
            setVarsOnVNode(suspense.activeBranch, vars);
        });
    }
    while(vnode.component)vnode = vnode.component.subTree;
    if (vnode.shapeFlag & 1 && vnode.el) setVarsOnNode(vnode.el, vars);
    else if (vnode.type === (0, _runtimeCore.Fragment)) vnode.children.forEach((c)=>setVarsOnVNode(c, vars));
    else if (vnode.type === (0, _runtimeCore.Static)) {
        let { el, anchor } = vnode;
        while(el){
            setVarsOnNode(el, vars);
            if (el === anchor) break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for(const key in vars)style.setProperty(`--${key}`, vars[key]);
    }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots })=>(0, _runtimeCore.h)((0, _runtimeCore.BaseTransition), resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [
        String,
        Number,
        Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ (0, _shared.extend)({}, (0, _runtimeCore.BaseTransitionPropsValidators), DOMTransitionPropsValidators);
const callHook = (hook, args = [])=>{
    if ((0, _shared.isArray)(hook)) hook.forEach((h2)=>h2(...args));
    else if (hook) hook(...args);
};
const hasExplicitCallback = (hook)=>{
    return hook ? (0, _shared.isArray)(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for(const key in rawProps)if (!(key in DOMTransitionPropsValidators)) baseProps[key] = rawProps[key];
    if (rawProps.css === false) return baseProps;
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done)=>{
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done)=>{
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear)=>{
        return (el, done)=>{
            const hook = isAppear ? onAppear : onEnter;
            const resolve = ()=>finishEnter(el, isAppear, done);
            callHook(hook, [
                el,
                resolve
            ]);
            nextFrame(()=>{
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) whenTransitionEnds(el, type, enterDuration, resolve);
            });
        };
    };
    return (0, _shared.extend)(baseProps, {
        onBeforeEnter (el) {
            callHook(onBeforeEnter, [
                el
            ]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear (el) {
            callHook(onBeforeAppear, [
                el
            ]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave (el, done) {
            el._isLeaving = true;
            const resolve = ()=>finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(()=>{
                if (!el._isLeaving) return;
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) whenTransitionEnds(el, type, leaveDuration, resolve);
            });
            callHook(onLeave, [
                el,
                resolve
            ]);
        },
        onEnterCancelled (el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [
                el
            ]);
        },
        onAppearCancelled (el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [
                el
            ]);
        },
        onLeaveCancelled (el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [
                el
            ]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) return null;
    else if ((0, _shared.isObject)(duration)) return [
        NumberOf(duration.enter),
        NumberOf(duration.leave)
    ];
    else {
        const n = NumberOf(duration);
        return [
            n,
            n
        ];
    }
}
function NumberOf(val) {
    const res = (0, _shared.toNumber)(val);
    (0, _runtimeCore.assertNumber)(res, "<transition> explicit duration");
    return res;
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
    (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) el._vtc = void 0;
    }
}
function nextFrame(cb) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = ()=>{
        if (id === el._endId) resolve();
    };
    if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) return resolve();
    const endEvent = type + "end";
    let ended = 0;
    const end = ()=>{
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e)=>{
        if (e.target === el && ++ended >= propCount) end();
    };
    setTimeout(()=>{
        if (ended < propCount) end();
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key)=>(styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while(delays.length < durations.length)delays = delays.concat(delays);
    return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
}
function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
    return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ (0, _shared.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup (props, { slots }) {
        const instance = (0, _runtimeCore.getCurrentInstance)();
        const state = (0, _runtimeCore.useTransitionState)();
        let prevChildren;
        let children;
        (0, _runtimeCore.onUpdated)(()=>{
            if (!prevChildren.length) return;
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c)=>{
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = "";
                const cb = el._moveCb = (e)=>{
                    if (e && e.target !== el) return;
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener("transitionend", cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                };
                el.addEventListener("transitionend", cb);
            });
        });
        return ()=>{
            const rawProps = (0, _runtimeCore.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || (0, _runtimeCore.Fragment);
            prevChildren = children;
            children = slots.default ? (0, _runtimeCore.getTransitionRawChildren)(slots.default()) : [];
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                if (child.key != null) (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                else (0, _runtimeCore.warn)(`<TransitionGroup> children must be keyed.`);
            }
            if (prevChildren) for(let i = 0; i < prevChildren.length; i++){
                const child = prevChildren[i];
                (0, _runtimeCore.setTransitionHooks)(child, (0, _runtimeCore.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
            }
            return (0, _runtimeCore.createVNode)(tag, null, children);
        };
    }
};
const removeMode = (props)=>delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) el._moveCb();
    if (el._enterCb) el._enterCb();
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    if (el._vtc) el._vtc.forEach((cls)=>{
        cls.split(/\s+/).forEach((c)=>c && clone.classList.remove(c));
    });
    moveClass.split(/\s+/).forEach((c)=>c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}
const getModelAssigner = (vnode)=>{
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return (0, _shared.isArray)(fn) ? (value)=>(0, _shared.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
    }
}
const vModelText = {
    created (el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e)=>{
            if (e.target.composing) return;
            let domValue = el.value;
            if (trim) domValue = domValue.trim();
            if (castToNumber) domValue = (0, _shared.looseToNumber)(domValue);
            el._assign(domValue);
        });
        if (trim) addEventListener(el, "change", ()=>{
            el.value = el.value.trim();
        });
        if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted (el, { value }) {
        el.value = value == null ? "" : value;
    },
    beforeUpdate (el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing) return;
        if (document.activeElement === el && el.type !== "range") {
            if (lazy) return;
            if (trim && el.value.trim() === value) return;
            if ((number || el.type === "number") && (0, _shared.looseToNumber)(el.value) === value) return;
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) el.value = newValue;
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created (el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0, _shared.isArray)(modelValue)) {
                const index = (0, _shared.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) assign(modelValue.concat(elementValue));
                else if (!checked && found) {
                    const filtered = [
                        ...modelValue
                    ];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            } else if ((0, _shared.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) cloned.add(elementValue);
                else cloned.delete(elementValue);
                assign(cloned);
            } else assign(getCheckboxValue(el, checked));
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate (el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0, _shared.isArray)(value)) el.checked = (0, _shared.looseIndexOf)(value, vnode.props.value) > -1;
    else if ((0, _shared.isSet)(value)) el.checked = value.has(vnode.props.value);
    else if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, getCheckboxValue(el, true));
}
const vModelRadio = {
    created (el, { value }, vnode) {
        el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", ()=>{
            el._assign(getValue(el));
        });
    },
    beforeUpdate (el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) el.checked = (0, _shared.looseEqual)(value, vnode.props.value);
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created (el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0, _shared.isSet)(value);
        addEventListener(el, "change", ()=>{
            const selectedVal = Array.prototype.filter.call(el.options, (o)=>o.selected).map((o)=>number ? (0, _shared.looseToNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted (el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate (el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated (el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0, _shared.isArray)(value) && !(0, _shared.isSet)(value)) {
        (0, _runtimeCore.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for(let i = 0, l = el.options.length; i < l; i++){
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0, _shared.isArray)(value)) option.selected = (0, _shared.looseIndexOf)(value, optionValue) > -1;
            else option.selected = value.has(optionValue);
        } else if ((0, _shared.looseEqual)(getValue(option), value)) {
            if (el.selectedIndex !== i) el.selectedIndex = i;
            return;
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) el.selectedIndex = -1;
}
function getValue(el) {
    return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
    },
    mounted (el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated (el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
    }
};
function resolveDynamicModel(tagName, type) {
    switch(tagName){
        case "SELECT":
            return vModelSelect;
        case "TEXTAREA":
            return vModelText;
        default:
            switch(type){
                case "checkbox":
                    return vModelCheckbox;
                case "radio":
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value })=>({
            value
        });
    vModelRadio.getSSRProps = ({ value }, vnode)=>{
        if (vnode.props && (0, _shared.looseEqual)(vnode.props.value, value)) return {
            checked: true
        };
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode)=>{
        if ((0, _shared.isArray)(value)) {
            if (vnode.props && (0, _shared.looseIndexOf)(value, vnode.props.value) > -1) return {
                checked: true
            };
        } else if ((0, _shared.isSet)(value)) {
            if (vnode.props && value.has(vnode.props.value)) return {
                checked: true
            };
        } else if (value) return {
            checked: true
        };
    };
    vModelDynamic.getSSRProps = (binding, vnode)=>{
        if (typeof vnode.type !== "string") return;
        const modelToUse = resolveDynamicModel(// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) return modelToUse.getSSRProps(binding, vnode);
    };
}
const systemModifiers = [
    "ctrl",
    "shift",
    "alt",
    "meta"
];
const modifierGuards = {
    stop: (e)=>e.stopPropagation(),
    prevent: (e)=>e.preventDefault(),
    self: (e)=>e.target !== e.currentTarget,
    ctrl: (e)=>!e.ctrlKey,
    shift: (e)=>!e.shiftKey,
    alt: (e)=>!e.altKey,
    meta: (e)=>!e.metaKey,
    left: (e)=>"button" in e && e.button !== 0,
    middle: (e)=>"button" in e && e.button !== 1,
    right: (e)=>"button" in e && e.button !== 2,
    exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers)=>{
    return (event, ...args)=>{
        for(let i = 0; i < modifiers.length; i++){
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers)) return;
        }
        return fn(event, ...args);
    };
};
const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
};
const withKeys = (fn, modifiers)=>{
    return (event)=>{
        if (!("key" in event)) return;
        const eventKey = (0, _shared.hyphenate)(event.key);
        if (modifiers.some((k)=>k === eventKey || keyNames[k] === eventKey)) return fn(event);
    };
};
const vShow = {
    beforeMount (el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) transition.beforeEnter(el);
        else setDisplay(el, value);
    },
    mounted (el, { value }, { transition }) {
        if (transition && value) transition.enter(el);
    },
    updated (el, { value, oldValue }, { transition }) {
        if (!value === !oldValue) return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            } else transition.leave(el, ()=>{
                setDisplay(el, false);
            });
        } else setDisplay(el, value);
    },
    beforeUnmount (el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value })=>{
        if (!value) return {
            style: {
                display: "none"
            }
        };
    };
}
const rendererOptions = /* @__PURE__ */ (0, _shared.extend)({
    patchProp
}, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0, _runtimeCore.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : (0, _runtimeCore.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
const render = (...args)=>{
    ensureRenderer().render(...args);
};
const hydrate = (...args)=>{
    ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args)=>{
    const app = ensureRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (!container) return;
        const component = app._component;
        if (!(0, _shared.isFunction)(component) && !component.render && !component.template) component.template = container.innerHTML;
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
        }
        return proxy;
    };
    return app;
};
const createSSRApp = (...args)=>{
    const app = ensureHydrationRenderer().createApp(...args);
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
    const { mount } = app;
    app.mount = (containerOrSelector)=>{
        const container = normalizeContainer(containerOrSelector);
        if (container) return mount(container, true, container instanceof SVGElement);
    };
    return app;
};
function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
        value: (tag)=>(0, _shared.isHTMLTag)(tag) || (0, _shared.isSVGTag)(tag),
        writable: false
    });
}
function injectCompilerOptionsCheck(app) {
    if ((0, _runtimeCore.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
            get () {
                return isCustomElement;
            },
            set () {
                (0, _runtimeCore.warn)(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
            get () {
                (0, _runtimeCore.warn)(msg);
                return compilerOptions;
            },
            set () {
                (0, _runtimeCore.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0, _shared.isString)(container)) {
        const res = document.querySelector(container);
        if (!res) (0, _runtimeCore.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        return res;
    }
    if ((0, window.ShadowRoot) && container instanceof window.ShadowRoot && container.mode === "closed") (0, _runtimeCore.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = ()=>{
    if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
    }
};

},{"@vue/runtime-core":"jzxpK","@vue/shared":"hPWoE","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jzxpK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>(0, _reactivity.EffectScope));
parcelHelpers.export(exports, "ReactiveEffect", ()=>(0, _reactivity.ReactiveEffect));
parcelHelpers.export(exports, "customRef", ()=>(0, _reactivity.customRef));
parcelHelpers.export(exports, "effect", ()=>(0, _reactivity.effect));
parcelHelpers.export(exports, "effectScope", ()=>(0, _reactivity.effectScope));
parcelHelpers.export(exports, "getCurrentScope", ()=>(0, _reactivity.getCurrentScope));
parcelHelpers.export(exports, "isProxy", ()=>(0, _reactivity.isProxy));
parcelHelpers.export(exports, "isReactive", ()=>(0, _reactivity.isReactive));
parcelHelpers.export(exports, "isReadonly", ()=>(0, _reactivity.isReadonly));
parcelHelpers.export(exports, "isRef", ()=>(0, _reactivity.isRef));
parcelHelpers.export(exports, "isShallow", ()=>(0, _reactivity.isShallow));
parcelHelpers.export(exports, "markRaw", ()=>(0, _reactivity.markRaw));
parcelHelpers.export(exports, "onScopeDispose", ()=>(0, _reactivity.onScopeDispose));
parcelHelpers.export(exports, "proxyRefs", ()=>(0, _reactivity.proxyRefs));
parcelHelpers.export(exports, "reactive", ()=>(0, _reactivity.reactive));
parcelHelpers.export(exports, "readonly", ()=>(0, _reactivity.readonly));
parcelHelpers.export(exports, "ref", ()=>(0, _reactivity.ref));
parcelHelpers.export(exports, "shallowReactive", ()=>(0, _reactivity.shallowReactive));
parcelHelpers.export(exports, "shallowReadonly", ()=>(0, _reactivity.shallowReadonly));
parcelHelpers.export(exports, "shallowRef", ()=>(0, _reactivity.shallowRef));
parcelHelpers.export(exports, "stop", ()=>(0, _reactivity.stop));
parcelHelpers.export(exports, "toRaw", ()=>(0, _reactivity.toRaw));
parcelHelpers.export(exports, "toRef", ()=>(0, _reactivity.toRef));
parcelHelpers.export(exports, "toRefs", ()=>(0, _reactivity.toRefs));
parcelHelpers.export(exports, "toValue", ()=>(0, _reactivity.toValue));
parcelHelpers.export(exports, "triggerRef", ()=>(0, _reactivity.triggerRef));
parcelHelpers.export(exports, "unref", ()=>(0, _reactivity.unref));
parcelHelpers.export(exports, "camelize", ()=>(0, _shared.camelize));
parcelHelpers.export(exports, "capitalize", ()=>(0, _shared.capitalize));
parcelHelpers.export(exports, "normalizeClass", ()=>(0, _shared.normalizeClass));
parcelHelpers.export(exports, "normalizeProps", ()=>(0, _shared.normalizeProps));
parcelHelpers.export(exports, "normalizeStyle", ()=>(0, _shared.normalizeStyle));
parcelHelpers.export(exports, "toDisplayString", ()=>(0, _shared.toDisplayString));
parcelHelpers.export(exports, "toHandlerKey", ()=>(0, _shared.toHandlerKey));
parcelHelpers.export(exports, "BaseTransition", ()=>BaseTransition);
parcelHelpers.export(exports, "BaseTransitionPropsValidators", ()=>BaseTransitionPropsValidators);
parcelHelpers.export(exports, "Comment", ()=>Comment);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "KeepAlive", ()=>KeepAlive);
parcelHelpers.export(exports, "Static", ()=>Static);
parcelHelpers.export(exports, "Suspense", ()=>Suspense);
parcelHelpers.export(exports, "Teleport", ()=>Teleport);
parcelHelpers.export(exports, "Text", ()=>Text);
parcelHelpers.export(exports, "assertNumber", ()=>assertNumber);
parcelHelpers.export(exports, "callWithAsyncErrorHandling", ()=>callWithAsyncErrorHandling);
parcelHelpers.export(exports, "callWithErrorHandling", ()=>callWithErrorHandling);
parcelHelpers.export(exports, "cloneVNode", ()=>cloneVNode);
parcelHelpers.export(exports, "compatUtils", ()=>compatUtils);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "createBlock", ()=>createBlock);
parcelHelpers.export(exports, "createCommentVNode", ()=>createCommentVNode);
parcelHelpers.export(exports, "createElementBlock", ()=>createElementBlock);
parcelHelpers.export(exports, "createElementVNode", ()=>createBaseVNode);
parcelHelpers.export(exports, "createHydrationRenderer", ()=>createHydrationRenderer);
parcelHelpers.export(exports, "createPropsRestProxy", ()=>createPropsRestProxy);
parcelHelpers.export(exports, "createRenderer", ()=>createRenderer);
parcelHelpers.export(exports, "createSlots", ()=>createSlots);
parcelHelpers.export(exports, "createStaticVNode", ()=>createStaticVNode);
parcelHelpers.export(exports, "createTextVNode", ()=>createTextVNode);
parcelHelpers.export(exports, "createVNode", ()=>createVNode);
parcelHelpers.export(exports, "defineAsyncComponent", ()=>defineAsyncComponent);
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
parcelHelpers.export(exports, "defineEmits", ()=>defineEmits);
parcelHelpers.export(exports, "defineExpose", ()=>defineExpose);
parcelHelpers.export(exports, "defineModel", ()=>defineModel);
parcelHelpers.export(exports, "defineOptions", ()=>defineOptions);
parcelHelpers.export(exports, "defineProps", ()=>defineProps);
parcelHelpers.export(exports, "defineSlots", ()=>defineSlots);
parcelHelpers.export(exports, "devtools", ()=>devtools);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getTransitionRawChildren", ()=>getTransitionRawChildren);
parcelHelpers.export(exports, "guardReactiveProps", ()=>guardReactiveProps);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "handleError", ()=>handleError);
parcelHelpers.export(exports, "hasInjectionContext", ()=>hasInjectionContext);
parcelHelpers.export(exports, "initCustomFormatter", ()=>initCustomFormatter);
parcelHelpers.export(exports, "inject", ()=>inject);
parcelHelpers.export(exports, "isMemoSame", ()=>isMemoSame);
parcelHelpers.export(exports, "isRuntimeOnly", ()=>isRuntimeOnly);
parcelHelpers.export(exports, "isVNode", ()=>isVNode);
parcelHelpers.export(exports, "mergeDefaults", ()=>mergeDefaults);
parcelHelpers.export(exports, "mergeModels", ()=>mergeModels);
parcelHelpers.export(exports, "mergeProps", ()=>mergeProps);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
parcelHelpers.export(exports, "onActivated", ()=>onActivated);
parcelHelpers.export(exports, "onBeforeMount", ()=>onBeforeMount);
parcelHelpers.export(exports, "onBeforeUnmount", ()=>onBeforeUnmount);
parcelHelpers.export(exports, "onBeforeUpdate", ()=>onBeforeUpdate);
parcelHelpers.export(exports, "onDeactivated", ()=>onDeactivated);
parcelHelpers.export(exports, "onErrorCaptured", ()=>onErrorCaptured);
parcelHelpers.export(exports, "onMounted", ()=>onMounted);
parcelHelpers.export(exports, "onRenderTracked", ()=>onRenderTracked);
parcelHelpers.export(exports, "onRenderTriggered", ()=>onRenderTriggered);
parcelHelpers.export(exports, "onServerPrefetch", ()=>onServerPrefetch);
parcelHelpers.export(exports, "onUnmounted", ()=>onUnmounted);
parcelHelpers.export(exports, "onUpdated", ()=>onUpdated);
parcelHelpers.export(exports, "openBlock", ()=>openBlock);
parcelHelpers.export(exports, "popScopeId", ()=>popScopeId);
parcelHelpers.export(exports, "provide", ()=>provide);
parcelHelpers.export(exports, "pushScopeId", ()=>pushScopeId);
parcelHelpers.export(exports, "queuePostFlushCb", ()=>queuePostFlushCb);
parcelHelpers.export(exports, "registerRuntimeCompiler", ()=>registerRuntimeCompiler);
parcelHelpers.export(exports, "renderList", ()=>renderList);
parcelHelpers.export(exports, "renderSlot", ()=>renderSlot);
parcelHelpers.export(exports, "resolveComponent", ()=>resolveComponent);
parcelHelpers.export(exports, "resolveDirective", ()=>resolveDirective);
parcelHelpers.export(exports, "resolveDynamicComponent", ()=>resolveDynamicComponent);
parcelHelpers.export(exports, "resolveFilter", ()=>resolveFilter);
parcelHelpers.export(exports, "resolveTransitionHooks", ()=>resolveTransitionHooks);
parcelHelpers.export(exports, "setBlockTracking", ()=>setBlockTracking);
parcelHelpers.export(exports, "setDevtoolsHook", ()=>setDevtoolsHook);
parcelHelpers.export(exports, "setTransitionHooks", ()=>setTransitionHooks);
parcelHelpers.export(exports, "ssrContextKey", ()=>ssrContextKey);
parcelHelpers.export(exports, "ssrUtils", ()=>ssrUtils);
parcelHelpers.export(exports, "toHandlers", ()=>toHandlers);
parcelHelpers.export(exports, "transformVNodeArgs", ()=>transformVNodeArgs);
parcelHelpers.export(exports, "useAttrs", ()=>useAttrs);
parcelHelpers.export(exports, "useModel", ()=>useModel);
parcelHelpers.export(exports, "useSSRContext", ()=>useSSRContext);
parcelHelpers.export(exports, "useSlots", ()=>useSlots);
parcelHelpers.export(exports, "useTransitionState", ()=>useTransitionState);
parcelHelpers.export(exports, "version", ()=>version);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "watch", ()=>watch);
parcelHelpers.export(exports, "watchEffect", ()=>watchEffect);
parcelHelpers.export(exports, "watchPostEffect", ()=>watchPostEffect);
parcelHelpers.export(exports, "watchSyncEffect", ()=>watchSyncEffect);
parcelHelpers.export(exports, "withAsyncContext", ()=>withAsyncContext);
parcelHelpers.export(exports, "withCtx", ()=>withCtx);
parcelHelpers.export(exports, "withDefaults", ()=>withDefaults);
parcelHelpers.export(exports, "withDirectives", ()=>withDirectives);
parcelHelpers.export(exports, "withMemo", ()=>withMemo);
parcelHelpers.export(exports, "withScopeId", ()=>withScopeId);
var _reactivity = require("@vue/reactivity");
var _shared = require("@vue/shared");
const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    (0, _reactivity.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
    ]);
    else {
        const warnArgs = [
            `[Vue warn]: ${msg}`,
            ...args
        ];
        if (trace.length && // avoid spamming console during tests
        true) warnArgs.push(`
`, ...formatTrace(trace));
        console.warn(...warnArgs);
    }
    (0, _reactivity.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) return [];
    const normalizedStack = [];
    while(currentVNode){
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) last.recurseCount++;
        else normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
        });
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i)=>{
        logs.push(...i === 0 ? [] : [
            `
`
        ], ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [
        open,
        ...formatProps(vnode.props),
        close
    ] : [
        open + close
    ];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key)=>{
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) res.push(` ...`);
    return res;
}
function formatProp(key, value1, raw) {
    if ((0, _shared.isString)(value1)) {
        value1 = JSON.stringify(value1);
        return raw ? value1 : [
            `${key}=${value1}`
        ];
    } else if (typeof value1 === "number" || typeof value1 === "boolean" || value1 == null) return raw ? value1 : [
        `${key}=${value1}`
    ];
    else if ((0, _reactivity.isRef)(value1)) {
        value1 = formatProp(key, (0, _reactivity.toRaw)(value1.value), true);
        return raw ? value1 : [
            `${key}=Ref<`,
            value1,
            `>`
        ];
    } else if ((0, _shared.isFunction)(value1)) return [
        `${key}=fn${value1.name ? `<${value1.name}>` : ``}`
    ];
    else {
        value1 = (0, _reactivity.toRaw)(value1);
        return raw ? value1 : [
            `${key}=`,
            value1
        ];
    }
}
function assertNumber(val, type) {
    if (val === void 0) return;
    else if (typeof val !== "number") warn(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    else if (isNaN(val)) warn(`${type} is NaN - the duration expression might be incorrect.`);
}
const ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    } catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0, _shared.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0, _shared.isPromise)(res)) res.catch((err)=>{
            handleError(err, instance, type);
        });
        return res;
    }
    const values = [];
    for(let i = 0; i < fn.length; i++)values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = (0, ErrorTypeStrings[type]);
        while(cur){
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) for(let i = 0; i < errorCapturedHooks.length; i++){
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) return;
            }
            cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10, [
                err,
                exposedInstance,
                errorInfo
            ]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    {
        const info = ErrorTypeStrings[type];
        if (contextVNode) pushWarningContext(contextVNode);
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) popWarningContext();
        if (throwInDev) throw err;
        else console.error(err);
    }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while(start < end){
        const middle = start + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
}
function queueJob(job) {
    if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) queue.push(job);
        else queue.splice(findInsertionIndex(job.id), 0, job);
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) queue.splice(i, 1);
}
function queuePostFlushCb(cb) {
    if (!(0, _shared.isArray)(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) pendingPostFlushCbs.push(cb);
    } else pendingPostFlushCbs.push(...cb);
    queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
    seen = seen || /* @__PURE__ */ new Map();
    for(; i < queue.length; i++){
        const cb = queue[i];
        if (cb && cb.pre) {
            if (checkRecursiveUpdates(seen, cb)) continue;
            queue.splice(i, 1);
            i--;
            cb();
        }
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [
            ...new Set(pendingPostFlushCbs)
        ];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        seen = seen || /* @__PURE__ */ new Map();
        activePostFlushCbs.sort((a, b)=>getId(a) - getId(b));
        for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue;
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job)=>job.id == null ? Infinity : job.id;
const comparator = (a, b)=>{
    const diff = getId(a) - getId(b);
    if (diff === 0) {
        if (a.pre && !b.pre) return -1;
        if (b.pre && !a.pre) return 1;
    }
    return diff;
};
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    seen = seen || /* @__PURE__ */ new Map();
    queue.sort(comparator);
    const check = (job)=>checkRecursiveUpdates(seen, job);
    try {
        for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (check(job)) continue;
                callWithErrorHandling(job, null, 14);
            }
        }
    } finally{
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) seen.set(fn, 1);
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
            return true;
        } else seen.set(fn, count + 1);
    }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
(0, _shared.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
};
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) return false;
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) return;
    record.initialDef.render = newRender;
    [
        ...record.instances
    ].forEach((instance)=>{
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [
        ...record.instances
    ];
    for (const instance of instances){
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) updateComponentDef(oldComp, newComp);
            hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) queueJob(instance.parent.update);
        else if (instance.appContext.reload) instance.appContext.reload();
        else if (typeof window !== "undefined") window.location.reload();
        else console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
    queuePostFlushCb(()=>{
        for (const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    });
}
function updateComponentDef(oldComp, newComp) {
    (0, _shared.extend)(oldComp, newComp);
    for(const key in oldComp)if (key !== "__file" && !(key in newComp)) delete oldComp[key];
}
function tryWrap(fn) {
    return (id, arg)=>{
        try {
            return fn(id, arg);
        } catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
        }
    };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
    if (devtools) devtools.emit(event, ...args);
    else if (!devtoolsNotInstalled) buffer.push({
        event,
        args
    });
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args })=>devtools.emit(event, ...args));
        buffer = [];
    } else if (// handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook)=>{
            setDevtoolsHook(newHook, target);
        });
        setTimeout(()=>{
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3e3);
    } else {
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit$1("app:init" /* APP_INIT */ , app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit$1("app:unmount" /* APP_UNMOUNT */ , app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */ );
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */ );
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */ );
const devtoolsComponentRemoved = (component)=>{
    if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools.cleanupBuffer(component)) _devtoolsComponentRemoved(component);
};
function createDevtoolsComponentHook(hook) {
    return (component)=>{
        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */ );
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */ );
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time)=>{
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit$1("component:emit" /* COMPONENT_EMIT */ , component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || (0, _shared.EMPTY_OBJ);
    {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) && true) {
                if (!propsOptions || !((0, _shared.toHandlerKey)(event) in propsOptions)) warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0, _shared.toHandlerKey)(event)}" prop.`);
            } else {
                const validator = emitsOptions[event];
                if ((0, _shared.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) warn(`Invalid event arguments: event validation failed for event "${event}".`);
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || (0, _shared.EMPTY_OBJ);
        if (trim) args = rawArgs.map((a)=>(0, _shared.isString)(a) ? a.trim() : a);
        if (number) args = rawArgs.map((0, _shared.looseToNumber));
    }
    devtoolsComponentEmit(instance, event, args);
    {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0, _shared.toHandlerKey)(lowerCaseEvent)]) warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0, _shared.hyphenate)(event)}" instead of "${event}".`);
    }
    let handlerName;
    let handler = props[handlerName = (0, _shared.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
    props[handlerName = (0, _shared.toHandlerKey)((0, _shared.camelize)(event))];
    if (!handler && isModelListener) handler = props[handlerName = (0, _shared.toHandlerKey)((0, _shared.hyphenate)(event))];
    if (handler) callWithAsyncErrorHandling(handler, instance, 6, args);
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) instance.emitted = {};
        else if (instance.emitted[handlerName]) return;
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) return cached;
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendEmits = (raw2)=>{
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0, _shared.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendEmits);
        if (comp.extends) extendEmits(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendEmits);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, null);
        return null;
    }
    if ((0, _shared.isArray)(raw)) raw.forEach((key)=>normalized[key] = null);
    else (0, _shared.extend)(normalized, raw);
    if ((0, _shared.isObject)(comp)) cache.set(comp, normalized);
    return normalized;
}
function isEmitListener(options, key) {
    if (!options || !(0, _shared.isOn)(key)) return false;
    key = key.slice(2).replace(/Once$/, "");
    return (0, _shared.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, _shared.hasOwn)(options, (0, _shared.hyphenate)(key)) || (0, _shared.hasOwn)(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
}
function pushScopeId(id) {
    currentScopeId = id;
}
function popScopeId() {
    currentScopeId = null;
}
const withScopeId = (_id)=>withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) return fn;
    const renderFnWithContext = (...args)=>{
        if (renderFnWithContext._d) setBlockTracking(-1);
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
            res = fn(...args);
        } finally{
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) setBlockTracking(1);
        }
        devtoolsComponentUpdated(ctx);
        return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    accessedAttrs = false;
    try {
        if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        } else {
            const render2 = Component;
            if (attrs === props) markAttrsAccessed();
            result = normalizeVNode(render2.length > 1 ? render2(props, {
                get attrs () {
                    markAttrsAccessed();
                    return attrs;
                },
                slots,
                emit
            }) : render2(props, null));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
    } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) [root, setRoot] = getChildRoot(result);
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & 7) {
                if (propsOptions && keys.some((0, _shared.isModelListener))) fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for(let i = 0, l = allAttrs.length; i < l; i++){
                    const key = allAttrs[i];
                    if ((0, _shared.isOn)(key)) {
                        if (!(0, _shared.isModelListener)(key)) eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                    } else extraAttrs.push(key);
                }
                if (extraAttrs.length) warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
                if (eventAttrs.length) warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
        }
    }
    if (vnode.dirs) {
        if (!isElementRoot(root)) warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
        if (!isElementRoot(root)) warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        root.transition = vnode.transition;
    }
    if (setRoot) setRoot(root);
    else result = root;
    setCurrentRenderingInstance(prev);
    return result;
}
const getChildRoot = (vnode)=>{
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) return [
        vnode,
        void 0
    ];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot)=>{
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) dynamicChildren[dynamicIndex] = updatedRoot;
            else if (updatedRoot.patchFlag > 0) vnode.dynamicChildren = [
                ...dynamicChildren,
                updatedRoot
            ];
        }
    };
    return [
        normalizeVNode(childRoot),
        setRoot
    ];
};
function filterSingleRoot(children) {
    let singleRoot;
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
                if (singleRoot) return;
                else singleRoot = child;
            }
        } else return;
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs)=>{
    let res;
    for(const key in attrs)if (key === "class" || key === "style" || (0, _shared.isOn)(key)) (res || (res = {}))[key] = attrs[key];
    return res;
};
const filterModelListeners = (attrs, props)=>{
    const res = {};
    for(const key in attrs)if (!(0, _shared.isModelListener)(key) || !(key.slice(9) in props)) res[key] = attrs[key];
    return res;
};
const isElementRoot = (vnode)=>{
    return vnode.shapeFlag & 7 || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) return true;
    if (nextVNode.dirs || nextVNode.transition) return true;
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) return true;
        if (patchFlag & 16) {
            if (!prevProps) return !!nextProps;
            return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for(let i = 0; i < dynamicProps.length; i++){
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) return true;
            }
        }
    } else {
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) return true;
        }
        if (prevProps === nextProps) return false;
        if (!prevProps) return !!nextProps;
        if (!nextProps) return true;
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) return true;
    for(let i = 0; i < nextKeys.length; i++){
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) return true;
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
    while(parent && parent.subTree === vnode){
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}
const isSuspense = (type)=>type.__isSuspense;
const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        else patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0, _shared.isFunction)(eventListener)) eventListener();
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    } else suspense.resolve(false, true);
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) suspense.resolve();
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        } else {
            suspense.pendingId++;
            if (isHydrating) {
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            } else unmount(pendingBranch, parentComponent, suspense);
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                suspense.resolve(true);
            } else {
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) suspense.resolve();
            }
        }
    } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
    } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) suspense.resolve();
        else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) setTimeout(()=>{
                if (suspense.pendingId === pendingId) suspense.fallback(newFallback);
            }, timeout);
            else if (timeout === 0) suspense.fallback(newFallback);
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
        if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
            parentSuspenseId = parentSuspense.pendingId;
            parentSuspense.deps++;
        }
    }
    const timeout = vnode.props ? (0, _shared.toNumber)(vnode.props.timeout) : void 0;
    assertNumber(timeout, `Suspense timeout`);
    const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve (resume = false, sync = false) {
            if (!resume && !suspense.pendingBranch) throw new Error(`suspense.resolve() is called without a pending branch.`);
            if (suspense.isUnmounted) throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            if (suspense.isHydrating) suspense.isHydrating = false;
            else if (!resume) {
                const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                if (delayEnter) activeBranch.transition.afterLeave = ()=>{
                    if (pendingId === suspense.pendingId) move(pendingBranch, container2, anchor2, 0);
                };
                let { anchor: anchor2 } = suspense;
                if (activeBranch) {
                    anchor2 = next(activeBranch);
                    unmount(activeBranch, parentComponent2, suspense, true);
                }
                if (!delayEnter) move(pendingBranch, container2, anchor2, 0);
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while(parent){
                if (parent.pendingBranch) {
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            if (!hasUnresolvedAncestor) queuePostFlushCb(effects);
            suspense.effects = [];
            if (isSuspensible) {
                if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                    parentSuspense.deps--;
                    if (parentSuspense.deps === 0 && !sync) parentSuspense.resolve();
                }
            }
            triggerEvent(vnode2, "onResolve");
        },
        fallback (fallbackVNode) {
            if (!suspense.pendingBranch) return;
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next(activeBranch);
            const mountFallback = ()=>{
                if (!suspense.isInFallback) return;
                patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, // fallback tree will not have suspense context
                isSVG2, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) activeBranch.transition.afterLeave = mountFallback;
            suspense.isInFallback = true;
            unmount(activeBranch, parentComponent2, null, // no suspense so unmount hooks fire now
            true);
            if (!delayEnter) mountFallback();
        },
        move (container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
        },
        next () {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep (instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) suspense.deps++;
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err)=>{
                handleError(err, instance, 0);
            }).then((asyncSetupResult)=>{
                if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) return;
                instance.asyncResolved = true;
                const { vnode: vnode2 } = instance;
                pushWarningContext(vnode2);
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) vnode2.el = hydratedEl;
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode2, // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) remove(placeholder);
                updateHOCHostEl(instance, vnode2.el);
                popWarningContext();
                if (isInPendingSuspense && --suspense.deps === 0) suspense.resolve();
            });
        },
        unmount (parentSuspense2, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
            if (suspense.pendingBranch) unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) suspense.resolve(false, true);
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0, _shared.isFunction)(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0, _shared.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild) warn(`<Suspense> slots expect a single root node.`);
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) s.dynamicChildren = block.filter((c)=>c !== s);
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0, _shared.isArray)(fn)) suspense.effects.push(...fn);
        else suspense.effects.push(fn);
    } else queuePostFlushCb(fn);
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}
function isVNodeSuspensible(vnode) {
    var _a;
    return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "post"
    }));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (0, _shared.extend)({}, options, {
        flush: "sync"
    }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
    if (!(0, _shared.isFunction)(cb)) warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = (0, _shared.EMPTY_OBJ)) {
    var _a;
    if (!cb) {
        if (immediate !== void 0) warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        if (deep !== void 0) warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    const warnInvalidSource = (s)=>{
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = (0, _reactivity.getCurrentScope)() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0, _reactivity.isRef)(source)) {
        getter = ()=>source.value;
        forceTrigger = (0, _reactivity.isShallow)(source);
    } else if ((0, _reactivity.isReactive)(source)) {
        getter = ()=>source;
        deep = true;
    } else if ((0, _shared.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s)=>(0, _reactivity.isReactive)(s) || (0, _reactivity.isShallow)(s));
        getter = ()=>source.map((s)=>{
                if ((0, _reactivity.isRef)(s)) return s.value;
                else if ((0, _reactivity.isReactive)(s)) return traverse(s);
                else if ((0, _shared.isFunction)(s)) return callWithErrorHandling(s, instance, 2);
                else warnInvalidSource(s);
            });
    } else if ((0, _shared.isFunction)(source)) {
        if (cb) getter = ()=>callWithErrorHandling(source, instance, 2);
        else getter = ()=>{
            if (instance && instance.isUnmounted) return;
            if (cleanup) cleanup();
            return callWithAsyncErrorHandling(source, instance, 3, [
                onCleanup
            ]);
        };
    } else {
        getter = (0, _shared.NOOP);
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = ()=>traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn)=>{
        cleanup = effect.onStop = ()=>{
            callWithErrorHandling(fn, instance, 4);
        };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        onCleanup = (0, _shared.NOOP);
        if (!cb) getter();
        else if (immediate) callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
        ]);
        if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else return 0, _shared.NOOP;
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = ()=>{
        if (!effect.active) return;
        if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v1, i)=>(0, _shared.hasChanged)(v1, oldValue[i])) : (0, _shared.hasChanged)(newValue, oldValue)) || false) {
                if (cleanup) cleanup();
                callWithAsyncErrorHandling(cb, instance, 3, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        } else effect.run();
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") scheduler = job;
    else if (flush === "post") scheduler = ()=>queuePostRenderEffect(job, instance && instance.suspense);
    else {
        job.pre = true;
        if (instance) job.id = instance.uid;
        scheduler = ()=>queueJob(job);
    }
    const effect = new (0, _reactivity.ReactiveEffect)(getter, scheduler);
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
    if (cb) {
        if (immediate) job();
        else oldValue = effect.run();
    } else if (flush === "post") queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    else effect.run();
    const unwatch = ()=>{
        effect.stop();
        if (instance && instance.scope) (0, _shared.remove)(instance.scope.effects, effect);
    };
    if (ssrCleanup) ssrCleanup.push(unwatch);
    return unwatch;
}
function instanceWatch(source, value1, options) {
    const publicThis = this.proxy;
    const getter = (0, _shared.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if ((0, _shared.isFunction)(value1)) cb = value1;
    else {
        cb = value1.handler;
        options = value1;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) setCurrentInstance(cur);
    else unsetCurrentInstance();
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return ()=>{
        let cur = ctx;
        for(let i = 0; i < segments.length && cur; i++)cur = cur[segments[i]];
        return cur;
    };
}
function traverse(value1, seen) {
    if (!(0, _shared.isObject)(value1) || value1["__v_skip"]) return value1;
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value1)) return value1;
    seen.add(value1);
    if ((0, _reactivity.isRef)(value1)) traverse(value1.value, seen);
    else if ((0, _shared.isArray)(value1)) for(let i = 0; i < value1.length; i++)traverse(value1[i], seen);
    else if ((0, _shared.isSet)(value1) || (0, _shared.isMap)(value1)) value1.forEach((v1)=>{
        traverse(v1, seen);
    });
    else if ((0, _shared.isPlainObject)(value1)) for(const key in value1)traverse(value1[key], seen);
    return value1;
}
function validateDirectiveName(name) {
    if ((0, _shared.isBuiltInDirective)(name)) warn("Do not use built-in directive ids as custom directive id: " + name);
}
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for(let i = 0; i < directives.length; i++){
        let [dir, value1, arg, modifiers = (0, _shared.EMPTY_OBJ)] = directives[i];
        if (dir) {
            if ((0, _shared.isFunction)(dir)) dir = {
                mounted: dir,
                updated: dir
            };
            if (dir.deep) traverse(value1);
            bindings.push({
                dir,
                instance,
                value: value1,
                oldValue: void 0,
                arg,
                modifiers
            });
        }
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for(let i = 0; i < bindings.length; i++){
        const binding = bindings[i];
        if (oldBindings) binding.oldValue = oldBindings[i].value;
        let hook = binding.dir[name];
        if (hook) {
            (0, _reactivity.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0, _reactivity.resetTracking)();
        }
    }
}
function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(()=>{
        state.isMounted = true;
    });
    onBeforeUnmount(()=>{
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [
    Function,
    Array
];
const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return ()=>{
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) return;
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                for (const c of children)if (c.type !== Comment) {
                    if (hasFound) {
                        warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                        break;
                    }
                    child = c;
                    hasFound = true;
                }
            }
            const rawProps = (0, _reactivity.toRaw)(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") warn(`invalid <transition> mode: ${mode}`);
            if (state.isLeaving) return emptyPlaceholder(child);
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) return emptyPlaceholder(child);
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === void 0) prevTransitionKey = key;
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                setTransitionHooks(oldInnerChild, leavingHooks);
                if (mode === "out-in") {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = ()=>{
                        state.isLeaving = false;
                        if (instance.update.active !== false) instance.update();
                    };
                    return emptyPlaceholder(child);
                } else if (mode === "in-out" && innerChild.type !== Comment) leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                    el._leaveCb = ()=>{
                        earlyRemove();
                        el._leaveCb = void 0;
                        delete enterHooks.delayedLeave;
                    };
                    enterHooks.delayedLeave = delayedLeave;
                };
            }
            return child;
        };
    }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args)=>{
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const callAsyncHook = (hook, args)=>{
        const done = args[1];
        callHook(hook, args);
        if ((0, _shared.isArray)(hook)) {
            if (hook.every((hook2)=>hook2.length <= 1)) done();
        } else if (hook.length <= 1) done();
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter (el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) hook = onBeforeAppear || onBeforeEnter;
                else return;
            }
            if (el._leaveCb) el._leaveCb(true);
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) leavingVNode.el._leaveCb();
            callHook(hook, [
                el
            ]);
        },
        enter (el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                } else return;
            }
            let called = false;
            const done = el._enterCb = (cancelled)=>{
                if (called) return;
                called = true;
                if (cancelled) callHook(cancelHook, [
                    el
                ]);
                else callHook(afterHook, [
                    el
                ]);
                if (hooks.delayedLeave) hooks.delayedLeave();
                el._enterCb = void 0;
            };
            if (hook) callAsyncHook(hook, [
                el,
                done
            ]);
            else done();
        },
        leave (el, remove) {
            const key2 = String(vnode.key);
            if (el._enterCb) el._enterCb(true);
            if (state.isUnmounting) return remove();
            callHook(onBeforeLeave, [
                el
            ]);
            let called = false;
            const done = el._leaveCb = (cancelled)=>{
                if (called) return;
                called = true;
                remove();
                if (cancelled) callHook(onLeaveCancelled, [
                    el
                ]);
                else callHook(onAfterLeave, [
                    el
                ]);
                el._leaveCb = void 0;
                if (leavingVNodesCache[key2] === vnode) delete leavingVNodesCache[key2];
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) callAsyncHook(onLeave, [
                el,
                done
            ]);
            else done();
        },
        clone (vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
        }
    };
    return hooks;
}
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) setTransitionHooks(vnode.component.subTree, hooks);
    else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else vnode.transition = hooks;
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for(let i = 0; i < children.length; i++){
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
            if (child.patchFlag & 128) keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) ret.push(key != null ? cloneVNode(child, {
            key
        }) : child);
    }
    if (keyedFragmentCount > 1) for(let i = 0; i < ret.length; i++)ret[i].patchFlag = -2;
    return ret;
}
function defineComponent(options, extraOptions) {
    return (0, _shared.isFunction)(options) ? // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (()=>(0, _shared.extend)({
            name: options.name
        }, extraOptions, {
            setup: options
        }))() : options;
}
const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0, _shared.isFunction)(source)) source = {
        loader: source
    };
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = ()=>{
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = ()=>{
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err)=>{
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) return new Promise((resolve, reject)=>{
                const userRetry = ()=>resolve(retry());
                const userFail = ()=>reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
            });
            else throw err;
        }).then((comp)=>{
            if (thisRequest !== pendingRequest && pendingRequest) return pendingRequest;
            if (!comp) warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) comp = comp.default;
            if (comp && !(0, _shared.isObject)(comp) && !(0, _shared.isFunction)(comp)) throw new Error(`Invalid async component load result: ${comp}`);
            resolvedComp = comp;
            return comp;
        }));
    };
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved () {
            return resolvedComp;
        },
        setup () {
            const instance = currentInstance;
            if (resolvedComp) return ()=>createInnerComp(resolvedComp, instance);
            const onError = (err)=>{
                pendingRequest = null;
                handleError(err, instance, 13, !errorComponent);
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) return load().then((comp)=>{
                return ()=>createInnerComp(comp, instance);
            }).catch((err)=>{
                onError(err);
                return ()=>errorComponent ? createVNode(errorComponent, {
                        error: err
                    }) : null;
            });
            const loaded = (0, _reactivity.ref)(false);
            const error = (0, _reactivity.ref)();
            const delayed = (0, _reactivity.ref)(!!delay);
            if (delay) setTimeout(()=>{
                delayed.value = false;
            }, delay);
            if (timeout != null) setTimeout(()=>{
                if (!loaded.value && !error.value) {
                    const err = new Error(`Async component timed out after ${timeout}ms.`);
                    onError(err);
                    error.value = err;
                }
            }, timeout);
            load().then(()=>{
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) queueJob(instance.parent.update);
            }).catch((err)=>{
                onError(err);
                error.value = err;
            });
            return ()=>{
                if (loaded.value && resolvedComp) return createInnerComp(resolvedComp, instance);
                else if (error.value && errorComponent) return createVNode(errorComponent, {
                    error: error.value
                });
                else if (loadingComponent && !delayed.value) return createVNode(loadingComponent);
            };
        }
    });
}
function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
}
const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [
            String,
            RegExp,
            Array
        ],
        exclude: [
            String,
            RegExp,
            Array
        ],
        max: [
            String,
            Number
        ]
    },
    setup (props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) return ()=>{
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
        };
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        instance.__v_cache = cache;
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized)=>{
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(()=>{
                instance2.isDeactivated = false;
                if (instance2.a) (0, _shared.invokeArrayFns)(instance2.a);
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        sharedContext.deactivate = (vnode)=>{
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(()=>{
                if (instance2.da) (0, _shared.invokeArrayFns)(instance2.da);
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) invokeVNodeHook(vnodeHook, instance2.parent, vnode);
                instance2.isDeactivated = true;
            }, parentSuspense);
            devtoolsComponentAdded(instance2);
        };
        function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key)=>{
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) pruneCacheEntry(key);
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || !isSameVNodeType(cached, current)) unmount(cached);
            else if (current) resetShapeFlag(current);
            cache.delete(key);
            keys.delete(key);
        }
        watch(()=>[
                props.include,
                props.exclude
            ], ([include, exclude])=>{
            include && pruneCache((name)=>matches(include, name));
            exclude && pruneCache((name)=>!matches(exclude, name));
        }, // prune post-render after `current` has been updated
        {
            flush: "post",
            deep: true
        });
        let pendingCacheKey = null;
        const cacheSubtree = ()=>{
            if (pendingCacheKey != null) cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(()=>{
            cache.forEach((cached)=>{
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type && cached.key === vnode.key) {
                    resetShapeFlag(vnode);
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return ()=>{
            pendingCacheKey = null;
            if (!slots.default) return null;
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                warn(`KeepAlive should contain exactly one component child.`);
                current = null;
                return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128) rawVNode.ssContent = vnode;
            }
            pendingCacheKey = key;
            if (cachedVNode) {
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) setTransitionHooks(vnode, vnode.transition);
                vnode.shapeFlag |= 512;
                keys.delete(key);
                keys.add(key);
            } else {
                keys.add(key);
                if (max && keys.size > parseInt(max, 10)) pruneCacheEntry(keys.values().next().value);
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0, _shared.isArray)(pattern)) return pattern.some((p)=>matches(p, name));
    else if ((0, _shared.isString)(pattern)) return pattern.split(",").includes(name);
    else if ((0, _shared.isRegExp)(pattern)) return pattern.test(name);
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
        let current = target;
        while(current){
            if (current.isDeactivated) return;
            current = current.parent;
        }
        return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
        let current = target.parent;
        while(current && current.parent){
            if (isKeepAlive(current.parent.vnode)) injectToKeepAliveRoot(wrappedHook, type, target, current);
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(()=>{
        (0, _shared.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
            if (target.isUnmounted) return;
            (0, _reactivity.pauseTracking)();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            (0, _reactivity.resetTracking)();
            return res;
        });
        if (prepend) hooks.unshift(wrappedHook);
        else hooks.push(wrappedHook);
        return wrappedHook;
    } else {
        const apiName = (0, _shared.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ""));
        warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
}
const createHook = (lifecycle)=>(hook, target = currentInstance)=>// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args)=>hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
    if ((0, _shared.isString)(component)) return resolveAsset(COMPONENTS, component, false) || component;
    else return component || NULL_DYNAMIC_COMPONENT;
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false);
            if (selfName && (selfName === name || selfName === (0, _shared.camelize)(name) || selfName === (0, _shared.capitalize)((0, _shared.camelize)(name)))) return Component;
        }
        const res = // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) return Component;
        if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    } else warn(`resolve${(0, _shared.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);
}
function resolve(registry, name) {
    return registry && (registry[name] || registry[(0, _shared.camelize)(name)] || registry[(0, _shared.capitalize)((0, _shared.camelize)(name))]);
}
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if ((0, _shared.isArray)(source) || (0, _shared.isString)(source)) {
        ret = new Array(source.length);
        for(let i = 0, l = source.length; i < l; i++)ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    } else if (typeof source === "number") {
        if (!Number.isInteger(source)) warn(`The v-for range expect an integer value but got ${source}.`);
        ret = new Array(source);
        for(let i = 0; i < source; i++)ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    } else if ((0, _shared.isObject)(source)) {
        if (source[Symbol.iterator]) ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached && cached[i]));
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for(let i = 0, l = keys.length; i < l; i++){
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    } else ret = [];
    if (cache) cache[index] = ret;
    return ret;
}
function createSlots(slots, dynamicSlots) {
    for(let i = 0; i < dynamicSlots.length; i++){
        const slot = dynamicSlots[i];
        if ((0, _shared.isArray)(slot)) for(let j = 0; j < slot.length; j++)slots[slot[j].name] = slot[j].fn;
        else if (slot) slots[slot.name] = slot.key ? (...args)=>{
            const res = slot.fn(...args);
            if (res) res.key = slot.key;
            return res;
        } : slot.fn;
    }
    return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default") props.name = name;
        return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
        slot = ()=>[];
    }
    if (slot && slot._c) slot._d = false;
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) rendered.slotScopeIds = [
        rendered.scopeId + "-s"
    ];
    if (slot && slot._c) slot._d = true;
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some((child)=>{
        if (!isVNode(child)) return true;
        if (child.type === Comment) return false;
        if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
        return true;
    }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!(0, _shared.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for(const key in obj)ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, _shared.toHandlerKey)(key)] = obj[key];
    return ret;
}
const getPublicInstance = (i)=>{
    if (!i) return null;
    if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = // Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/* @__PURE__ */ (0, _shared.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i)=>i,
    $el: (i)=>i.vnode.el,
    $data: (i)=>i.data,
    $props: (i)=>(0, _reactivity.shallowReadonly)(i.props),
    $attrs: (i)=>(0, _reactivity.shallowReadonly)(i.attrs),
    $slots: (i)=>(0, _reactivity.shallowReadonly)(i.slots),
    $refs: (i)=>(0, _reactivity.shallowReadonly)(i.refs),
    $parent: (i)=>getPublicInstance(i.parent),
    $root: (i)=>getPublicInstance(i.root),
    $emit: (i)=>i.emit,
    $options: (i)=>__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i)=>i.f || (i.f = ()=>queueJob(i.update)),
    $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i)=>__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : (0, _shared.NOOP)
});
const isReservedPrefix = (key)=>key === "_" || key === "$";
const hasSetupBinding = (state, key)=>state !== (0, _shared.EMPTY_OBJ) && !state.__isScriptSetup && (0, _shared.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
    get ({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") return true;
        let normalizedProps;
        if (key[0] !== "$") {
            const n = accessCache[key];
            if (n !== void 0) switch(n){
                case 1 /* SETUP */ :
                    return setupState[key];
                case 2 /* DATA */ :
                    return data[key];
                case 4 /* CONTEXT */ :
                    return ctx[key];
                case 3 /* PROPS */ :
                    return props[key];
            }
            else if (hasSetupBinding(setupState, key)) {
                accessCache[key] = 1 /* SETUP */ ;
                return setupState[key];
            } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
                accessCache[key] = 2 /* DATA */ ;
                return data[key];
            } else if (// only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */ ;
                return props[key];
            } else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */ ;
                return ctx[key];
            } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) accessCache[key] = 0 /* OTHER */ ;
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
            if (key === "$attrs") {
                (0, _reactivity.track)(instance, "get", key);
                markAttrsAccessed();
            } else if (key === "$slots") (0, _reactivity.track)(instance, "get", key);
            return publicGetter(instance);
        } else if (// css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])) return cssModule;
        else if (ctx !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(ctx, key)) {
            accessCache[key] = 4 /* CONTEXT */ ;
            return ctx[key];
        } else if (// global properties
        globalProperties = appContext.config.globalProperties, (0, _shared.hasOwn)(globalProperties, key)) return globalProperties[key];
        else if (currentRenderingInstance && (!(0, _shared.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
            if (data !== (0, _shared.EMPTY_OBJ) && isReservedPrefix(key[0]) && (0, _shared.hasOwn)(data, key)) warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            else if (instance === currentRenderingInstance) warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
    },
    set ({ _: instance }, key, value1) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
            setupState[key] = value1;
            return true;
        } else if ((0, setupState.__isScriptSetup) && (0, _shared.hasOwn)(setupState, key)) {
            warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
            return false;
        } else if (data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key)) {
            data[key] = value1;
            return true;
        } else if ((0, _shared.hasOwn)(instance.props, key)) {
            warn(`Attempting to mutate prop "${key}". Props are readonly.`);
            return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
            warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
            return false;
        } else if (key in instance.appContext.config.globalProperties) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value1
        });
        else ctx[key] = value1;
        return true;
    },
    has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== (0, _shared.EMPTY_OBJ) && (0, _shared.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, _shared.hasOwn)(normalizedProps, key) || (0, _shared.hasOwn)(ctx, key) || (0, _shared.hasOwn)(publicPropertiesMap, key) || (0, _shared.hasOwn)(appContext.config.globalProperties, key);
    },
    defineProperty (target, key, descriptor) {
        if (descriptor.get != null) target._.accessCache[key] = 0;
        else if ((0, _shared.hasOwn)(descriptor, "value")) this.set(target, key, descriptor.value, null);
        return Reflect.defineProperty(target, key, descriptor);
    }
};
PublicInstanceProxyHandlers.ownKeys = (target)=>{
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, PublicInstanceProxyHandlers, {
    get (target, key) {
        if (key === Symbol.unscopables) return;
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has (_, key) {
        const has = key[0] !== "_" && !(0, _shared.isGloballyWhitelisted)(key);
        if (!has && PublicInstanceProxyHandlers.has(_, key)) warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        return has;
    }
});
function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: ()=>instance
    });
    Object.keys(publicPropertiesMap).forEach((key)=>{
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: ()=>publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: (0, _shared.NOOP)
        });
    });
    return target;
}
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) Object.keys(propsOptions).forEach((key)=>{
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>instance.props[key],
            set: (0, _shared.NOOP)
        });
    });
}
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0, _reactivity.toRaw)(setupState)).forEach((key)=>{
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: ()=>setupState[key],
                set: (0, _shared.NOOP)
            });
        }
    });
}
const warnRuntimeUsage = (method)=>warn(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
    warnRuntimeUsage(`defineProps`);
    return null;
}
function defineEmits() {
    warnRuntimeUsage(`defineEmits`);
    return null;
}
function defineExpose(exposed) {
    warnRuntimeUsage(`defineExpose`);
}
function defineOptions(options) {
    warnRuntimeUsage(`defineOptions`);
}
function defineSlots() {
    warnRuntimeUsage(`defineSlots`);
    return null;
}
function defineModel() {
    warnRuntimeUsage("defineModel");
}
function withDefaults(props, defaults) {
    warnRuntimeUsage(`withDefaults`);
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function useModel(props, name, options) {
    const i = getCurrentInstance();
    if (!i) {
        warn(`useModel() called without active instance.`);
        return (0, _reactivity.ref)();
    }
    if (!i.propsOptions[0][name]) {
        warn(`useModel() called with prop "${name}" which is not declared.`);
        return (0, _reactivity.ref)();
    }
    if (options && options.local) {
        const proxy = (0, _reactivity.ref)(props[name]);
        watch(()=>props[name], (v1)=>proxy.value = v1);
        watch(proxy, (value1)=>{
            if (value1 !== props[name]) i.emit(`update:${name}`, value1);
        });
        return proxy;
    } else return {
        __v_isRef: true,
        get value () {
            return props[name];
        },
        set value (value){
            i.emit(`update:${name}`, value);
        }
    };
}
function getContext() {
    const i = getCurrentInstance();
    if (!i) warn(`useContext() called without active instance.`);
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
    return (0, _shared.isArray)(props) ? props.reduce((normalized, p)=>(normalized[p] = null, normalized), {}) : props;
}
function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for(const key in defaults){
        if (key.startsWith("__skip")) continue;
        let opt = props[key];
        if (opt) {
            if ((0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt)) opt = props[key] = {
                type: opt,
                default: defaults[key]
            };
            else opt.default = defaults[key];
        } else if (opt === null) opt = props[key] = {
            default: defaults[key]
        };
        else warn(`props default key "${key}" has no corresponding declaration.`);
        if (opt && defaults[`__skip_${key}`]) opt.skipFactory = true;
    }
    return props;
}
function mergeModels(a, b) {
    if (!a || !b) return a || b;
    if ((0, _shared.isArray)(a) && (0, _shared.isArray)(b)) return a.concat(b);
    return (0, _shared.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for(const key in props)if (!excludedKeys.includes(key)) Object.defineProperty(ret, key, {
        enumerable: true,
        get: ()=>props[key]
    });
    return ret;
}
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) warn(`withAsyncContext called without active current instance. This is likely a bug.`);
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if ((0, _shared.isPromise)(awaitable)) awaitable = awaitable.catch((e)=>{
        setCurrentInstance(ctx);
        throw e;
    });
    return [
        awaitable,
        ()=>setCurrentInstance(ctx)
    ];
}
function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key)=>{
        if (cache[key]) warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        else cache[key] = type;
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) callHook(options.beforeCreate, instance, "bc");
    const { // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, // public API
    expose, inheritAttrs, // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) for(const key in propsOptions)checkDuplicateProperties("Props" /* PROPS */ , key);
    }
    if (injectOptions) resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    if (methods) for(const key in methods){
        const methodHandler = methods[key];
        if ((0, _shared.isFunction)(methodHandler)) {
            Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
            });
            checkDuplicateProperties("Methods" /* METHODS */ , key);
        } else warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
    }
    if (dataOptions) {
        if (!(0, _shared.isFunction)(dataOptions)) warn(`The data option must be a function. Plain object usage is no longer supported.`);
        const data = dataOptions.call(publicThis, publicThis);
        if ((0, _shared.isPromise)(data)) warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
        if (!(0, _shared.isObject)(data)) warn(`data() should return an object.`);
        else {
            instance.data = (0, _reactivity.reactive)(data);
            for(const key in data){
                checkDuplicateProperties("Data" /* DATA */ , key);
                if (!isReservedPrefix(key[0])) Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: ()=>data[key],
                    set: (0, _shared.NOOP)
                });
            }
        }
    }
    shouldCacheAccess = true;
    if (computedOptions) for(const key in computedOptions){
        const opt = computedOptions[key];
        const get = (0, _shared.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, _shared.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : (0, _shared.NOOP);
        if (get === (0, _shared.NOOP)) warn(`Computed property "${key}" has no getter.`);
        const set = !(0, _shared.isFunction)(opt) && (0, _shared.isFunction)(opt.set) ? opt.set.bind(publicThis) : ()=>{
            warn(`Write operation failed: computed property "${key}" is readonly.`);
        };
        const c = computed({
            get,
            set
        });
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>c.value,
            set: (v1)=>c.value = v1
        });
        checkDuplicateProperties("Computed" /* COMPUTED */ , key);
    }
    if (watchOptions) for(const key in watchOptions)createWatcher(watchOptions[key], ctx, publicThis, key);
    if (provideOptions) {
        const provides = (0, _shared.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key)=>{
            provide(key, provides[key]);
        });
    }
    if (created) callHook(created, instance, "c");
    function registerLifecycleHook(register, hook) {
        if ((0, _shared.isArray)(hook)) hook.forEach((_hook)=>register(_hook.bind(publicThis)));
        else if (hook) register(hook.bind(publicThis));
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0, _shared.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key)=>{
                Object.defineProperty(exposed, key, {
                    get: ()=>publicThis[key],
                    set: (val)=>publicThis[key] = val
                });
            });
        } else if (!instance.exposed) instance.exposed = {};
    }
    if (render && instance.render === (0, _shared.NOOP)) instance.render = render;
    if (inheritAttrs != null) instance.inheritAttrs = inheritAttrs;
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = (0, _shared.NOOP)) {
    if ((0, _shared.isArray)(injectOptions)) injectOptions = normalizeInject(injectOptions);
    for(const key in injectOptions){
        const opt = injectOptions[key];
        let injected;
        if ((0, _shared.isObject)(opt)) {
            if ("default" in opt) injected = inject(opt.from || key, opt.default, true);
            else injected = inject(opt.from || key);
        } else injected = inject(opt);
        if ((0, _reactivity.isRef)(injected)) Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: ()=>injected.value,
            set: (v1)=>injected.value = v1
        });
        else ctx[key] = injected;
        checkDuplicateProperties("Inject" /* INJECT */ , key);
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0, _shared.isArray)(hook) ? hook.map((h)=>h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
    if ((0, _shared.isString)(raw)) {
        const handler = ctx[raw];
        if ((0, _shared.isFunction)(handler)) watch(getter, handler);
        else warn(`Invalid watch handler specified by key "${raw}"`, handler);
    } else if ((0, _shared.isFunction)(raw)) watch(getter, raw.bind(publicThis));
    else if ((0, _shared.isObject)(raw)) {
        if ((0, _shared.isArray)(raw)) raw.forEach((r)=>createWatcher(r, ctx, publicThis, key));
        else {
            const handler = (0, _shared.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if ((0, _shared.isFunction)(handler)) watch(getter, handler, raw);
            else warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
    } else warn(`Invalid watch option: "${key}"`, raw);
}
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) resolved = cached;
    else if (!globalMixins.length && !mixins && !extendsOptions) resolved = base;
    else {
        resolved = {};
        if (globalMixins.length) globalMixins.forEach((m)=>mergeOptions(resolved, m, optionMergeStrategies, true));
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    if ((0, _shared.isObject)(base)) cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) mergeOptions(to, extendsOptions, strats, true);
    if (mixins) mixins.forEach((m)=>mergeOptions(to, m, strats, true));
    for(const key in from)if (asMixin && key === "expose") warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) return to;
    if (!to) return from;
    return function mergedDataFn() {
        return (0, _shared.extend)((0, _shared.isFunction)(to) ? to.call(this, this) : to, (0, _shared.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0, _shared.isArray)(raw)) {
        const res = {};
        for(let i = 0; i < raw.length; i++)res[raw[i]] = raw[i];
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [
        ...new Set([].concat(to, from))
    ] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
        if ((0, _shared.isArray)(to) && (0, _shared.isArray)(from)) return [
            .../* @__PURE__ */ new Set([
                ...to,
                ...from
            ])
        ];
        return (0, _shared.extend)(/* @__PURE__ */ Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
    } else return from;
}
function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = (0, _shared.extend)(/* @__PURE__ */ Object.create(null), to);
    for(const key in from)merged[key] = mergeAsArray(to[key], from[key]);
    return merged;
}
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: (0, _shared.NO),
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
    };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!(0, _shared.isFunction)(rootComponent)) rootComponent = (0, _shared.extend)({}, rootComponent);
        if (rootProps != null && !(0, _shared.isObject)(rootProps)) {
            warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        Object.defineProperty(context.config, "unwrapInjectedRef", {
            get () {
                return true;
            },
            set () {
                warn(`app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.`);
            }
        });
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config () {
                return context.config;
            },
            set config (v){
                warn(`app.config cannot be replaced. Modify individual options instead.`);
            },
            use (plugin, ...options) {
                if (installedPlugins.has(plugin)) warn(`Plugin has already been applied to target app.`);
                else if (plugin && (0, _shared.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                } else if ((0, _shared.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                } else warn(`A plugin must either be a function or an object with an "install" function.`);
                return app;
            },
            mixin (mixin) {
                if (__VUE_OPTIONS_API__) {
                    if (!context.mixins.includes(mixin)) context.mixins.push(mixin);
                    else warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                } else warn("Mixins are only available in builds supporting Options API");
                return app;
            },
            component (name, component) {
                validateComponentName(name, context.config);
                if (!component) return context.components[name];
                if (0, context.components[name]) warn(`Component "${name}" has already been registered in target app.`);
                context.components[name] = component;
                return app;
            },
            directive (name, directive) {
                validateDirectiveName(name);
                if (!directive) return context.directives[name];
                if (0, context.directives[name]) warn(`Directive "${name}" has already been registered in target app.`);
                context.directives[name] = directive;
                return app;
            },
            mount (rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    if (0, rootContainer.__vue_app__) warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    const vnode = createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    context.reload = ()=>{
                        render(cloneVNode(vnode), rootContainer, isSVG);
                    };
                    if (isHydrate && hydrate) hydrate(vnode, rootContainer);
                    else render(vnode, rootContainer, isSVG);
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    app._instance = vnode.component;
                    devtoolsInitApp(app, version);
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                } else warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
            },
            unmount () {
                if (isMounted) {
                    render(null, app._container);
                    app._instance = null;
                    devtoolsUnmountApp(app);
                    delete app._container.__vue_app__;
                } else warn(`Cannot unmount an app that is not mounted.`);
            },
            provide (key, value1) {
                if (key in context.provides) warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
                context.provides[key] = value1;
                return app;
            },
            runWithContext (fn) {
                currentApp = app;
                try {
                    return fn();
                } finally{
                    currentApp = null;
                }
            }
        };
        return app;
    };
}
let currentApp = null;
function provide(key, value1) {
    if (!currentInstance) warn(`provide() can only be used inside setup().`);
    else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) provides = currentInstance.provides = Object.create(parentProvides);
        provides[key] = value1;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) return provides[key];
        else if (arguments.length > 1) return treatDefaultAsFactory && (0, _shared.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        else warn(`injection "${String(key)}" not found.`);
    } else warn(`inject() can only be used inside setup() or functional components.`);
}
function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    (0, _shared.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for(const key in instance.propsOptions[0])if (!(key in props)) props[key] = void 0;
    validateProps(rawProps || {}, props, instance);
    if (isStateful) instance.props = isSSR ? props : (0, _reactivity.shallowReactive)(props);
    else if (!instance.type.props) instance.props = attrs;
    else instance.props = props;
    instance.attrs = attrs;
}
function isInHmrContext(instance) {
    while(instance){
        if (instance.type.__hmrId) return true;
        instance = instance.parent;
    }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0, _reactivity.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (// always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for(let i = 0; i < propsToUpdate.length; i++){
                let key = propsToUpdate[i];
                if (isEmitListener(instance.emitsOptions, key)) continue;
                const value1 = rawProps[key];
                if (options) {
                    if ((0, _shared.hasOwn)(attrs, key)) {
                        if (value1 !== attrs[key]) {
                            attrs[key] = value1;
                            hasAttrsChanged = true;
                        }
                    } else {
                        const camelizedKey = (0, _shared.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value1, instance, false);
                    }
                } else if (value1 !== attrs[key]) {
                    attrs[key] = value1;
                    hasAttrsChanged = true;
                }
            }
        }
    } else {
        if (setFullProps(instance, rawProps, props, attrs)) hasAttrsChanged = true;
        let kebabKey;
        for(const key in rawCurrentProps)if (!rawProps || // for camelCase
        !(0, _shared.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = (0, _shared.hyphenate)(key)) === key || !(0, _shared.hasOwn)(rawProps, kebabKey))) {
            if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            } else delete props[key];
        }
        if (attrs !== rawCurrentProps) {
            for(const key in attrs)if (!rawProps || !(0, _shared.hasOwn)(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
            }
        }
    }
    if (hasAttrsChanged) (0, _reactivity.trigger)(instance, "set", "$attrs");
    validateProps(rawProps || {}, props, instance);
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) for(let key in rawProps){
        if ((0, _shared.isReservedProp)(key)) continue;
        const value1 = rawProps[key];
        let camelKey;
        if (options && (0, _shared.hasOwn)(options, camelKey = (0, _shared.camelize)(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) props[camelKey] = value1;
            else (rawCastValues || (rawCastValues = {}))[camelKey] = value1;
        } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value1 !== attrs[key]) {
                attrs[key] = value1;
                hasAttrsChanged = true;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0, _reactivity.toRaw)(props);
        const castValues = rawCastValues || (0, _shared.EMPTY_OBJ);
        for(let i = 0; i < needCastKeys.length; i++){
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, _shared.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value1, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0, _shared.hasOwn)(opt, "default");
        if (hasDefault && value1 === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && (0, _shared.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) value1 = propsDefaults[key];
                else {
                    setCurrentInstance(instance);
                    value1 = propsDefaults[key] = defaultValue.call(null, props);
                    unsetCurrentInstance();
                }
            } else value1 = defaultValue;
        }
        if (opt[0 /* shouldCast */ ]) {
            if (isAbsent && !hasDefault) value1 = false;
            else if (opt[1 /* shouldCastTrue */ ] && (value1 === "" || value1 === (0, _shared.hyphenate)(key))) value1 = true;
        }
    }
    return value1;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) return cached;
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !(0, _shared.isFunction)(comp)) {
        const extendProps = (raw2)=>{
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            (0, _shared.extend)(normalized, props);
            if (keys) needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) appContext.mixins.forEach(extendProps);
        if (comp.extends) extendProps(comp.extends);
        if (comp.mixins) comp.mixins.forEach(extendProps);
    }
    if (!raw && !hasExtends) {
        if ((0, _shared.isObject)(comp)) cache.set(comp, (0, _shared.EMPTY_ARR));
        return 0, _shared.EMPTY_ARR;
    }
    if ((0, _shared.isArray)(raw)) for(let i = 0; i < raw.length; i++){
        if (!(0, _shared.isString)(raw[i])) warn(`props must be strings when using array syntax.`, raw[i]);
        const normalizedKey = (0, _shared.camelize)(raw[i]);
        if (validatePropName(normalizedKey)) normalized[normalizedKey] = (0, _shared.EMPTY_OBJ);
    }
    else if (raw) {
        if (!(0, _shared.isObject)(raw)) warn(`invalid props options`, raw);
        for(const key in raw){
            const normalizedKey = (0, _shared.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = normalized[normalizedKey] = (0, _shared.isArray)(opt) || (0, _shared.isFunction)(opt) ? {
                    type: opt
                } : (0, _shared.extend)({}, opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */ ] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */ ] = stringIndex < 0 || booleanIndex < stringIndex;
                    if (booleanIndex > -1 || (0, _shared.hasOwn)(prop, "default")) needCastKeys.push(normalizedKey);
                }
            }
        }
    }
    const res = [
        normalized,
        needCastKeys
    ];
    if ((0, _shared.isObject)(comp)) cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== "$") return true;
    else warn(`Invalid prop name: "${key}" is a reserved property.`);
    return false;
}
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0, _shared.isArray)(expectedTypes)) return expectedTypes.findIndex((t)=>isSameType(t, type));
    else if ((0, _shared.isFunction)(expectedTypes)) return isSameType(expectedTypes, type) ? 0 : -1;
    return -1;
}
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0, _reactivity.toRaw)(props);
    const options = instance.propsOptions[0];
    for(const key in options){
        let opt = options[key];
        if (opt == null) continue;
        validateProp(key, resolvedValues[key], opt, !(0, _shared.hasOwn)(rawProps, key) && !(0, _shared.hasOwn)(rawProps, (0, _shared.hyphenate)(key)));
    }
}
function validateProp(name, value1, prop, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    if (value1 == null && !required) return;
    if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = (0, _shared.isArray)(type) ? type : [
            type
        ];
        const expectedTypes = [];
        for(let i = 0; i < types.length && !isValid; i++){
            const { valid, expectedType } = assertType(value1, types[i]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value1, expectedTypes));
            return;
        }
    }
    if (validator && !validator(value1)) warn('Invalid prop: custom validator check failed for prop "' + name + '".');
}
const isSimpleType = /* @__PURE__ */ (0, _shared.makeMap)("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value1, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value1;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") valid = value1 instanceof type;
    } else if (expectedType === "Object") valid = (0, _shared.isObject)(value1);
    else if (expectedType === "Array") valid = (0, _shared.isArray)(value1);
    else if (expectedType === "null") valid = value1 === null;
    else valid = value1 instanceof type;
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value1, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map((0, _shared.capitalize)).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0, _shared.toRawType)(value1);
    const expectedValue = styleValue(value1, expectedType);
    const receivedValue = styleValue(value1, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) message += ` with value ${expectedValue}`;
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) message += `with value ${receivedValue}.`;
    return message;
}
function styleValue(value1, type) {
    if (type === "String") return `"${value1}"`;
    else if (type === "Number") return `${Number(value1)}`;
    else return `${value1}`;
}
function isExplicable(type) {
    const explicitTypes = [
        "string",
        "number",
        "boolean"
    ];
    return explicitTypes.some((elem)=>type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some((elem)=>elem.toLowerCase() === "boolean");
}
const isInternalKey = (key)=>key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value1)=>(0, _shared.isArray)(value1) ? value1.map(normalizeVNode) : [
        normalizeVNode(value1)
    ];
const normalizeSlot = (key, rawSlot, ctx)=>{
    if (rawSlot._n) return rawSlot;
    const normalized = withCtx((...args)=>{
        if (currentInstance) warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance)=>{
    const ctx = rawSlots._ctx;
    for(const key in rawSlots){
        if (isInternalKey(key)) continue;
        const value1 = rawSlots[key];
        if ((0, _shared.isFunction)(value1)) slots[key] = normalizeSlot(key, value1, ctx);
        else if (value1 != null) {
            warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            const normalized = normalizeSlotValue(value1);
            slots[key] = ()=>normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children)=>{
    if (!isKeepAlive(instance.vnode) && true) warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    const normalized = normalizeSlotValue(children);
    instance.slots.default = ()=>normalized;
};
const initSlots = (instance, children)=>{
    if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            instance.slots = (0, _reactivity.toRaw)(children);
            (0, _shared.def)(children, "_", type);
        } else normalizeObjectSlots(children, instance.slots = {});
    } else {
        instance.slots = {};
        if (children) normalizeVNodeSlots(instance, children);
    }
    (0, _shared.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized)=>{
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = (0, _shared.EMPTY_OBJ);
    if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
            if (isHmrUpdating) {
                (0, _shared.extend)(slots, children);
                (0, _reactivity.trigger)(instance, "set", "$slots");
            } else if (optimized && type === 1) needDeletionCheck = false;
            else {
                (0, _shared.extend)(slots, children);
                if (!optimized && type === 1) delete slots._;
            }
        } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = {
            default: 1
        };
    }
    if (needDeletionCheck) {
        for(const key in slots)if (!isInternalKey(key) && !(key in deletionComparisonTarget)) delete slots[key];
    }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if ((0, _shared.isArray)(rawRef)) {
        rawRef.forEach((r, i)=>setRef(r, oldRawRef && ((0, _shared.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) return;
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value1 = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (!owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === (0, _shared.EMPTY_OBJ) ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
        if ((0, _shared.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0, _shared.hasOwn)(setupState, oldRef)) setupState[oldRef] = null;
        } else if ((0, _reactivity.isRef)(oldRef)) oldRef.value = null;
    }
    if ((0, _shared.isFunction)(ref)) callWithErrorHandling(ref, owner, 12, [
        value1,
        refs
    ]);
    else {
        const _isString = (0, _shared.isString)(ref);
        const _isRef = (0, _reactivity.isRef)(ref);
        if (_isString || _isRef) {
            const doSet = ()=>{
                if (rawRef.f) {
                    const existing = _isString ? (0, _shared.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
                    if (isUnmount) (0, _shared.isArray)(existing) && (0, _shared.remove)(existing, refValue);
                    else {
                        if (!(0, _shared.isArray)(existing)) {
                            if (_isString) {
                                refs[ref] = [
                                    refValue
                                ];
                                if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = refs[ref];
                            } else {
                                ref.value = [
                                    refValue
                                ];
                                if (rawRef.k) refs[rawRef.k] = ref.value;
                            }
                        } else if (!existing.includes(refValue)) existing.push(refValue);
                    }
                } else if (_isString) {
                    refs[ref] = value1;
                    if ((0, _shared.hasOwn)(setupState, ref)) setupState[ref] = value1;
                } else if (_isRef) {
                    ref.value = value1;
                    if (rawRef.k) refs[rawRef.k] = value1;
                } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
            };
            if (value1) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            } else doSet();
        } else warn("Invalid template ref type:", ref, `(${typeof ref})`);
    }
}
let hasMismatch = false;
const isSVGContainer = (container)=>/svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node)=>node.nodeType === 8 /* COMMENT */ ;
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container)=>{
        if (!container.hasChildNodes()) {
            warn(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) console.error(`Hydration completed but contains mismatches.`);
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false)=>{
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = ()=>handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch(type){
            case Text:
                if (domType !== 3 /* TEXT */ ) {
                    if (vnode.children === "") {
                        insert(vnode.el = createText(""), parentNode(node), node);
                        nextNode = node;
                    } else nextNode = onMismatch();
                } else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        warn(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */  || isFragmentStart) nextNode = onMismatch();
                else nextNode = nextSibling(node);
                break;
            case Static:
                if (isFragmentStart) {
                    node = nextSibling(node);
                    domType = node.nodeType;
                }
                if (domType === 1 /* ELEMENT */  || domType === 3 /* TEXT */ ) {
                    nextNode = node;
                    const needToAdoptContent = !vnode.children.length;
                    for(let i = 0; i < vnode.staticCount; i++){
                        if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */  ? nextNode.outerHTML : nextNode.data;
                        if (i === vnode.staticCount - 1) vnode.anchor = nextNode;
                        nextNode = nextSibling(nextNode);
                    }
                    return isFragmentStart ? nextSibling(nextNode) : nextNode;
                } else onMismatch();
                break;
            case Fragment:
                if (!isFragmentStart) nextNode = onMismatch();
                else nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) {
                    if (domType !== 1 /* ELEMENT */  || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) nextNode = onMismatch();
                    else nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                } else if (shapeFlag & 6) {
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                    if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") nextNode = nextSibling(nextNode);
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                        } else subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                } else if (shapeFlag & 64) {
                    if (domType !== 8 /* COMMENT */ ) nextNode = onMismatch();
                    else nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                } else if (shapeFlag & 128) nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                else warn("Invalid HostVNode type:", type, `(${typeof type})`);
        }
        if (ref != null) setRef(ref, null, parentSuspense, vnode);
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        const forcePatchValue = type === "input" && dirs || type === "option";
        {
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
            if (props) {
                if (forcePatchValue || !optimized || patchFlag & 48) {
                    for(const key in props)if (forcePatchValue && key.endsWith("value") || (0, _shared.isOn)(key) && !(0, _shared.isReservedProp)(key)) patchProp(el, key, null, props[key], false, void 0, parentComponent);
                } else if (props.onClick) patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) queueEffectWithSuspense(()=>{
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while(next){
                    hasMismatch = true;
                    if (!hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            } else if (shapeFlag & 8) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    warn(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for(let i = 0; i < l; i++){
            const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
            if (node) node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            else if (vnode.type === Text && !vnode.children) continue;
            else {
                hasMismatch = true;
                if (!hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized)=>{
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === "]") return nextSibling(vnode.anchor = next);
        else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment)=>{
        hasMismatch = true;
        warn(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */  ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
        vnode.el = null;
        if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while(true){
                const next2 = nextSibling(node);
                if (next2 && next2 !== end) remove(next2);
                else break;
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node)=>{
        let match = 0;
        while(node){
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === "[") match++;
                if (node.data === "]") {
                    if (match === 0) return nextSibling(node);
                    else match--;
                }
            }
        }
        return node;
    };
    return [
        hydrate,
        hydrateNode
    ];
}
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) perf.mark(`vue-${type}-${instance.uid}`);
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
}
function isSupported() {
    if (supported !== void 0) return supported;
    if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
    } else supported = false;
    return supported;
}
function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
        needWarn.push(`__VUE_OPTIONS_API__`);
        (0, _shared.getGlobalThis)().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
        needWarn.push(`__VUE_PROD_DEVTOOLS__`);
        (0, _shared.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (0, needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
    }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
    return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
    initFeatureFlags();
    const target = (0, _shared.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = (0, _shared.NOOP), insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren)=>{
        if (n1 === n2) return;
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch(type){
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) mountStaticNode(n2, container, anchor, isSVG);
                else patchStaticNode(n1, n2, container, isSVG);
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1) processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 6) processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (shapeFlag & 64) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else if (shapeFlag & 128) type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                else warn("Invalid VNode type:", type, `(${typeof type})`);
        }
        if (ref != null && parentComponent) setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    };
    const processText = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) hostSetText(el, n2.children);
        }
    };
    const processCommentNode = (n1, n2, container, anchor)=>{
        if (n1 == null) hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        else n2.el = n1.el;
    };
    const mountStaticNode = (n2, container, anchor, isSVG)=>{
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    const patchStaticNode = (n1, n2, container, isSVG)=>{
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        } else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor })=>{
        let next;
        while(el && el !== anchor){
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        else patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) hostSetElementText(el, vnode.children);
        else if (shapeFlag & 16) mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "created");
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
            for(const key in props)if (key !== "value" && !(0, _shared.isReservedProp)(key)) hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            if ("value" in props) hostPatchProp(el, "value", null, props.value);
            if (vnodeHook = props.onVnodeBeforeMount) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
        });
        if (dirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
        if (scopeId) hostSetScopeId(el, scopeId);
        if (slotScopeIds) for(let i = 0; i < slotScopeIds.length; i++)hostSetScopeId(el, slotScopeIds[i]);
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) subTree = filterSingleRoot(subTree.children) || subTree;
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0)=>{
        for(let i = start; i < children.length; i++){
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || (0, _shared.EMPTY_OBJ);
        const newProps = n2.props || (0, _shared.EMPTY_OBJ);
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        if (dirs) invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else if (!optimized) patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        if (patchFlag > 0) {
            if (patchFlag & 16) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            else {
                if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
                if (patchFlag & 4) hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
                if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for(let i = 0; i < propsToUpdate.length; i++){
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev || key === "value") hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if (patchFlag & 1) {
                if (n1.children !== n2.children) hostSetElementText(el, n2.children);
            }
        } else if (!optimized && dynamicChildren == null) patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds)=>{
        for(let i = 0; i < newChildren.length; i++){
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & 70) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG)=>{
        if (oldProps !== newProps) {
            if (oldProps !== (0, _shared.EMPTY_OBJ)) {
                for(const key in oldProps)if (!(0, _shared.isReservedProp)(key) && !(key in newProps)) hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            for(const key in newProps){
                if ((0, _shared.isReservedProp)(key)) continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev && key !== "value") hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
            if ("value" in newProps) hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (// #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2);
        } else patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512) parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            else mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        } else updateComponent(n1, n2, optimized);
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized)=>{
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (0, instance.type.__hmrId) registerHMR(instance);
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
        if (isKeepAlive(initialVNode)) instance.ctx.renderer = internals;
        startMeasure(instance, `init`);
        setupComponent(instance);
        endMeasure(instance, `init`);
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
                const placeholder = instance.subTree = createVNode(Comment);
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        popWarningContext();
        endMeasure(instance, `mount`);
    };
    const updateComponent = (n1, n2, optimized)=>{
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
                pushWarningContext(n2);
                updateComponentPreRender(instance, n2, optimized);
                popWarningContext();
                return;
            } else {
                instance.next = n2;
                invalidateJob(instance.update);
                instance.update();
            }
        } else {
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)=>{
        const componentUpdateFn = ()=>{
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                if (bm) (0, _shared.invokeArrayFns)(bm);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) invokeVNodeHook(vnodeHook, parent, initialVNode);
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    const hydrateSubTree = ()=>{
                        startMeasure(instance, `render`);
                        instance.subTree = renderComponentRoot(instance);
                        endMeasure(instance, `render`);
                        startMeasure(instance, `hydrate`);
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        endMeasure(instance, `hydrate`);
                    };
                    if (isAsyncWrapperVNode) initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    ()=>!instance.isUnmounted && hydrateSubTree());
                    else hydrateSubTree();
                } else {
                    startMeasure(instance, `render`);
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    endMeasure(instance, `render`);
                    startMeasure(instance, `patch`);
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    endMeasure(instance, `patch`);
                    initialVNode.el = subTree.el;
                }
                if (m) queuePostRenderEffect(m, parentSuspense);
                if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                instance.isMounted = true;
                devtoolsComponentAdded(instance);
                initialVNode = container = anchor = null;
            } else {
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                pushWarningContext(next || instance.vnode);
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                } else next = vnode;
                if (bu) (0, _shared.invokeArrayFns)(bu);
                if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) invokeVNodeHook(vnodeHook, parent, next, vnode);
                toggleRecurse(instance, true);
                startMeasure(instance, `render`);
                const nextTree = renderComponentRoot(instance);
                endMeasure(instance, `render`);
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                startMeasure(instance, `patch`);
                patch(prevTree, nextTree, // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                endMeasure(instance, `patch`);
                next.el = nextTree.el;
                if (originNext === null) updateHOCHostEl(instance, nextTree.el);
                if (u) queuePostRenderEffect(u, parentSuspense);
                if (vnodeHook = next.props && next.props.onVnodeUpdated) queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                devtoolsComponentUpdated(instance);
                popWarningContext();
            }
        };
        const effect = instance.effect = new (0, _reactivity.ReactiveEffect)(componentUpdateFn, ()=>queueJob(update), instance.scope);
        const update = instance.update = ()=>effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        effect.onTrack = instance.rtc ? (e)=>(0, _shared.invokeArrayFns)(instance.rtc, e) : void 0;
        effect.onTrigger = instance.rtg ? (e)=>(0, _shared.invokeArrayFns)(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized)=>{
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0, _reactivity.pauseTracking)();
        flushPreFlushCbs();
        (0, _reactivity.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false)=>{
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
            if (patchFlag & 128) {
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            } else if (patchFlag & 256) {
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        if (shapeFlag & 8) {
            if (prevShapeFlag & 16) unmountChildren(c1, parentComponent, parentSuspense);
            if (c2 !== c1) hostSetElementText(container, c2);
        } else if (prevShapeFlag & 16) {
            if (shapeFlag & 16) patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else unmountChildren(c1, parentComponent, parentSuspense, true);
        } else {
            if (prevShapeFlag & 8) hostSetElementText(container, "");
            if (shapeFlag & 16) mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        c1 = c1 || (0, _shared.EMPTY_ARR);
        c2 = c2 || (0, _shared.EMPTY_ARR);
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for(i = 0; i < commonLength; i++){
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        else mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized)=>{
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while(i <= e1 && i <= e2){
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            i++;
        }
        while(i <= e1 && i <= e2){
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            else break;
            e1--;
            e2--;
        }
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while(i <= e2){
                    patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        } else if (i > e2) while(i <= e1){
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
        }
        else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for(i = s2; i <= e2; i++){
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (nextChild.key != null) {
                    if (keyToNewIndexMap.has(nextChild.key)) warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
            for(i = s1; i <= e1; i++){
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) newIndex = keyToNewIndexMap.get(prevChild.key);
                else {
                    for(j = s2; j <= e2; j++)if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                    }
                }
                if (newIndex === void 0) unmount(prevChild, parentComponent, parentSuspense, true);
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) maxNewIndexSoFar = newIndex;
                    else moved = true;
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : (0, _shared.EMPTY_ARR);
            j = increasingNewIndexSequence.length - 1;
            for(i = toBePatched - 1; i >= 0; i--){
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) move(nextChild, container, anchor, 2);
                    else j--;
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for(let i = 0; i < children.length; i++)move(children[i], container, anchor, moveType);
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
            if (moveType === 0) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
            } else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove2 = ()=>hostInsert(el, container, anchor);
                const performLeave = ()=>{
                    leave(el, ()=>{
                        remove2();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) delayLeave(el, remove2, performLeave);
                else performLeave();
            }
        } else hostInsert(el, container, anchor);
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref != null) setRef(ref, null, parentSuspense, vnode, true);
        if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) invokeVNodeHook(vnodeHook, parentComponent, vnode);
        if (shapeFlag & 6) unmountComponent(vnode.component, parentSuspense, doRemove);
        else {
            if (shapeFlag & 128) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            if (shapeFlag & 64) vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            else if (type === Fragment && patchFlag & 384 || !optimized && shapeFlag & 16) unmountChildren(children, parentComponent, parentSuspense);
            if (doRemove) remove(vnode);
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) queuePostRenderEffect(()=>{
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
    };
    const remove = (vnode)=>{
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) vnode.children.forEach((child)=>{
                if (child.type === Comment) hostRemove(child.el);
                else remove(child);
            });
            else removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = ()=>{
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) transition.afterLeave();
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = ()=>leave(el, performRemove);
            if (delayLeave) delayLeave(vnode.el, performRemove, performLeave);
            else performLeave();
        } else performRemove();
    };
    const removeFragment = (cur, end)=>{
        let next;
        while(cur !== end){
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove)=>{
        if (0, instance.type.__hmrId) unregisterHMR(instance);
        const { bum, scope, update, subTree, um } = instance;
        if (bum) (0, _shared.invokeArrayFns)(bum);
        scope.stop();
        if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) queuePostRenderEffect(um, parentSuspense);
        queuePostRenderEffect(()=>{
            instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) parentSuspense.resolve();
        }
        devtoolsComponentRemoved(instance);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0)=>{
        for(let i = start; i < children.length; i++)unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    };
    const getNextHostNode = (vnode)=>{
        if (vnode.shapeFlag & 6) return getNextHostNode(vnode.component.subTree);
        if (vnode.shapeFlag & 128) return vnode.suspense.next();
        return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG)=>{
        if (vnode == null) {
            if (container._vnode) unmount(container._vnode, null, null, true);
        } else patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) [hydrate, hydrateNode] = createHydrationFns(internals);
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0, _shared.isArray)(ch1) && (0, _shared.isArray)(ch2)) for(let i = 0; i < ch1.length; i++){
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
            }
            if (!shallow) traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) c2.el = c1.el;
        if (c2.type === Comment && !c2.el) c2.el = c1.el;
    }
}
function getSequence(arr) {
    const p = arr.slice();
    const result = [
        0
    ];
    let i, j, u, v1, c;
    const len = arr.length;
    for(i = 0; i < len; i++){
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v1 = result.length - 1;
            while(u < v1){
                c = u + v1 >> 1;
                if (arr[result[c]] < arrI) u = c + 1;
                else v1 = c;
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) p[i] = result[u - 1];
                result[u] = i;
            }
        }
    }
    u = result.length;
    v1 = result[u - 1];
    while(u-- > 0){
        result[u] = v1;
        v1 = p[v1];
    }
    return result;
}
const isTeleport = (type)=>type.__isTeleport;
const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select)=>{
    const targetSelector = props && props.to;
    if ((0, _shared.isString)(targetSelector)) {
        if (!select) {
            warn(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
        } else {
            const target = select(targetSelector);
            if (!target) warn(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            return target;
        }
    } else {
        if (!targetSelector && !isTeleportDisabled(props)) warn(`Invalid Teleport target: ${targetSelector}`);
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            const placeholder = n2.el = createComment("teleport start");
            const mainAnchor = n2.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
                insert(targetAnchor, target);
                isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) warn("Invalid Teleport target on mount:", target, `(${typeof target})`);
            const mount = (container2, anchor2)=>{
                if (shapeFlag & 16) mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            };
            if (disabled) mount(container, mainAnchor);
            else if (target) mount(target, targetAnchor);
        } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                traverseStaticChildren(n1, n2, true);
            } else if (!optimized) patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            if (disabled) {
                if (!wasDisabled) moveTeleport(n2, container, mainAnchor, internals, 1);
            } else {
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                    if (nextTarget) moveTeleport(n2, nextTarget, null, internals, 0);
                    else warn("Invalid Teleport target on update:", target, `(${typeof target})`);
                } else if (wasDisabled) moveTeleport(n2, target, targetAnchor, internals, 1);
            }
        }
        updateCssVars(n2);
    },
    remove (vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) hostRemove(targetAnchor);
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) for(let i = 0; i < children.length; i++){
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) insert(vnode.targetAnchor, container, parentAnchor);
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) insert(el, container, parentAnchor);
    if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) for(let i = 0; i < children.length; i++)move(children[i], container, parentAnchor, 2);
    }
    if (isReorder) insert(anchor, container, parentAnchor);
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            } else {
                vnode.anchor = nextSibling(node);
                let targetAnchor = targetNode;
                while(targetAnchor){
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
        updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while(node !== vnode.targetAnchor){
            if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
        }
        ctx.ut();
    }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value1) {
    isBlockTreeEnabled += value1;
}
function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || (0, _shared.EMPTY_ARR) : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(vnode);
    return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value1) {
    return value1 ? value1.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args)=>{
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key })=>key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for })=>{
    if (typeof ref === "number") ref = "" + ref;
    return ref != null ? (0, _shared.isString)(ref) || (0, _reactivity.isRef)(ref) || (0, _shared.isFunction)(ref) ? {
        i: currentRenderingInstance,
        r: ref,
        k: ref_key,
        f: !!ref_for
    } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) type.normalize(vnode);
    } else if (children) vnode.shapeFlag |= (0, _shared.isString)(children) ? 8 : 16;
    if (vnode.key !== vnode.key) warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) currentBlock.push(vnode);
    return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) warn(`Invalid vnode type when creating vnode: ${type}.`);
        type = Comment;
    }
    if (isVNode(type)) {
        const cloned = cloneVNode(type, props, true);
        if (children) normalizeChildren(cloned, children);
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) currentBlock[currentBlock.indexOf(type)] = cloned;
            else currentBlock.push(cloned);
        }
        cloned.patchFlag |= -2;
        return cloned;
    }
    if (isClassComponent(type)) type = type.__vccOpts;
    if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !(0, _shared.isString)(klass)) props.class = (0, _shared.normalizeClass)(klass);
        if ((0, _shared.isObject)(style)) {
            if ((0, _reactivity.isProxy)(style) && !(0, _shared.isArray)(style)) style = (0, _shared.extend)({}, style);
            props.style = (0, _shared.normalizeStyle)(style);
        }
    }
    const shapeFlag = (0, _shared.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0, _shared.isObject)(type) ? 4 : (0, _shared.isFunction)(type) ? 2 : 0;
    if (shapeFlag & 4 && (0, _reactivity.isProxy)(type)) {
        type = (0, _reactivity.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props) return null;
    return (0, _reactivity.isProxy)(props) || InternalObjectKey in props ? (0, _shared.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? (0, _shared.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [
            ref,
            normalizeRef(extraProps)
        ] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && (0, _shared.isArray)(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
    };
    return cloned;
}
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0, _shared.isArray)(vnode.children)) cloned.children = vnode.children.map(deepCloneVNode);
    return cloned;
}
function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") return createVNode(Comment);
    else if ((0, _shared.isArray)(child)) return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
    else if (typeof child === "object") return cloneIfMounted(child);
    else return createVNode(Text, null, String(child));
}
function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) children = null;
    else if ((0, _shared.isArray)(children)) type = 16;
    else if (typeof children === "object") {
        if (shapeFlag & 65) {
            const slot = children.default;
            if (slot) {
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) children._ctx = currentRenderingInstance;
            else if (slotFlag === 3 && currentRenderingInstance) {
                if (currentRenderingInstance.slots._ === 1) children._ = 1;
                else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                }
            }
        }
    } else if ((0, _shared.isFunction)(children)) {
        children = {
            default: children,
            _ctx: currentRenderingInstance
        };
        type = 32;
    } else {
        children = String(children);
        if (shapeFlag & 64) {
            type = 16;
            children = [
                createTextVNode(children)
            ];
        } else type = 8;
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for(let i = 0; i < args.length; i++){
        const toMerge = args[i];
        for(const key in toMerge){
            if (key === "class") {
                if (ret.class !== toMerge.class) ret.class = (0, _shared.normalizeClass)([
                    ret.class,
                    toMerge.class
                ]);
            } else if (key === "style") ret.style = (0, _shared.normalizeStyle)([
                ret.style,
                toMerge.style
            ]);
            else if ((0, _shared.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming && existing !== incoming && !((0, _shared.isArray)(existing) && existing.includes(incoming))) ret[key] = existing ? [].concat(existing, incoming) : incoming;
            } else if (key !== "") ret[key] = toMerge[key];
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
    ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new (0, _reactivity.EffectScope)(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: (0, _shared.EMPTY_OBJ),
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: (0, _shared.EMPTY_OBJ),
        data: (0, _shared.EMPTY_OBJ),
        props: (0, _shared.EMPTY_OBJ),
        attrs: (0, _shared.EMPTY_OBJ),
        slots: (0, _shared.EMPTY_OBJ),
        refs: (0, _shared.EMPTY_OBJ),
        setupState: (0, _shared.EMPTY_OBJ),
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    instance.ctx = createDevRenderContext(instance);
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) vnode.ce(instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
if (!(globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey])) globalCurrentInstanceSetters = (0, _shared.getGlobalThis)()[settersKey] = [];
globalCurrentInstanceSetters.push((i)=>currentInstance = i);
internalSetCurrentInstance = (instance)=>{
    if (globalCurrentInstanceSetters.length > 1) globalCurrentInstanceSetters.forEach((s)=>s(instance));
    else globalCurrentInstanceSetters[0](instance);
};
const setCurrentInstance = (instance)=>{
    internalSetCurrentInstance(instance);
    instance.scope.on();
};
const unsetCurrentInstance = ()=>{
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0, _shared.makeMap)("slot,component");
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || (0, _shared.NO);
    if (isBuiltInTag(name) || appIsNativeTag(name)) warn("Do not use built-in or reserved HTML elements as component id: " + name);
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if (Component.name) validateComponentName(Component.name, instance.appContext.config);
    if (Component.components) {
        const names = Object.keys(Component.components);
        for(let i = 0; i < names.length; i++)validateComponentName(names[i], instance.appContext.config);
    }
    if (Component.directives) {
        const names = Object.keys(Component.directives);
        for(let i = 0; i < names.length; i++)validateDirectiveName(names[i]);
    }
    if (Component.compilerOptions && isRuntimeOnly()) warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = (0, _reactivity.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    exposePropsOnRenderContext(instance);
    const { setup } = Component;
    if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0, [
            (0, _reactivity.shallowReadonly)(instance.props),
            setupContext
        ]);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
        if ((0, _shared.isPromise)(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) return setupResult.then((resolvedResult)=>{
                handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e)=>{
                handleError(e, instance, 0);
            });
            else {
                instance.asyncDep = setupResult;
                if (!instance.suspense) {
                    const name = (_a = Component.name) != null ? _a : "Anonymous";
                    warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
                }
            }
        } else handleSetupResult(instance, setupResult, isSSR);
    } else finishComponentSetup(instance, isSSR);
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0, _shared.isFunction)(setupResult)) {
        if (instance.type.__ssrInlineRender) instance.ssrRender = setupResult;
        else instance.render = setupResult;
    } else if ((0, _shared.isObject)(setupResult)) {
        if (isVNode(setupResult)) warn(`setup() should not return VNodes directly - return a render function instead.`);
        instance.devtoolsRawSetupState = setupResult;
        instance.setupState = (0, _reactivity.proxyRefs)(setupResult);
        exposeSetupStateOnRenderContext(instance);
    } else if (setupResult !== void 0) warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i)=>{
        if (i.render._rc) i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    };
}
const isRuntimeOnly = ()=>!compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                startMeasure(instance, `compile`);
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0, _shared.extend)((0, _shared.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                endMeasure(instance, `compile`);
            }
        }
        instance.render = Component.render || (0, _shared.NOOP);
        if (installWithProxy) installWithProxy(instance);
    }
    if (__VUE_OPTIONS_API__ && true) {
        setCurrentInstance(instance);
        (0, _reactivity.pauseTracking)();
        applyOptions(instance);
        (0, _reactivity.resetTracking)();
        unsetCurrentInstance();
    }
    if (!Component.render && instance.render === (0, _shared.NOOP) && !isSSR) {
        if (!compile && Component.template) warn(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
        else warn(`Component is missing template or render function.`);
    }
}
function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs, {
        get (target, key) {
            markAttrsAccessed();
            (0, _reactivity.track)(instance, "get", "$attrs");
            return target[key];
        },
        set () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        },
        deleteProperty () {
            warn(`setupContext.attrs is readonly.`);
            return false;
        }
    }));
}
function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get (target, key) {
            (0, _reactivity.track)(instance, "get", "$slots");
            return target[key];
        }
    }));
}
function createSetupContext(instance) {
    const expose = (exposed)=>{
        if (instance.exposed) warn(`expose() should be called only once per setup().`);
        if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
                if ((0, _shared.isArray)(exposed)) exposedType = "array";
                else if ((0, _reactivity.isRef)(exposed)) exposedType = "ref";
            }
            if (exposedType !== "object") warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
        instance.exposed = exposed || {};
    };
    return Object.freeze({
        get attrs () {
            return getAttrsProxy(instance);
        },
        get slots () {
            return getSlotsProxy(instance);
        },
        get emit () {
            return (event, ...args)=>instance.emit(event, ...args);
        },
        expose
    });
}
function getExposeProxy(instance) {
    if (instance.exposed) return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, _reactivity.proxyRefs)((0, _reactivity.markRaw)(instance.exposed)), {
        get (target, key) {
            if (key in target) return target[key];
            else if (key in publicPropertiesMap) return publicPropertiesMap[key](instance);
        },
        has (target, key) {
            return key in target || key in publicPropertiesMap;
        }
    }));
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
    return (0, _shared.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) name = match[1];
    }
    if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry)=>{
            for(const key in registry){
                if (registry[key] === Component) return key;
            }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value1) {
    return (0, _shared.isFunction)(value1) && "__vccOpts" in value1;
}
const computed = (getterOrOptions, debugOptions)=>{
    return (0, _reactivity.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0, _shared.isObject)(propsOrChildren) && !(0, _shared.isArray)(propsOrChildren)) {
            if (isVNode(propsOrChildren)) return createVNode(type, null, [
                propsOrChildren
            ]);
            return createVNode(type, propsOrChildren);
        } else return createVNode(type, null, propsOrChildren);
    } else {
        if (l > 3) children = Array.prototype.slice.call(arguments, 2);
        else if (l === 3 && isVNode(children)) children = [
            children
        ];
        return createVNode(type, propsOrChildren, children);
    }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = ()=>{
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
        return ctx;
    }
};
function isShallow(value1) {
    return !!(value1 && value1["__v_isShallow"]);
}
function initCustomFormatter() {
    if (typeof window === "undefined") return;
    const vueStyle = {
        style: "color:#3ba776"
    };
    const numberStyle = {
        style: "color:#0b1bc9"
    };
    const stringStyle = {
        style: "color:#b62e24"
    };
    const keywordStyle = {
        style: "color:#9d288c"
    };
    const formatter = {
        header (obj) {
            if (!(0, _shared.isObject)(obj)) return null;
            if (obj.__isVue) return [
                "div",
                vueStyle,
                `VueInstance`
            ];
            else if ((0, _reactivity.isRef)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    genRefFlag(obj)
                ],
                "<",
                formatValue(obj.value),
                `>`
            ];
            else if ((0, _reactivity.isReactive)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReactive" : "Reactive"
                ],
                "<",
                formatValue(obj),
                `>${(0, _reactivity.isReadonly)(obj) ? ` (readonly)` : ``}`
            ];
            else if ((0, _reactivity.isReadonly)(obj)) return [
                "div",
                {},
                [
                    "span",
                    vueStyle,
                    isShallow(obj) ? "ShallowReadonly" : "Readonly"
                ],
                "<",
                formatValue(obj),
                ">"
            ];
            return null;
        },
        hasBody (obj) {
            return obj && obj.__isVue;
        },
        body (obj) {
            if (obj && obj.__isVue) return [
                "div",
                {},
                ...formatInstance(obj.$)
            ];
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) blocks.push(createInstanceBlock("props", (0, _reactivity.toRaw)(instance.props)));
        if (instance.setupState !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("setup", instance.setupState));
        if (instance.data !== (0, _shared.EMPTY_OBJ)) blocks.push(createInstanceBlock("data", (0, _reactivity.toRaw)(instance.data)));
        const computed = extractKeys(instance, "computed");
        if (computed) blocks.push(createInstanceBlock("computed", computed));
        const injected = extractKeys(instance, "inject");
        if (injected) blocks.push(createInstanceBlock("injected", injected));
        blocks.push([
            "div",
            {},
            [
                "span",
                {
                    style: keywordStyle.style + ";opacity:0.66"
                },
                "$ (internal): "
            ],
            [
                "object",
                {
                    object: instance
                }
            ]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0, _shared.extend)({}, target);
        if (!Object.keys(target).length) return [
            "span",
            {}
        ];
        return [
            "div",
            {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            [
                "div",
                {
                    style: "color:#476582"
                },
                type
            ],
            [
                "div",
                {
                    style: "padding-left:1.25em"
                },
                ...Object.keys(target).map((key)=>{
                    return [
                        "div",
                        {},
                        [
                            "span",
                            keywordStyle,
                            key + ": "
                        ],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v1, asRaw = true) {
        if (typeof v1 === "number") return [
            "span",
            numberStyle,
            v1
        ];
        else if (typeof v1 === "string") return [
            "span",
            stringStyle,
            JSON.stringify(v1)
        ];
        else if (typeof v1 === "boolean") return [
            "span",
            keywordStyle,
            v1
        ];
        else if ((0, _shared.isObject)(v1)) return [
            "object",
            {
                object: asRaw ? (0, _reactivity.toRaw)(v1) : v1
            }
        ];
        else return [
            "span",
            stringStyle,
            String(v1)
        ];
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0, _shared.isFunction)(Comp)) return;
        const extracted = {};
        for(const key in instance.ctx)if (isKeyOfType(Comp, key, type)) extracted[key] = instance.ctx[key];
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((0, _shared.isArray)(opts) && opts.includes(key) || (0, _shared.isObject)(opts) && key in opts) return true;
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) return true;
        if (Comp.mixins && Comp.mixins.some((m)=>isKeyOfType(m, key, type))) return true;
    }
    function genRefFlag(v1) {
        if (isShallow(v1)) return `ShallowRef`;
        if (v1.effect) return `ComputedRef`;
        return `Ref`;
    }
    if (window.devtoolsFormatters) window.devtoolsFormatters.push(formatter);
    else window.devtoolsFormatters = [
        formatter
    ];
}
function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) return cached;
    const ret = render();
    ret.memo = memo.slice();
    return cache[index] = ret;
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) return false;
    for(let i = 0; i < prev.length; i++){
        if ((0, _shared.hasChanged)(prev[i], memo[i])) return false;
    }
    if (isBlockTreeEnabled > 0 && currentBlock) currentBlock.push(cached);
    return true;
}
const version = "3.3.4";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode: isVNode,
    normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;

},{"@vue/reactivity":"TU1x5","@vue/shared":"hPWoE","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"TU1x5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EffectScope", ()=>EffectScope);
parcelHelpers.export(exports, "ITERATE_KEY", ()=>ITERATE_KEY);
parcelHelpers.export(exports, "ReactiveEffect", ()=>ReactiveEffect);
parcelHelpers.export(exports, "computed", ()=>computed);
parcelHelpers.export(exports, "customRef", ()=>customRef);
parcelHelpers.export(exports, "deferredComputed", ()=>deferredComputed);
parcelHelpers.export(exports, "effect", ()=>effect);
parcelHelpers.export(exports, "effectScope", ()=>effectScope);
parcelHelpers.export(exports, "enableTracking", ()=>enableTracking);
parcelHelpers.export(exports, "getCurrentScope", ()=>getCurrentScope);
parcelHelpers.export(exports, "isProxy", ()=>isProxy);
parcelHelpers.export(exports, "isReactive", ()=>isReactive);
parcelHelpers.export(exports, "isReadonly", ()=>isReadonly);
parcelHelpers.export(exports, "isRef", ()=>isRef);
parcelHelpers.export(exports, "isShallow", ()=>isShallow);
parcelHelpers.export(exports, "markRaw", ()=>markRaw);
parcelHelpers.export(exports, "onScopeDispose", ()=>onScopeDispose);
parcelHelpers.export(exports, "pauseTracking", ()=>pauseTracking);
parcelHelpers.export(exports, "proxyRefs", ()=>proxyRefs);
parcelHelpers.export(exports, "reactive", ()=>reactive);
parcelHelpers.export(exports, "readonly", ()=>readonly);
parcelHelpers.export(exports, "ref", ()=>ref);
parcelHelpers.export(exports, "resetTracking", ()=>resetTracking);
parcelHelpers.export(exports, "shallowReactive", ()=>shallowReactive);
parcelHelpers.export(exports, "shallowReadonly", ()=>shallowReadonly);
parcelHelpers.export(exports, "shallowRef", ()=>shallowRef);
parcelHelpers.export(exports, "stop", ()=>stop);
parcelHelpers.export(exports, "toRaw", ()=>toRaw);
parcelHelpers.export(exports, "toRef", ()=>toRef);
parcelHelpers.export(exports, "toRefs", ()=>toRefs);
parcelHelpers.export(exports, "toValue", ()=>toValue);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "trigger", ()=>trigger);
parcelHelpers.export(exports, "triggerRef", ()=>triggerRef);
parcelHelpers.export(exports, "unref", ()=>unref);
var _shared = require("@vue/shared");
function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
    constructor(detached = false){
        this.detached = detached;
        /**
     * @internal
     */ this._active = true;
        /**
     * @internal
     */ this.effects = [];
        /**
     * @internal
     */ this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
    get active() {
        return this._active;
    }
    run(fn) {
        if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            } finally{
                activeEffectScope = currentEffectScope;
            }
        } else warn(`cannot run an inactive effect scope.`);
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ on() {
        activeEffectScope = this;
    }
    /**
   * This should only be called on non-detached scopes
   * @internal
   */ off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this._active) {
            let i, l;
            for(i = 0, l = this.effects.length; i < l; i++)this.effects[i].stop();
            for(i = 0, l = this.cleanups.length; i < l; i++)this.cleanups[i]();
            if (this.scopes) for(i = 0, l = this.scopes.length; i < l; i++)this.scopes[i].stop(true);
            if (!this.detached && this.parent && !fromParent) {
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = void 0;
            this._active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) scope.effects.push(effect);
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) activeEffectScope.cleanups.push(fn);
    else warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
}
const createDep = (effects)=>{
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep)=>(dep.w & trackOpBit) > 0;
const newTracked = (dep)=>(dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps })=>{
    if (deps.length) for(let i = 0; i < deps.length; i++)deps[i].w |= trackOpBit;
};
const finalizeDepMarkers = (effect)=>{
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for(let i = 0; i < deps.length; i++){
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) dep.delete(effect);
            else deps[ptr++] = dep;
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
    constructor(fn, scheduler = null, scope){
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) return this.fn();
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while(parent){
            if (parent === this) return;
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) initDepMarkers(this);
            else cleanupEffect(this);
            return this.fn();
        } finally{
            if (effectTrackDepth <= maxMarkerBits) finalizeDepMarkers(this);
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) this.stop();
        }
    }
    stop() {
        if (activeEffect === this) this.deferStop = true;
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) this.onStop();
            this.active = false;
        }
    }
}
function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
        for(let i = 0; i < deps.length; i++)deps[i].delete(effect2);
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) fn = fn.effect.fn;
    const _effect = new ReactiveEffect(fn);
    if (options) {
        (0, _shared.extend)(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) _effect.run();
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        let dep = depsMap.get(key);
        if (!dep) depsMap.set(key, dep = createDep());
        const eventInfo = {
            effect: activeEffect,
            target,
            type,
            key
        };
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
        }
    } else shouldTrack2 = !dep.has(activeEffect);
    if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (0, activeEffect.onTrack) activeEffect.onTrack((0, _shared.extend)({
            effect: activeEffect
        }, debuggerEventExtraInfo));
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    let deps = [];
    if (type === "clear") deps = [
        ...depsMap.values()
    ];
    else if (key === "length" && (0, _shared.isArray)(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2)=>{
            if (key2 === "length" || key2 >= newLength) deps.push(dep);
        });
    } else {
        if (key !== void 0) deps.push(depsMap.get(key));
        switch(type){
            case "add":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                } else if ((0, _shared.isIntegerKey)(key)) deps.push(depsMap.get("length"));
                break;
            case "delete":
                if (!(0, _shared.isArray)(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if ((0, _shared.isMap)(target)) deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
                break;
            case "set":
                if ((0, _shared.isMap)(target)) deps.push(depsMap.get(ITERATE_KEY));
                break;
        }
    }
    const eventInfo = {
        target,
        type,
        key,
        newValue,
        oldValue,
        oldTarget
    };
    if (deps.length === 1) {
        if (deps[0]) triggerEffects(deps[0], eventInfo);
    } else {
        const effects = [];
        for (const dep of deps)if (dep) effects.push(...dep);
        triggerEffects(createDep(effects), eventInfo);
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    const effects = (0, _shared.isArray)(dep) ? dep : [
        ...dep
    ];
    for (const effect2 of effects)if (effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
    for (const effect2 of effects)if (!effect2.computed) triggerEffect(effect2, debuggerEventExtraInfo);
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (0, effect2.onTrigger) effect2.onTrigger((0, _shared.extend)({
            effect: effect2
        }, debuggerEventExtraInfo));
        if (effect2.scheduler) effect2.scheduler();
        else effect2.run();
    }
}
function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ (0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter((0, _shared.isSymbol)));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    [
        "includes",
        "indexOf",
        "lastIndexOf"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for(let i = 0, l = this.length; i < l; i++)track(arr, "get", i + "");
            const res = arr[key](...args);
            if (res === -1 || res === false) return arr[key](...args.map(toRaw));
            else return res;
        };
    });
    [
        "push",
        "pop",
        "shift",
        "unshift",
        "splice"
    ].forEach((key)=>{
        instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function hasOwnProperty(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
        if (key === "__v_isReactive") return !isReadonly2;
        else if (key === "__v_isReadonly") return isReadonly2;
        else if (key === "__v_isShallow") return shallow;
        else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) return target;
        const targetIsArray = (0, _shared.isArray)(target);
        if (!isReadonly2) {
            if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) return Reflect.get(arrayInstrumentations, key, receiver);
            if (key === "hasOwnProperty") return hasOwnProperty;
        }
        const res = Reflect.get(target, key, receiver);
        if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) return res;
        if (!isReadonly2) track(target, "get", key);
        if (shallow) return res;
        if (isRef(res)) return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;
        if ((0, _shared.isObject)(res)) return isReadonly2 ? readonly(res) : reactive(res);
        return res;
    };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
    return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) return false;
        if (!shallow) {
            if (!isShallow(value) && !isReadonly(value)) {
                oldValue = toRaw(oldValue);
                value = toRaw(value);
            }
            if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
            if (!hadKey) trigger(target, "add", key, value);
            else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0, _shared.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function has$1(target, key) {
    const result = Reflect.has(target, key);
    if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) track(target, "has", key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate", (0, _shared.isArray)(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get: get$1,
    set: set$1,
    deleteProperty,
    has: has$1,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set (target, key) {
        warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    },
    deleteProperty (target, key) {
        warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        return true;
    }
};
const shallowReactiveHandlers = /* @__PURE__ */ (0, _shared.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ (0, _shared.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});
const toShallow = (value)=>value;
const getProto = (v)=>Reflect.getPrototypeOf(v);
function get(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "get", key);
        track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) return wrap(target.get(key));
    else if (has2.call(rawTarget, rawKey)) return wrap(target.get(rawKey));
    else if (target !== rawTarget) target.get(key);
}
function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) track(rawTarget, "has", key);
        track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
    }
    return this;
}
function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) trigger(target, "add", key, value);
    else if ((0, _shared.hasChanged)(value, oldValue)) trigger(target, "set", key, value, oldValue);
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
    } else checkIdentityKeys(target, has2, key);
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) trigger(target, "delete", key, void 0, oldValue);
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = (0, _shared.isMap)(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) trigger(target, "clear", void 0, void 0, oldTarget);
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key)=>{
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = (0, _shared.isMap)(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
            // iterator protocol
            next () {
                const { value, done } = innerIterator.next();
                return done ? {
                    value,
                    done
                } : {
                    value: isPair ? [
                        wrap(value[0]),
                        wrap(value[1])
                    ] : wrap(value),
                    done
                };
            },
            // iterable protocol
            [Symbol.iterator] () {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function(...args) {
        {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations2 = {
        get (key) {
            return get(this, key);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
        get (key) {
            return get(this, key, false, true);
        },
        get size () {
            return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
        get (key) {
            return get(this, key, true, true);
        },
        get size () {
            return size(this, true);
        },
        has (key) {
            return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
    ];
    iteratorMethods.forEach((method)=>{
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver)=>{
        if (key === "__v_isReactive") return !isReadonly;
        else if (key === "__v_isReadonly") return isReadonly;
        else if (key === "__v_raw") return target;
        return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
        const type = (0, _shared.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
    switch(rawType){
        case "Object":
        case "Array":
            return 1 /* COMMON */ ;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2 /* COLLECTION */ ;
        default:
            return 0 /* INVALID */ ;
    }
}
function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */  : targetTypeMap((0, _shared.toRawType)(value));
}
function reactive(target) {
    if (isReadonly(target)) return target;
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0, _shared.isObject)(target)) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
        return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) return target;
    const existingProxy = proxyMap.get(target);
    if (existingProxy) return existingProxy;
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */ ) return target;
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */  ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) return isReactive(value["__v_raw"]);
    return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    (0, _shared.def)(value, "__v_skip", true);
    return value;
}
const toReactive = (value)=>(0, _shared.isObject)(value) ? reactive(value) : value;
const toReadonly = (value)=>(0, _shared.isObject)(value) ? readonly(value) : value;
function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffects(ref2.dep || (ref2.dep = createDep()), {
            target: ref2,
            type: "get",
            key: "value"
        });
    }
}
function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
    });
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) return rawValue;
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow){
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if ((0, _shared.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref2) {
    triggerRefValue(ref2, (0, ref2.value));
}
function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
    return (0, _shared.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver)=>unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver)=>{
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        } else return Reflect.set(target, key, value, receiver);
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory){
        this.dep = void 0;
        this.__v_isRef = true;
        const { get, set } = factory(()=>trackRefValue(this), ()=>triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (!isProxy(object)) console.warn(`toRefs() expects a reactive object but received a plain one.`);
    const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};
    for(const key in object)ret[key] = propertyToRef(object, key);
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue){
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
    get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
    }
}
class GetterRefImpl {
    constructor(_getter){
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
    }
    get value() {
        return this._getter();
    }
}
function toRef(source, key, defaultValue) {
    if (isRef(source)) return source;
    else if ((0, _shared.isFunction)(source)) return new GetterRefImpl(source);
    else if ((0, _shared.isObject)(source) && arguments.length > 1) return propertyToRef(source, key, defaultValue);
    else return ref(source);
}
function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR){
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, ()=>{
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly;
    }
    get value() {
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = (0, _shared.isFunction)(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ()=>{
            console.warn("Write operation failed: computed value is readonly");
        };
    } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}
const tick = /* @__PURE__ */ Promise.resolve();
const queue = [];
let queued = false;
const scheduler = (fn)=>{
    queue.push(fn);
    if (!queued) {
        queued = true;
        tick.then(flush);
    }
};
const flush = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue.length = 0;
    queued = false;
};
class DeferredComputedRefImpl {
    constructor(getter){
        this.dep = void 0;
        this._dirty = true;
        this.__v_isRef = true;
        this["__v_isReadonly"] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger)=>{
            if (this.dep) {
                if (computedTrigger) {
                    compareTarget = this._value;
                    hasCompareTarget = true;
                } else if (!scheduled) {
                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                    scheduled = true;
                    hasCompareTarget = false;
                    scheduler(()=>{
                        if (this.effect.active && this._get() !== valueToCompare) triggerRefValue(this);
                        scheduled = false;
                    });
                }
                for (const e of this.dep)if (e.computed instanceof DeferredComputedRefImpl) e.scheduler(true);
            }
            this._dirty = true;
        });
        this.effect.computed = this;
    }
    _get() {
        if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
        }
        return this._value;
    }
    get value() {
        trackRefValue(this);
        return toRaw(this)._get();
    }
}
function deferredComputed(getter) {
    return new DeferredComputedRefImpl(getter);
}

},{"@vue/shared":"hPWoE","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hPWoE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY_ARR", ()=>EMPTY_ARR);
parcelHelpers.export(exports, "EMPTY_OBJ", ()=>EMPTY_OBJ);
parcelHelpers.export(exports, "NO", ()=>NO);
parcelHelpers.export(exports, "NOOP", ()=>NOOP);
parcelHelpers.export(exports, "PatchFlagNames", ()=>PatchFlagNames);
parcelHelpers.export(exports, "camelize", ()=>camelize);
parcelHelpers.export(exports, "capitalize", ()=>capitalize);
parcelHelpers.export(exports, "def", ()=>def);
parcelHelpers.export(exports, "escapeHtml", ()=>escapeHtml);
parcelHelpers.export(exports, "escapeHtmlComment", ()=>escapeHtmlComment);
parcelHelpers.export(exports, "extend", ()=>extend);
parcelHelpers.export(exports, "genPropsAccessExp", ()=>genPropsAccessExp);
parcelHelpers.export(exports, "generateCodeFrame", ()=>generateCodeFrame);
parcelHelpers.export(exports, "getGlobalThis", ()=>getGlobalThis);
parcelHelpers.export(exports, "hasChanged", ()=>hasChanged);
parcelHelpers.export(exports, "hasOwn", ()=>hasOwn);
parcelHelpers.export(exports, "hyphenate", ()=>hyphenate);
parcelHelpers.export(exports, "includeBooleanAttr", ()=>includeBooleanAttr);
parcelHelpers.export(exports, "invokeArrayFns", ()=>invokeArrayFns);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isBooleanAttr", ()=>isBooleanAttr);
parcelHelpers.export(exports, "isBuiltInDirective", ()=>isBuiltInDirective);
parcelHelpers.export(exports, "isDate", ()=>isDate);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
parcelHelpers.export(exports, "isGloballyWhitelisted", ()=>isGloballyWhitelisted);
parcelHelpers.export(exports, "isHTMLTag", ()=>isHTMLTag);
parcelHelpers.export(exports, "isIntegerKey", ()=>isIntegerKey);
parcelHelpers.export(exports, "isKnownHtmlAttr", ()=>isKnownHtmlAttr);
parcelHelpers.export(exports, "isKnownSvgAttr", ()=>isKnownSvgAttr);
parcelHelpers.export(exports, "isMap", ()=>isMap);
parcelHelpers.export(exports, "isModelListener", ()=>isModelListener);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "isOn", ()=>isOn);
parcelHelpers.export(exports, "isPlainObject", ()=>isPlainObject);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
parcelHelpers.export(exports, "isRegExp", ()=>isRegExp);
parcelHelpers.export(exports, "isReservedProp", ()=>isReservedProp);
parcelHelpers.export(exports, "isSSRSafeAttrName", ()=>isSSRSafeAttrName);
parcelHelpers.export(exports, "isSVGTag", ()=>isSVGTag);
parcelHelpers.export(exports, "isSet", ()=>isSet);
parcelHelpers.export(exports, "isSpecialBooleanAttr", ()=>isSpecialBooleanAttr);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
parcelHelpers.export(exports, "isVoidTag", ()=>isVoidTag);
parcelHelpers.export(exports, "looseEqual", ()=>looseEqual);
parcelHelpers.export(exports, "looseIndexOf", ()=>looseIndexOf);
parcelHelpers.export(exports, "looseToNumber", ()=>looseToNumber);
parcelHelpers.export(exports, "makeMap", ()=>makeMap);
parcelHelpers.export(exports, "normalizeClass", ()=>normalizeClass);
parcelHelpers.export(exports, "normalizeProps", ()=>normalizeProps);
parcelHelpers.export(exports, "normalizeStyle", ()=>normalizeStyle);
parcelHelpers.export(exports, "objectToString", ()=>objectToString);
parcelHelpers.export(exports, "parseStringStyle", ()=>parseStringStyle);
parcelHelpers.export(exports, "propsToAttrMap", ()=>propsToAttrMap);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "slotFlagsText", ()=>slotFlagsText);
parcelHelpers.export(exports, "stringifyStyle", ()=>stringifyStyle);
parcelHelpers.export(exports, "toDisplayString", ()=>toDisplayString);
parcelHelpers.export(exports, "toHandlerKey", ()=>toHandlerKey);
parcelHelpers.export(exports, "toNumber", ()=>toNumber);
parcelHelpers.export(exports, "toRawType", ()=>toRawType);
parcelHelpers.export(exports, "toTypeString", ()=>toTypeString);
var global = arguments[3];
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++)map[list[i]] = true;
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = ()=>{};
const NO = ()=>false;
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key);
const isModelListener = (key)=>key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el)=>{
    const i = arr.indexOf(el);
    if (i > -1) arr.splice(i, 1);
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key)=>hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val)=>toTypeString(val) === "[object Map]";
const isSet = (val)=>toTypeString(val) === "[object Set]";
const isDate = (val)=>toTypeString(val) === "[object Date]";
const isRegExp = (val)=>toTypeString(val) === "[object RegExp]";
const isFunction = (val)=>typeof val === "function";
const isString = (val)=>typeof val === "string";
const isSymbol = (val)=>typeof val === "symbol";
const isObject = (val)=>val !== null && typeof val === "object";
const isPromise = (val)=>{
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value)=>objectToString.call(value);
const toRawType = (value)=>{
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val)=>toTypeString(val) === "[object Object]";
const isIntegerKey = (key)=>isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(// the leading comma is intentional so empty string "" is also included
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn)=>{
    const cache = /* @__PURE__ */ Object.create(null);
    return (str)=>{
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str)=>{
    return str.replace(camelizeRE, (_, c)=>c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str)=>str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str)=>str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
const invokeArrayFns = (fns, arg)=>{
    for(let i = 0; i < fns.length; i++)fns[i](arg);
};
const def = (obj, key, value)=>{
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const looseToNumber = (val)=>{
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
const toNumber = (val)=>{
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = ()=>{
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
    return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
};
const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
};
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx)=>idx % 2 === 1);
    lines = lines.filter((_, idx)=>idx % 2 === 0);
    let count = 0;
    const res = [];
    for(let i = 0; i < lines.length; i++){
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
            for(let j = i - range; j <= i + range || end > count; j++){
                if (j < 0 || j >= lines.length) continue;
                const line = j + 1;
                res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
                if (j === i) {
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
                } else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + "^".repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join("\n");
}
function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for(let i = 0; i < value.length; i++){
            const item = value[i];
            const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) for(const key in normalized)res[key] = normalized[key];
        }
        return res;
    } else if (isString(value)) return value;
    else if (isObject(value)) return value;
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) return ret;
    for(const key in styles){
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number") ret += `${normalizedKey}:${value};`;
    }
    return ret;
}
function normalizeClass(value) {
    let res = "";
    if (isString(value)) res = value;
    else if (isArray(value)) for(let i = 0; i < value.length; i++){
        const normalized = normalizeClass(value[i]);
        if (normalized) res += normalized + " ";
    }
    else if (isObject(value)) {
        for(const name in value)if (value[name]) res += name + " ";
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) props.class = normalizeClass(klass);
    if (style) props.style = normalizeStyle(style);
    return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
    return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) return attrValidationCache[name];
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) console.error(`unsafe attribute name: ${name}`);
    return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) return str;
    let html = "";
    let escaped;
    let index;
    let lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escaped = "&quot;";
                break;
            case 38:
                escaped = "&amp;";
                break;
            case 39:
                escaped = "&#39;";
                break;
            case 60:
                escaped = "&lt;";
                break;
            case 62:
                escaped = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.slice(lastIndex, index);
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for(let i = 0; equal && i < a.length; i++)equal = looseEqual(a[i], b[i]);
    return equal;
}
function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) return a === b;
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        if (!aValidType || !bValidType) return false;
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) return false;
        for(const key in a){
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) return false;
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex((item)=>looseEqual(item, val));
}
const toDisplayString = (val)=>{
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val)=>{
    if (val && val.__v_isRef) return replacer(_key, val.value);
    else if (isMap(val)) return {
        [`Map(${val.size})`]: [
            ...val.entries()
        ].reduce((entries, [key, val2])=>{
            entries[`${key} =>`] = val2;
            return entries;
        }, {})
    };
    else if (isSet(val)) return {
        [`Set(${val.size})`]: [
            ...val.values()
        ]
    };
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) return String(val);
    return val;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j7FRh":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"3XNOl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("9a0e878b2c966db7");
    if (script.__esModule) script = script.default;
    script.render = require("83c4961b1fab4013").render;
    require("b6434c1879c48fcf").default(script);
    script.__scopeId = "data-v-a73bc7";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/views/Index.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "a73bc7-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("a73bc7-hmr", script)) __VUE_HMR_RUNTIME__.reload("a73bc7-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"9a0e878b2c966db7":"l92l2","83c4961b1fab4013":"irpcQ","b6434c1879c48fcf":"fcG6L","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"l92l2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../ts/Utils");
exports.default = {
    data () {
        return {
            classrooms: window["edrys"].index,
            peerID: (0, _utils.getPeerID)()
        };
    },
    methods: {
        async init () {
            console.log("init");
        },
        deleteClass (id) {
            window["edrys"].database.drop(id);
            window.location.search = "";
        },
        forkClass (classroom) {
            classroom = JSON.parse(JSON.stringify(classroom));
            console.log(classroom);
            const id = (0, _utils.infoHash)();
            classroom.data.createdBy = (0, _utils.getPeerID)();
            classroom.id = id;
            window["edrys"].database.put(id, classroom.data, null);
            window.location.href = `?/classroom/${id}`;
        },
        async createClass () {
            const id = (0, _utils.infoHash)();
            const classroom = {
                id,
                createdBy: (0, _utils.getPeerID)(),
                dateCreated: new Date().getTime(),
                name: "My New Class",
                meta: {
                    logo: "",
                    description: "",
                    selfAssign: false,
                    defaultNumberOfRooms: 0
                },
                members: {
                    teacher: [],
                    student: []
                },
                modules: [
                    {
                        url: "https://edrys-org.github.io/module-reference/",
                        config: "",
                        studentConfig: "",
                        teacherConfig: "",
                        stationConfig: "",
                        width: "full",
                        height: "tall"
                    }
                ]
            };
            window["edrys"].database.put(id, classroom, null);
            window.location.href = `?/classroom/${id}`;
        }
    }
};

},{"../ts/Utils":"j822r","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j822r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyUrl", ()=>copyUrl);
parcelHelpers.export(exports, "parseClassroom", ()=>parseClassroom);
parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "stringify", ()=>stringify);
parcelHelpers.export(exports, "scrapeModule", ()=>scrapeModule);
parcelHelpers.export(exports, "download", ()=>download);
parcelHelpers.export(exports, "debounce", ()=>debounce);
parcelHelpers.export(exports, "setToValue", ()=>setToValue);
parcelHelpers.export(exports, "validateUrl", ()=>validateUrl);
parcelHelpers.export(exports, "infoHash", ()=>infoHash);
parcelHelpers.export(exports, "getPeerID", ()=>getPeerID);
var _jsYaml = require("js-yaml");
function loadResource(type, url, base) {
    if (url.match(/(https?)?:\/\//i)) {
        if (type === "script") return `<script src="${url}"></script>`;
        else return `<link rel="stylesheet" href="${url}" />`;
    }
    const absoluteURL = new URL(url, base).toString();
    return `<script>
        fetch("${absoluteURL}")
        .then((response) => response.text())
        .then((code) => {
            const blob = new Blob([code], { type: "text/${type}" })
            const blobUrl = window.URL.createObjectURL(blob)

            switch("${type}") {
                case "script": {
                    const tag = document.createElement('script')
                    tag.setAttribute('src', blobUrl)
                    document.head.appendChild(tag)
                    break
                }
                case "css": {
                    const tag = document.createElement('link')
                    tag.setAttribute('rel', 'stylesheet')
                    tag.setAttribute('href', blobUrl)
                    document.head.appendChild(tag)
                    break
                }
                default: {
                    console.warn("Unknown type: ${type}")
                }
            }
        })
        .catch((e) => {
            console.warn("failed to fetch: ${absoluteURL}")
        })
    </script>
    `;
}
function replace(code, baseURL) {
    try {
        let head = code.match(/<head>.*?<\/head>/is)[0];
        head = head.replace(/<script.*?src=(?:'|")([^"']+)(?:'|").*?>.*?<\/script>/gims, (pat)=>{
            let url = pat.match(/src=(?:'|")([^"']+)(?:'|")/is);
            if (url) {
                url = url[1];
                if (!(url.startsWith("https://") || url.startsWith("http://"))) return loadResource("script", url, baseURL);
            }
            return pat;
        });
        head = head.replace(/<link.*?href=(?:'|")([^"']+)(?:'|").*?>/gims, (pat)=>{
            let url = pat.match(/href=(?:'|")([^"']+)(?:'|")/is);
            if (url) {
                url = url[1];
                if (!(url.startsWith("https://") || url.startsWith("http://"))) return loadResource("css", url, baseURL);
            }
            return pat;
        });
        return code.replace(/<head>.*?<\/head>/is, head);
    } catch (e) {
        console.warn("problems parsing html:", e);
    }
}
function copyUrl(url) {
    navigator.clipboard.writeText(url);
}
function parseClassroom(config) {
    let classroom;
    console.warn("parse Classroom", config);
    try {
        classroom = parse(config);
        if (classroom) // guarantees that older modules without a custom show can be loaded
        for(let i = 0; i < classroom.modules; i++)classroom.modules[i].showInCustom = classroom.modules[i].showInCustom || classroom.modules[i].showIn || "";
    } catch (e) {
        console.warn("could not parse classroom", e.message);
    }
    return classroom;
}
function parse(config) {
    let data = undefined;
    try {
        data = JSON.parse(config);
    } catch (e) {
        data = _jsYaml.load(config);
    }
    return data;
}
function stringify(config) {
    return _jsYaml.dump(config);
}
async function scrapeModule(module) {
    try {
        const response = await fetch(module.url);
        const content = await response.text();
        if (module.url.match(/\.ya?ml$/i)) try {
            const yaml = _jsYaml.load(content);
            const links = yaml.load?.links || [];
            const scripts = yaml.load?.scripts || [];
            const code = `<!DOCTYPE html>
                      <html>
                      <head>
                      ${links.map((url)=>{
                return loadResource("css", url, module.url);
            }).join("\n")}
                      
                          ${scripts.map((url)=>{
                return loadResource("script", url, module.url);
            }).join("\n")}

                          <style type="module">${yaml.style || ""}</style>
                          <script>${yaml.main}</script>
                          </head>
                          <body>
                          ${yaml.body || ""}
                          </body>
                          </html>
                          `;
            return {
                ...module,
                name: yaml.name,
                description: yaml.description,
                icon: yaml.icon || "mdi-package",
                shownIn: yaml["show-in"] || [
                    "*"
                ],
                srcdoc: "data:text/html," + escape(code),
                origin: "*"
            };
        } catch (error) {
            console.warn("loading yaml:", error);
            throw new Error("Could not load the YAML-declaration: " + error.message);
        }
        else {
            const moduleEl = document.createElement("html");
            moduleEl.innerHTML = content;
            const meta = Object.fromEntries(Object.values(moduleEl.getElementsByTagName("meta")).map((m)=>[
                    m.name,
                    m.content
                ]));
            if (meta["fetch"] && meta["fetch"] !== "false") return {
                ...module,
                name: moduleEl.getElementsByTagName("title")[0].innerText || meta["name"],
                description: meta["description"],
                icon: meta["icon"] || "mdi-package",
                shownIn: (meta["show-in"] || "*").replace(/\s+/g, "").split(","),
                srcdoc: "data:text/html," + escape(replace(content, module.url)),
                origin: "*"
            };
            try {
                return {
                    ...module,
                    name: moduleEl.getElementsByTagName("title")[0].innerText || meta["name"],
                    description: meta["description"],
                    icon: meta["icon"] || "mdi-package",
                    shownIn: (meta["show-in"] || "*").replace(/\s+/g, "").split(",")
                };
            } catch (error) {
                throw new Error("This does not seem to be a valid module declaration, check the URL manually.");
            }
        }
    } catch (error) {
        return {
            ...module,
            name: "<Error: exception scraping module>",
            description: error,
            icon: "mdi-alert",
            shownIn: ""
        };
    }
}
function download(filename, text) {
    /**
   * https://stackoverflow.com/questions/3665115/how-to-create-a-file-in-memory-for-user-to-download-but-not-through-server
   */ const element = document.createElement("a");
    element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    element.setAttribute("download", filename);
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}
function debounce(func, wait, immediate) {
    /**
   * https://davidwalsh.name/javascript-debounce-function
   */ let timeout;
    return function() {
        const context = this, args = arguments;
        const later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
}
function setToValue(obj, pathArr, value) {
    let i = 0;
    for(i = 0; i < pathArr.length - 1; i++){
        obj = obj[pathArr[i]];
        if (!obj[pathArr[i + 1]]) obj[pathArr[i + 1]] = {};
    }
    obj[pathArr[i]] = value;
// if (value == undefined)
//     delete obj[pathArr[i]]
}
function validateUrl(string) {
    try {
        const url = new URL(string);
        // URL: allows to define protocols such as `abc:` or `bla:`
        const protocols = [
            "http:",
            "https:",
            "file:",
            "ipfs:",
            "ipns:",
            "blob:",
            "dat:",
            "hyper:"
        ];
        if (protocols.includes(url.protocol)) return true;
    } catch (err) {}
    return false;
}
function infoHash(length = 40) {
    let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    // Pick characters randomly
    let str = "";
    for(let i = 0; i < length; i++)str += chars.charAt(Math.floor(Math.random() * chars.length));
    return str;
}
function getPeerID() {
    let peerID = localStorage.getItem("peerID");
    if (!peerID) {
        peerID = infoHash(12);
        localStorage.setItem("peerID", peerID);
    }
    return peerID;
}

},{"js-yaml":"9ulSV","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9ulSV":[function(require,module,exports) {
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CORE_SCHEMA", ()=>CORE_SCHEMA);
parcelHelpers.export(exports, "DEFAULT_SCHEMA", ()=>DEFAULT_SCHEMA);
parcelHelpers.export(exports, "FAILSAFE_SCHEMA", ()=>FAILSAFE_SCHEMA);
parcelHelpers.export(exports, "JSON_SCHEMA", ()=>JSON_SCHEMA);
parcelHelpers.export(exports, "Schema", ()=>Schema);
parcelHelpers.export(exports, "Type", ()=>Type);
parcelHelpers.export(exports, "YAMLException", ()=>YAMLException);
parcelHelpers.export(exports, "dump", ()=>dump);
parcelHelpers.export(exports, "load", ()=>load);
parcelHelpers.export(exports, "loadAll", ()=>loadAll);
parcelHelpers.export(exports, "safeDump", ()=>safeDump);
parcelHelpers.export(exports, "safeLoad", ()=>safeLoad);
parcelHelpers.export(exports, "safeLoadAll", ()=>safeLoadAll);
parcelHelpers.export(exports, "types", ()=>types);
function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
    return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function repeat(string, count) {
    var result = "", cycle;
    for(cycle = 0; cycle < count; cycle += 1)result += string;
    return result;
}
function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
};
// YAML error class. http://stackoverflow.com/questions/8458984
function formatError(exception, compact) {
    var where = "", message = exception.reason || "(unknown reason)";
    if (!exception.mark) return message;
    if (exception.mark.name) where += 'in "' + exception.mark.name + '" ';
    where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
    if (!compact && exception.mark.snippet) where += "\n\n" + exception.mark.snippet;
    return message + " " + where;
}
function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    // Include stack trace in error object
    if (Error.captureStackTrace) // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
    else // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || "";
}
// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
    }
    return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "‚Üí") + tail,
        pos: position - lineStart + head.length // relative position
    };
}
function padStart(string, max) {
    return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [
        0
    ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while(match = re.exec(mark.buffer)){
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) foundLineNo = lineStarts.length - 2;
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for(i = 1; i <= options.linesBefore; i++){
        if (foundLineNo - i < 0) break;
        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^" + "\n";
    for(i = 1; i <= options.linesAfter; i++){
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
];
var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
];
function compileStyleAliases(map) {
    var result = {};
    if (map !== null) Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
            result[String(alias)] = style;
        });
    });
    return result;
}
function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    });
    // TODO: Add tag format check.
    this.options = options; // keep original options in case user wants to extend this type later
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
        return true;
    };
    this.construct = options["construct"] || function(data) {
        return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type = Type$1;
/*eslint-disable max-len*/ function compileList(schema, name) {
    var result = [];
    schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) newIndex = previousIndex;
        });
        result[newIndex] = currentType;
    });
    return result;
}
function compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
        }
    }, index, length;
    function collectType(type) {
        if (type.multi) {
            result.multi[type.kind].push(type);
            result.multi["fallback"].push(type);
        } else result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for(index = 0, length = arguments.length; index < length; index += 1)arguments[index].forEach(collectType);
    return result;
}
function Schema$1(definition) {
    return this.extend(definition);
}
Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) // Schema.extend(type)
    explicit.push(definition);
    else if (Array.isArray(definition)) // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);
    else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        if (type$1.loadKind && type$1.loadKind !== "scalar") throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        if (type$1.multi) throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    });
    explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
        return data !== null ? data : "";
    }
});
var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
        return data !== null ? data : [];
    }
});
var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
        return data !== null ? data : {};
    }
});
var failsafe = new schema({
    explicit: [
        str,
        seq,
        map
    ]
});
function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
    return null;
}
function isNull(object) {
    return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
        canonical: function() {
            return "~";
        },
        lowercase: function() {
            return "null";
        },
        uppercase: function() {
            return "NULL";
        },
        camelcase: function() {
            return "Null";
        },
        empty: function() {
            return "";
        }
    },
    defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? "true" : "false";
        },
        uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
            return object ? "True" : "False";
        }
    },
    defaultStyle: "lowercase"
});
function isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === "-" || ch === "+") ch = data[++index];
    if (ch === "0") {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === "b") {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "x") {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "o") {
            // base 8
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!isOctCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
    }
    // base 10 (except 0)
    // value should not start with `_`;
    if (ch === "_") return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === "_") continue;
        if (!isDecCode(data.charCodeAt(index))) return false;
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === "_") return false;
    return true;
}
function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) value = value.replace(/_/g, "");
    ch = value[0];
    if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
}
function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
}
var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [
            2,
            "bin"
        ],
        octal: [
            8,
            "oct"
        ],
        decimal: [
            10,
            "dec"
        ],
        hexadecimal: [
            16,
            "hex"
        ]
    }
});
var YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") return false;
    return true;
}
function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) value = value.slice(1);
    if (value === ".inf") return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    else if (value === ".nan") return NaN;
    return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) switch(style){
        case "lowercase":
            return ".nan";
        case "uppercase":
            return ".NAN";
        case "camelcase":
            return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === object) switch(style){
        case "lowercase":
            return ".inf";
        case "uppercase":
            return ".INF";
        case "camelcase":
            return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === object) switch(style){
        case "lowercase":
            return "-.inf";
        case "uppercase":
            return "-.INF";
        case "camelcase":
            return "-.Inf";
    }
    else if (common.isNegativeZero(object)) return "-0.0";
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
});
var json = failsafe.extend({
    implicit: [
        _null,
        bool,
        int,
        float
    ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"); // [3] day
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"); // [11] tz_minute
function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) return new Date(Date.UTC(year, month, day));
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3)fraction += "0";
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
    return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
});
/*eslint-disable no-bitwise*/ // [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) result.push(bits >> 4 & 0xFF);
    return new Uint8Array(result);
}
function representYamlBinary(object /*, style*/ ) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if (_toString$2.call(pair) !== "[object Object]") return false;
        for(pairKey in pair)if (_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function constructYamlOmap(data) {
    return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if (_toString$1.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object)if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
    }
    return true;
}
function constructYamlSet(data) {
    return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
});
var _default = core.extend({
    implicit: [
        timestamp,
        merge
    ],
    explicit: [
        binary,
        omap,
        pairs,
        set
    ]
});
/*eslint-disable max-len,no-use-before-define*/ var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
    return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) return lc - 0x61 + 10;
    return -1;
}
function escapedHexLen(c) {
    if (c === 0x78 /* x */ ) return 2;
    if (c === 0x75 /* u */ ) return 4;
    if (c === 0x55 /* U */ ) return 8;
    return 0;
}
function fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    return -1;
}
function simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? "\x00" : c === 0x61 /* a */  ? "\x07" : c === 0x62 /* b */  ? "\b" : c === 0x74 /* t */  ? "	" : c === 0x09 /* Tab */  ? "	" : c === 0x6E /* n */  ? "\n" : c === 0x76 /* v */  ? "\v" : c === 0x66 /* f */  ? "\f" : c === 0x72 /* r */  ? "\r" : c === 0x65 /* e */  ? "\x1b" : c === 0x20 /* Space */  ? " " : c === 0x22 /* " */  ? '"' : c === 0x2F /* / */  ? "/" : c === 0x5C /* \ */  ? "\\" : c === 0x4E /* N */  ? "\x85" : c === 0x5F /* _ */  ? "\xa0" : c === 0x4C /* L */  ? "\u2028" : c === 0x50 /* P */  ? "\u2029" : "";
}
function charFromCodepoint(c) {
    if (c <= 0xFFFF) return String.fromCharCode(c);
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for(var i = 0; i < 256; i++){
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function generateError(state, message) {
    var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
}
function throwError(state, message) {
    throw generateError(state, message);
}
function throwWarning(state, message) {
    if (state.onWarning) state.onWarning.call(null, generateError(state, message));
}
var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) throwError(state, "duplication of %YAML directive");
        if (args.length !== 1) throwError(state, "YAML directive accepts exactly one argument");
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) throwError(state, "ill-formed argument of the YAML directive");
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) throwError(state, "unacceptable YAML version of the document");
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) throwError(state, "TAG directive accepts exactly two arguments");
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        if (_hasOwnProperty$1.call(state.tagMap, handle)) throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        if (!PATTERN_TAG_URI.test(prefix)) throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        try {
            prefix = decodeURIComponent(prefix);
        } catch (err) {
            throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
    }
};
function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) for(_position = 0, _length = _result.length; _position < _length; _position += 1){
            _character = _result.charCodeAt(_position);
            if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) throwError(state, "expected valid JSON character");
        }
        else if (PATTERN_NON_PRINTABLE.test(_result)) throwError(state, "the stream contains non-printable characters");
        state.result += _result;
    }
}
function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!_hasOwnProperty$1.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) throwError(state, "nested arrays are not supported inside keys");
            if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") keyNode[index] = "[object Object]";
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") keyNode = "[object Object]";
    keyNode = String(keyNode);
    if (_result === null) _result = {};
    if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) for(index = 0, quantity = valueNode.length; index < quantity; index += 1)mergeMappings(state, _result, valueNode[index], overridableKeys);
        else mergeMappings(state, _result, valueNode, overridableKeys);
    } else {
        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.lineStart = startLineStart || state.lineStart;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
        }
        // used for this specific key only because Object.defineProperty is slow
        if (keyNode === "__proto__") Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
        });
        else _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
    }
    return _result;
}
function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) state.position++;
    else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) state.position++;
    } else throwError(state, "a line break is expected");
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while(is_WHITE_SPACE(ch)){
            if (ch === 0x09 /* Tab */  && state.firstTabInLine === -1) state.firstTabInLine = state.position;
            ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);
        if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else break;
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) throwWarning(state, "deficient indentation");
    return lineBreaks;
}
function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) return true;
    }
    return false;
}
function writeFoldedLines(state, count) {
    if (count === 1) state.result += " ";
    else if (count > 1) state.result += common.repeat("\n", count - 1);
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) return false;
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) return false;
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) break;
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) break;
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) break;
        else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) captureEnd = state.position + 1;
        ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) return true;
    state.kind = _kind;
    state.result = _result;
    return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else return true;
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, "unexpected end of the document within a single quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) skipSeparationSpace(state, false, nodeIndent);
            else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
                    else throwError(state, "expected hexadecimal character");
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
            } else throwError(state, "unknown escape sequence");
            captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, "unexpected end of the document within a double quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else return false;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
        } else if (!readNext) throwError(state, "missed comma between flow collection entries");
        else if (ch === 0x2C /* , */ ) // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
        throwError(state, "expected the node content, but found ','");
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line; // Save the current line.
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        else if (isPair) _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        else _result.push(keyNode);
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else readNext = false;
    }
    throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) folding = false;
    else if (ch === 0x3E /* > */ ) folding = true;
    else return false;
    state.kind = "scalar";
    state.result = "";
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if (CHOMPING_CLIP === chomping) chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;
            else throwError(state, "repeat of a chomping mode identifier");
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else throwError(state, "repeat of an indentation width identifier");
        } else break;
    }
    if (is_WHITE_SPACE(ch)) {
        do ch = state.input.charCodeAt(++state.position);
        while (is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (!is_EOL(ch) && ch !== 0);
    }
    while(ch !== 0){
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) textIndent = state.lineIndent;
        if (is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) state.result += "\n";
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat("\n", emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) state.result += " ";
            } else state.result += common.repeat("\n", emptyLines);
        // Literal style: just add exact number of line breaks between content lines.
        } else // Keep all line breaks except the header line break.
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!is_EOL(ch) && ch !== 0)ch = state.input.charCodeAt(++state.position);
        captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 0x2D /* - */ ) break;
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) break;
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) throwError(state, "bad indentation of a sequence entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
    }
    return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (!atExplicitKey && state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) break;
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while(is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) throwError(state, "can not read an implicit mapping pair; a colon is missed");
                else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        }
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if (atExplicitKey) {
                _keyLine = state.line;
                _keyLineStart = state.lineStart;
                _keyPos = state.position;
            }
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) keyNode = state.result;
                else valueNode = state.result;
            }
            if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) throwError(state, "bad indentation of a mapping entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
    }
    return detected;
}
function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) throwError(state, "duplication of a tag property");
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
    } else tagHandle = "!";
    _position = state.position;
    if (isVerbatim) {
        do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && ch !== 0x3E /* > */ );
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else throwError(state, "unexpected end of the stream within a verbatim tag");
    } else {
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) throwError(state, "named tag handle cannot contain such characters");
                    isNamed = true;
                    _position = state.position + 1;
                } else throwError(state, "tag suffix cannot contain exclamation marks");
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) throwError(state, "tag suffix cannot contain flow indicator characters");
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) throwError(state, "tag name cannot contain such characters: " + tagName);
    try {
        tagName = decodeURIComponent(tagName);
    } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) state.tag = tagName;
    else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) state.tag = state.tagMap[tagHandle] + tagName;
    else if (tagHandle === "!") state.tag = "!" + tagName;
    else if (tagHandle === "!!") state.tag = "tag:yaml.org,2002:" + tagName;
    else throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    return true;
}
function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) throwError(state, "duplication of an anchor property");
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) throwError(state, "name of an anchor node must contain at least one character");
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) throwError(state, "name of an alias node must contain at least one character");
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) throwError(state, 'unidentified alias "' + alias + '"');
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
    if (state.listener !== null) state.listener("open", state);
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        }
    }
    if (indentStatus === 1) {
        while(readTagProperty(state) || readAnchorProperty(state))if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        } else allowBlockCollections = false;
    }
    if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) flowIndent = parentIndent;
        else flowIndent = parentIndent + 1;
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) hasContent = true;
            else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) hasContent = true;
                else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) throwError(state, "alias node should not have any properties");
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) state.tag = "?";
                }
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
            }
        } else if (indentStatus === 0) // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
    if (state.tag === null) {
        if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
    } else if (state.tag === "?") {
        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only automatically assigned to plain scalars.
        //
        // We only need to check kind conformity in case user explicitly assigns '?'
        // tag, for example like this: "!<?> [0]"
        //
        if (state.result !== null && state.kind !== "scalar") throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
                state.result = type.construct(state.result);
                state.tag = type.tag;
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
                break;
            }
        }
    } else if (state.tag !== "!") {
        if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) type = state.typeMap[state.kind || "fallback"][state.tag];
        else {
            // looking for multi type
            type = null;
            typeList = state.typeMap.multi[state.kind || "fallback"];
            for(typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                type = typeList[typeIndex];
                break;
            }
        }
        if (!type) throwError(state, "unknown tag !<" + state.tag + ">");
        if (state.result !== null && type.kind !== state.kind) throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        if (!type.resolve(state.result, state.tag)) throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        else {
            state.result = type.construct(state.result, state.tag);
            if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
        }
    }
    if (state.listener !== null) state.listener("close", state);
    return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) break;
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) throwError(state, "directive name must not be less than one character in length");
        while(ch !== 0){
            while(is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
            if (ch === 0x23 /* # */ ) {
                do ch = state.input.charCodeAt(++state.position);
                while (ch !== 0 && !is_EOL(ch));
                break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) directiveHandlers[directiveName](state, directiveName, directiveArgs);
        else throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) throwError(state, "directives end mark is expected");
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) throwWarning(state, "non-ASCII line breaks are interpreted as content");
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) throwError(state, "end of the stream or a document separator is expected");
    else return;
}
function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) input += "\n";
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) input = input.slice(1);
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\x00");
    if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += "\x00";
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1)readDocument(state);
    return state.documents;
}
function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") return documents;
    for(var index = 0, length = documents.length; index < length; index += 1)iterator(documents[index]);
}
function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) /*eslint-disable no-undefined*/ return undefined;
    else if (documents.length === 1) return documents[0];
    throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
    loadAll: loadAll_1,
    load: load_1
};
/*eslint-disable no-use-before-define*/ var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 0xFEFF;
var CHAR_TAB = 0x09; /* Tab */ 
var CHAR_LINE_FEED = 0x0A; /* LF */ 
var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var CHAR_SPACE = 0x20; /* Space */ 
var CHAR_EXCLAMATION = 0x21; /* ! */ 
var CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var CHAR_SHARP = 0x23; /* # */ 
var CHAR_PERCENT = 0x25; /* % */ 
var CHAR_AMPERSAND = 0x26; /* & */ 
var CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var CHAR_ASTERISK = 0x2A; /* * */ 
var CHAR_COMMA = 0x2C; /* , */ 
var CHAR_MINUS = 0x2D; /* - */ 
var CHAR_COLON = 0x3A; /* : */ 
var CHAR_EQUALS = 0x3D; /* = */ 
var CHAR_GREATER_THAN = 0x3E; /* > */ 
var CHAR_QUESTION = 0x3F; /* ? */ 
var CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = "\\0";
ESCAPE_SEQUENCES[0x07] = "\\a";
ESCAPE_SEQUENCES[0x08] = "\\b";
ESCAPE_SEQUENCES[0x09] = "\\t";
ESCAPE_SEQUENCES[0x0A] = "\\n";
ESCAPE_SEQUENCES[0x0B] = "\\v";
ESCAPE_SEQUENCES[0x0C] = "\\f";
ESCAPE_SEQUENCES[0x0D] = "\\r";
ESCAPE_SEQUENCES[0x1B] = "\\e";
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = "\\\\";
ESCAPE_SEQUENCES[0x85] = "\\N";
ESCAPE_SEQUENCES[0xA0] = "\\_";
ESCAPE_SEQUENCES[0x2028] = "\\L";
ESCAPE_SEQUENCES[0x2029] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") tag = "tag:yaml.org,2002:" + tag.slice(2);
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) style = type.styleAliases[style];
        result[tag] = style;
    }
    return result;
}
function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = "x";
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = "u";
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = "U";
        length = 8;
    } else throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while(position < length){
        next = string.indexOf("\n", position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
    }
    return result;
}
function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) return true;
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn‚Äôt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
// [127]  ns-plain-safe(c) ::= c = flow-out  ‚áí ns-plain-safe-out
//                             c = flow-in   ‚áí ns-plain-safe-in
//                             c = block-key ‚áí ns-plain-safe-out
//                             c = flow-key  ‚áí ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - ‚Äú:‚Äù - ‚Äú#‚Äù )
//                            | ( /* An ns-char preceding */ ‚Äú#‚Äù )
//                            | ( ‚Äú:‚Äù /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return(// ns-plain-safe
    (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP // false on '#'
     && !(prev === CHAR_COLON && !cIsNsChar // false on ': '
    ) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'
     || prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}
// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( ‚Äú?‚Äù | ‚Äú:‚Äù | ‚Äú-‚Äù ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white
     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
}
// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
    return first;
}
// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
        char = codePointAt(string, i);
        if (!isPrintable(char)) return STYLE_DOUBLE;
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
    }
    else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
            char = codePointAt(string, i);
            if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i;
                }
            } else if (!isPrintable(char)) return STYLE_DOUBLE;
            plain = plain && isPlainSafe(char, prevChar, inblock);
            prevChar = char;
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
        // Strings interpretable as another type have to be quoted;
        // e.g. the string 'true' vs. the boolean true.
        if (plain && !forceQuotes && !testAmbiguousType(string)) return STYLE_PLAIN;
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) return STYLE_DOUBLE;
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    ‚Ä¢ No ending newline => unaffected; already using strip "-" chomping.
//    ‚Ä¢ Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
        if (string.length === 0) return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        if (!state.noCompatMode) {
            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth ‚â§ 40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return testImplicitResolving(state, string);
        }
        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)){
            case STYLE_PLAIN:
                return string;
            case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
                return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
                return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
                return '"' + escapeString(string) + '"';
            default:
                throw new exception("impossible error: invalid scalar style");
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
}
// (See the note for writeScalar.)
function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines‚Äî
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += "\n" + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += "\n";
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    else result += line.slice(start);
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for(var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
            result += string[i];
            if (char >= 0x10000) result += string[i + 1];
        } else result += escapeSeq || encodeHex(char);
    }
    return result;
}
function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for(index = 0, length = object.length; index < length; index += 1){
        value = object[index];
        if (state.replacer) value = state.replacer.call(object, String(index), value);
        // Write only valid elements, put null instead of invalid elements.
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
            if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for(index = 0, length = object.length; index < length; index += 1){
        value = object[index];
        if (state.replacer) value = state.replacer.call(object, String(index), value);
        // Write only valid elements, put null instead of invalid elements.
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
            if (!compact || _result !== "") _result += generateNextLine(state, level);
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) _result += "-";
            else _result += "- ";
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = _result || "[]"; // Empty sequence if no valid values.
}
function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (_result !== "") pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) objectValue = state.replacer.call(object, objectKey, objectValue);
        if (!writeNode(state, level, objectKey, false, false)) continue; // Skip this pair because of invalid key;
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) continue; // Skip this pair because of invalid value.
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) // Default sorting
    objectKeyList.sort();
    else if (typeof state.sortKeys === "function") // Custom sort function
    objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys) // Something is wrong
    throw new exception("sortKeys must be a boolean or a function");
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (!compact || _result !== "") pairBuffer += generateNextLine(state, level);
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) objectValue = state.replacer.call(object, objectKey, objectValue);
        if (!writeNode(state, level + 1, objectKey, true, true, true)) continue; // Skip this pair because of invalid key.
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += "?";
            else pairBuffer += "? ";
        }
        pairBuffer += state.dump;
        if (explicitPair) pairBuffer += generateNextLine(state, level);
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) continue; // Skip this pair because of invalid value.
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += ":";
        else pairBuffer += ": ";
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}"; // Empty mapping if no valid pairs.
}
function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            if (explicit) {
                if (type.multi && type.representName) state.tag = type.representName(object);
                else state.tag = type.tag;
            } else state.tag = "?";
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === "[object Function]") _result = type.represent(object, style);
                else if (_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
                else throw new exception("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) detectType(state, object, true);
    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) block = state.flowLevel < 0 || state.flowLevel > level;
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) compact = false;
    if (duplicate && state.usedDuplicates[duplicateIndex]) state.dump = "*ref_" + duplicateIndex;
    else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) state.usedDuplicates[duplicateIndex] = true;
        if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object Array]") {
            if (block && state.dump.length !== 0) {
                if (state.noArrayIndent && !isblockseq && level > 0) writeBlockSequence(state, level - 1, state.dump, compact);
                else writeBlockSequence(state, level, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object String]") {
            if (state.tag !== "?") writeScalar(state, state.dump, level, iskey, inblock);
        } else if (type === "[object Undefined]") return false;
        else {
            if (state.skipInvalid) return false;
            throw new exception("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
            // Need to encode all characters except those allowed by the spec:
            //
            // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
            // [36] ns-hex-digit    ::=  ns-dec-digit
            //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
            // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
            // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | ‚Äú-‚Äù
            // [39] ns-uri-char     ::=  ‚Äú%‚Äù ns-hex-digit ns-hex-digit | ns-word-char | ‚Äú#‚Äù
            //                         | ‚Äú;‚Äù | ‚Äú/‚Äù | ‚Äú?‚Äù | ‚Äú:‚Äù | ‚Äú@‚Äù | ‚Äú&‚Äù | ‚Äú=‚Äù | ‚Äú+‚Äù | ‚Äú$‚Äù | ‚Äú,‚Äù
            //                         | ‚Äú_‚Äù | ‚Äú.‚Äù | ‚Äú!‚Äù | ‚Äú~‚Äù | ‚Äú*‚Äù | ‚Äú'‚Äù | ‚Äú(‚Äù | ‚Äú)‚Äù | ‚Äú[‚Äù | ‚Äú]‚Äù
            //
            // Also need to encode '!' because it has special meaning (end of tag prefix).
            //
            tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
            if (state.tag[0] === "!") tagStr = "!" + tagStr;
            else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") tagStr = "!!" + tagStr.slice(18);
            else tagStr = "!<" + tagStr + ">";
            state.dump = tagStr + " " + state.dump;
        }
    }
    return true;
}
function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1)state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) duplicatesIndexes.push(index);
        } else {
            objects.push(object);
            if (Array.isArray(object)) for(index = 0, length = object.length; index < length; index += 1)inspectNode(object[index], objects, duplicatesIndexes);
            else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1)inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
        }
    }
}
function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) value = state.replacer.call({
        "": value
    }, "", value);
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
}
var dump_1 = dump$1;
var dumper = {
    dump: dump_1
};
function renamed(from, to) {
    return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. " + "Use yaml." + to + " instead, which is now safe by default.");
    };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
// Re-export all types in case user wants to create custom schema
var types = {
    binary: binary,
    float: float,
    map: map,
    null: _null,
    pairs: pairs,
    set: set,
    timestamp: timestamp,
    bool: bool,
    int: int,
    merge: merge,
    omap: omap,
    seq: seq,
    str: str
};
// Removed functions from JS-YAML 3.0.x
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
    Type: Type,
    Schema: Schema,
    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
    JSON_SCHEMA: JSON_SCHEMA,
    CORE_SCHEMA: CORE_SCHEMA,
    DEFAULT_SCHEMA: DEFAULT_SCHEMA,
    load: load,
    loadAll: loadAll,
    dump: dump,
    YAMLException: YAMLException,
    types: types,
    safeLoad: safeLoad,
    safeLoadAll: safeLoadAll,
    safeDump: safeDump
};
exports.default = jsYaml;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"irpcQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = {
    key: 0
};
const _hoisted_2 = {
    key: 1
};
const _hoisted_3 = [
    "href"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar = (0, _vue.resolveComponent)("v-app-bar");
    const _component_v_img = (0, _vue.resolveComponent)("v-img");
    const _component_v_card_title = (0, _vue.resolveComponent)("v-card-title");
    const _component_v_card_subtitle = (0, _vue.resolveComponent)("v-card-subtitle");
    const _component_v_card_text = (0, _vue.resolveComponent)("v-card-text");
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_list_item_title = (0, _vue.resolveComponent)("v-list-item-title");
    const _component_v_list_item = (0, _vue.resolveComponent)("v-list-item");
    const _component_v_list = (0, _vue.resolveComponent)("v-list");
    const _component_v_menu = (0, _vue.resolveComponent)("v-menu");
    const _component_v_spacer = (0, _vue.resolveComponent)("v-spacer");
    const _component_v_card_actions = (0, _vue.resolveComponent)("v-card-actions");
    const _component_v_card = (0, _vue.resolveComponent)("v-card");
    const _component_v_col = (0, _vue.resolveComponent)("v-col");
    const _component_v_row = (0, _vue.resolveComponent)("v-row");
    const _component_v_container = (0, _vue.resolveComponent)("v-container");
    const _component_v_main = (0, _vue.resolveComponent)("v-main");
    const _component_v_app = (0, _vue.resolveComponent)("v-app");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_app, null, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_app_bar, {
                    color: "surface-variant",
                    title: "edrys-lite"
                }),
                (0, _vue.createVNode)(_component_v_main, {
                    class: "d-flex"
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_container, {
                                fluid: "",
                                class: "align-start"
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_row, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($data.classrooms, (classroom)=>{
                                                        return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_col, {
                                                            cols: "12",
                                                            sm: "6",
                                                            md: "4",
                                                            lg: "3",
                                                            key: classroom.id
                                                        }, {
                                                            default: (0, _vue.withCtx)(()=>[
                                                                    (0, _vue.createVNode)(_component_v_card, {
                                                                        class: "item",
                                                                        color: "surface-variant",
                                                                        elevation: "4"
                                                                    }, {
                                                                        default: (0, _vue.withCtx)(()=>[
                                                                                (0, _vue.createVNode)(_component_v_img, {
                                                                                    src: classroom?.data?.meta?.logo || "https://repository-images.githubusercontent.com/453979926/ab6bf9d7-a4bc-4a47-97b7-c8bc8bb4654d",
                                                                                    height: "200px",
                                                                                    cover: ""
                                                                                }, null, 8 /* PROPS */ , [
                                                                                    "src"
                                                                                ]),
                                                                                (0, _vue.createVNode)(_component_v_card_title, null, {
                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)(classroom.data?.name), 1 /* TEXT */ )
                                                                                        ]),
                                                                                    _: 2 /* DYNAMIC */ 
                                                                                }, 1024 /* DYNAMIC_SLOTS */ ),
                                                                                (0, _vue.createVNode)(_component_v_card_subtitle, null, {
                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                            classroom?.data.createdBy === $data.peerID ? ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_1, "You own this class")) : ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("span", _hoisted_2, "You're a student here"))
                                                                                        ]),
                                                                                    _: 2 /* DYNAMIC */ 
                                                                                }, 1024 /* DYNAMIC_SLOTS */ ),
                                                                                (0, _vue.createVNode)(_component_v_card_text, {
                                                                                    innerHTML: classroom?.data?.meta?.description || "No Description"
                                                                                }, null, 8 /* PROPS */ , [
                                                                                    "innerHTML"
                                                                                ]),
                                                                                (0, _vue.createVNode)(_component_v_card_actions, null, {
                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                            (0, _vue.createVNode)(_component_v_btn, {
                                                                                                icon: "",
                                                                                                title: "fork",
                                                                                                onClick: ($event)=>$options.forkClass(classroom)
                                                                                            }, {
                                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                                        (0, _vue.createVNode)(_component_v_icon, null, {
                                                                                                            default: (0, _vue.withCtx)(()=>[
                                                                                                                    (0, _vue.createTextVNode)("mdi-source-fork")
                                                                                                                ]),
                                                                                                            _: 1 /* STABLE */ 
                                                                                                        })
                                                                                                    ]),
                                                                                                _: 2 /* DYNAMIC */ 
                                                                                            }, 1032 /* PROPS, DYNAMIC_SLOTS */ , [
                                                                                                "onClick"
                                                                                            ]),
                                                                                            (0, _vue.createVNode)(_component_v_menu, null, {
                                                                                                activator: (0, _vue.withCtx)(({ props })=>[
                                                                                                        (0, _vue.createVNode)(_component_v_btn, (0, _vue.mergeProps)({
                                                                                                            color: ""
                                                                                                        }, props, {
                                                                                                            icon: "mdi-delete"
                                                                                                        }), null, 16 /* FULL_PROPS */ )
                                                                                                    ]),
                                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                                        (0, _vue.createVNode)(_component_v_list, null, {
                                                                                                            default: (0, _vue.withCtx)(()=>[
                                                                                                                    (0, _vue.createVNode)(_component_v_list_item, null, {
                                                                                                                        default: (0, _vue.withCtx)(()=>[
                                                                                                                                (0, _vue.createVNode)(_component_v_list_item_title, null, {
                                                                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                                                                            (0, _vue.createTextVNode)(" Are you sure? ")
                                                                                                                                        ]),
                                                                                                                                    _: 1 /* STABLE */ 
                                                                                                                                }),
                                                                                                                                (0, _vue.createVNode)(_component_v_btn, {
                                                                                                                                    color: "red",
                                                                                                                                    depressed: "",
                                                                                                                                    onClick: ($event)=>$options.deleteClass(classroom.id),
                                                                                                                                    class: "float-right",
                                                                                                                                    style: {
                                                                                                                                        "margin-top": "10px"
                                                                                                                                    }
                                                                                                                                }, {
                                                                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                                                                            (0, _vue.createTextVNode)(" Yes, delete forever")
                                                                                                                                        ]),
                                                                                                                                    _: 2 /* DYNAMIC */ 
                                                                                                                                }, 1032 /* PROPS, DYNAMIC_SLOTS */ , [
                                                                                                                                    "onClick"
                                                                                                                                ])
                                                                                                                            ]),
                                                                                                                        _: 2 /* DYNAMIC */ 
                                                                                                                    }, 1024 /* DYNAMIC_SLOTS */ )
                                                                                                                ]),
                                                                                                            _: 2 /* DYNAMIC */ 
                                                                                                        }, 1024 /* DYNAMIC_SLOTS */ )
                                                                                                    ]),
                                                                                                _: 2 /* DYNAMIC */ 
                                                                                            }, 1024 /* DYNAMIC_SLOTS */ ),
                                                                                            (0, _vue.createVNode)(_component_v_spacer),
                                                                                            (0, _vue.createElementVNode)("a", {
                                                                                                "data-link": "true",
                                                                                                href: `/?/classroom/${classroom.id}`,
                                                                                                style: {
                                                                                                    "color": "white"
                                                                                                }
                                                                                            }, [
                                                                                                (0, _vue.createVNode)(_component_v_btn, {
                                                                                                    icon: "",
                                                                                                    title: "open"
                                                                                                }, {
                                                                                                    default: (0, _vue.withCtx)(()=>[
                                                                                                            (0, _vue.createVNode)(_component_v_icon, null, {
                                                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                                                        (0, _vue.createTextVNode)("mdi-arrow-right-bold")
                                                                                                                    ]),
                                                                                                                _: 1 /* STABLE */ 
                                                                                                            })
                                                                                                        ]),
                                                                                                    _: 1 /* STABLE */ 
                                                                                                })
                                                                                            ], 8 /* PROPS */ , _hoisted_3)
                                                                                        ]),
                                                                                    _: 2 /* DYNAMIC */ 
                                                                                }, 1024 /* DYNAMIC_SLOTS */ )
                                                                            ]),
                                                                        _: 2 /* DYNAMIC */ 
                                                                    }, 1024 /* DYNAMIC_SLOTS */ )
                                                                ]),
                                                            _: 2 /* DYNAMIC */ 
                                                        }, 1024 /* DYNAMIC_SLOTS */ );
                                                    }), 128 /* KEYED_FRAGMENT */ )),
                                                    (0, _vue.createVNode)(_component_v_col, {
                                                        cols: "12",
                                                        sm: "6",
                                                        md: "4",
                                                        lg: "3"
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createVNode)(_component_v_card, {
                                                                    class: "item",
                                                                    color: "surface-variant",
                                                                    elevation: "4",
                                                                    onClick: _cache[0] || (_cache[0] = ($event)=>$options.createClass()),
                                                                    variant: "elevated"
                                                                }, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createVNode)(_component_v_card_title, null, {
                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                        (0, _vue.createTextVNode)("Create a class")
                                                                                    ]),
                                                                                _: 1 /* STABLE */ 
                                                                            }),
                                                                            (0, _vue.createVNode)(_component_v_card_subtitle, null, {
                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                        (0, _vue.createTextVNode)("Start teaching now")
                                                                                    ]),
                                                                                _: 1 /* STABLE */ 
                                                                            }),
                                                                            (0, _vue.createVNode)(_component_v_card_actions, null, {
                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                        (0, _vue.createVNode)(_component_v_spacer),
                                                                                        (0, _vue.createVNode)(_component_v_btn, {
                                                                                            icon: ""
                                                                                        }, {
                                                                                            default: (0, _vue.withCtx)(()=>[
                                                                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                                                                        icon: "mdi-plus"
                                                                                                    })
                                                                                                ]),
                                                                                            _: 1 /* STABLE */ 
                                                                                        })
                                                                                    ]),
                                                                                _: 1 /* STABLE */ 
                                                                            })
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                })
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    })
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("a73bc7-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fcG6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7eaj4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("a1f03eaee1a48ec4");
    if (script.__esModule) script = script.default;
    script.render = require("154c238e49f95afe").render;
    require("51f71cc4d947d3b0").default(script);
    script.__scopeId = "data-v-19d649";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/views/Classroom.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "19d649-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("19d649-hmr", script)) __VUE_HMR_RUNTIME__.reload("19d649-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"a1f03eaee1a48ec4":"ctxbF","154c238e49f95afe":"r4dLl","51f71cc4d947d3b0":"dZNk4","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ctxbF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _settingsVue = require("../components/Settings.vue");
var _settingsVueDefault = parcelHelpers.interopDefault(_settingsVue);
var _modulesVue = require("../components/Modules.vue");
var _modulesVueDefault = parcelHelpers.interopDefault(_modulesVue);
var _database = require("../ts/Database");
var _databaseDefault = parcelHelpers.interopDefault(_database);
var _utils = require("../ts/Utils");
var _comm = require("../ts/Comm");
var _commDefault = parcelHelpers.interopDefault(_comm);
var _comm2 = require("../ts/Comm2");
var _comm2Default = parcelHelpers.interopDefault(_comm2);
exports.default = {
    props: [
        "id",
        "comm",
        "station"
    ],
    data () {
        const room = null;
        const data = null;
        setTimeout(this.init, 100);
        return {
            database: null,
            room,
            data,
            client: this.comm,
            communication: null,
            showSideMenu: true,
            showSettings: false,
            scrapedModules: [],
            liveClassProxy: null,
            isStation: this.station,
            stationName: this.station ? (0, _utils.infoHash)(6) : "",
            componentKey: 0,
            class_id: this.id
        };
    },
    watch: {
        showSettings () {
            if (!this.showSettings) this.data = this.copy(this.room.data);
        }
    },
    methods: {
        getRooms () {
            if (!this.liveClassProxy) return;
            const sortedKeys = Object.keys(this.liveClassProxy.rooms).sort();
            const rooms = {};
            sortedKeys.forEach((key)=>{
                rooms[key] = this.liveClassProxy.rooms[key];
            });
            return rooms;
        },
        async init () {
            this.database = new (0, _databaseDefault.default)();
            const self = this;
            if (!this.client) this.client = new (0, _commDefault.default)({
                id: this.id,
                data: null,
                timestamp: 0
            });
            this.room = await this.database.get(this.id);
            if (this.room) {
                this.data = this.copy(this.room.data);
                this.client.on("update", (room)=>{
                    setTimeout(()=>{
                        if (self.room.timestamp < room.timestamp && room) {
                            self.database.put(room.id, room.data, room.timestamp);
                            self.init();
                        }
                    }, 1000);
                });
                this.scrapeModules();
            } else {
                this.client.on("update", (room)=>{
                    console.warn("callback", room);
                    if (room.timestamp && room) {
                        self.database.put(room.id, room.data, room.timestamp);
                        self.init();
                    }
                });
                this.client.join();
            }
        },
        async scrapeModules () {
            this.scrapedModules = [];
            for(let i = 0; i < this.data.modules.length; i++){
                let module = await (0, _utils.scrapeModule)(this.data.modules[i]);
                this.scrapedModules.push(module);
            }
            const self = this;
            setTimeout(()=>{
                self.communication = new (0, _comm2Default.default)(this.id, this.room.data.meta.defaultNumberOfRooms, this.stationName);
                self.communication.on("update", (config)=>{
                    self.liveClassProxy = config.data;
                });
                self.liveClassProxy = self.communication.getDoc();
                self.componentKey++;
            }, Math.random() * 1000 + 1000);
        },
        copy (json) {
            return JSON.parse(JSON.stringify(json));
        },
        saveClass (config) {
            this.$refs.Settings.close = true;
            this.room.data = this.copy(config);
            this.data = this.copy(config);
            console.warn("saveClass", JSON.stringify(this.data, null, 2));
            this.database.update(this.copy(this.room));
        //this.client.updateConfig(this.copy(this.room));
        //this.scrapeModules();
        },
        usersInRoom (name) {
            const users = [];
            for(const id in this.liveClassProxy.users)if (this.liveClassProxy.users[id].room === name) users.push(this.liveClassProxy.users[id].displayName);
            return users;
        },
        gotoRoom (name) {
            this.communication?.gotoRoom(name);
        },
        addRoom () {
            this.communication?.addRoom();
        },
        deleteClass () {
            this.database.drop(this.room.id);
            window.location.search = "";
        },
        updateClass (config) {
            this.data = this.copy(config.data);
        }
    },
    components: {
        Settings: (0, _settingsVueDefault.default),
        Modules: (0, _modulesVueDefault.default)
    }
};

},{"../components/Settings.vue":"6ITSW","../components/Modules.vue":"ft1le","../ts/Database":"hn5oJ","../ts/Utils":"j822r","../ts/Comm":"6TTUj","../ts/Comm2":"ltUfB","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6ITSW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("432a7584d7139325");
    if (script.__esModule) script = script.default;
    script.render = require("acf54a6d932e33b3").render;
    require("d739e473dd581a3").default(script);
    script.__scopeId = "data-v-4f1cba";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "4f1cba-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("4f1cba-hmr", script)) __VUE_HMR_RUNTIME__.reload("4f1cba-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"432a7584d7139325":"kxNjM","acf54a6d932e33b3":"5wQVR","d739e473dd581a3":"5WNJn","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kxNjM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mainVue = require("./Settings/Main.vue");
var _mainVueDefault = parcelHelpers.interopDefault(_mainVue);
var _membersVue = require("./Settings/Members.vue");
var _membersVueDefault = parcelHelpers.interopDefault(_membersVue);
var _modulesVue = require("./Settings/Modules.vue");
var _modulesVueDefault = parcelHelpers.interopDefault(_modulesVue);
var _stationsVue = require("./Settings/Stations.vue");
var _stationsVueDefault = parcelHelpers.interopDefault(_stationsVue);
var _shareVue = require("./Settings/Share.vue");
var _shareVueDefault = parcelHelpers.interopDefault(_shareVue);
exports.default = {
    name: "Settings",
    props: {
        config: {
            type: Object,
            required: true
        },
        scrapedModules: {
            type: Object,
            required: true
        }
    },
    emits: [
        "close",
        "saveClass",
        "deleteClass",
        "updateClass"
    ],
    data () {
        console.log("Classroom config", JSON.stringify(this.config, null, 2));
        return {
            tab: 2
        };
    },
    methods: {
        updateModules () {
            console.warn("updateModules", this.scrapedModules);
        },
        saveClass () {
            this.$emit("saveClass", this.config);
        },
        deleteClass () {
            this.$emit("deleteClass");
        },
        updateClass () {
            this.$emit("updateClass", this.config);
        }
    },
    components: {
        Main: (0, _mainVueDefault.default),
        Members: (0, _membersVueDefault.default),
        Modules: (0, _modulesVueDefault.default),
        Stations: (0, _stationsVueDefault.default),
        Share: (0, _shareVueDefault.default)
    }
};

},{"./Settings/Main.vue":"6ZuSO","./Settings/Members.vue":"5oZKM","./Settings/Modules.vue":"2Ozaw","./Settings/Stations.vue":"haH5e","./Settings/Share.vue":"jIHxD","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6ZuSO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("eddb777e63f5a3fd");
    if (script.__esModule) script = script.default;
    script.render = require("65d6e76a0f119f60").render;
    require("ce325ba857e3e6e9").default(script);
    script.__scopeId = "data-v-592c28";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Main.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "592c28-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("592c28-hmr", script)) __VUE_HMR_RUNTIME__.reload("592c28-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"eddb777e63f5a3fd":"g0Btg","65d6e76a0f119f60":"3UZtX","ce325ba857e3e6e9":"jgzkP","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"g0Btg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    name: "Settings-Main",
    props: {
        config: {
            type: Object,
            required: true
        }
    },
    data () {
        return {};
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3UZtX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_text_field = (0, _vue.resolveComponent)("v-text-field");
    const _component_v_textarea = (0, _vue.resolveComponent)("v-textarea");
    const _component_v_checkbox = (0, _vue.resolveComponent)("v-checkbox");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        (0, _vue.createVNode)(_component_v_text_field, {
            modelValue: $props.config.name,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$props.config.name = $event),
            counter: 20,
            label: "Class Name",
            outlined: "",
            required: ""
        }, null, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createVNode)(_component_v_text_field, {
            modelValue: $props.config.meta.logo,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>$props.config.meta.logo = $event),
            label: "Logo URL",
            outlined: "",
            required: ""
        }, null, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createVNode)(_component_v_textarea, {
            modelValue: $props.config.meta.description,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>$props.config.meta.description = $event),
            filled: "",
            label: "Description",
            "auto-grow": ""
        }, null, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createVNode)(_component_v_text_field, {
            modelValue: $props.config.meta.defaultNumberOfRooms,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event)=>$props.config.meta.defaultNumberOfRooms = $event),
            label: "Default number of rooms (optional)",
            type: "number",
            outlined: ""
        }, null, 8 /* PROPS */ , [
            "modelValue"
        ]),
        (0, _vue.createVNode)(_component_v_checkbox, {
            modelValue: $props.config.meta.selfAssign,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>$props.config.meta.selfAssign = $event),
            label: "Enable self-assignment",
            outlined: ""
        }, null, 8 /* PROPS */ , [
            "modelValue"
        ])
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("592c28-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jgzkP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5oZKM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("8183a8c52866718d");
    if (script.__esModule) script = script.default;
    script.render = require("4e4f28fd8f5235db").render;
    require("28a9b2213a398f71").default(script);
    script.__scopeId = "data-v-3aaf70";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Members.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "3aaf70-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("3aaf70-hmr", script)) __VUE_HMR_RUNTIME__.reload("3aaf70-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"8183a8c52866718d":"lFeAW","4e4f28fd8f5235db":"67NEf","28a9b2213a398f71":"45hde","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lFeAW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../../ts/Utils");
exports.default = {
    name: "Settings-Members",
    props: {
        config: {
            type: Object,
            required: true
        }
    },
    data () {
        return {
            url: window.location.toString()
        };
    },
    methods: {
        copyUrl () {
            (0, _utils.copyUrl)(this.url);
        }
    }
};

},{"../../ts/Utils":"j822r","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"67NEf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = [
    "href"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_container = (0, _vue.resolveComponent)("v-container");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_alert = (0, _vue.resolveComponent)("v-alert");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_alert, {
        outlined: "",
        dense: "",
        type: "info",
        text: "Invite your users in by sharing this link: "
    }, {
        append: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_btn, {
                    icon: "mdi-content-copy",
                    onClick: $options.copyUrl,
                    variant: "text"
                }, null, 8 /* PROPS */ , [
                    "onClick"
                ])
            ]),
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_container, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createElementVNode)("a", {
                                href: $data.url
                            }, (0, _vue.toDisplayString)($data.url), 9 /* TEXT, PROPS */ , _hoisted_1)
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("3aaf70-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"45hde":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2Ozaw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("be0e44b9a4ffa7e0");
    if (script.__esModule) script = script.default;
    script.render = require("a7c9e031a7a35109").render;
    require("e5ec21d433d7ac4d").default(script);
    script.__scopeId = "data-v-e5658a";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Modules.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "e5658a-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("e5658a-hmr", script)) __VUE_HMR_RUNTIME__.reload("e5658a-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"be0e44b9a4ffa7e0":"dmyYN","a7c9e031a7a35109":"39aO0","e5ec21d433d7ac4d":"ci6rT","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dmyYN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../../ts/Utils");
var _vuedraggable = require("vuedraggable");
var _vuedraggableDefault = parcelHelpers.interopDefault(_vuedraggable);
var _moduleVue = require("./Module.vue");
var _moduleVueDefault = parcelHelpers.interopDefault(_moduleVue);
exports.default = {
    name: "Settings-Modules",
    props: {
        config: {
            type: Object,
            required: true
        },
        scrapedModules: {
            type: Object,
            required: true
        }
    },
    data () {
        return {
            moduleImportUrl: ""
        };
    },
    methods: {
        async update () {
            this.scrapedModules = [];
            for(let i = 0; i < this.config.modules.length; i++){
                let module = await (0, _utils.scrapeModule)(this.config.modules[i]);
                this.scrapedModules.push(module);
            }
        },
        move (event) {
            const element = this.scrapedModules[event.oldIndex];
            this.scrapedModules[event.oldIndex] = this.scrapedModules[event.newIndex];
            this.scrapedModules[event.newIndex] = element;
            return true;
        },
        validate_url (url) {
            return (0, _utils.validateUrl)(url);
        },
        async loadURL () {
            const module = {
                url: this.moduleImportUrl,
                config: "",
                studentConfig: "",
                teacherConfig: "",
                stationConfig: "",
                showInCustom: "",
                width: "full",
                height: "tall"
            };
            const scrapedModule = await (0, _utils.scrapeModule)(module);
            this.config.modules.push(module);
            this.scrapedModules.push(scrapedModule);
            this.moduleImportUrl = "";
        }
    },
    components: {
        Module: (0, _moduleVueDefault.default),
        draggable: (0, _vuedraggableDefault.default)
    }
};

},{"../../ts/Utils":"j822r","vuedraggable":"h8N0i","./Module.vue":"lI6Ao","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"h8N0i":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(require("994aba414f6e11f"), require("f2b29fe3c2c19cbd"));
})(typeof self !== "undefined" ? self : this, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.l = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)
        /******/ __webpack_require__.m = modules;
        /******/ /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules;
        /******/ /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ if (!__webpack_require__.o(exports, name)) /******/ Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter
            });
        /******/ };
        /******/ /******/ // define __esModule on exports
        /******/ __webpack_require__.r = function(exports) {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            });
            /******/ Object.defineProperty(exports, "__esModule", {
                value: true
            });
        /******/ };
        /******/ /******/ // create a fake namespace object
        /******/ // mode & 1: value is a module id, require it
        /******/ // mode & 2: merge all properties of value into the ns
        /******/ // mode & 4: return value when already ns object
        /******/ // mode & 8|1: behave like require
        /******/ __webpack_require__.t = function(value, mode) {
            /******/ if (mode & 1) value = __webpack_require__(value);
            /******/ if (mode & 8) return value;
            /******/ if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            /******/ var ns = Object.create(null);
            /******/ __webpack_require__.r(ns);
            /******/ Object.defineProperty(ns, "default", {
                enumerable: true,
                value: value
            });
            /******/ if (mode & 2 && typeof value != "string") for(var key in value)__webpack_require__.d(ns, key, (function(key) {
                return value[key];
            }).bind(null, key));
            /******/ return ns;
        /******/ };
        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module1) {
            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {
                return module1["default"];
            } : /******/ function getModuleExports() {
                return module1;
            };
            /******/ __webpack_require__.d(getter, "a", getter);
            /******/ return getter;
        /******/ };
        /******/ /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/ /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "";
        /******/ /******/ /******/ // Load entry module and return exports
        /******/ return __webpack_require__(__webpack_require__.s = "fb15");
    /******/ }({
        /***/ "00ee": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var test = {};
            test[TO_STRING_TAG] = "z";
            module1.exports = String(test) === "[object z]";
        /***/ },
        /***/ "0366": /***/ function(module1, exports, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            // optional / simple context binding
            module1.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === undefined) return fn;
                switch(length){
                    case 0:
                        return function() {
                            return fn.call(that);
                        };
                    case 1:
                        return function(a) {
                            return fn.call(that, a);
                        };
                    case 2:
                        return function(a, b) {
                            return fn.call(that, a, b);
                        };
                    case 3:
                        return function(a, b, c) {
                            return fn.call(that, a, b, c);
                        };
                }
                return function() {
                    return fn.apply(that, arguments);
                };
            };
        /***/ },
        /***/ "057f": /***/ function(module1, exports, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
            var toString = {}.toString;
            var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
                try {
                    return nativeGetOwnPropertyNames(it);
                } catch (error) {
                    return windowNames.slice();
                }
            };
            // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
            module1.exports.f = function getOwnPropertyNames(it) {
                return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
            };
        /***/ },
        /***/ "06cf": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var has = __webpack_require__("5135");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            // `Object.getOwnPropertyDescriptor` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
            exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPrimitive(P, true);
                if (IE8_DOM_DEFINE) try {
                    return nativeGetOwnPropertyDescriptor(O, P);
                } catch (error) {}
                if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
            };
        /***/ },
        /***/ "0cfb": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var createElement = __webpack_require__("cc12");
            // Thank's IE8 for his funny defineProperty
            module1.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                    get: function() {
                        return 7;
                    }
                }).a != 7;
            });
        /***/ },
        /***/ "13d5": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $reduce = __webpack_require__("d58f").left;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("reduce");
            var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", {
                1: 0
            });
            // `Array.prototype.reduce` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
            $({
                target: "Array",
                proto: true,
                forced: !STRICT_METHOD || !USES_TO_LENGTH
            }, {
                reduce: function reduce(callbackfn /* , initialValue */ ) {
                    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
        /***/ },
        /***/ "14c3": /***/ function(module1, exports, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            var regexpExec = __webpack_require__("9263");
            // `RegExpExec` abstract operation
            // https://tc39.github.io/ecma262/#sec-regexpexec
            module1.exports = function(R, S) {
                var exec = R.exec;
                if (typeof exec === "function") {
                    var result = exec.call(R, S);
                    if (typeof result !== "object") throw TypeError("RegExp exec method returned something other than an Object or null");
                    return result;
                }
                if (classof(R) !== "RegExp") throw TypeError("RegExp#exec called on incompatible receiver");
                return regexpExec.call(R, S);
            };
        /***/ },
        /***/ "159b": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var forEach = __webpack_require__("17c2");
            var createNonEnumerableProperty = __webpack_require__("9112");
            for(var COLLECTION_NAME in DOMIterables){
                var Collection = global[COLLECTION_NAME];
                var CollectionPrototype = Collection && Collection.prototype;
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
                    createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
                } catch (error) {
                    CollectionPrototype.forEach = forEach;
                }
            }
        /***/ },
        /***/ "17c2": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $forEach = __webpack_require__("b727").forEach;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var STRICT_METHOD = arrayMethodIsStrict("forEach");
            var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
            // `Array.prototype.forEach` method implementation
            // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
            module1.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn /* , thisArg */ ) {
                return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            } : [].forEach;
        /***/ },
        /***/ "1be4": /***/ function(module1, exports, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module1.exports = getBuiltIn("document", "documentElement");
        /***/ },
        /***/ "1c0b": /***/ function(module1, exports) {
            module1.exports = function(it) {
                if (typeof it != "function") throw TypeError(String(it) + " is not a function");
                return it;
            };
        /***/ },
        /***/ "1c7e": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var SAFE_CLOSING = false;
            try {
                var called = 0;
                var iteratorWithReturn = {
                    next: function() {
                        return {
                            done: !!called++
                        };
                    },
                    "return": function() {
                        SAFE_CLOSING = true;
                    }
                };
                iteratorWithReturn[ITERATOR] = function() {
                    return this;
                };
                // eslint-disable-next-line no-throw-literal
                Array.from(iteratorWithReturn, function() {
                    throw 2;
                });
            } catch (error) {}
            module1.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
                var ITERATION_SUPPORT = false;
                try {
                    var object = {};
                    object[ITERATOR] = function() {
                        return {
                            next: function() {
                                return {
                                    done: ITERATION_SUPPORT = true
                                };
                            }
                        };
                    };
                    exec(object);
                } catch (error) {}
                return ITERATION_SUPPORT;
            };
        /***/ },
        /***/ "1d80": /***/ function(module1, exports) {
            // `RequireObjectCoercible` abstract operation
            // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
            module1.exports = function(it) {
                if (it == undefined) throw TypeError("Can't call method on " + it);
                return it;
            };
        /***/ },
        /***/ "1dde": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var SPECIES = wellKnownSymbol("species");
            module1.exports = function(METHOD_NAME) {
                // We can't use this feature detection in V8 since it causes
                // deoptimization and serious performance degradation
                // https://github.com/zloirock/core-js/issues/677
                return V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    var constructor = array.constructor = {};
                    constructor[SPECIES] = function() {
                        return {
                            foo: 1
                        };
                    };
                    return array[METHOD_NAME](Boolean).foo !== 1;
                });
            };
        /***/ },
        /***/ "23cb": /***/ function(module1, exports, __webpack_require__) {
            var toInteger = __webpack_require__("a691");
            var max = Math.max;
            var min = Math.min;
            // Helper for a popular repeating case of the spec:
            // Let integer be ? ToInteger(index).
            // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
            module1.exports = function(index, length) {
                var integer = toInteger(index);
                return integer < 0 ? max(integer + length, 0) : min(integer, length);
            };
        /***/ },
        /***/ "23e7": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var setGlobal = __webpack_require__("ce4e");
            var copyConstructorProperties = __webpack_require__("e893");
            var isForced = __webpack_require__("94ca");
            /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/ module1.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) target = global;
                else if (STATIC) target = global[TARGET] || setGlobal(TARGET, {});
                else target = (global[TARGET] || {}).prototype;
                if (target) for(key in source){
                    sourceProperty = source[key];
                    if (options.noTargetGet) {
                        descriptor = getOwnPropertyDescriptor(target, key);
                        targetProperty = descriptor && descriptor.value;
                    } else targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                    // contained in target
                    if (!FORCED && targetProperty !== undefined) {
                        if (typeof sourceProperty === typeof targetProperty) continue;
                        copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    // add a flag to not completely full polyfills
                    if (options.sham || targetProperty && targetProperty.sham) createNonEnumerableProperty(sourceProperty, "sham", true);
                    // extend global
                    redefine(target, key, sourceProperty, options);
                }
            };
        /***/ },
        /***/ "241c": /***/ function(module1, exports, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            // `Object.getOwnPropertyNames` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
            exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
            };
        /***/ },
        /***/ "25f0": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var redefine = __webpack_require__("6eeb");
            var anObject = __webpack_require__("825a");
            var fails = __webpack_require__("d039");
            var flags = __webpack_require__("ad6d");
            var TO_STRING = "toString";
            var RegExpPrototype = RegExp.prototype;
            var nativeToString = RegExpPrototype[TO_STRING];
            var NOT_GENERIC = fails(function() {
                return nativeToString.call({
                    source: "a",
                    flags: "b"
                }) != "/a/b";
            });
            // FF44- RegExp#toString has a wrong name
            var INCORRECT_NAME = nativeToString.name != TO_STRING;
            // `RegExp.prototype.toString` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
            if (NOT_GENERIC || INCORRECT_NAME) redefine(RegExp.prototype, TO_STRING, function toString() {
                var R = anObject(this);
                var p = String(R.source);
                var rf = R.flags;
                var f = String(rf === undefined && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
                return "/" + p + "/" + f;
            }, {
                unsafe: true
            });
        /***/ },
        /***/ "2ca0": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var toLength = __webpack_require__("50c4");
            var notARegExp = __webpack_require__("5a34");
            var requireObjectCoercible = __webpack_require__("1d80");
            var correctIsRegExpLogic = __webpack_require__("ab13");
            var IS_PURE = __webpack_require__("c430");
            var nativeStartsWith = "".startsWith;
            var min = Math.min;
            var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
            // https://github.com/zloirock/core-js/pull/702
            var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
                var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
                return descriptor && !descriptor.writable;
            }();
            // `String.prototype.startsWith` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.startswith
            $({
                target: "String",
                proto: true,
                forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
            }, {
                startsWith: function startsWith(searchString /* , position = 0 */ ) {
                    var that = String(requireObjectCoercible(this));
                    notARegExp(searchString);
                    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
                    var search = String(searchString);
                    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
                }
            });
        /***/ },
        /***/ "2d00": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var userAgent = __webpack_require__("342f");
            var process = global.process;
            var versions = process && process.versions;
            var v8 = versions && versions.v8;
            var match, version;
            if (v8) {
                match = v8.split(".");
                version = match[0] + match[1];
            } else if (userAgent) {
                match = userAgent.match(/Edge\/(\d+)/);
                if (!match || match[1] >= 74) {
                    match = userAgent.match(/Chrome\/(\d+)/);
                    if (match) version = match[1];
                }
            }
            module1.exports = version && +version;
        /***/ },
        /***/ "342f": /***/ function(module1, exports, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            module1.exports = getBuiltIn("navigator", "userAgent") || "";
        /***/ },
        /***/ "35a1": /***/ function(module1, exports, __webpack_require__) {
            var classof = __webpack_require__("f5df");
            var Iterators = __webpack_require__("3f8c");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            module1.exports = function(it) {
                if (it != undefined) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
        /***/ },
        /***/ "37e8": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var anObject = __webpack_require__("825a");
            var objectKeys = __webpack_require__("df75");
            // `Object.defineProperties` method
            // https://tc39.github.io/ecma262/#sec-object.defineproperties
            module1.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var index = 0;
                var key;
                while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);
                return O;
            };
        /***/ },
        /***/ "3bbe": /***/ function(module1, exports, __webpack_require__) {
            var isObject = __webpack_require__("861d");
            module1.exports = function(it) {
                if (!isObject(it) && it !== null) throw TypeError("Can't set " + String(it) + " as a prototype");
                return it;
            };
        /***/ },
        /***/ "3ca3": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var charAt = __webpack_require__("6547").charAt;
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var STRING_ITERATOR = "String Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
            // `String.prototype[@@iterator]` method
            // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
            defineIterator(String, "String", function(iterated) {
                setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: String(iterated),
                    index: 0
                });
            // `%StringIteratorPrototype%.next` method
            // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
            }, function next() {
                var state = getInternalState(this);
                var string = state.string;
                var index = state.index;
                var point;
                if (index >= string.length) return {
                    value: undefined,
                    done: true
                };
                point = charAt(string, index);
                state.index += point.length;
                return {
                    value: point,
                    done: false
                };
            });
        /***/ },
        /***/ "3f8c": /***/ function(module1, exports) {
            module1.exports = {};
        /***/ },
        /***/ "4160": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var forEach = __webpack_require__("17c2");
            // `Array.prototype.forEach` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
            $({
                target: "Array",
                proto: true,
                forced: [].forEach != forEach
            }, {
                forEach: forEach
            });
        /***/ },
        /***/ "428f": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            module1.exports = global;
        /***/ },
        /***/ "44ad": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var classof = __webpack_require__("c6b6");
            var split = "".split;
            // fallback for non-array-like ES3 and non-enumerable old V8 strings
            module1.exports = fails(function() {
                // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
                // eslint-disable-next-line no-prototype-builtins
                return !Object("z").propertyIsEnumerable(0);
            }) ? function(it) {
                return classof(it) == "String" ? split.call(it, "") : Object(it);
            } : Object;
        /***/ },
        /***/ "44d2": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var create = __webpack_require__("7c73");
            var definePropertyModule = __webpack_require__("9bf2");
            var UNSCOPABLES = wellKnownSymbol("unscopables");
            var ArrayPrototype = Array.prototype;
            // Array.prototype[@@unscopables]
            // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
            if (ArrayPrototype[UNSCOPABLES] == undefined) definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                configurable: true,
                value: create(null)
            });
            // add a key to Array.prototype[@@unscopables]
            module1.exports = function(key) {
                ArrayPrototype[UNSCOPABLES][key] = true;
            };
        /***/ },
        /***/ "44e7": /***/ function(module1, exports, __webpack_require__) {
            var isObject = __webpack_require__("861d");
            var classof = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            // `IsRegExp` abstract operation
            // https://tc39.github.io/ecma262/#sec-isregexp
            module1.exports = function(it) {
                var isRegExp;
                return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == "RegExp");
            };
        /***/ },
        /***/ "4930": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module1.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                // Chrome 38 Symbol has incorrect toString conversion
                // eslint-disable-next-line no-undef
                return !String(Symbol());
            });
        /***/ },
        /***/ "4d64": /***/ function(module1, exports, __webpack_require__) {
            var toIndexedObject = __webpack_require__("fc6a");
            var toLength = __webpack_require__("50c4");
            var toAbsoluteIndex = __webpack_require__("23cb");
            // `Array.prototype.{ indexOf, includes }` methods implementation
            var createMethod = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                    var O = toIndexedObject($this);
                    var length = toLength(O.length);
                    var index = toAbsoluteIndex(fromIndex, length);
                    var value;
                    // Array#includes uses SameValueZero equality algorithm
                    // eslint-disable-next-line no-self-compare
                    if (IS_INCLUDES && el != el) while(length > index){
                        value = O[index++];
                        // eslint-disable-next-line no-self-compare
                        if (value != value) return true;
                    // Array#indexOf ignores holes, Array#includes - not
                    }
                    else for(; length > index; index++){
                        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                    }
                    return !IS_INCLUDES && -1;
                };
            };
            module1.exports = {
                // `Array.prototype.includes` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.includes
                includes: createMethod(true),
                // `Array.prototype.indexOf` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
                indexOf: createMethod(false)
            };
        /***/ },
        /***/ "4de4": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $filter = __webpack_require__("b727").filter;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
            // Edge 14- issue
            var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
            // `Array.prototype.filter` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.filter
            // with adding support of @@species
            $({
                target: "Array",
                proto: true,
                forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
            }, {
                filter: function filter(callbackfn /* , thisArg */ ) {
                    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
        /***/ },
        /***/ "4df4": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var bind = __webpack_require__("0366");
            var toObject = __webpack_require__("7b0b");
            var callWithSafeIterationClosing = __webpack_require__("9bdd");
            var isArrayIteratorMethod = __webpack_require__("e95a");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var getIteratorMethod = __webpack_require__("35a1");
            // `Array.from` method implementation
            // https://tc39.github.io/ecma262/#sec-array.from
            module1.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {
                var O = toObject(arrayLike);
                var C = typeof this == "function" ? this : Array;
                var argumentsLength = arguments.length;
                var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
                var mapping = mapfn !== undefined;
                var iteratorMethod = getIteratorMethod(O);
                var index = 0;
                var length, result, step, iterator, next, value;
                if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
                // if the target is not iterable or it's an array with the default iterator - use a simple case
                if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
                    iterator = iteratorMethod.call(O);
                    next = iterator.next;
                    result = new C();
                    for(; !(step = next.call(iterator)).done; index++){
                        value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [
                            step.value,
                            index
                        ], true) : step.value;
                        createProperty(result, index, value);
                    }
                } else {
                    length = toLength(O.length);
                    result = new C(length);
                    for(; length > index; index++){
                        value = mapping ? mapfn(O[index], index) : O[index];
                        createProperty(result, index, value);
                    }
                }
                result.length = index;
                return result;
            };
        /***/ },
        /***/ "4fad": /***/ function(module1, exports, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var $entries = __webpack_require__("6f53").entries;
            // `Object.entries` method
            // https://tc39.github.io/ecma262/#sec-object.entries
            $({
                target: "Object",
                stat: true
            }, {
                entries: function entries(O) {
                    return $entries(O);
                }
            });
        /***/ },
        /***/ "50c4": /***/ function(module1, exports, __webpack_require__) {
            var toInteger = __webpack_require__("a691");
            var min = Math.min;
            // `ToLength` abstract operation
            // https://tc39.github.io/ecma262/#sec-tolength
            module1.exports = function(argument) {
                return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
            };
        /***/ },
        /***/ "5135": /***/ function(module1, exports) {
            var hasOwnProperty = {}.hasOwnProperty;
            module1.exports = function(it, key) {
                return hasOwnProperty.call(it, key);
            };
        /***/ },
        /***/ "5319": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var toInteger = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            var advanceStringIndex = __webpack_require__("8aa5");
            var regExpExec = __webpack_require__("14c3");
            var max = Math.max;
            var min = Math.min;
            var floor = Math.floor;
            var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
            var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
            var maybeToString = function(it) {
                return it === undefined ? it : String(it);
            };
            // @@replace logic
            fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
                var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
                var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
                var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
                return [
                    // `String.prototype.replace` method
                    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                        var O = requireObjectCoercible(this);
                        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
                        return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                    function(regexp, replaceValue) {
                        if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                            var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                            if (res.done) return res.value;
                        }
                        var rx = anObject(regexp);
                        var S = String(this);
                        var functionalReplace = typeof replaceValue === "function";
                        if (!functionalReplace) replaceValue = String(replaceValue);
                        var global = rx.global;
                        if (global) {
                            var fullUnicode = rx.unicode;
                            rx.lastIndex = 0;
                        }
                        var results = [];
                        while(true){
                            var result = regExpExec(rx, S);
                            if (result === null) break;
                            results.push(result);
                            if (!global) break;
                            var matchStr = String(result[0]);
                            if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                        }
                        var accumulatedResult = "";
                        var nextSourcePosition = 0;
                        for(var i = 0; i < results.length; i++){
                            result = results[i];
                            var matched = String(result[0]);
                            var position = max(min(toInteger(result.index), S.length), 0);
                            var captures = [];
                            // NOTE: This is equivalent to
                            //   captures = result.slice(1).map(maybeToString)
                            // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                            // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                            // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                            for(var j = 1; j < result.length; j++)captures.push(maybeToString(result[j]));
                            var namedCaptures = result.groups;
                            if (functionalReplace) {
                                var replacerArgs = [
                                    matched
                                ].concat(captures, position, S);
                                if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                                var replacement = String(replaceValue.apply(undefined, replacerArgs));
                            } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                            if (position >= nextSourcePosition) {
                                accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                                nextSourcePosition = position + matched.length;
                            }
                        }
                        return accumulatedResult + S.slice(nextSourcePosition);
                    }
                ];
                // https://tc39.github.io/ecma262/#sec-getsubstitution
                function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
                    var tailPos = position + matched.length;
                    var m = captures.length;
                    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                    if (namedCaptures !== undefined) {
                        namedCaptures = toObject(namedCaptures);
                        symbols = SUBSTITUTION_SYMBOLS;
                    }
                    return nativeReplace.call(replacement, symbols, function(match, ch) {
                        var capture;
                        switch(ch.charAt(0)){
                            case "$":
                                return "$";
                            case "&":
                                return matched;
                            case "`":
                                return str.slice(0, position);
                            case "'":
                                return str.slice(tailPos);
                            case "<":
                                capture = namedCaptures[ch.slice(1, -1)];
                                break;
                            default:
                                var n = +ch;
                                if (n === 0) return match;
                                if (n > m) {
                                    var f = floor(n / 10);
                                    if (f === 0) return match;
                                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                                    return match;
                                }
                                capture = captures[n - 1];
                        }
                        return capture === undefined ? "" : capture;
                    });
                }
            });
        /***/ },
        /***/ "5692": /***/ function(module1, exports, __webpack_require__) {
            var IS_PURE = __webpack_require__("c430");
            var store = __webpack_require__("c6cd");
            (module1.exports = function(key, value) {
                return store[key] || (store[key] = value !== undefined ? value : {});
            })("versions", []).push({
                version: "3.6.5",
                mode: IS_PURE ? "pure" : "global",
                copyright: "\xa9 2020 Denis Pushkarev (zloirock.ru)"
            });
        /***/ },
        /***/ "56ef": /***/ function(module1, exports, __webpack_require__) {
            var getBuiltIn = __webpack_require__("d066");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var anObject = __webpack_require__("825a");
            // all object keys, includes non-enumerable and symbols
            module1.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
            };
        /***/ },
        /***/ "5a34": /***/ function(module1, exports, __webpack_require__) {
            var isRegExp = __webpack_require__("44e7");
            module1.exports = function(it) {
                if (isRegExp(it)) throw TypeError("The method doesn't accept regular expressions");
                return it;
            };
        /***/ },
        /***/ "5c6c": /***/ function(module1, exports) {
            module1.exports = function(bitmap, value) {
                return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value: value
                };
            };
        /***/ },
        /***/ "5db7": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var flattenIntoArray = __webpack_require__("a2bf");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var aFunction = __webpack_require__("1c0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            // `Array.prototype.flatMap` method
            // https://github.com/tc39/proposal-flatMap
            $({
                target: "Array",
                proto: true
            }, {
                flatMap: function flatMap(callbackfn /* , thisArg */ ) {
                    var O = toObject(this);
                    var sourceLen = toLength(O.length);
                    var A;
                    aFunction(callbackfn);
                    A = arraySpeciesCreate(O, 0);
                    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    return A;
                }
            });
        /***/ },
        /***/ "6547": /***/ function(module1, exports, __webpack_require__) {
            var toInteger = __webpack_require__("a691");
            var requireObjectCoercible = __webpack_require__("1d80");
            // `String.prototype.{ codePointAt, at }` methods implementation
            var createMethod = function(CONVERT_TO_STRING) {
                return function($this, pos) {
                    var S = String(requireObjectCoercible($this));
                    var position = toInteger(pos);
                    var size = S.length;
                    var first, second;
                    if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : undefined;
                    first = S.charCodeAt(position);
                    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
                };
            };
            module1.exports = {
                // `String.prototype.codePointAt` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
                codeAt: createMethod(false),
                // `String.prototype.at` method
                // https://github.com/mathiasbynens/String.prototype.at
                charAt: createMethod(true)
            };
        /***/ },
        /***/ "65f0": /***/ function(module1, exports, __webpack_require__) {
            var isObject = __webpack_require__("861d");
            var isArray = __webpack_require__("e8b5");
            var wellKnownSymbol = __webpack_require__("b622");
            var SPECIES = wellKnownSymbol("species");
            // `ArraySpeciesCreate` abstract operation
            // https://tc39.github.io/ecma262/#sec-arrayspeciescreate
            module1.exports = function(originalArray, length) {
                var C;
                if (isArray(originalArray)) {
                    C = originalArray.constructor;
                    // cross-realm fallback
                    if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = undefined;
                    else if (isObject(C)) {
                        C = C[SPECIES];
                        if (C === null) C = undefined;
                    }
                }
                return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
            };
        /***/ },
        /***/ "69f3": /***/ function(module1, exports, __webpack_require__) {
            var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
            var global = __webpack_require__("da84");
            var isObject = __webpack_require__("861d");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var objectHas = __webpack_require__("5135");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var WeakMap = global.WeakMap;
            var set, get, has;
            var enforce = function(it) {
                return has(it) ? get(it) : set(it, {});
            };
            var getterFor = function(TYPE) {
                return function(it) {
                    var state;
                    if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required");
                    return state;
                };
            };
            if (NATIVE_WEAK_MAP) {
                var store = new WeakMap();
                var wmget = store.get;
                var wmhas = store.has;
                var wmset = store.set;
                set = function(it, metadata) {
                    wmset.call(store, it, metadata);
                    return metadata;
                };
                get = function(it) {
                    return wmget.call(store, it) || {};
                };
                has = function(it) {
                    return wmhas.call(store, it);
                };
            } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = function(it, metadata) {
                    createNonEnumerableProperty(it, STATE, metadata);
                    return metadata;
                };
                get = function(it) {
                    return objectHas(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                    return objectHas(it, STATE);
                };
            }
            module1.exports = {
                set: set,
                get: get,
                has: has,
                enforce: enforce,
                getterFor: getterFor
            };
        /***/ },
        /***/ "6eeb": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has = __webpack_require__("5135");
            var setGlobal = __webpack_require__("ce4e");
            var inspectSource = __webpack_require__("8925");
            var InternalStateModule = __webpack_require__("69f3");
            var getInternalState = InternalStateModule.get;
            var enforceInternalState = InternalStateModule.enforce;
            var TEMPLATE = String(String).split("String");
            (module1.exports = function(O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false;
                var simple = options ? !!options.enumerable : false;
                var noTargetGet = options ? !!options.noTargetGet : false;
                if (typeof value == "function") {
                    if (typeof key == "string" && !has(value, "name")) createNonEnumerableProperty(value, "name", key);
                    enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
                }
                if (O === global) {
                    if (simple) O[key] = value;
                    else setGlobal(key, value);
                    return;
                } else if (!unsafe) delete O[key];
                else if (!noTargetGet && O[key]) simple = true;
                if (simple) O[key] = value;
                else createNonEnumerableProperty(O, key, value);
            // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
            })(Function.prototype, "toString", function toString() {
                return typeof this == "function" && getInternalState(this).source || inspectSource(this);
            });
        /***/ },
        /***/ "6f53": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var objectKeys = __webpack_require__("df75");
            var toIndexedObject = __webpack_require__("fc6a");
            var propertyIsEnumerable = __webpack_require__("d1e7").f;
            // `Object.{ entries, values }` methods implementation
            var createMethod = function(TO_ENTRIES) {
                return function(it) {
                    var O = toIndexedObject(it);
                    var keys = objectKeys(O);
                    var length = keys.length;
                    var i = 0;
                    var result = [];
                    var key;
                    while(length > i){
                        key = keys[i++];
                        if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) result.push(TO_ENTRIES ? [
                            key,
                            O[key]
                        ] : O[key]);
                    }
                    return result;
                };
            };
            module1.exports = {
                // `Object.entries` method
                // https://tc39.github.io/ecma262/#sec-object.entries
                entries: createMethod(true),
                // `Object.values` method
                // https://tc39.github.io/ecma262/#sec-object.values
                values: createMethod(false)
            };
        /***/ },
        /***/ "73d9": /***/ function(module1, exports, __webpack_require__) {
            // this method was added to unscopables after implementation
            // in popular engines, so it's moved to a separate module
            var addToUnscopables = __webpack_require__("44d2");
            addToUnscopables("flatMap");
        /***/ },
        /***/ "7418": /***/ function(module1, exports) {
            exports.f = Object.getOwnPropertySymbols;
        /***/ },
        /***/ "746f": /***/ function(module1, exports, __webpack_require__) {
            var path = __webpack_require__("428f");
            var has = __webpack_require__("5135");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineProperty = __webpack_require__("9bf2").f;
            module1.exports = function(NAME) {
                var Symbol1 = path.Symbol || (path.Symbol = {});
                if (!has(Symbol1, NAME)) defineProperty(Symbol1, NAME, {
                    value: wrappedWellKnownSymbolModule.f(NAME)
                });
            };
        /***/ },
        /***/ "7839": /***/ function(module1, exports) {
            // IE8- don't enum bug keys
            module1.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
            ];
        /***/ },
        /***/ "7b0b": /***/ function(module1, exports, __webpack_require__) {
            var requireObjectCoercible = __webpack_require__("1d80");
            // `ToObject` abstract operation
            // https://tc39.github.io/ecma262/#sec-toobject
            module1.exports = function(argument) {
                return Object(requireObjectCoercible(argument));
            };
        /***/ },
        /***/ "7c73": /***/ function(module1, exports, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var defineProperties = __webpack_require__("37e8");
            var enumBugKeys = __webpack_require__("7839");
            var hiddenKeys = __webpack_require__("d012");
            var html = __webpack_require__("1be4");
            var documentCreateElement = __webpack_require__("cc12");
            var sharedKey = __webpack_require__("f772");
            var GT = ">";
            var LT = "<";
            var PROTOTYPE = "prototype";
            var SCRIPT = "script";
            var IE_PROTO = sharedKey("IE_PROTO");
            var EmptyConstructor = function() {};
            var scriptTag = function(content) {
                return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
            };
            // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
            var NullProtoObjectViaActiveX = function(activeXDocument) {
                activeXDocument.write(scriptTag(""));
                activeXDocument.close();
                var temp = activeXDocument.parentWindow.Object;
                activeXDocument = null; // avoid memory leak
                return temp;
            };
            // Create object with fake `null` prototype: use iframe Object with cleared prototype
            var NullProtoObjectViaIFrame = function() {
                // Thrash, waste and sodomy: IE GC bug
                var iframe = documentCreateElement("iframe");
                var JS = "java" + SCRIPT + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                // https://github.com/zloirock/core-js/issues/475
                iframe.src = String(JS);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(scriptTag("document.F=Object"));
                iframeDocument.close();
                return iframeDocument.F;
            };
            // Check for document.domain and active x support
            // No need to use active x approach when document.domain is not set
            // see https://github.com/es-shims/es5-shim/issues/150
            // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
            // avoid IE GC bug
            var activeXDocument;
            var NullProtoObject = function() {
                try {
                    /* global ActiveXObject */ activeXDocument = document.domain && new ActiveXObject("htmlfile");
                } catch (error) {}
                NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
                var length = enumBugKeys.length;
                while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                return NullProtoObject();
            };
            hiddenKeys[IE_PROTO] = true;
            // `Object.create` method
            // https://tc39.github.io/ecma262/#sec-object.create
            module1.exports = Object.create || function create(O, Properties) {
                var result;
                if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O);
                    result = new EmptyConstructor();
                    EmptyConstructor[PROTOTYPE] = null;
                    // add "__proto__" for Object.getPrototypeOf polyfill
                    result[IE_PROTO] = O;
                } else result = NullProtoObject();
                return Properties === undefined ? result : defineProperties(result, Properties);
            };
        /***/ },
        /***/ "7dd0": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var createIteratorConstructor = __webpack_require__("9ed3");
            var getPrototypeOf = __webpack_require__("e163");
            var setPrototypeOf = __webpack_require__("d2bb");
            var setToStringTag = __webpack_require__("d44e");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var Iterators = __webpack_require__("3f8c");
            var IteratorsCore = __webpack_require__("ae93");
            var IteratorPrototype = IteratorsCore.IteratorPrototype;
            var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
            var ITERATOR = wellKnownSymbol("iterator");
            var KEYS = "keys";
            var VALUES = "values";
            var ENTRIES = "entries";
            var returnThis = function() {
                return this;
            };
            module1.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = function(KIND) {
                    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
                    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
                    switch(KIND){
                        case KEYS:
                            return function keys() {
                                return new IteratorConstructor(this, KIND);
                            };
                        case VALUES:
                            return function values() {
                                return new IteratorConstructor(this, KIND);
                            };
                        case ENTRIES:
                            return function entries() {
                                return new IteratorConstructor(this, KIND);
                            };
                    }
                    return function() {
                        return new IteratorConstructor(this);
                    };
                };
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                // fix native
                if (anyNativeIterator) {
                    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                        if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                            if (setPrototypeOf) setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                            else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                        }
                        // Set @@toStringTag to native iterators
                        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                        if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
                    }
                }
                // fix Array#{values, @@iterator}.name in V8 / FF
                if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                        return nativeIterator.call(this);
                    };
                }
                // define iterator
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
                Iterators[NAME] = defaultIterator;
                // export additional methods
                if (DEFAULT) {
                    methods = {
                        values: getIterationMethod(VALUES),
                        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                        entries: getIterationMethod(ENTRIES)
                    };
                    if (FORCED) {
                        for(KEY in methods)if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) redefine(IterablePrototype, KEY, methods[KEY]);
                    } else $({
                        target: NAME,
                        proto: true,
                        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
                    }, methods);
                }
                return methods;
            };
        /***/ },
        /***/ "7f9a": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var inspectSource = __webpack_require__("8925");
            var WeakMap = global.WeakMap;
            module1.exports = typeof WeakMap === "function" && /native code/.test(inspectSource(WeakMap));
        /***/ },
        /***/ "825a": /***/ function(module1, exports, __webpack_require__) {
            var isObject = __webpack_require__("861d");
            module1.exports = function(it) {
                if (!isObject(it)) throw TypeError(String(it) + " is not an object");
                return it;
            };
        /***/ },
        /***/ "83ab": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            // Thank's IE8 for his funny defineProperty
            module1.exports = !fails(function() {
                return Object.defineProperty({}, 1, {
                    get: function() {
                        return 7;
                    }
                })[1] != 7;
            });
        /***/ },
        /***/ "8418": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var toPrimitive = __webpack_require__("c04e");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module1.exports = function(object, key, value) {
                var propertyKey = toPrimitive(key);
                if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                else object[propertyKey] = value;
            };
        /***/ },
        /***/ "861d": /***/ function(module1, exports) {
            module1.exports = function(it) {
                return typeof it === "object" ? it !== null : typeof it === "function";
            };
        /***/ },
        /***/ "8875": /***/ function(module1, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // addapted from the document.currentScript polyfill by Adam Miller
            // MIT license
            // source: https://github.com/amiller-gh/currentScript-polyfill
            // added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505
            (function(root, factory) {
                __WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module1.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            })(typeof self !== "undefined" ? self : this, function() {
                function getCurrentScript() {
                    var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
                    // for chrome
                    if (!descriptor && "currentScript" in document && document.currentScript) return document.currentScript;
                    // for other browsers with native support for currentScript
                    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) return document.currentScript;
                    // IE 8-10 support script readyState
                    // IE 11+ & Firefox support stack trace
                    try {
                        throw new Error();
                    } catch (err) {
                        // Find the second match for the "at" string to get file src url from stack.
                        var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script"); // Live NodeList collection
                        if (scriptLocation === currentLocation) {
                            pageSource = document.documentElement.outerHTML;
                            inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                            inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                        }
                        for(var i = 0; i < scripts.length; i++){
                            // If ready state is interactive, return the script tag
                            if (scripts[i].readyState === "interactive") return scripts[i];
                            // If src matches, return the script tag
                            if (scripts[i].src === scriptLocation) return scripts[i];
                            // If inline source matches, return the script tag
                            if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) return scripts[i];
                        }
                        // If no match, return null
                        return null;
                    }
                }
                return getCurrentScript;
            });
        /***/ },
        /***/ "8925": /***/ function(module1, exports, __webpack_require__) {
            var store = __webpack_require__("c6cd");
            var functionToString = Function.toString;
            // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
            if (typeof store.inspectSource != "function") store.inspectSource = function(it) {
                return functionToString.call(it);
            };
            module1.exports = store.inspectSource;
        /***/ },
        /***/ "8aa5": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var charAt = __webpack_require__("6547").charAt;
            // `AdvanceStringIndex` abstract operation
            // https://tc39.github.io/ecma262/#sec-advancestringindex
            module1.exports = function(S, index, unicode) {
                return index + (unicode ? charAt(S, index).length : 1);
            };
        /***/ },
        /***/ "8bbf": /***/ function(module1, exports) {
            module1.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
        /***/ },
        /***/ "90e3": /***/ function(module1, exports) {
            var id = 0;
            var postfix = Math.random();
            module1.exports = function(key) {
                return "Symbol(" + String(key === undefined ? "" : key) + ")_" + (++id + postfix).toString(36);
            };
        /***/ },
        /***/ "9112": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var definePropertyModule = __webpack_require__("9bf2");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            module1.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
                object[key] = value;
                return object;
            };
        /***/ },
        /***/ "9263": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var regexpFlags = __webpack_require__("ad6d");
            var stickyHelpers = __webpack_require__("9f7f");
            var nativeExec = RegExp.prototype.exec;
            // This always refers to the native implementation, because the
            // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
            // which loads this file before patching the method.
            var nativeReplace = String.prototype.replace;
            var patchedExec = nativeExec;
            var UPDATES_LAST_INDEX_WRONG = function() {
                var re1 = /a/;
                var re2 = /b*/g;
                nativeExec.call(re1, "a");
                nativeExec.call(re2, "a");
                return re1.lastIndex !== 0 || re2.lastIndex !== 0;
            }();
            var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
            // nonparticipating capturing group, copied from es5-shim's String#split patch.
            var NPCG_INCLUDED = /()??/.exec("")[1] !== undefined;
            var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
            if (PATCH) patchedExec = function exec(str) {
                var re = this;
                var lastIndex, reCopy, match, i;
                var sticky = UNSUPPORTED_Y && re.sticky;
                var flags = regexpFlags.call(re);
                var source = re.source;
                var charsAdded = 0;
                var strCopy = str;
                if (sticky) {
                    flags = flags.replace("y", "");
                    if (flags.indexOf("g") === -1) flags += "g";
                    strCopy = String(str).slice(re.lastIndex);
                    // Support anchored sticky behavior.
                    if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
                        source = "(?: " + source + ")";
                        strCopy = " " + strCopy;
                        charsAdded++;
                    }
                    // ^(? + rx + ) is needed, in combination with some str slicing, to
                    // simulate the 'y' flag.
                    reCopy = new RegExp("^(?:" + source + ")", flags);
                }
                if (NPCG_INCLUDED) reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
                if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
                match = nativeExec.call(sticky ? reCopy : re, strCopy);
                if (sticky) {
                    if (match) {
                        match.input = match.input.slice(charsAdded);
                        match[0] = match[0].slice(charsAdded);
                        match.index = re.lastIndex;
                        re.lastIndex += match[0].length;
                    } else re.lastIndex = 0;
                } else if (UPDATES_LAST_INDEX_WRONG && match) re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
                if (NPCG_INCLUDED && match && match.length > 1) // Fix browsers whose `exec` methods don't consistently return `undefined`
                // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                nativeReplace.call(match[0], reCopy, function() {
                    for(i = 1; i < arguments.length - 2; i++)if (arguments[i] === undefined) match[i] = undefined;
                });
                return match;
            };
            module1.exports = patchedExec;
        /***/ },
        /***/ "94ca": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
                var value = data[normalize(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
            };
            var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
            };
            var data = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module1.exports = isForced;
        /***/ },
        /***/ "99af": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var isArray = __webpack_require__("e8b5");
            var isObject = __webpack_require__("861d");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var createProperty = __webpack_require__("8418");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var wellKnownSymbol = __webpack_require__("b622");
            var V8_VERSION = __webpack_require__("2d00");
            var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
            var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
            var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
            // We can't use this feature detection in V8 since it causes
            // deoptimization and serious performance degradation
            // https://github.com/zloirock/core-js/issues/679
            var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                var array = [];
                array[IS_CONCAT_SPREADABLE] = false;
                return array.concat()[0] !== array;
            });
            var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
            var isConcatSpreadable = function(O) {
                if (!isObject(O)) return false;
                var spreadable = O[IS_CONCAT_SPREADABLE];
                return spreadable !== undefined ? !!spreadable : isArray(O);
            };
            var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
            // `Array.prototype.concat` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.concat
            // with adding support of @@isConcatSpreadable and @@species
            $({
                target: "Array",
                proto: true,
                forced: FORCED
            }, {
                concat: function concat(arg) {
                    var O = toObject(this);
                    var A = arraySpeciesCreate(O, 0);
                    var n = 0;
                    var i, k, length, len, E;
                    for(i = -1, length = arguments.length; i < length; i++){
                        E = i === -1 ? O : arguments[i];
                        if (isConcatSpreadable(E)) {
                            len = toLength(E.length);
                            if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                            for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);
                        } else {
                            if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                            createProperty(A, n++, E);
                        }
                    }
                    A.length = n;
                    return A;
                }
            });
        /***/ },
        /***/ "9bdd": /***/ function(module1, exports, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            // call something on iterator step with safe closing on error
            module1.exports = function(iterator, fn, value, ENTRIES) {
                try {
                    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                // 7.4.6 IteratorClose(iterator, completion)
                } catch (error) {
                    var returnMethod = iterator["return"];
                    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
                    throw error;
                }
            };
        /***/ },
        /***/ "9bf2": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var IE8_DOM_DEFINE = __webpack_require__("0cfb");
            var anObject = __webpack_require__("825a");
            var toPrimitive = __webpack_require__("c04e");
            var nativeDefineProperty = Object.defineProperty;
            // `Object.defineProperty` method
            // https://tc39.github.io/ecma262/#sec-object.defineproperty
            exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPrimitive(P, true);
                anObject(Attributes);
                if (IE8_DOM_DEFINE) try {
                    return nativeDefineProperty(O, P, Attributes);
                } catch (error) {}
                if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
                if ("value" in Attributes) O[P] = Attributes.value;
                return O;
            };
        /***/ },
        /***/ "9ed3": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
            var create = __webpack_require__("7c73");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var setToStringTag = __webpack_require__("d44e");
            var Iterators = __webpack_require__("3f8c");
            var returnThis = function() {
                return this;
            };
            module1.exports = function(IteratorConstructor, NAME, next) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create(IteratorPrototype, {
                    next: createPropertyDescriptor(1, next)
                });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
            };
        /***/ },
        /***/ "9f7f": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var fails = __webpack_require__("d039");
            // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
            // so we use an intermediate function.
            function RE(s, f) {
                return RegExp(s, f);
            }
            exports.UNSUPPORTED_Y = fails(function() {
                // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
                var re = RE("a", "y");
                re.lastIndex = 2;
                return re.exec("abcd") != null;
            });
            exports.BROKEN_CARET = fails(function() {
                // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
                var re = RE("^r", "gy");
                re.lastIndex = 2;
                return re.exec("str") != null;
            });
        /***/ },
        /***/ "a2bf": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var isArray = __webpack_require__("e8b5");
            var toLength = __webpack_require__("50c4");
            var bind = __webpack_require__("0366");
            // `FlattenIntoArray` abstract operation
            // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
            var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
                var targetIndex = start;
                var sourceIndex = 0;
                var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
                var element;
                while(sourceIndex < sourceLen){
                    if (sourceIndex in source) {
                        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                        if (depth > 0 && isArray(element)) targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                        else {
                            if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError("Exceed the acceptable array length");
                            target[targetIndex] = element;
                        }
                        targetIndex++;
                    }
                    sourceIndex++;
                }
                return targetIndex;
            };
            module1.exports = flattenIntoArray;
        /***/ },
        /***/ "a352": /***/ function(module1, exports) {
            module1.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
        /***/ },
        /***/ "a434": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toInteger = __webpack_require__("a691");
            var toLength = __webpack_require__("50c4");
            var toObject = __webpack_require__("7b0b");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var createProperty = __webpack_require__("8418");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("splice", {
                ACCESSORS: true,
                0: 0,
                1: 2
            });
            var max = Math.max;
            var min = Math.min;
            var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
            var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
            // `Array.prototype.splice` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.splice
            // with adding support of @@species
            $({
                target: "Array",
                proto: true,
                forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
            }, {
                splice: function splice(start, deleteCount /* , ...items */ ) {
                    var O = toObject(this);
                    var len = toLength(O.length);
                    var actualStart = toAbsoluteIndex(start, len);
                    var argumentsLength = arguments.length;
                    var insertCount, actualDeleteCount, A, k, from, to;
                    if (argumentsLength === 0) insertCount = actualDeleteCount = 0;
                    else if (argumentsLength === 1) {
                        insertCount = 0;
                        actualDeleteCount = len - actualStart;
                    } else {
                        insertCount = argumentsLength - 2;
                        actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
                    }
                    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                    A = arraySpeciesCreate(O, actualDeleteCount);
                    for(k = 0; k < actualDeleteCount; k++){
                        from = actualStart + k;
                        if (from in O) createProperty(A, k, O[from]);
                    }
                    A.length = actualDeleteCount;
                    if (insertCount < actualDeleteCount) {
                        for(k = actualStart; k < len - actualDeleteCount; k++){
                            from = k + actualDeleteCount;
                            to = k + insertCount;
                            if (from in O) O[to] = O[from];
                            else delete O[to];
                        }
                        for(k = len; k > len - actualDeleteCount + insertCount; k--)delete O[k - 1];
                    } else if (insertCount > actualDeleteCount) for(k = len - actualDeleteCount; k > actualStart; k--){
                        from = k + actualDeleteCount - 1;
                        to = k + insertCount - 1;
                        if (from in O) O[to] = O[from];
                        else delete O[to];
                    }
                    for(k = 0; k < insertCount; k++)O[k + actualStart] = arguments[k + 2];
                    O.length = len - actualDeleteCount + insertCount;
                    return A;
                }
            });
        /***/ },
        /***/ "a4d3": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var global = __webpack_require__("da84");
            var getBuiltIn = __webpack_require__("d066");
            var IS_PURE = __webpack_require__("c430");
            var DESCRIPTORS = __webpack_require__("83ab");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var fails = __webpack_require__("d039");
            var has = __webpack_require__("5135");
            var isArray = __webpack_require__("e8b5");
            var isObject = __webpack_require__("861d");
            var anObject = __webpack_require__("825a");
            var toObject = __webpack_require__("7b0b");
            var toIndexedObject = __webpack_require__("fc6a");
            var toPrimitive = __webpack_require__("c04e");
            var createPropertyDescriptor = __webpack_require__("5c6c");
            var nativeObjectCreate = __webpack_require__("7c73");
            var objectKeys = __webpack_require__("df75");
            var getOwnPropertyNamesModule = __webpack_require__("241c");
            var getOwnPropertyNamesExternal = __webpack_require__("057f");
            var getOwnPropertySymbolsModule = __webpack_require__("7418");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            var propertyIsEnumerableModule = __webpack_require__("d1e7");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var redefine = __webpack_require__("6eeb");
            var shared = __webpack_require__("5692");
            var sharedKey = __webpack_require__("f772");
            var hiddenKeys = __webpack_require__("d012");
            var uid = __webpack_require__("90e3");
            var wellKnownSymbol = __webpack_require__("b622");
            var wrappedWellKnownSymbolModule = __webpack_require__("e538");
            var defineWellKnownSymbol = __webpack_require__("746f");
            var setToStringTag = __webpack_require__("d44e");
            var InternalStateModule = __webpack_require__("69f3");
            var $forEach = __webpack_require__("b727").forEach;
            var HIDDEN = sharedKey("hidden");
            var SYMBOL = "Symbol";
            var PROTOTYPE = "prototype";
            var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(SYMBOL);
            var ObjectPrototype = Object[PROTOTYPE];
            var $Symbol = global.Symbol;
            var $stringify = getBuiltIn("JSON", "stringify");
            var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            var nativeDefineProperty = definePropertyModule.f;
            var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
            var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
            var AllSymbols = shared("symbols");
            var ObjectPrototypeSymbols = shared("op-symbols");
            var StringToSymbolRegistry = shared("string-to-symbol-registry");
            var SymbolToStringRegistry = shared("symbol-to-string-registry");
            var WellKnownSymbolsStore = shared("wks");
            var QObject = global.QObject;
            // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
            var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
            // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
            var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                return nativeObjectCreate(nativeDefineProperty({}, "a", {
                    get: function() {
                        return nativeDefineProperty(this, "a", {
                            value: 7
                        }).a;
                    }
                })).a != 7;
            }) ? function(O, P, Attributes) {
                var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
                nativeDefineProperty(O, P, Attributes);
                if (ObjectPrototypeDescriptor && O !== ObjectPrototype) nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
            } : nativeDefineProperty;
            var wrap = function(tag, description) {
                var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
                setInternalState(symbol, {
                    type: SYMBOL,
                    tag: tag,
                    description: description
                });
                if (!DESCRIPTORS) symbol.description = description;
                return symbol;
            };
            var isSymbol = USE_SYMBOL_AS_UID ? function(it) {
                return typeof it == "symbol";
            } : function(it) {
                return Object(it) instanceof $Symbol;
            };
            var $defineProperty = function defineProperty(O, P, Attributes) {
                if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
                anObject(O);
                var key = toPrimitive(P, true);
                anObject(Attributes);
                if (has(AllSymbols, key)) {
                    if (!Attributes.enumerable) {
                        if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                        O[HIDDEN][key] = true;
                    } else {
                        if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
                        Attributes = nativeObjectCreate(Attributes, {
                            enumerable: createPropertyDescriptor(0, false)
                        });
                    }
                    return setSymbolDescriptor(O, key, Attributes);
                }
                return nativeDefineProperty(O, key, Attributes);
            };
            var $defineProperties = function defineProperties(O, Properties) {
                anObject(O);
                var properties = toIndexedObject(Properties);
                var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                $forEach(keys, function(key) {
                    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
                });
                return O;
            };
            var $create = function create(O, Properties) {
                return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(V) {
                var P = toPrimitive(V, true);
                var enumerable = nativePropertyIsEnumerable.call(this, P);
                if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
                return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
                var it = toIndexedObject(O);
                var key = toPrimitive(P, true);
                if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
                var descriptor = nativeGetOwnPropertyDescriptor(it, key);
                if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) descriptor.enumerable = true;
                return descriptor;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(O) {
                var names = nativeGetOwnPropertyNames(toIndexedObject(O));
                var result = [];
                $forEach(names, function(key) {
                    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
                });
                return result;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
                var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
                var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
                var result = [];
                $forEach(names, function(key) {
                    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) result.push(AllSymbols[key]);
                });
                return result;
            };
            // `Symbol` constructor
            // https://tc39.github.io/ecma262/#sec-symbol-constructor
            if (!NATIVE_SYMBOL) {
                $Symbol = function Symbol1() {
                    if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor");
                    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
                    var tag = uid(description);
                    var setter = function(value) {
                        if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
                        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                        setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                    };
                    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
                        configurable: true,
                        set: setter
                    });
                    return wrap(tag, description);
                };
                redefine($Symbol[PROTOTYPE], "toString", function toString() {
                    return getInternalState(this).tag;
                });
                redefine($Symbol, "withoutSetter", function(description) {
                    return wrap(uid(description), description);
                });
                propertyIsEnumerableModule.f = $propertyIsEnumerable;
                definePropertyModule.f = $defineProperty;
                getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                wrappedWellKnownSymbolModule.f = function(name) {
                    return wrap(wellKnownSymbol(name), name);
                };
                if (DESCRIPTORS) {
                    // https://github.com/tc39/proposal-Symbol-description
                    nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                        configurable: true,
                        get: function description() {
                            return getInternalState(this).description;
                        }
                    });
                    if (!IS_PURE) redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, {
                        unsafe: true
                    });
                }
            }
            $({
                global: true,
                wrap: true,
                forced: !NATIVE_SYMBOL,
                sham: !NATIVE_SYMBOL
            }, {
                Symbol: $Symbol
            });
            $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                defineWellKnownSymbol(name);
            });
            $({
                target: SYMBOL,
                stat: true,
                forced: !NATIVE_SYMBOL
            }, {
                // `Symbol.for` method
                // https://tc39.github.io/ecma262/#sec-symbol.for
                "for": function(key) {
                    var string = String(key);
                    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
                    var symbol = $Symbol(string);
                    StringToSymbolRegistry[string] = symbol;
                    SymbolToStringRegistry[symbol] = string;
                    return symbol;
                },
                // `Symbol.keyFor` method
                // https://tc39.github.io/ecma262/#sec-symbol.keyfor
                keyFor: function keyFor(sym) {
                    if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol");
                    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
                },
                useSetter: function() {
                    USE_SETTER = true;
                },
                useSimple: function() {
                    USE_SETTER = false;
                }
            });
            $({
                target: "Object",
                stat: true,
                forced: !NATIVE_SYMBOL,
                sham: !DESCRIPTORS
            }, {
                // `Object.create` method
                // https://tc39.github.io/ecma262/#sec-object.create
                create: $create,
                // `Object.defineProperty` method
                // https://tc39.github.io/ecma262/#sec-object.defineproperty
                defineProperty: $defineProperty,
                // `Object.defineProperties` method
                // https://tc39.github.io/ecma262/#sec-object.defineproperties
                defineProperties: $defineProperties,
                // `Object.getOwnPropertyDescriptor` method
                // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
                getOwnPropertyDescriptor: $getOwnPropertyDescriptor
            });
            $({
                target: "Object",
                stat: true,
                forced: !NATIVE_SYMBOL
            }, {
                // `Object.getOwnPropertyNames` method
                // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
                getOwnPropertyNames: $getOwnPropertyNames,
                // `Object.getOwnPropertySymbols` method
                // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
                getOwnPropertySymbols: $getOwnPropertySymbols
            });
            // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
            // https://bugs.chromium.org/p/v8/issues/detail?id=3443
            $({
                target: "Object",
                stat: true,
                forced: fails(function() {
                    getOwnPropertySymbolsModule.f(1);
                })
            }, {
                getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                    return getOwnPropertySymbolsModule.f(toObject(it));
                }
            });
            // `JSON.stringify` method behavior with symbols
            // https://tc39.github.io/ecma262/#sec-json.stringify
            if ($stringify) {
                var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                    var symbol = $Symbol();
                    // MS Edge converts symbol values to JSON as {}
                    return $stringify([
                        symbol
                    ]) != "[null]" || $stringify({
                        a: symbol
                    }) != "{}" || $stringify(Object(symbol)) != "{}";
                });
                $({
                    target: "JSON",
                    stat: true,
                    forced: FORCED_JSON_STRINGIFY
                }, {
                    // eslint-disable-next-line no-unused-vars
                    stringify: function stringify(it, replacer, space) {
                        var args = [
                            it
                        ];
                        var index = 1;
                        var $replacer;
                        while(arguments.length > index)args.push(arguments[index++]);
                        $replacer = replacer;
                        if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
                        if (!isArray(replacer)) replacer = function(key, value) {
                            if (typeof $replacer == "function") value = $replacer.call(this, key, value);
                            if (!isSymbol(value)) return value;
                        };
                        args[1] = replacer;
                        return $stringify.apply(null, args);
                    }
                });
            }
            // `Symbol.prototype[@@toPrimitive]` method
            // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
            if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
            // `Symbol.prototype[@@toStringTag]` property
            // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
            setToStringTag($Symbol, SYMBOL);
            hiddenKeys[HIDDEN] = true;
        /***/ },
        /***/ "a630": /***/ function(module1, exports, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var from = __webpack_require__("4df4");
            var checkCorrectnessOfIteration = __webpack_require__("1c7e");
            var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                Array.from(iterable);
            });
            // `Array.from` method
            // https://tc39.github.io/ecma262/#sec-array.from
            $({
                target: "Array",
                stat: true,
                forced: INCORRECT_ITERATION
            }, {
                from: from
            });
        /***/ },
        /***/ "a640": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var fails = __webpack_require__("d039");
            module1.exports = function(METHOD_NAME, argument) {
                var method = [][METHOD_NAME];
                return !!method && fails(function() {
                    // eslint-disable-next-line no-useless-call,no-throw-literal
                    method.call(null, argument || function() {
                        throw 1;
                    }, 1);
                });
            };
        /***/ },
        /***/ "a691": /***/ function(module1, exports) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            // `ToInteger` abstract operation
            // https://tc39.github.io/ecma262/#sec-tointeger
            module1.exports = function(argument) {
                return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
            };
        /***/ },
        /***/ "ab13": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var MATCH = wellKnownSymbol("match");
            module1.exports = function(METHOD_NAME) {
                var regexp = /./;
                try {
                    "/./"[METHOD_NAME](regexp);
                } catch (e) {
                    try {
                        regexp[MATCH] = false;
                        return "/./"[METHOD_NAME](regexp);
                    } catch (f) {}
                }
                return false;
            };
        /***/ },
        /***/ "ac1f": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var exec = __webpack_require__("9263");
            $({
                target: "RegExp",
                proto: true,
                forced: /./.exec !== exec
            }, {
                exec: exec
            });
        /***/ },
        /***/ "ad6d": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var anObject = __webpack_require__("825a");
            // `RegExp.prototype.flags` getter implementation
            // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
            module1.exports = function() {
                var that = anObject(this);
                var result = "";
                if (that.global) result += "g";
                if (that.ignoreCase) result += "i";
                if (that.multiline) result += "m";
                if (that.dotAll) result += "s";
                if (that.unicode) result += "u";
                if (that.sticky) result += "y";
                return result;
            };
        /***/ },
        /***/ "ae40": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var fails = __webpack_require__("d039");
            var has = __webpack_require__("5135");
            var defineProperty = Object.defineProperty;
            var cache = {};
            var thrower = function(it) {
                throw it;
            };
            module1.exports = function(METHOD_NAME, options) {
                if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
                if (!options) options = {};
                var method = [][METHOD_NAME];
                var ACCESSORS = has(options, "ACCESSORS") ? options.ACCESSORS : false;
                var argument0 = has(options, 0) ? options[0] : thrower;
                var argument1 = has(options, 1) ? options[1] : undefined;
                return cache[METHOD_NAME] = !!method && !fails(function() {
                    if (ACCESSORS && !DESCRIPTORS) return true;
                    var O = {
                        length: -1
                    };
                    if (ACCESSORS) defineProperty(O, 1, {
                        enumerable: true,
                        get: thrower
                    });
                    else O[1] = 1;
                    method.call(O, argument0, argument1);
                });
            };
        /***/ },
        /***/ "ae93": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var getPrototypeOf = __webpack_require__("e163");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var has = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var IS_PURE = __webpack_require__("c430");
            var ITERATOR = wellKnownSymbol("iterator");
            var BUGGY_SAFARI_ITERATORS = false;
            var returnThis = function() {
                return this;
            };
            // `%IteratorPrototype%` object
            // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
            var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
            if ([].keys) {
                arrayIterator = [].keys();
                // Safari 8 has buggy iterators w/o `next`
                if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
                else {
                    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
            }
            if (IteratorPrototype == undefined) IteratorPrototype = {};
            // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
            if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
            module1.exports = {
                IteratorPrototype: IteratorPrototype,
                BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
            };
        /***/ },
        /***/ "b041": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classof = __webpack_require__("f5df");
            // `Object.prototype.toString` method implementation
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            module1.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {
                return "[object " + classof(this) + "]";
            };
        /***/ },
        /***/ "b0c0": /***/ function(module1, exports, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__("83ab");
            var defineProperty = __webpack_require__("9bf2").f;
            var FunctionPrototype = Function.prototype;
            var FunctionPrototypeToString = FunctionPrototype.toString;
            var nameRE = /^\s*function ([^ (]*)/;
            var NAME = "name";
            // Function instances `.name` property
            // https://tc39.github.io/ecma262/#sec-function-instances-name
            if (DESCRIPTORS && !(NAME in FunctionPrototype)) defineProperty(FunctionPrototype, NAME, {
                configurable: true,
                get: function() {
                    try {
                        return FunctionPrototypeToString.call(this).match(nameRE)[1];
                    } catch (error) {
                        return "";
                    }
                }
            });
        /***/ },
        /***/ "b622": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var shared = __webpack_require__("5692");
            var has = __webpack_require__("5135");
            var uid = __webpack_require__("90e3");
            var NATIVE_SYMBOL = __webpack_require__("4930");
            var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
            var WellKnownSymbolsStore = shared("wks");
            var Symbol1 = global.Symbol;
            var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;
            module1.exports = function(name) {
                if (!has(WellKnownSymbolsStore, name)) {
                    if (NATIVE_SYMBOL && has(Symbol1, name)) WellKnownSymbolsStore[name] = Symbol1[name];
                    else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
                }
                return WellKnownSymbolsStore[name];
            };
        /***/ },
        /***/ "b64b": /***/ function(module1, exports, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var toObject = __webpack_require__("7b0b");
            var nativeKeys = __webpack_require__("df75");
            var fails = __webpack_require__("d039");
            var FAILS_ON_PRIMITIVES = fails(function() {
                nativeKeys(1);
            });
            // `Object.keys` method
            // https://tc39.github.io/ecma262/#sec-object.keys
            $({
                target: "Object",
                stat: true,
                forced: FAILS_ON_PRIMITIVES
            }, {
                keys: function keys(it) {
                    return nativeKeys(toObject(it));
                }
            });
        /***/ },
        /***/ "b727": /***/ function(module1, exports, __webpack_require__) {
            var bind = __webpack_require__("0366");
            var IndexedObject = __webpack_require__("44ad");
            var toObject = __webpack_require__("7b0b");
            var toLength = __webpack_require__("50c4");
            var arraySpeciesCreate = __webpack_require__("65f0");
            var push = [].push;
            // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
            var createMethod = function(TYPE) {
                var IS_MAP = TYPE == 1;
                var IS_FILTER = TYPE == 2;
                var IS_SOME = TYPE == 3;
                var IS_EVERY = TYPE == 4;
                var IS_FIND_INDEX = TYPE == 6;
                var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                return function($this, callbackfn, that, specificCreate) {
                    var O = toObject($this);
                    var self1 = IndexedObject(O);
                    var boundFunction = bind(callbackfn, that, 3);
                    var length = toLength(self1.length);
                    var index = 0;
                    var create = specificCreate || arraySpeciesCreate;
                    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
                    var value, result;
                    for(; length > index; index++)if (NO_HOLES || index in self1) {
                        value = self1[index];
                        result = boundFunction(value, index, O);
                        if (TYPE) {
                            if (IS_MAP) target[index] = result; // map
                            else if (result) switch(TYPE){
                                case 3:
                                    return true; // some
                                case 5:
                                    return value; // find
                                case 6:
                                    return index; // findIndex
                                case 2:
                                    push.call(target, value); // filter
                            }
                            else if (IS_EVERY) return false; // every
                        }
                    }
                    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                };
            };
            module1.exports = {
                // `Array.prototype.forEach` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
                forEach: createMethod(0),
                // `Array.prototype.map` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.map
                map: createMethod(1),
                // `Array.prototype.filter` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.filter
                filter: createMethod(2),
                // `Array.prototype.some` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.some
                some: createMethod(3),
                // `Array.prototype.every` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.every
                every: createMethod(4),
                // `Array.prototype.find` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.find
                find: createMethod(5),
                // `Array.prototype.findIndex` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
                findIndex: createMethod(6)
            };
        /***/ },
        /***/ "c04e": /***/ function(module1, exports, __webpack_require__) {
            var isObject = __webpack_require__("861d");
            // `ToPrimitive` abstract operation
            // https://tc39.github.io/ecma262/#sec-toprimitive
            // instead of the ES6 spec version, we didn't implement @@toPrimitive case
            // and the second argument - flag - preferred type is a string
            module1.exports = function(input, PREFERRED_STRING) {
                if (!isObject(input)) return input;
                var fn, val;
                if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
                if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input))) return val;
                if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input))) return val;
                throw TypeError("Can't convert object to primitive value");
            };
        /***/ },
        /***/ "c430": /***/ function(module1, exports) {
            module1.exports = false;
        /***/ },
        /***/ "c6b6": /***/ function(module1, exports) {
            var toString = {}.toString;
            module1.exports = function(it) {
                return toString.call(it).slice(8, -1);
            };
        /***/ },
        /***/ "c6cd": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var setGlobal = __webpack_require__("ce4e");
            var SHARED = "__core-js_shared__";
            var store = global[SHARED] || setGlobal(SHARED, {});
            module1.exports = store;
        /***/ },
        /***/ "c740": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $findIndex = __webpack_require__("b727").findIndex;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var FIND_INDEX = "findIndex";
            var SKIPS_HOLES = true;
            var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
            // Shouldn't skip holes
            if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
                SKIPS_HOLES = false;
            });
            // `Array.prototype.findIndex` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.findindex
            $({
                target: "Array",
                proto: true,
                forced: SKIPS_HOLES || !USES_TO_LENGTH
            }, {
                findIndex: function findIndex(callbackfn /* , that = undefined */ ) {
                    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
            // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
            addToUnscopables(FIND_INDEX);
        /***/ },
        /***/ "c8ba": /***/ function(module1, exports) {
            var g;
            // This works in non-strict mode
            g = function() {
                return this;
            }();
            try {
                // This works if eval is allowed (see CSP)
                g = g || new Function("return this")();
            } catch (e) {
                // This works if the window reference is available
                if (typeof window === "object") g = window;
            }
            // g can still be undefined, but nothing to do about it...
            // We return undefined, instead of nothing here, so it's
            // easier to handle this case. if(!global) { ...}
            module1.exports = g;
        /***/ },
        /***/ "c975": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $indexOf = __webpack_require__("4d64").indexOf;
            var arrayMethodIsStrict = __webpack_require__("a640");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var nativeIndexOf = [].indexOf;
            var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [
                1
            ].indexOf(1, -0) < 0;
            var STRICT_METHOD = arrayMethodIsStrict("indexOf");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", {
                ACCESSORS: true,
                1: 0
            });
            // `Array.prototype.indexOf` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
            $({
                target: "Array",
                proto: true,
                forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH
            }, {
                indexOf: function indexOf(searchElement /* , fromIndex = 0 */ ) {
                    return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
        /***/ },
        /***/ "ca84": /***/ function(module1, exports, __webpack_require__) {
            var has = __webpack_require__("5135");
            var toIndexedObject = __webpack_require__("fc6a");
            var indexOf = __webpack_require__("4d64").indexOf;
            var hiddenKeys = __webpack_require__("d012");
            module1.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = 0;
                var result = [];
                var key;
                for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);
                // Don't enum bug & hidden keys
                while(names.length > i)if (has(O, key = names[i++])) ~indexOf(result, key) || result.push(key);
                return result;
            };
        /***/ },
        /***/ "caad": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $includes = __webpack_require__("4d64").includes;
            var addToUnscopables = __webpack_require__("44d2");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", {
                ACCESSORS: true,
                1: 0
            });
            // `Array.prototype.includes` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.includes
            $({
                target: "Array",
                proto: true,
                forced: !USES_TO_LENGTH
            }, {
                includes: function includes(el /* , fromIndex = 0 */ ) {
                    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
            // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
            addToUnscopables("includes");
        /***/ },
        /***/ "cc12": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var isObject = __webpack_require__("861d");
            var document1 = global.document;
            // typeof document.createElement is 'object' in old IE
            var EXISTS = isObject(document1) && isObject(document1.createElement);
            module1.exports = function(it) {
                return EXISTS ? document1.createElement(it) : {};
            };
        /***/ },
        /***/ "ce4e": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var createNonEnumerableProperty = __webpack_require__("9112");
            module1.exports = function(key, value) {
                try {
                    createNonEnumerableProperty(global, key, value);
                } catch (error) {
                    global[key] = value;
                }
                return value;
            };
        /***/ },
        /***/ "d012": /***/ function(module1, exports) {
            module1.exports = {};
        /***/ },
        /***/ "d039": /***/ function(module1, exports) {
            module1.exports = function(exec) {
                try {
                    return !!exec();
                } catch (error) {
                    return true;
                }
            };
        /***/ },
        /***/ "d066": /***/ function(module1, exports, __webpack_require__) {
            var path = __webpack_require__("428f");
            var global = __webpack_require__("da84");
            var aFunction = function(variable) {
                return typeof variable == "function" ? variable : undefined;
            };
            module1.exports = function(namespace, method) {
                return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
            };
        /***/ },
        /***/ "d1e7": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            // Nashorn ~ JDK8 bug
            var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
                1: 2
            }, 1);
            // `Object.prototype.propertyIsEnumerable` method implementation
            // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
            exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
            } : nativePropertyIsEnumerable;
        /***/ },
        /***/ "d28b": /***/ function(module1, exports, __webpack_require__) {
            var defineWellKnownSymbol = __webpack_require__("746f");
            // `Symbol.iterator` well-known symbol
            // https://tc39.github.io/ecma262/#sec-symbol.iterator
            defineWellKnownSymbol("iterator");
        /***/ },
        /***/ "d2bb": /***/ function(module1, exports, __webpack_require__) {
            var anObject = __webpack_require__("825a");
            var aPossiblePrototype = __webpack_require__("3bbe");
            // `Object.setPrototypeOf` method
            // https://tc39.github.io/ecma262/#sec-object.setprototypeof
            // Works with __proto__ only. Old v8 can't work with null proto objects.
            /* eslint-disable no-proto */ module1.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                    setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                    setter.call(test, []);
                    CORRECT_SETTER = test instanceof Array;
                } catch (error) {}
                return function setPrototypeOf(O, proto) {
                    anObject(O);
                    aPossiblePrototype(proto);
                    if (CORRECT_SETTER) setter.call(O, proto);
                    else O.__proto__ = proto;
                    return O;
                };
            }() : undefined);
        /***/ },
        /***/ "d3b7": /***/ function(module1, exports, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var redefine = __webpack_require__("6eeb");
            var toString = __webpack_require__("b041");
            // `Object.prototype.toString` method
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            if (!TO_STRING_TAG_SUPPORT) redefine(Object.prototype, "toString", toString, {
                unsafe: true
            });
        /***/ },
        /***/ "d44e": /***/ function(module1, exports, __webpack_require__) {
            var defineProperty = __webpack_require__("9bf2").f;
            var has = __webpack_require__("5135");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            module1.exports = function(it, TAG, STATIC) {
                if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) defineProperty(it, TO_STRING_TAG, {
                    configurable: true,
                    value: TAG
                });
            };
        /***/ },
        /***/ "d58f": /***/ function(module1, exports, __webpack_require__) {
            var aFunction = __webpack_require__("1c0b");
            var toObject = __webpack_require__("7b0b");
            var IndexedObject = __webpack_require__("44ad");
            var toLength = __webpack_require__("50c4");
            // `Array.prototype.{ reduce, reduceRight }` methods implementation
            var createMethod = function(IS_RIGHT) {
                return function(that, callbackfn, argumentsLength, memo) {
                    aFunction(callbackfn);
                    var O = toObject(that);
                    var self1 = IndexedObject(O);
                    var length = toLength(O.length);
                    var index = IS_RIGHT ? length - 1 : 0;
                    var i = IS_RIGHT ? -1 : 1;
                    if (argumentsLength < 2) while(true){
                        if (index in self1) {
                            memo = self1[index];
                            index += i;
                            break;
                        }
                        index += i;
                        if (IS_RIGHT ? index < 0 : length <= index) throw TypeError("Reduce of empty array with no initial value");
                    }
                    for(; IS_RIGHT ? index >= 0 : length > index; index += i)if (index in self1) memo = callbackfn(memo, self1[index], index, O);
                    return memo;
                };
            };
            module1.exports = {
                // `Array.prototype.reduce` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
                left: createMethod(false),
                // `Array.prototype.reduceRight` method
                // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
                right: createMethod(true)
            };
        /***/ },
        /***/ "d784": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            // TODO: Remove from `core-js@4` since it's moved to entry points
            __webpack_require__("ac1f");
            var redefine = __webpack_require__("6eeb");
            var fails = __webpack_require__("d039");
            var wellKnownSymbol = __webpack_require__("b622");
            var regexpExec = __webpack_require__("9263");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var SPECIES = wellKnownSymbol("species");
            var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
                // #replace needs built-in support for named groups.
                // #match works fine because it just return the exec results, even if it has
                // a "grops" property.
                var re = /./;
                re.exec = function() {
                    var result = [];
                    result.groups = {
                        a: "7"
                    };
                    return result;
                };
                return "".replace(re, "$<a>") !== "7";
            });
            // IE <= 11 replaces $0 with the whole match, as if it was $&
            // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
            var REPLACE_KEEPS_$0 = function() {
                return "a".replace(/./, "$0") === "$0";
            }();
            var REPLACE = wellKnownSymbol("replace");
            // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
            var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
                if (/./[REPLACE]) return /./[REPLACE]("a", "$0") === "";
                return false;
            }();
            // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
            // Weex JS has frozen built-in prototypes, so use try / catch wrapper
            var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
                var re = /(?:)/;
                var originalExec = re.exec;
                re.exec = function() {
                    return originalExec.apply(this, arguments);
                };
                var result = "ab".split(re);
                return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
            });
            module1.exports = function(KEY, length, exec, sham) {
                var SYMBOL = wellKnownSymbol(KEY);
                var DELEGATES_TO_SYMBOL = !fails(function() {
                    // String methods call symbol-named RegEp methods
                    var O = {};
                    O[SYMBOL] = function() {
                        return 7;
                    };
                    return ""[KEY](O) != 7;
                });
                var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                    // Symbol-named RegExp methods call .exec
                    var execCalled = false;
                    var re = /a/;
                    if (KEY === "split") {
                        // We can't use real regex here since it causes deoptimization
                        // and serious performance degradation in V8
                        // https://github.com/zloirock/core-js/issues/306
                        re = {};
                        // RegExp[@@split] doesn't call the regex's exec method, but first creates
                        // a new one. We need to return the patched regex when creating the new one.
                        re.constructor = {};
                        re.constructor[SPECIES] = function() {
                            return re;
                        };
                        re.flags = "";
                        re[SYMBOL] = /./[SYMBOL];
                    }
                    re.exec = function() {
                        execCalled = true;
                        return null;
                    };
                    re[SYMBOL]("");
                    return !execCalled;
                });
                if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                    var nativeRegExpMethod = /./[SYMBOL];
                    var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                        if (regexp.exec === regexpExec) {
                            if (DELEGATES_TO_SYMBOL && !forceStringMethod) // The native String method already delegates to @@method (this
                            // polyfilled function), leasing to infinite recursion.
                            // We avoid it by directly calling the native @@method method.
                            return {
                                done: true,
                                value: nativeRegExpMethod.call(regexp, str, arg2)
                            };
                            return {
                                done: true,
                                value: nativeMethod.call(str, regexp, arg2)
                            };
                        }
                        return {
                            done: false
                        };
                    }, {
                        REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
                        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    });
                    var stringMethod = methods[0];
                    var regexMethod = methods[1];
                    redefine(String.prototype, KEY, stringMethod);
                    redefine(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
                        return regexMethod.call(string, this, arg);
                    } : function(string) {
                        return regexMethod.call(string, this);
                    });
                }
                if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
            };
        /***/ },
        /***/ "d81d": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var $map = __webpack_require__("b727").map;
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
            // FF49- issue
            var USES_TO_LENGTH = arrayMethodUsesToLength("map");
            // `Array.prototype.map` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.map
            // with adding support of @@species
            $({
                target: "Array",
                proto: true,
                forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
            }, {
                map: function map(callbackfn /* , thisArg */ ) {
                    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                }
            });
        /***/ },
        /***/ "da84": /***/ function(module1, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function(global) {
                var check = function(it) {
                    return it && it.Math == Math && it;
                };
                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
                module1.exports = // eslint-disable-next-line no-undef
                check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || // eslint-disable-next-line no-new-func
                Function("return this")();
            /* WEBPACK VAR INJECTION */ }).call(this, __webpack_require__("c8ba"));
        /***/ },
        /***/ "dbb4": /***/ function(module1, exports, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var ownKeys = __webpack_require__("56ef");
            var toIndexedObject = __webpack_require__("fc6a");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var createProperty = __webpack_require__("8418");
            // `Object.getOwnPropertyDescriptors` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
            $({
                target: "Object",
                stat: true,
                sham: !DESCRIPTORS
            }, {
                getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                    var O = toIndexedObject(object);
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    var keys = ownKeys(O);
                    var result = {};
                    var index = 0;
                    var key, descriptor;
                    while(keys.length > index){
                        descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                        if (descriptor !== undefined) createProperty(result, key, descriptor);
                    }
                    return result;
                }
            });
        /***/ },
        /***/ "dbf1": /***/ function(module1, __webpack_exports__, __webpack_require__) {
            "use strict";
            /* WEBPACK VAR INJECTION */ (function(global) {
                __webpack_require__.d(__webpack_exports__, "a", function() {
                    return console;
                });
                function getConsole() {
                    if (typeof window !== "undefined") return window.console;
                    return global.console;
                }
                var console = getConsole();
            /* WEBPACK VAR INJECTION */ }).call(this, __webpack_require__("c8ba"));
        /***/ },
        /***/ "ddb0": /***/ function(module1, exports, __webpack_require__) {
            var global = __webpack_require__("da84");
            var DOMIterables = __webpack_require__("fdbc");
            var ArrayIteratorMethods = __webpack_require__("e260");
            var createNonEnumerableProperty = __webpack_require__("9112");
            var wellKnownSymbol = __webpack_require__("b622");
            var ITERATOR = wellKnownSymbol("iterator");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var ArrayValues = ArrayIteratorMethods.values;
            for(var COLLECTION_NAME in DOMIterables){
                var Collection = global[COLLECTION_NAME];
                var CollectionPrototype = Collection && Collection.prototype;
                if (CollectionPrototype) {
                    // some Chrome versions have non-configurable methods on DOMTokenList
                    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
                        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                    } catch (error) {
                        CollectionPrototype[ITERATOR] = ArrayValues;
                    }
                    if (!CollectionPrototype[TO_STRING_TAG]) createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                    if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){
                        // some Chrome versions have non-configurable methods on DOMTokenList
                        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                        } catch (error) {
                            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                        }
                    }
                }
            }
        /***/ },
        /***/ "df75": /***/ function(module1, exports, __webpack_require__) {
            var internalObjectKeys = __webpack_require__("ca84");
            var enumBugKeys = __webpack_require__("7839");
            // `Object.keys` method
            // https://tc39.github.io/ecma262/#sec-object.keys
            module1.exports = Object.keys || function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
            };
        /***/ },
        /***/ "e01a": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            // `Symbol.prototype.description` getter
            // https://tc39.github.io/ecma262/#sec-symbol.prototype.description
            var $ = __webpack_require__("23e7");
            var DESCRIPTORS = __webpack_require__("83ab");
            var global = __webpack_require__("da84");
            var has = __webpack_require__("5135");
            var isObject = __webpack_require__("861d");
            var defineProperty = __webpack_require__("9bf2").f;
            var copyConstructorProperties = __webpack_require__("e893");
            var NativeSymbol = global.Symbol;
            if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
            NativeSymbol().description !== undefined)) {
                var EmptyStringDescriptionStore = {};
                // wrap Symbol constructor for correct work with undefined description
                var SymbolWrapper = function Symbol1() {
                    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
                    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);
                    if (description === "") EmptyStringDescriptionStore[result] = true;
                    return result;
                };
                copyConstructorProperties(SymbolWrapper, NativeSymbol);
                var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
                symbolPrototype.constructor = SymbolWrapper;
                var symbolToString = symbolPrototype.toString;
                var native = String(NativeSymbol("test")) == "Symbol(test)";
                var regexp = /^Symbol\((.*)\)[^)]+$/;
                defineProperty(symbolPrototype, "description", {
                    configurable: true,
                    get: function description() {
                        var symbol = isObject(this) ? this.valueOf() : this;
                        var string = symbolToString.call(symbol);
                        if (has(EmptyStringDescriptionStore, symbol)) return "";
                        var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                        return desc === "" ? undefined : desc;
                    }
                });
                $({
                    global: true,
                    forced: true
                }, {
                    Symbol: SymbolWrapper
                });
            }
        /***/ },
        /***/ "e163": /***/ function(module1, exports, __webpack_require__) {
            var has = __webpack_require__("5135");
            var toObject = __webpack_require__("7b0b");
            var sharedKey = __webpack_require__("f772");
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
            var IE_PROTO = sharedKey("IE_PROTO");
            var ObjectPrototype = Object.prototype;
            // `Object.getPrototypeOf` method
            // https://tc39.github.io/ecma262/#sec-object.getprototypeof
            module1.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                O = toObject(O);
                if (has(O, IE_PROTO)) return O[IE_PROTO];
                if (typeof O.constructor == "function" && O instanceof O.constructor) return O.constructor.prototype;
                return O instanceof Object ? ObjectPrototype : null;
            };
        /***/ },
        /***/ "e177": /***/ function(module1, exports, __webpack_require__) {
            var fails = __webpack_require__("d039");
            module1.exports = !fails(function() {
                function F() {}
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
            });
        /***/ },
        /***/ "e260": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var toIndexedObject = __webpack_require__("fc6a");
            var addToUnscopables = __webpack_require__("44d2");
            var Iterators = __webpack_require__("3f8c");
            var InternalStateModule = __webpack_require__("69f3");
            var defineIterator = __webpack_require__("7dd0");
            var ARRAY_ITERATOR = "Array Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
            // `Array.prototype.entries` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.entries
            // `Array.prototype.keys` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.keys
            // `Array.prototype.values` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.values
            // `Array.prototype[@@iterator]` method
            // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
            // `CreateArrayIterator` internal method
            // https://tc39.github.io/ecma262/#sec-createarrayiterator
            module1.exports = defineIterator(Array, "Array", function(iterated, kind) {
                setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated),
                    index: 0,
                    kind: kind // kind
                });
            // `%ArrayIteratorPrototype%.next` method
            // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
            }, function() {
                var state = getInternalState(this);
                var target = state.target;
                var kind = state.kind;
                var index = state.index++;
                if (!target || index >= target.length) {
                    state.target = undefined;
                    return {
                        value: undefined,
                        done: true
                    };
                }
                if (kind == "keys") return {
                    value: index,
                    done: false
                };
                if (kind == "values") return {
                    value: target[index],
                    done: false
                };
                return {
                    value: [
                        index,
                        target[index]
                    ],
                    done: false
                };
            }, "values");
            // argumentsList[@@iterator] is %ArrayProto_values%
            // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
            // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
            Iterators.Arguments = Iterators.Array;
            // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
        /***/ },
        /***/ "e439": /***/ function(module1, exports, __webpack_require__) {
            var $ = __webpack_require__("23e7");
            var fails = __webpack_require__("d039");
            var toIndexedObject = __webpack_require__("fc6a");
            var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
            var DESCRIPTORS = __webpack_require__("83ab");
            var FAILS_ON_PRIMITIVES = fails(function() {
                nativeGetOwnPropertyDescriptor(1);
            });
            var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
            // `Object.getOwnPropertyDescriptor` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
            $({
                target: "Object",
                stat: true,
                forced: FORCED,
                sham: !DESCRIPTORS
            }, {
                getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
                    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
                }
            });
        /***/ },
        /***/ "e538": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            exports.f = wellKnownSymbol;
        /***/ },
        /***/ "e893": /***/ function(module1, exports, __webpack_require__) {
            var has = __webpack_require__("5135");
            var ownKeys = __webpack_require__("56ef");
            var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
            var definePropertyModule = __webpack_require__("9bf2");
            module1.exports = function(target, source) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
            };
        /***/ },
        /***/ "e8b5": /***/ function(module1, exports, __webpack_require__) {
            var classof = __webpack_require__("c6b6");
            // `IsArray` abstract operation
            // https://tc39.github.io/ecma262/#sec-isarray
            module1.exports = Array.isArray || function isArray(arg) {
                return classof(arg) == "Array";
            };
        /***/ },
        /***/ "e95a": /***/ function(module1, exports, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__("b622");
            var Iterators = __webpack_require__("3f8c");
            var ITERATOR = wellKnownSymbol("iterator");
            var ArrayPrototype = Array.prototype;
            // check on default Array iterator
            module1.exports = function(it) {
                return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
            };
        /***/ },
        /***/ "f5df": /***/ function(module1, exports, __webpack_require__) {
            var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
            var classofRaw = __webpack_require__("c6b6");
            var wellKnownSymbol = __webpack_require__("b622");
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            // ES3 wrong here
            var CORRECT_ARGUMENTS = classofRaw(function() {
                return arguments;
            }()) == "Arguments";
            // fallback for IE11 Script Access Denied error
            var tryGet = function(it, key) {
                try {
                    return it[key];
                } catch (error) {}
            };
            // getting tag from ES6+ `Object.prototype.toString`
            module1.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                var O, tag, result;
                return it === undefined ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
            };
        /***/ },
        /***/ "f772": /***/ function(module1, exports, __webpack_require__) {
            var shared = __webpack_require__("5692");
            var uid = __webpack_require__("90e3");
            var keys = shared("keys");
            module1.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
            };
        /***/ },
        /***/ "fb15": /***/ function(module1, __webpack_exports__, __webpack_require__) {
            "use strict";
            // ESM COMPAT FLAG
            __webpack_require__.r(__webpack_exports__);
            // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
            // This file is imported into lib/wc client bundles.
            if (typeof window !== "undefined") {
                var currentScript = window.document.currentScript;
                var getCurrentScript = __webpack_require__("8875");
                currentScript = getCurrentScript();
                // for backward compatibility, because previously we directly included the polyfill
                if (!("currentScript" in document)) Object.defineProperty(document, "currentScript", {
                    get: getCurrentScript
                });
                var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
                if (src) __webpack_require__.p = src[1] // eslint-disable-line
                ;
            }
            // Indicate to webpack that this file can be concatenated
            /* harmony default export */ var setPublicPath = null;
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
            var es_array_concat = __webpack_require__("99af");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
            var es_array_filter = __webpack_require__("4de4");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.for-each.js
            var es_array_for_each = __webpack_require__("4160");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
            var es_array_index_of = __webpack_require__("c975");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
            var es_array_map = __webpack_require__("d81d");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
            var es_array_splice = __webpack_require__("a434");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
            var web_dom_collections_for_each = __webpack_require__("159b");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
            var es_symbol = __webpack_require__("a4d3");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js
            var es_object_get_own_property_descriptor = __webpack_require__("e439");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js
            var es_object_get_own_property_descriptors = __webpack_require__("dbb4");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
            var es_object_keys = __webpack_require__("b64b");
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
            function _defineProperty(obj, key, value) {
                if (key in obj) Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
                else obj[key] = value;
                return obj;
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly) symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    });
                    keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread2(target) {
                for(var i = 1; i < arguments.length; i++){
                    var source = arguments[i] != null ? arguments[i] : {};
                    if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
                        _defineProperty(target, key, source[key]);
                    });
                    else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    else ownKeys(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
                return target;
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
            function _arrayWithHoles(arr) {
                if (Array.isArray(arr)) return arr;
            }
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
            var es_symbol_description = __webpack_require__("e01a");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
            var es_symbol_iterator = __webpack_require__("d28b");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
            var es_array_iterator = __webpack_require__("e260");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
            var es_object_to_string = __webpack_require__("d3b7");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
            var es_string_iterator = __webpack_require__("3ca3");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
            var web_dom_collections_iterator = __webpack_require__("ddb0");
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
            function _iterableToArrayLimit(arr, i) {
                if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                        _arr.push(_s.value);
                        if (i && _arr.length === i) break;
                    }
                } catch (err) {
                    _d = true;
                    _e = err;
                } finally{
                    try {
                        if (!_n && _i["return"] != null) _i["return"]();
                    } finally{
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
            var es_array_from = __webpack_require__("a630");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
            var es_array_slice = __webpack_require__("fb6a");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
            var es_function_name = __webpack_require__("b0c0");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
            var es_regexp_to_string = __webpack_require__("25f0");
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
                return arr2;
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
            function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
            function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js
            function _slicedToArray(arr, i) {
                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
            function _arrayWithoutHoles(arr) {
                if (Array.isArray(arr)) return _arrayLikeToArray(arr);
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
            function _iterableToArray(iter) {
                if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
            function _nonIterableSpread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
            function _toConsumableArray(arr) {
                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
            }
            // EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
            var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
            // CONCATENATED MODULE: ./src/util/htmlHelper.js
            function removeNode(node) {
                if (node.parentElement !== null) node.parentElement.removeChild(node);
            }
            function insertNodeAt(fatherNode, node, position) {
                var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
                fatherNode.insertBefore(node, refNode);
            }
            // EXTERNAL MODULE: ./src/util/console.js
            var console = __webpack_require__("dbf1");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
            var es_array_reduce = __webpack_require__("13d5");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.entries.js
            var es_object_entries = __webpack_require__("4fad");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
            var es_regexp_exec = __webpack_require__("ac1f");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
            var es_string_replace = __webpack_require__("5319");
            // CONCATENATED MODULE: ./src/util/string.js
            function cached(fn) {
                var cache = Object.create(null);
                return function cachedFn(str) {
                    var hit = cache[str];
                    return hit || (cache[str] = fn(str));
                };
            }
            var regex = /-(\w)/g;
            var camelize = cached(function(str) {
                return str.replace(regex, function(_, c) {
                    return c.toUpperCase();
                });
            });
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.flat-map.js
            var es_array_flat_map = __webpack_require__("5db7");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat-map.js
            var es_array_unscopables_flat_map = __webpack_require__("73d9");
            // CONCATENATED MODULE: ./src/core/sortableEvents.js
            var manageAndEmit = [
                "Start",
                "Add",
                "Remove",
                "Update",
                "End"
            ];
            var emit = [
                "Choose",
                "Unchoose",
                "Sort",
                "Filter",
                "Clone"
            ];
            var manage = [
                "Move"
            ];
            var eventHandlerNames = [
                manage,
                manageAndEmit,
                emit
            ].flatMap(function(events) {
                return events;
            }).map(function(evt) {
                return "on".concat(evt);
            });
            var events = {
                manage: manage,
                manageAndEmit: manageAndEmit,
                emit: emit
            };
            function isReadOnly(eventName) {
                return eventHandlerNames.indexOf(eventName) !== -1;
            }
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
            var es_array_includes = __webpack_require__("caad");
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.starts-with.js
            var es_string_starts_with = __webpack_require__("2ca0");
            // CONCATENATED MODULE: ./src/util/tags.js
            var tags = [
                "a",
                "abbr",
                "address",
                "area",
                "article",
                "aside",
                "audio",
                "b",
                "base",
                "bdi",
                "bdo",
                "blockquote",
                "body",
                "br",
                "button",
                "canvas",
                "caption",
                "cite",
                "code",
                "col",
                "colgroup",
                "data",
                "datalist",
                "dd",
                "del",
                "details",
                "dfn",
                "dialog",
                "div",
                "dl",
                "dt",
                "em",
                "embed",
                "fieldset",
                "figcaption",
                "figure",
                "footer",
                "form",
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "head",
                "header",
                "hgroup",
                "hr",
                "html",
                "i",
                "iframe",
                "img",
                "input",
                "ins",
                "kbd",
                "label",
                "legend",
                "li",
                "link",
                "main",
                "map",
                "mark",
                "math",
                "menu",
                "menuitem",
                "meta",
                "meter",
                "nav",
                "noscript",
                "object",
                "ol",
                "optgroup",
                "option",
                "output",
                "p",
                "param",
                "picture",
                "pre",
                "progress",
                "q",
                "rb",
                "rp",
                "rt",
                "rtc",
                "ruby",
                "s",
                "samp",
                "script",
                "section",
                "select",
                "slot",
                "small",
                "source",
                "span",
                "strong",
                "style",
                "sub",
                "summary",
                "sup",
                "svg",
                "table",
                "tbody",
                "td",
                "template",
                "textarea",
                "tfoot",
                "th",
                "thead",
                "time",
                "title",
                "tr",
                "track",
                "u",
                "ul",
                "var",
                "video",
                "wbr"
            ];
            function isHtmlTag(name) {
                return tags.includes(name);
            }
            function isTransition(name) {
                return [
                    "transition-group",
                    "TransitionGroup"
                ].includes(name);
            }
            function isHtmlAttribute(value) {
                return [
                    "id",
                    "class",
                    "role",
                    "style"
                ].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
            }
            // CONCATENATED MODULE: ./src/core/componentBuilderHelper.js
            function project(entries) {
                return entries.reduce(function(res, _ref) {
                    var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                    res[key] = value;
                    return res;
                }, {});
            }
            function getComponentAttributes(_ref3) {
                var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
                var attributes = project(Object.entries($attrs).filter(function(_ref4) {
                    var _ref5 = _slicedToArray(_ref4, 2), key = _ref5[0], _ = _ref5[1];
                    return isHtmlAttribute(key);
                }));
                return _objectSpread2(_objectSpread2({}, attributes), componentData);
            }
            function createSortableOption(_ref6) {
                var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
                var options = project(getValidSortableEntries($attrs));
                Object.entries(callBackBuilder).forEach(function(_ref7) {
                    var _ref8 = _slicedToArray(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
                    events[eventType].forEach(function(event) {
                        options["on".concat(event)] = eventBuilder(event);
                    });
                });
                var draggable = "[data-draggable]".concat(options.draggable || "");
                return _objectSpread2(_objectSpread2({}, options), {}, {
                    draggable: draggable
                });
            }
            function getValidSortableEntries(value) {
                return Object.entries(value).filter(function(_ref9) {
                    var _ref10 = _slicedToArray(_ref9, 2), key = _ref10[0], _ = _ref10[1];
                    return !isHtmlAttribute(key);
                }).map(function(_ref11) {
                    var _ref12 = _slicedToArray(_ref11, 2), key = _ref12[0], value = _ref12[1];
                    return [
                        camelize(key),
                        value
                    ];
                }).filter(function(_ref13) {
                    var _ref14 = _slicedToArray(_ref13, 2), key = _ref14[0], _ = _ref14[1];
                    return !isReadOnly(key);
                });
            }
            // EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
            var es_array_find_index = __webpack_require__("c740");
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
            function _defineProperties(target, props) {
                for(var i = 0; i < props.length; i++){
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            // CONCATENATED MODULE: ./src/core/componentStructure.js
            var getHtmlElementFromNode = function getHtmlElementFromNode(_ref) {
                var el = _ref.el;
                return el;
            };
            var addContext = function addContext(domElement, context) {
                return domElement.__draggable_context = context;
            };
            var getContext = function getContext(domElement) {
                return domElement.__draggable_context;
            };
            var componentStructure_ComponentStructure = /*#__PURE__*/ function() {
                function ComponentStructure(_ref2) {
                    var _ref2$nodes = _ref2.nodes, header = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer = _ref2$nodes.footer, root = _ref2.root, realList = _ref2.realList;
                    _classCallCheck(this, ComponentStructure);
                    this.defaultNodes = defaultNodes;
                    this.children = [].concat(_toConsumableArray(header), _toConsumableArray(defaultNodes), _toConsumableArray(footer));
                    this.externalComponent = root.externalComponent;
                    this.rootTransition = root.transition;
                    this.tag = root.tag;
                    this.realList = realList;
                }
                _createClass(ComponentStructure, [
                    {
                        key: "render",
                        value: function render(h, attributes) {
                            var tag = this.tag, children = this.children, _isRootComponent = this._isRootComponent;
                            var option = !_isRootComponent ? children : {
                                default: function _default() {
                                    return children;
                                }
                            };
                            return h(tag, attributes, option);
                        }
                    },
                    {
                        key: "updated",
                        value: function updated() {
                            var defaultNodes = this.defaultNodes, realList = this.realList;
                            defaultNodes.forEach(function(node, index) {
                                addContext(getHtmlElementFromNode(node), {
                                    element: realList[index],
                                    index: index
                                });
                            });
                        }
                    },
                    {
                        key: "getUnderlyingVm",
                        value: function getUnderlyingVm(domElement) {
                            return getContext(domElement);
                        }
                    },
                    {
                        key: "getVmIndexFromDomIndex",
                        value: function getVmIndexFromDomIndex(domIndex, element) {
                            var defaultNodes = this.defaultNodes;
                            var length = defaultNodes.length;
                            var domChildren = element.children;
                            var domElement = domChildren.item(domIndex);
                            if (domElement === null) return length;
                            var context = getContext(domElement);
                            if (context) return context.index;
                            if (length === 0) return 0;
                            var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
                            var indexFirstDomListElement = _toConsumableArray(domChildren).findIndex(function(element) {
                                return element === firstDomListElement;
                            });
                            return domIndex < indexFirstDomListElement ? 0 : length;
                        }
                    },
                    {
                        key: "_isRootComponent",
                        get: function get() {
                            return this.externalComponent || this.rootTransition;
                        }
                    }
                ]);
                return ComponentStructure;
            }();
            // EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
            var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
            // CONCATENATED MODULE: ./src/core/renderHelper.js
            function getSlot(slots, key) {
                var slotValue = slots[key];
                return slotValue ? slotValue() : [];
            }
            function computeNodes(_ref) {
                var $slots = _ref.$slots, realList = _ref.realList, getKey = _ref.getKey;
                var normalizedList = realList || [];
                var _map = [
                    "header",
                    "footer"
                ].map(function(name) {
                    return getSlot($slots, name);
                }), _map2 = _slicedToArray(_map, 2), header = _map2[0], footer = _map2[1];
                var item = $slots.item;
                if (!item) throw new Error("draggable element must have an item slot");
                var defaultNodes = normalizedList.flatMap(function(element, index) {
                    return item({
                        element: element,
                        index: index
                    }).map(function(node) {
                        node.key = getKey(element);
                        node.props = _objectSpread2(_objectSpread2({}, node.props || {}), {}, {
                            "data-draggable": true
                        });
                        return node;
                    });
                });
                if (defaultNodes.length !== normalizedList.length) throw new Error("Item slot must have only one child");
                return {
                    header: header,
                    footer: footer,
                    default: defaultNodes
                };
            }
            function getRootInformation(tag) {
                var transition = isTransition(tag);
                var externalComponent = !isHtmlTag(tag) && !transition;
                return {
                    transition: transition,
                    externalComponent: externalComponent,
                    tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
                };
            }
            function computeComponentStructure(_ref2) {
                var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey = _ref2.getKey;
                var nodes = computeNodes({
                    $slots: $slots,
                    realList: realList,
                    getKey: getKey
                });
                var root = getRootInformation(tag);
                return new componentStructure_ComponentStructure({
                    nodes: nodes,
                    root: root,
                    realList: realList
                });
            }
            // CONCATENATED MODULE: ./src/vuedraggable.js
            function _emit(evtName, evtData) {
                var _this = this;
                Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                    return _this.$emit(evtName.toLowerCase(), evtData);
                });
            }
            function _manage(evtName) {
                var _this2 = this;
                return function(evtData, originalElement) {
                    if (_this2.realList !== null) return _this2["onDrag".concat(evtName)](evtData, originalElement);
                };
            }
            function _manageAndEmit(evtName) {
                var _this3 = this;
                var delegateCallBack = _manage.call(this, evtName);
                return function(evtData, originalElement) {
                    delegateCallBack.call(_this3, evtData, originalElement);
                    _emit.call(_this3, evtName, evtData);
                };
            }
            var draggingElement = null;
            var props = {
                list: {
                    type: Array,
                    required: false,
                    default: null
                },
                modelValue: {
                    type: Array,
                    required: false,
                    default: null
                },
                itemKey: {
                    type: [
                        String,
                        Function
                    ],
                    required: true
                },
                clone: {
                    type: Function,
                    default: function _default(original) {
                        return original;
                    }
                },
                tag: {
                    type: String,
                    default: "div"
                },
                move: {
                    type: Function,
                    default: null
                },
                componentData: {
                    type: Object,
                    required: false,
                    default: null
                }
            };
            var emits = [
                "update:modelValue",
                "change"
            ].concat(_toConsumableArray([].concat(_toConsumableArray(events.manageAndEmit), _toConsumableArray(events.emit)).map(function(evt) {
                return evt.toLowerCase();
            })));
            var draggableComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
                name: "draggable",
                inheritAttrs: false,
                props: props,
                emits: emits,
                data: function data() {
                    return {
                        error: false
                    };
                },
                render: function render() {
                    try {
                        this.error = false;
                        var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey = this.getKey;
                        var componentStructure = computeComponentStructure({
                            $slots: $slots,
                            tag: tag,
                            realList: realList,
                            getKey: getKey
                        });
                        this.componentStructure = componentStructure;
                        var attributes = getComponentAttributes({
                            $attrs: $attrs,
                            componentData: componentData
                        });
                        return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
                    } catch (err) {
                        this.error = true;
                        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", {
                            style: {
                                color: "red"
                            }
                        }, err.stack);
                    }
                },
                created: function created() {
                    if (this.list !== null && this.modelValue !== null) console["a" /* console */ ].error("modelValue and list props are mutually exclusive! Please set one or another.");
                },
                mounted: function mounted() {
                    var _this4 = this;
                    if (this.error) return;
                    var $attrs = this.$attrs, $el = this.$el, componentStructure = this.componentStructure;
                    componentStructure.updated();
                    var sortableOptions = createSortableOption({
                        $attrs: $attrs,
                        callBackBuilder: {
                            manageAndEmit: function manageAndEmit(event) {
                                return _manageAndEmit.call(_this4, event);
                            },
                            emit: function emit(event) {
                                return _emit.bind(_this4, event);
                            },
                            manage: function manage(event) {
                                return _manage.call(_this4, event);
                            }
                        }
                    });
                    var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
                    this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
                    this.targetDomElement = targetDomElement;
                    targetDomElement.__draggable_component__ = this;
                },
                updated: function updated() {
                    this.componentStructure.updated();
                },
                beforeUnmount: function beforeUnmount() {
                    if (this._sortable !== undefined) this._sortable.destroy();
                },
                computed: {
                    realList: function realList() {
                        var list = this.list;
                        return list ? list : this.modelValue;
                    },
                    getKey: function getKey() {
                        var itemKey = this.itemKey;
                        if (typeof itemKey === "function") return itemKey;
                        return function(element) {
                            return element[itemKey];
                        };
                    }
                },
                watch: {
                    $attrs: {
                        handler: function handler(newOptionValue) {
                            var _sortable = this._sortable;
                            if (!_sortable) return;
                            getValidSortableEntries(newOptionValue).forEach(function(_ref) {
                                var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                                _sortable.option(key, value);
                            });
                        },
                        deep: true
                    }
                },
                methods: {
                    getUnderlyingVm: function getUnderlyingVm(domElement) {
                        return this.componentStructure.getUnderlyingVm(domElement) || null;
                    },
                    getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
                        //TODO check case where you need to see component children
                        return htmElement.__draggable_component__;
                    },
                    emitChanges: function emitChanges(evt) {
                        var _this5 = this;
                        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                            return _this5.$emit("change", evt);
                        });
                    },
                    alterList: function alterList(onList) {
                        if (this.list) {
                            onList(this.list);
                            return;
                        }
                        var newList = _toConsumableArray(this.modelValue);
                        onList(newList);
                        this.$emit("update:modelValue", newList);
                    },
                    spliceList: function spliceList() {
                        var _arguments = arguments;
                        var spliceList = function spliceList(list) {
                            return list.splice.apply(list, _toConsumableArray(_arguments));
                        };
                        this.alterList(spliceList);
                    },
                    updatePosition: function updatePosition(oldIndex, newIndex) {
                        var updatePosition = function updatePosition(list) {
                            return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
                        };
                        this.alterList(updatePosition);
                    },
                    getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
                        var to = _ref3.to, related = _ref3.related;
                        var component = this.getUnderlyingPotencialDraggableComponent(to);
                        if (!component) return {
                            component: component
                        };
                        var list = component.realList;
                        var context = {
                            list: list,
                            component: component
                        };
                        if (to !== related && list) {
                            var destination = component.getUnderlyingVm(related) || {};
                            return _objectSpread2(_objectSpread2({}, destination), context);
                        }
                        return context;
                    },
                    getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex) {
                        return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
                    },
                    onDragStart: function onDragStart(evt) {
                        this.context = this.getUnderlyingVm(evt.item);
                        evt.item._underlying_vm_ = this.clone(this.context.element);
                        draggingElement = evt.item;
                    },
                    onDragAdd: function onDragAdd(evt) {
                        var element = evt.item._underlying_vm_;
                        if (element === undefined) return;
                        removeNode(evt.item);
                        var newIndex = this.getVmIndexFromDomIndex(evt.newIndex);
                        this.spliceList(newIndex, 0, element);
                        var added = {
                            element: element,
                            newIndex: newIndex
                        };
                        this.emitChanges({
                            added: added
                        });
                    },
                    onDragRemove: function onDragRemove(evt) {
                        insertNodeAt(this.$el, evt.item, evt.oldIndex);
                        if (evt.pullMode === "clone") {
                            removeNode(evt.clone);
                            return;
                        }
                        var _this$context = this.context, oldIndex = _this$context.index, element = _this$context.element;
                        this.spliceList(oldIndex, 1);
                        var removed = {
                            element: element,
                            oldIndex: oldIndex
                        };
                        this.emitChanges({
                            removed: removed
                        });
                    },
                    onDragUpdate: function onDragUpdate(evt) {
                        removeNode(evt.item);
                        insertNodeAt(evt.from, evt.item, evt.oldIndex);
                        var oldIndex = this.context.index;
                        var newIndex = this.getVmIndexFromDomIndex(evt.newIndex);
                        this.updatePosition(oldIndex, newIndex);
                        var moved = {
                            element: this.context.element,
                            oldIndex: oldIndex,
                            newIndex: newIndex
                        };
                        this.emitChanges({
                            moved: moved
                        });
                    },
                    computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
                        if (!relatedContext.element) return 0;
                        var domChildren = _toConsumableArray(evt.to.children).filter(function(el) {
                            return el.style["display"] !== "none";
                        });
                        var currentDomIndex = domChildren.indexOf(evt.related);
                        var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
                        var draggedInList = domChildren.indexOf(draggingElement) !== -1;
                        return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
                    },
                    onDragMove: function onDragMove(evt, originalEvent) {
                        var move = this.move, realList = this.realList;
                        if (!move || !realList) return true;
                        var relatedContext = this.getRelatedContextFromMoveEvent(evt);
                        var futureIndex = this.computeFutureIndex(relatedContext, evt);
                        var draggedContext = _objectSpread2(_objectSpread2({}, this.context), {}, {
                            futureIndex: futureIndex
                        });
                        var sendEvent = _objectSpread2(_objectSpread2({}, evt), {}, {
                            relatedContext: relatedContext,
                            draggedContext: draggedContext
                        });
                        return move(sendEvent, originalEvent);
                    },
                    onDragEnd: function onDragEnd() {
                        draggingElement = null;
                    }
                }
            });
            /* harmony default export */ var vuedraggable = draggableComponent;
            // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js
            /* harmony default export */ var entry_lib = __webpack_exports__["default"] = vuedraggable;
        /***/ },
        /***/ "fb6a": /***/ function(module1, exports, __webpack_require__) {
            "use strict";
            var $ = __webpack_require__("23e7");
            var isObject = __webpack_require__("861d");
            var isArray = __webpack_require__("e8b5");
            var toAbsoluteIndex = __webpack_require__("23cb");
            var toLength = __webpack_require__("50c4");
            var toIndexedObject = __webpack_require__("fc6a");
            var createProperty = __webpack_require__("8418");
            var wellKnownSymbol = __webpack_require__("b622");
            var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
            var arrayMethodUsesToLength = __webpack_require__("ae40");
            var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
            var USES_TO_LENGTH = arrayMethodUsesToLength("slice", {
                ACCESSORS: true,
                0: 0,
                1: 2
            });
            var SPECIES = wellKnownSymbol("species");
            var nativeSlice = [].slice;
            var max = Math.max;
            // `Array.prototype.slice` method
            // https://tc39.github.io/ecma262/#sec-array.prototype.slice
            // fallback for not array-like ES3 strings and DOM objects
            $({
                target: "Array",
                proto: true,
                forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
            }, {
                slice: function slice(start, end) {
                    var O = toIndexedObject(this);
                    var length = toLength(O.length);
                    var k = toAbsoluteIndex(start, length);
                    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
                    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
                    var Constructor, result, n;
                    if (isArray(O)) {
                        Constructor = O.constructor;
                        // cross-realm fallback
                        if (typeof Constructor == "function" && (Constructor === Array || isArray(Constructor.prototype))) Constructor = undefined;
                        else if (isObject(Constructor)) {
                            Constructor = Constructor[SPECIES];
                            if (Constructor === null) Constructor = undefined;
                        }
                        if (Constructor === Array || Constructor === undefined) return nativeSlice.call(O, k, fin);
                    }
                    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
                    for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);
                    result.length = n;
                    return result;
                }
            });
        /***/ },
        /***/ "fc6a": /***/ function(module1, exports, __webpack_require__) {
            // toObject with fallback for non-array-like ES3 strings
            var IndexedObject = __webpack_require__("44ad");
            var requireObjectCoercible = __webpack_require__("1d80");
            module1.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
            };
        /***/ },
        /***/ "fdbc": /***/ function(module1, exports) {
            // iterable DOM collections
            // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
            module1.exports = {
                CSSRuleList: 0,
                CSSStyleDeclaration: 0,
                CSSValueList: 0,
                ClientRectList: 0,
                DOMRectList: 0,
                DOMStringList: 0,
                DOMTokenList: 1,
                DataTransferItemList: 0,
                FileList: 0,
                HTMLAllCollection: 0,
                HTMLCollection: 0,
                HTMLFormElement: 0,
                HTMLSelectElement: 0,
                MediaList: 0,
                MimeTypeArray: 0,
                NamedNodeMap: 0,
                NodeList: 1,
                PaintRequestList: 0,
                Plugin: 0,
                PluginArray: 0,
                SVGLengthList: 0,
                SVGNumberList: 0,
                SVGPathSegList: 0,
                SVGPointList: 0,
                SVGStringList: 0,
                SVGTransformList: 0,
                SourceBufferList: 0,
                StyleSheetList: 0,
                TextTrackCueList: 0,
                TextTrackList: 0,
                TouchList: 0
            };
        /***/ },
        /***/ "fdbf": /***/ function(module1, exports, __webpack_require__) {
            var NATIVE_SYMBOL = __webpack_require__("4930");
            module1.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
        /***/ }
    })["default"];
});

},{"994aba414f6e11f":"ff77s","f2b29fe3c2c19cbd":"fCpem"}],"fCpem":[function(require,module,exports) {
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MultiDrag", ()=>MultiDragPlugin);
parcelHelpers.export(exports, "Sortable", ()=>Sortable);
parcelHelpers.export(exports, "Swap", ()=>SwapPlugin);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function(obj) {
        return typeof obj;
    };
    else _typeof = function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var version = "1.14.0";
function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) return !!/*@__PURE__*/ navigator.userAgent.match(pattern);
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
    capture: false,
    passive: false
};
function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches(/**HTMLElement*/ el, /**String*/ selector) {
    if (!selector) return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) try {
        if (el.matches) return el.matches(selector);
        else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    } catch (_) {
        return false;
    }
    return false;
}
function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(/**HTMLElement*/ el, /**String*/ selector, /**HTMLElement*/ ctx, includeCTX) {
    if (el) {
        ctx = ctx || document;
        do {
            if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) return el;
            if (el === ctx) break;
        /* jshint boss:true */ }while (el = getParentOrHost(el));
    }
    return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
    if (el && name) {
        if (el.classList) el.classList[state ? "add" : "remove"](name);
        else {
            var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
            el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
        }
    }
}
function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
        if (val === void 0) {
            if (document.defaultView && document.defaultView.getComputedStyle) val = document.defaultView.getComputedStyle(el, "");
            else if (el.currentStyle) val = el.currentStyle;
            return prop === void 0 ? val : val[prop];
        } else {
            if (!(prop in style) && prop.indexOf("webkit") === -1) prop = "-webkit-" + prop;
            style[prop] = val + (typeof val === "string" ? "" : "px");
        }
    }
}
function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") appliedTransforms = el;
    else do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") appliedTransforms = transform + " " + appliedTransforms;
    /* jshint boss:true */ }while (!selfOnly && (el = el.parentNode));
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    /*jshint -W056 */ return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
    if (ctx) {
        var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
        if (iterator) for(; i < n; i++)iterator(list[i], i);
        return list;
    }
    return [];
}
function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) return scrollingElement;
    else return document.documentElement;
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */ function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
        elRect = el.getBoundingClientRect();
        top = elRect.top;
        left = elRect.left;
        bottom = elRect.bottom;
        right = elRect.right;
        height = elRect.height;
        width = elRect.width;
    } else {
        top = 0;
        left = 0;
        bottom = window.innerHeight;
        right = window.innerWidth;
        height = window.innerHeight;
        width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
        // Adjust for translate()
        container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
        // Not needed on <= IE11
        if (!IE11OrLess) {
            do if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
                var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container
                top -= containerRect.top + parseInt(css(container, "border-top-width"));
                left -= containerRect.left + parseInt(css(container, "border-left-width"));
                bottom = top + elRect.height;
                right = left + elRect.width;
                break;
            }
            while (container = container.parentNode);
        }
    }
    if (undoScale && el !== window) {
        // Adjust for scale()
        var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
        if (elMatrix) {
            top /= scaleY;
            left /= scaleX;
            width /= scaleX;
            height /= scaleY;
            bottom = top + height;
            right = left + width;
        }
    }
    return {
        top: top,
        left: left,
        bottom: bottom,
        right: right,
        width: width,
        height: height
    };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */ function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    /* jshint boss:true */ while(parent){
        var parentSideVal = getRect(parent)[parentSide], visible = void 0;
        if (parentSide === "top" || parentSide === "left") visible = elSideVal >= parentSideVal;
        else visible = elSideVal <= parentSideVal;
        if (!visible) return parent;
        if (parent === getWindowScrollingElement()) break;
        parent = getParentAutoScrollElement(parent, false);
    }
    return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */ function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el.children;
    while(i < children.length){
        if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
            if (currentChild === childNum) return children[i];
            currentChild++;
        }
        i++;
    }
    return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */ function lastChild(el, selector) {
    var last = el.lastElementChild;
    while(last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector)))last = last.previousElementSibling;
    return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */ function index(el, selector) {
    var index = 0;
    if (!el || !el.parentNode) return -1;
    /* jshint boss:true */ while(el = el.previousElementSibling)if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) index++;
    return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */ function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) do {
        var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
    }while (el !== winScroller && (el = el.parentNode));
    return [
        offsetLeft,
        offsetTop
    ];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */ function indexOfObject(arr, obj) {
    for(var i in arr){
        if (!arr.hasOwnProperty(i)) continue;
        for(var key in obj){
            if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
        }
    }
    return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
            if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
            if (gotSelf || includeSelf) return elem;
            gotSelf = true;
        }
    }
    while (elem = elem.parentNode);
    return getWindowScrollingElement();
}
function extend(dst, src) {
    if (dst && src) {
        for(var key in src)if (src.hasOwnProperty(key)) dst[key] = src[key];
    }
    return dst;
}
function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
    return function() {
        if (!_throttleTimeout) {
            var args = arguments, _this = this;
            if (args.length === 1) callback.call(_this, args[0]);
            else callback.apply(_this, args);
            _throttleTimeout = setTimeout(function() {
                _throttleTimeout = void 0;
            }, ms);
        }
    };
}
function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
}
function clone(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) return Polymer.dom(el).cloneNode(true);
    else if ($) return $(el).clone(true)[0];
    else return el.cloneNode(true);
}
function setRect(el, rect) {
    css(el, "position", "absolute");
    css(el, "top", rect.top);
    css(el, "left", rect.left);
    css(el, "width", rect.width);
    css(el, "height", rect.height);
}
function unsetRect(el) {
    css(el, "position", "");
    css(el, "top", "");
    css(el, "left", "");
    css(el, "width", "");
    css(el, "height", "");
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
        captureAnimationState: function captureAnimationState() {
            animationStates = [];
            if (!this.options.animation) return;
            var children = [].slice.call(this.el.children);
            children.forEach(function(child) {
                if (css(child, "display") === "none" || child === Sortable.ghost) return;
                animationStates.push({
                    target: child,
                    rect: getRect(child)
                });
                var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation
                if (child.thisAnimationDuration) {
                    var childMatrix = matrix(child, true);
                    if (childMatrix) {
                        fromRect.top -= childMatrix.f;
                        fromRect.left -= childMatrix.e;
                    }
                }
                child.fromRect = fromRect;
            });
        },
        addAnimationState: function addAnimationState(state) {
            animationStates.push(state);
        },
        removeAnimationState: function removeAnimationState(target) {
            animationStates.splice(indexOfObject(animationStates, {
                target: target
            }), 1);
        },
        animateAll: function animateAll(callback) {
            var _this = this;
            if (!this.options.animation) {
                clearTimeout(animationCallbackId);
                if (typeof callback === "function") callback();
                return;
            }
            var animating = false, animationTime = 0;
            animationStates.forEach(function(state) {
                var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
                if (targetMatrix) {
                    // Compensate for current animation
                    toRect.top -= targetMatrix.f;
                    toRect.left -= targetMatrix.e;
                }
                target.toRect = toRect;
                if (target.thisAnimationDuration) // Could also check if animatingRect is between fromRect and toRect
                {
                    if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
                    (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) // If returning to same place as started from animation and on same axis
                    time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
                } // if fromRect != toRect: animate
                if (!isRectEqual(toRect, fromRect)) {
                    target.prevFromRect = fromRect;
                    target.prevToRect = toRect;
                    if (!time) time = _this.options.animation;
                    _this.animate(target, animatingRect, toRect, time);
                }
                if (time) {
                    animating = true;
                    animationTime = Math.max(animationTime, time);
                    clearTimeout(target.animationResetTimer);
                    target.animationResetTimer = setTimeout(function() {
                        target.animationTime = 0;
                        target.prevFromRect = null;
                        target.fromRect = null;
                        target.prevToRect = null;
                        target.thisAnimationDuration = null;
                    }, time);
                    target.thisAnimationDuration = time;
                }
            });
            clearTimeout(animationCallbackId);
            if (!animating) {
                if (typeof callback === "function") callback();
            } else animationCallbackId = setTimeout(function() {
                if (typeof callback === "function") callback();
            }, animationTime);
            animationStates = [];
        },
        animate: function animate(target, currentRect, toRect, duration) {
            if (duration) {
                css(target, "transition", "");
                css(target, "transform", "");
                var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
                target.animatingX = !!translateX;
                target.animatingY = !!translateY;
                css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
                this.forRepaintDummy = repaint(target); // repaint
                css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
                css(target, "transform", "translate3d(0,0,0)");
                typeof target.animated === "number" && clearTimeout(target.animated);
                target.animated = setTimeout(function() {
                    css(target, "transition", "");
                    css(target, "transform", "");
                    target.animated = false;
                    target.animatingX = false;
                    target.animatingY = false;
                }, duration);
            }
        }
    };
}
function repaint(target) {
    return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
    initializeByDefault: true
};
var PluginManager = {
    mount: function mount(plugin) {
        // Set default static properties
        for(var option in defaults)if (defaults.hasOwnProperty(option) && !(option in plugin)) plugin[option] = defaults[option];
        plugins.forEach(function(p) {
            if (p.pluginName === plugin.pluginName) throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        });
        plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
        var _this = this;
        this.eventCanceled = false;
        evt.cancel = function() {
            _this.eventCanceled = true;
        };
        var eventNameGlobal = eventName + "Global";
        plugins.forEach(function(plugin) {
            if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable
            if (sortable[plugin.pluginName][eventNameGlobal]) sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
                sortable: sortable
            }, evt));
             // Only fire plugin event if plugin is enabled in this sortable,
            // and plugin has event defined
            if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) sortable[plugin.pluginName][eventName](_objectSpread2({
                sortable: sortable
            }, evt));
        });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
        plugins.forEach(function(plugin) {
            var pluginName = plugin.pluginName;
            if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
            var initialized = new plugin(sortable, el, sortable.options);
            initialized.sortable = sortable;
            initialized.options = sortable.options;
            sortable[pluginName] = initialized; // Add default options from plugin
            _extends(defaults, initialized.defaults);
        });
        for(var option in sortable.options){
            if (!sortable.options.hasOwnProperty(option)) continue;
            var modified = this.modifyOption(sortable, option, sortable.options[option]);
            if (typeof modified !== "undefined") sortable.options[option] = modified;
        }
    },
    getEventProperties: function getEventProperties(name, sortable) {
        var eventProperties = {};
        plugins.forEach(function(plugin) {
            if (typeof plugin.eventProperties !== "function") return;
            _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
        });
        return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
        var modifiedValue;
        plugins.forEach(function(plugin) {
            // Plugin must exist on the Sortable
            if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
            if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        });
        return modifiedValue;
    }
};
function dispatchEvent(_ref) {
    var sortable = _ref.sortable, rootEl = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex = _ref.oldIndex, newIndex = _ref.newIndex, oldDraggableIndex = _ref.oldDraggableIndex, newDraggableIndex = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
    });
    else {
        evt = document.createEvent("Event");
        evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
    for(var option in allEventProperties)evt[option] = allEventProperties[option];
    if (rootEl) rootEl.dispatchEvent(evt);
    if (options[onName]) options[onName].call(sortable, evt);
}
var _excluded = [
    "evt"
];
var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl: dragEl,
        parentEl: parentEl,
        ghostEl: ghostEl,
        rootEl: rootEl,
        nextEl: nextEl,
        lastDownEl: lastDownEl,
        cloneEl: cloneEl,
        cloneHidden: cloneHidden,
        dragStarted: moved,
        putSortable: putSortable,
        activeSortable: Sortable.active,
        originalEvent: originalEvent,
        oldIndex: oldIndex,
        oldDraggableIndex: oldDraggableIndex,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
            cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
            cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name) {
            _dispatchEvent({
                sortable: sortable,
                name: name,
                originalEvent: originalEvent
            });
        }
    }, data));
};
function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
        putSortable: putSortable,
        cloneEl: cloneEl,
        targetEl: dragEl,
        rootEl: rootEl,
        oldIndex: oldIndex,
        oldDraggableIndex: oldDraggableIndex,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex
    }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, // For positioning ghost absolutely
ghostRelativeParent, ghostRelativeParentInitialScroll = [], // (left, top)
_silent = false, savedInputChecked = [];
/** @const */ var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
    if (!documentExists) return; // false when <= IE11
    if (IE11OrLess) return false;
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    if (elCSS.display === "grid") return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
        var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, /**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */ _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function(sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable)) return;
        var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) return ret = sortable;
    });
    return ret;
}, _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
        return function(to, from, dragEl, evt) {
            var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
            if (value == null && (pull || sameGroup)) // Default pull value
            // Default pull and put value if same group
            return true;
            else if (value == null || value === false) return false;
            else if (pull && value === "clone") return value;
            else if (typeof value === "function") return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
            else {
                var otherGroup = (pull ? to : from).options.group.name;
                return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
            }
        };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") originalGroup = {
        name: originalGroup
    };
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "none");
}, _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "");
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists) document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
    }
}, true);
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;
        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
        if (nearest) {
            // Create imitation event
            var event = {};
            for(var i in evt)if (evt.hasOwnProperty(i)) event[i] = evt[i];
            event.target = event.rootEl = nearest;
            event.preventDefault = void 0;
            event.stopPropagation = void 0;
            nearest[expando]._onDragOver(event);
        }
    }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */ function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) throw "Sortable: `el` must be an HTMLElement, not ".concat(({}).toString.call(el));
    this.el = el; // root element
    this.options = options = _extends({}, options); // Export instance
    el[expando] = this;
    var defaults = {
        group: null,
        sort: true,
        disabled: false,
        store: null,
        handle: null,
        draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
        swapThreshold: 1,
        // percentage; 0 <= x <= 1
        invertSwap: false,
        // invert always
        invertedSwapThreshold: null,
        // will be set to same as swapThreshold if default
        removeCloneOnHide: true,
        direction: function direction() {
            return _detectDirection(el, this.options);
        },
        ghostClass: "sortable-ghost",
        chosenClass: "sortable-chosen",
        dragClass: "sortable-drag",
        ignore: "a, img",
        filter: null,
        preventOnFilter: true,
        animation: 0,
        easing: null,
        setData: function setData(dataTransfer, dragEl) {
            dataTransfer.setData("Text", dragEl.textContent);
        },
        dropBubble: false,
        dragoverBubble: false,
        dataIdAttr: "data-id",
        delay: 0,
        delayOnTouchOnly: false,
        touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
        forceFallback: false,
        fallbackClass: "sortable-fallback",
        fallbackOnBody: false,
        fallbackTolerance: 0,
        fallbackOffset: {
            x: 0,
            y: 0
        },
        supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
        emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults); // Set default options
    for(var name in defaults)!(name in options) && (options[name] = defaults[name]);
    _prepareGroup(options); // Bind all private methods
    for(var fn in this)if (fn.charAt(0) === "_" && typeof this[fn] === "function") this[fn] = this[fn].bind(this);
     // Setup drag mode
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
     // Bind events
    if (options.supportPointer) on(el, "pointerdown", this._onTapStart);
    else {
        on(el, "mousedown", this._onTapStart);
        on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
        on(el, "dragover", this);
        on(el, "dragenter", this);
    }
    sortables.push(this.el); // Restore sorting
    options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager
    _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */ {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) lastTarget = null;
    },
    _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(/** Event|TouchEvent */ evt) {
        if (!evt.cancelable) return;
        var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
        _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
        if (dragEl) return;
        if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) return; // only left button and enabled
         // cancel dnd if original target is content editable
        if (originalTarget.isContentEditable) return;
         // Safari ignores further event handling after mousedown
        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") return;
        target = closest(target, options.draggable, el, false);
        if (target && target.animated) return;
        if (lastDownEl === target) // Ignoring duplicate `down`
        return;
         // Get the index of the dragged element within its parent
        oldIndex = index(target);
        oldDraggableIndex = index(target, options.draggable); // Check filter
        if (typeof filter === "function") {
            if (filter.call(this, evt, target, this)) {
                _dispatchEvent({
                    sortable: _this,
                    rootEl: originalTarget,
                    name: "filter",
                    targetEl: target,
                    toEl: el,
                    fromEl: el
                });
                pluginEvent("filter", _this, {
                    evt: evt
                });
                preventOnFilter && evt.cancelable && evt.preventDefault();
                return; // cancel dnd
            }
        } else if (filter) {
            filter = filter.split(",").some(function(criteria) {
                criteria = closest(originalTarget, criteria.trim(), el, false);
                if (criteria) {
                    _dispatchEvent({
                        sortable: _this,
                        rootEl: criteria,
                        name: "filter",
                        targetEl: target,
                        fromEl: el,
                        toEl: el
                    });
                    pluginEvent("filter", _this, {
                        evt: evt
                    });
                    return true;
                }
            });
            if (filter) {
                preventOnFilter && evt.cancelable && evt.preventDefault();
                return; // cancel dnd
            }
        }
        if (options.handle && !closest(originalTarget, options.handle, el, false)) return;
         // Prepare `dragstart`
        this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(/** Event */ evt, /** Touch */ touch, /** HTMLElement */ target) {
        var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
        if (target && !dragEl && target.parentNode === el) {
            var dragRect = getRect(target);
            rootEl = el;
            dragEl = target;
            parentEl = dragEl.parentNode;
            nextEl = dragEl.nextSibling;
            lastDownEl = target;
            activeGroup = options.group;
            Sortable.dragged = dragEl;
            tapEvt = {
                target: dragEl,
                clientX: (touch || evt).clientX,
                clientY: (touch || evt).clientY
            };
            tapDistanceLeft = tapEvt.clientX - dragRect.left;
            tapDistanceTop = tapEvt.clientY - dragRect.top;
            this._lastX = (touch || evt).clientX;
            this._lastY = (touch || evt).clientY;
            dragEl.style["will-change"] = "all";
            dragStartFn = function dragStartFn() {
                pluginEvent("delayEnded", _this, {
                    evt: evt
                });
                if (Sortable.eventCanceled) {
                    _this._onDrop();
                    return;
                } // Delayed drag has been triggered
                // we can re-enable the events: touchmove/mousemove
                _this._disableDelayedDragEvents();
                if (!FireFox && _this.nativeDraggable) dragEl.draggable = true;
                 // Bind the events: dragstart/dragend
                _this._triggerDragStart(evt, touch); // Drag start event
                _dispatchEvent({
                    sortable: _this,
                    name: "choose",
                    originalEvent: evt
                }); // Chosen item
                toggleClass(dragEl, options.chosenClass, true);
            }; // Disable "draggable"
            options.ignore.split(",").forEach(function(criteria) {
                find(dragEl, criteria.trim(), _disableDraggable);
            });
            on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
            on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
            on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
            on(ownerDocument, "mouseup", _this._onDrop);
            on(ownerDocument, "touchend", _this._onDrop);
            on(ownerDocument, "touchcancel", _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)
            if (FireFox && this.nativeDraggable) {
                this.options.touchStartThreshold = 4;
                dragEl.draggable = true;
            }
            pluginEvent("delayStart", this, {
                evt: evt
            }); // Delay is impossible for native DnD in Edge or IE
            if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
                if (Sortable.eventCanceled) {
                    this._onDrop();
                    return;
                } // If the user moves the pointer or let go the click or touch
                // before the delay has been reached:
                // disable the delayed drag
                on(ownerDocument, "mouseup", _this._disableDelayedDrag);
                on(ownerDocument, "touchend", _this._disableDelayedDrag);
                on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
                on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
                on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
                options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
                _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
            } else dragStartFn();
        }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(/** TouchEvent|PointerEvent **/ e) {
        var touch = e.touches ? e.touches[0] : e;
        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) this._disableDelayedDrag();
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);
        this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._disableDelayedDrag);
        off(ownerDocument, "touchend", this._disableDelayedDrag);
        off(ownerDocument, "touchcancel", this._disableDelayedDrag);
        off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(/** Event */ evt, /** Touch */ touch) {
        touch = touch || evt.pointerType == "touch" && evt;
        if (!this.nativeDraggable || touch) {
            if (this.options.supportPointer) on(document, "pointermove", this._onTouchMove);
            else if (touch) on(document, "touchmove", this._onTouchMove);
            else on(document, "mousemove", this._onTouchMove);
        } else {
            on(dragEl, "dragend", this);
            on(rootEl, "dragstart", this._onDragStart);
        }
        try {
            if (document.selection) // Timeout neccessary for IE9
            _nextTick(function() {
                document.selection.empty();
            });
            else window.getSelection().removeAllRanges();
        } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {
        awaitingDragStarted = false;
        if (rootEl && dragEl) {
            pluginEvent("dragStarted", this, {
                evt: evt
            });
            if (this.nativeDraggable) on(document, "dragover", _checkOutsideTargetEl);
            var options = this.options; // Apply effect
            !fallback && toggleClass(dragEl, options.dragClass, false);
            toggleClass(dragEl, options.ghostClass, true);
            Sortable.active = this;
            fallback && this._appendGhost(); // Drag start event
            _dispatchEvent({
                sortable: this,
                name: "start",
                originalEvent: evt
            });
        } else this._nulling();
    },
    _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
            this._lastX = touchEvt.clientX;
            this._lastY = touchEvt.clientY;
            _hideGhostForTarget();
            var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            var parent = target;
            while(target && target.shadowRoot){
                target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
                if (target === parent) break;
                parent = target;
            }
            dragEl.parentNode[expando]._isOutsideThisEl(target);
            if (parent) do {
                if (parent[expando]) {
                    var inserted = void 0;
                    inserted = parent[expando]._onDragOver({
                        clientX: touchEvt.clientX,
                        clientY: touchEvt.clientY,
                        target: target,
                        rootEl: parent
                    });
                    if (inserted && !this.options.dragoverBubble) break;
                }
                target = parent; // store last element
            }while (parent = parent.parentNode);
            _unhideGhostForTarget();
        }
    },
    _onTouchMove: function _onTouchMove(/**TouchEvent*/ evt) {
        if (tapEvt) {
            var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging
            if (!Sortable.active && !awaitingDragStarted) {
                if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) return;
                this._onDragStart(evt, true);
            }
            if (ghostEl) {
                if (ghostMatrix) {
                    ghostMatrix.e += dx - (lastDx || 0);
                    ghostMatrix.f += dy - (lastDy || 0);
                } else ghostMatrix = {
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    e: dx,
                    f: dy
                };
                var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
                css(ghostEl, "webkitTransform", cssMatrix);
                css(ghostEl, "mozTransform", cssMatrix);
                css(ghostEl, "msTransform", cssMatrix);
                css(ghostEl, "transform", cssMatrix);
                lastDx = dx;
                lastDy = dy;
                touchEvt = touch;
            }
            evt.cancelable && evt.preventDefault();
        }
    },
    _appendGhost: function _appendGhost() {
        // Bug if using scale(): https://stackoverflow.com/questions/2637058
        // Not being adjusted for
        if (!ghostEl) {
            var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options; // Position absolutely
            if (PositionGhostAbsolutely) {
                // Get relatively positioned parent
                ghostRelativeParent = container;
                while(css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document)ghostRelativeParent = ghostRelativeParent.parentNode;
                if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
                    if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
                    rect.top += ghostRelativeParent.scrollTop;
                    rect.left += ghostRelativeParent.scrollLeft;
                } else ghostRelativeParent = getWindowScrollingElement();
                ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
            }
            ghostEl = dragEl.cloneNode(true);
            toggleClass(ghostEl, options.ghostClass, false);
            toggleClass(ghostEl, options.fallbackClass, true);
            toggleClass(ghostEl, options.dragClass, true);
            css(ghostEl, "transition", "");
            css(ghostEl, "transform", "");
            css(ghostEl, "box-sizing", "border-box");
            css(ghostEl, "margin", 0);
            css(ghostEl, "top", rect.top);
            css(ghostEl, "left", rect.left);
            css(ghostEl, "width", rect.width);
            css(ghostEl, "height", rect.height);
            css(ghostEl, "opacity", "0.8");
            css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
            css(ghostEl, "zIndex", "100000");
            css(ghostEl, "pointerEvents", "none");
            Sortable.ghost = ghostEl;
            container.appendChild(ghostEl); // Set transform-origin
            css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
        }
    },
    _onDragStart: function _onDragStart(/**Event*/ evt, /**boolean*/ fallback) {
        var _this = this;
        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent("dragStart", this, {
            evt: evt
        });
        if (Sortable.eventCanceled) {
            this._onDrop();
            return;
        }
        pluginEvent("setupClone", this);
        if (!Sortable.eventCanceled) {
            cloneEl = clone(dragEl);
            cloneEl.draggable = false;
            cloneEl.style["will-change"] = "";
            this._hideClone();
            toggleClass(cloneEl, this.options.chosenClass, false);
            Sortable.clone = cloneEl;
        } // #1143: IFrame support workaround
        _this.cloneId = _nextTick(function() {
            pluginEvent("clone", _this);
            if (Sortable.eventCanceled) return;
            if (!_this.options.removeCloneOnHide) rootEl.insertBefore(cloneEl, dragEl);
            _this._hideClone();
            _dispatchEvent({
                sortable: _this,
                name: "clone"
            });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events
        if (fallback) {
            ignoreNextClick = true;
            _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
            // Undo what was set in _prepareDragStart before drag started
            off(document, "mouseup", _this._onDrop);
            off(document, "touchend", _this._onDrop);
            off(document, "touchcancel", _this._onDrop);
            if (dataTransfer) {
                dataTransfer.effectAllowed = "move";
                options.setData && options.setData.call(_this, dataTransfer, dragEl);
            }
            on(document, "drop", _this); // #1276 fix:
            css(dragEl, "transform", "translateZ(0)");
        }
        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on(document, "selectstart", _this);
        moved = true;
        if (Safari) css(document.body, "user-select", "none");
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(/**Event*/ evt) {
        var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
        if (_silent) return;
        function dragOverEvent(name, extra) {
            pluginEvent(name, _this, _objectSpread2({
                evt: evt,
                isOwner: isOwner,
                axis: vertical ? "vertical" : "horizontal",
                revert: revert,
                dragRect: dragRect,
                targetRect: targetRect,
                canSort: canSort,
                fromSortable: fromSortable,
                target: target,
                completed: completed,
                onMove: function onMove(target, after) {
                    return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
                },
                changed: changed
            }, extra));
        } // Capture animation state
        function capture() {
            dragOverEvent("dragOverAnimationCapture");
            _this.captureAnimationState();
            if (_this !== fromSortable) fromSortable.captureAnimationState();
        } // Return invocation when dragEl is inserted (or completed)
        function completed(insertion) {
            dragOverEvent("dragOverCompleted", {
                insertion: insertion
            });
            if (insertion) {
                // Clones must be hidden before folding animation to capture dragRectAbsolute properly
                if (isOwner) activeSortable._hideClone();
                else activeSortable._showClone(_this);
                if (_this !== fromSortable) {
                    // Set ghost class to new sortable's ghost class
                    toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
                    toggleClass(dragEl, options.ghostClass, true);
                }
                if (putSortable !== _this && _this !== Sortable.active) putSortable = _this;
                else if (_this === Sortable.active && putSortable) putSortable = null;
                 // Animation
                if (fromSortable === _this) _this._ignoreWhileAnimating = target;
                _this.animateAll(function() {
                    dragOverEvent("dragOverAnimationComplete");
                    _this._ignoreWhileAnimating = null;
                });
                if (_this !== fromSortable) {
                    fromSortable.animateAll();
                    fromSortable._ignoreWhileAnimating = null;
                }
            } // Null lastTarget if it is not inside a previously swapped element
            if (target === dragEl && !dragEl.animated || target === el && !target.animated) lastTarget = null;
             // no bubbling and not fallback
            if (!options.dragoverBubble && !evt.rootEl && target !== document) {
                dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted
                !insertion && nearestEmptyInsertDetectEvent(evt);
            }
            !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
            return completedFired = true;
        } // Call when dragEl has been inserted
        function changed() {
            newIndex = index(dragEl);
            newDraggableIndex = index(dragEl, options.draggable);
            _dispatchEvent({
                sortable: _this,
                name: "change",
                toEl: el,
                newIndex: newIndex,
                newDraggableIndex: newDraggableIndex,
                originalEvent: evt
            });
        }
        if (evt.preventDefault !== void 0) evt.cancelable && evt.preventDefault();
        target = closest(target, options.draggable, el, true);
        dragOverEvent("dragOver");
        if (Sortable.eventCanceled) return completedFired;
        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) return completed(false);
        ignoreNextClick = false;
        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl // Reverting item into the original list
        ) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
            vertical = this._getDirection(evt, target) === "vertical";
            dragRect = getRect(dragEl);
            dragOverEvent("dragOverValid");
            if (Sortable.eventCanceled) return completedFired;
            if (revert) {
                parentEl = rootEl; // actualization
                capture();
                this._hideClone();
                dragOverEvent("revert");
                if (!Sortable.eventCanceled) {
                    if (nextEl) rootEl.insertBefore(dragEl, nextEl);
                    else rootEl.appendChild(dragEl);
                }
                return completed(true);
            }
            var elLastChild = lastChild(el, options.draggable);
            if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
                // Insert to end of list
                // If already at end of list: Do not insert
                if (elLastChild === dragEl) return completed(false);
                 // if there is a last element, it is the target
                if (elLastChild && el === evt.target) target = elLastChild;
                if (target) targetRect = getRect(target);
                if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
                    capture();
                    el.appendChild(dragEl);
                    parentEl = el; // actualization
                    changed();
                    return completed(true);
                }
            } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
                // Insert to start of list
                var firstChild = getChild(el, 0, options, true);
                if (firstChild === dragEl) return completed(false);
                target = firstChild;
                targetRect = getRect(target);
                if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
                    capture();
                    el.insertBefore(dragEl, firstChild);
                    parentEl = el; // actualization
                    changed();
                    return completed(true);
                }
            } else if (target.parentNode === el) {
                targetRect = getRect(target);
                var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
                if (lastTarget !== target) {
                    targetBeforeFirstSwap = targetRect[side1];
                    pastFirstInvertThresh = false;
                    isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
                }
                direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
                var sibling;
                if (direction !== 0) {
                    // Check if target is beside dragEl in respective direction (ignoring hidden elements)
                    var dragIndex = index(dragEl);
                    do {
                        dragIndex -= direction;
                        sibling = parentEl.children[dragIndex];
                    }while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
                } // If dragEl is already beside target: Do not insert
                if (direction === 0 || sibling === target) return completed(false);
                lastTarget = target;
                lastDirection = direction;
                var nextSibling = target.nextElementSibling, after = false;
                after = direction === 1;
                var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
                if (moveVector !== false) {
                    if (moveVector === 1 || moveVector === -1) after = moveVector === 1;
                    _silent = true;
                    setTimeout(_unsilent, 30);
                    capture();
                    if (after && !nextSibling) el.appendChild(dragEl);
                    else target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                     // Undo chrome's scroll adjustment (has no effect on other browsers)
                    if (scrolledPastTop) scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
                    parentEl = dragEl.parentNode; // actualization
                    // must be done before animation
                    if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
                    changed();
                    return completed(true);
                }
            }
            if (el.contains(dragEl)) return completed(false);
        }
        return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
        off(document, "mousemove", this._onTouchMove);
        off(document, "touchmove", this._onTouchMove);
        off(document, "pointermove", this._onTouchMove);
        off(document, "dragover", nearestEmptyInsertDetectEvent);
        off(document, "mousemove", nearestEmptyInsertDetectEvent);
        off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._onDrop);
        off(ownerDocument, "touchend", this._onDrop);
        off(ownerDocument, "pointerup", this._onDrop);
        off(ownerDocument, "touchcancel", this._onDrop);
        off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(/**Event*/ evt) {
        var el = this.el, options = this.options; // Get the index of the dragged element within its parent
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        pluginEvent("drop", this, {
            evt: evt
        });
        parentEl = dragEl && dragEl.parentNode; // Get again after plugin event
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        if (Sortable.eventCanceled) {
            this._nulling();
            return;
        }
        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);
        _cancelNextTick(this.cloneId);
        _cancelNextTick(this._dragStartId); // Unbind events
        if (this.nativeDraggable) {
            off(document, "drop", this);
            off(el, "dragstart", this._onDragStart);
        }
        this._offMoveEvents();
        this._offUpEvents();
        if (Safari) css(document.body, "user-select", "");
        css(dragEl, "transform", "");
        if (evt) {
            if (moved) {
                evt.cancelable && evt.preventDefault();
                !options.dropBubble && evt.stopPropagation();
            }
            ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
            if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") // Remove clone(s)
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
            if (dragEl) {
                if (this.nativeDraggable) off(dragEl, "dragend", this);
                _disableDraggable(dragEl);
                dragEl.style["will-change"] = ""; // Remove classes
                // ghostClass is added in dragStarted
                if (moved && !awaitingDragStarted) toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
                toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event
                _dispatchEvent({
                    sortable: this,
                    name: "unchoose",
                    toEl: parentEl,
                    newIndex: null,
                    newDraggableIndex: null,
                    originalEvent: evt
                });
                if (rootEl !== parentEl) {
                    if (newIndex >= 0) {
                        // Add event
                        _dispatchEvent({
                            rootEl: parentEl,
                            name: "add",
                            toEl: parentEl,
                            fromEl: rootEl,
                            originalEvent: evt
                        }); // Remove event
                        _dispatchEvent({
                            sortable: this,
                            name: "remove",
                            toEl: parentEl,
                            originalEvent: evt
                        }); // drag from one list and drop into another
                        _dispatchEvent({
                            rootEl: parentEl,
                            name: "sort",
                            toEl: parentEl,
                            fromEl: rootEl,
                            originalEvent: evt
                        });
                        _dispatchEvent({
                            sortable: this,
                            name: "sort",
                            toEl: parentEl,
                            originalEvent: evt
                        });
                    }
                    putSortable && putSortable.save();
                } else {
                    if (newIndex !== oldIndex) {
                        if (newIndex >= 0) {
                            // drag & drop within the same list
                            _dispatchEvent({
                                sortable: this,
                                name: "update",
                                toEl: parentEl,
                                originalEvent: evt
                            });
                            _dispatchEvent({
                                sortable: this,
                                name: "sort",
                                toEl: parentEl,
                                originalEvent: evt
                            });
                        }
                    }
                }
                if (Sortable.active) {
                    /* jshint eqnull:true */ if (newIndex == null || newIndex === -1) {
                        newIndex = oldIndex;
                        newDraggableIndex = oldDraggableIndex;
                    }
                    _dispatchEvent({
                        sortable: this,
                        name: "end",
                        toEl: parentEl,
                        originalEvent: evt
                    }); // Save sorting
                    this.save();
                }
            }
        }
        this._nulling();
    },
    _nulling: function _nulling() {
        pluginEvent("nulling", this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function(el) {
            el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(/**Event*/ evt) {
        switch(evt.type){
            case "drop":
            case "dragend":
                this._onDrop(evt);
                break;
            case "dragenter":
            case "dragover":
                if (dragEl) {
                    this._onDragOver(evt);
                    _globalDragOver(evt);
                }
                break;
            case "selectstart":
                evt.preventDefault();
                break;
        }
    },
    /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */ toArray: function toArray() {
        var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
        for(; i < n; i++){
            el = children[i];
            if (closest(el, options.draggable, this.el, false)) order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
        return order;
    },
    /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */ sort: function sort(order, useAnimation) {
        var items = {}, rootEl = this.el;
        this.toArray().forEach(function(id, i) {
            var el = rootEl.children[i];
            if (closest(el, this.options.draggable, rootEl, false)) items[id] = el;
        }, this);
        useAnimation && this.captureAnimationState();
        order.forEach(function(id) {
            if (items[id]) {
                rootEl.removeChild(items[id]);
                rootEl.appendChild(items[id]);
            }
        });
        useAnimation && this.animateAll();
    },
    /**
   * Save the current sorting
   */ save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
    },
    /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */ closest: function closest$1(el, selector) {
        return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */ option: function option(name, value) {
        var options = this.options;
        if (value === void 0) return options[name];
        else {
            var modifiedValue = PluginManager.modifyOption(this, name, value);
            if (typeof modifiedValue !== "undefined") options[name] = modifiedValue;
            else options[name] = value;
            if (name === "group") _prepareGroup(options);
        }
    },
    /**
   * Destroy
   */ destroy: function destroy() {
        pluginEvent("destroy", this);
        var el = this.el;
        el[expando] = null;
        off(el, "mousedown", this._onTapStart);
        off(el, "touchstart", this._onTapStart);
        off(el, "pointerdown", this._onTapStart);
        if (this.nativeDraggable) {
            off(el, "dragover", this);
            off(el, "dragenter", this);
        } // Remove draggable attributes
        Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el) {
            el.removeAttribute("draggable");
        });
        this._onDrop();
        this._disableDelayedDragEvents();
        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
    },
    _hideClone: function _hideClone() {
        if (!cloneHidden) {
            pluginEvent("hideClone", this);
            if (Sortable.eventCanceled) return;
            css(cloneEl, "display", "none");
            if (this.options.removeCloneOnHide && cloneEl.parentNode) cloneEl.parentNode.removeChild(cloneEl);
            cloneHidden = true;
        }
    },
    _showClone: function _showClone(putSortable) {
        if (putSortable.lastPutMode !== "clone") {
            this._hideClone();
            return;
        }
        if (cloneHidden) {
            pluginEvent("showClone", this);
            if (Sortable.eventCanceled) return; // show clone at dragEl or original position
            if (dragEl.parentNode == rootEl && !this.options.group.revertClone) rootEl.insertBefore(cloneEl, dragEl);
            else if (nextEl) rootEl.insertBefore(cloneEl, nextEl);
            else rootEl.appendChild(cloneEl);
            if (this.options.group.revertClone) this.animate(dragEl, cloneEl);
            css(cloneEl, "display", "");
            cloneHidden = false;
        }
    }
};
function _globalDragOver(/**Event*/ evt) {
    if (evt.dataTransfer) evt.dataTransfer.dropEffect = "move";
    evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal; // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
    });
    else {
        evt = document.createEvent("Event");
        evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) retVal = onMoveFn.call(sortable, evt, originalEvent);
    return retVal;
}
function _disableDraggable(el) {
    el.draggable = false;
}
function _unsilent() {
    _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
    var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var spacer = 10;
    return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
    var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var spacer = 10;
    return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
        // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
        if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
            // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
            // check if past first invert threshold on side opposite of lastDirection
            if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) // past first invert threshold, do not restrict inverted threshold to dragEl shadow
            pastFirstInvertThresh = true;
            if (!pastFirstInvertThresh) {
                // dragEl shadow (target move distance shadow)
                if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
                 : mouseOnAxis > targetS2 - targetMoveDistance) return -lastDirection;
            } else invert = true;
        } else {
            // Regular
            if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) return _getInsertDirection(target);
        }
    }
    invert = invert || invertSwap;
    if (invert) {
        // Invert of regular
        if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
    return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */ function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) return 1;
    else return -1;
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */ function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
    while(i--)sum += str.charCodeAt(i);
    return sum.toString(36);
}
function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName("input");
    var idx = inputs.length;
    while(idx--){
        var el = inputs[idx];
        el.checked && savedInputChecked.push(el);
    }
}
function _nextTick(fn) {
    return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
    return clearTimeout(id);
} // Fixed #973:
if (documentExists) on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) evt.preventDefault();
});
 // Export utils
Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
        return !!closest(el, selector, el, false);
    },
    extend: extend,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone,
    index: index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */ Sortable.get = function(element) {
    return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */ Sortable.mount = function() {
    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++)plugins[_key] = arguments[_key];
    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function(plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat(({}).toString.call(plugin));
        if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
    });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */ Sortable.create = function(el, options) {
    return new Sortable(el, options);
}; // Export
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
    function AutoScroll() {
        this.defaults = {
            scroll: true,
            forceAutoScrollFallback: false,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            bubbleScroll: true
        }; // Bind all private methods
        for(var fn in this)if (fn.charAt(0) === "_" && typeof this[fn] === "function") this[fn] = this[fn].bind(this);
    }
    AutoScroll.prototype = {
        dragStarted: function dragStarted(_ref) {
            var originalEvent = _ref.originalEvent;
            if (this.sortable.nativeDraggable) on(document, "dragover", this._handleAutoScroll);
            else {
                if (this.options.supportPointer) on(document, "pointermove", this._handleFallbackAutoScroll);
                else if (originalEvent.touches) on(document, "touchmove", this._handleFallbackAutoScroll);
                else on(document, "mousemove", this._handleFallbackAutoScroll);
            }
        },
        dragOverCompleted: function dragOverCompleted(_ref2) {
            var originalEvent = _ref2.originalEvent;
            // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
            if (!this.options.dragOverBubble && !originalEvent.rootEl) this._handleAutoScroll(originalEvent);
        },
        drop: function drop() {
            if (this.sortable.nativeDraggable) off(document, "dragover", this._handleAutoScroll);
            else {
                off(document, "pointermove", this._handleFallbackAutoScroll);
                off(document, "touchmove", this._handleFallbackAutoScroll);
                off(document, "mousemove", this._handleFallbackAutoScroll);
            }
            clearPointerElemChangedInterval();
            clearAutoScrolls();
            cancelThrottle();
        },
        nulling: function nulling() {
            touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
            autoScrolls.length = 0;
        },
        _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
            this._handleAutoScroll(evt, true);
        },
        _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
            var _this = this;
            var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
            touchEvt$1 = evt; // IE does not seem to have native autoscroll,
            // Edge's autoscroll seems too conditional,
            // MACOS Safari does not have autoscroll,
            // Firefox and Chrome are good
            if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
                autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change
                var ogElemScroller = getParentAutoScrollElement(elem, true);
                if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
                    pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour
                    pointerElemChangedInterval = setInterval(function() {
                        var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
                        if (newElem !== ogElemScroller) {
                            ogElemScroller = newElem;
                            clearAutoScrolls();
                        }
                        autoScroll(evt, _this.options, newElem, fallback);
                    }, 10);
                    lastAutoScrollX = x;
                    lastAutoScrollY = y;
                }
            } else {
                // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
                if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
                    clearAutoScrolls();
                    return;
                }
                autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
            }
        }
    };
    return _extends(AutoScroll, {
        pluginName: "scroll",
        initializeByDefault: true
    });
}
function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll) {
        clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
}
function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn; // New scroll root, set scrollEl
    if (scrollRootEl !== rootEl) {
        scrollRootEl = rootEl;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) scrollEl = getParentAutoScrollElement(rootEl, true);
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
        var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
        if (el === winScroller) {
            canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
            canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
        } else {
            canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
            canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
        }
        var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
        if (!autoScrolls[layersOut]) {
            for(var i = 0; i <= layersOut; i++)if (!autoScrolls[i]) autoScrolls[i] = {};
        }
        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
            autoScrolls[layersOut].el = el;
            autoScrolls[layersOut].vx = vx;
            autoScrolls[layersOut].vy = vy;
            clearInterval(autoScrolls[layersOut].pid);
            if (vx != 0 || vy != 0) {
                scrollThisInstance = true;
                /* jshint loopfunc:true */ autoScrolls[layersOut].pid = setInterval((function() {
                    // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
                    if (isFallback && this.layer === 0) Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
                    var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
                    var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
                    if (typeof scrollCustomFn === "function") {
                        if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") return;
                    }
                    scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
                }).bind({
                    layer: layersOut
                }), 24);
            }
        }
        layersOut++;
    }while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);
var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent, putSortable = _ref.putSortable, dragEl = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent("spill");
        this.onSpill({
            dragEl: dragEl,
            putSortable: putSortable
        });
    }
};
function Revert() {}
Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
        var oldDraggableIndex = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
        var dragEl = _ref3.dragEl, putSortable = _ref3.putSortable;
        this.sortable.captureAnimationState();
        if (putSortable) putSortable.captureAnimationState();
        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
        if (nextSibling) this.sortable.el.insertBefore(dragEl, nextSibling);
        else this.sortable.el.appendChild(dragEl);
        this.sortable.animateAll();
        if (putSortable) putSortable.animateAll();
    },
    drop: drop
};
_extends(Revert, {
    pluginName: "revertOnSpill"
});
function Remove() {}
Remove.prototype = {
    onSpill: function onSpill(_ref4) {
        var dragEl = _ref4.dragEl, putSortable = _ref4.putSortable;
        var parentSortable = putSortable || this.sortable;
        parentSortable.captureAnimationState();
        dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
        parentSortable.animateAll();
    },
    drop: drop
};
_extends(Remove, {
    pluginName: "removeOnSpill"
});
var lastSwapEl;
function SwapPlugin() {
    function Swap() {
        this.defaults = {
            swapClass: "sortable-swap-highlight"
        };
    }
    Swap.prototype = {
        dragStart: function dragStart(_ref) {
            var dragEl = _ref.dragEl;
            lastSwapEl = dragEl;
        },
        dragOverValid: function dragOverValid(_ref2) {
            var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
            if (!activeSortable.options.swap) return;
            var el = this.sortable.el, options = this.options;
            if (target && target !== el) {
                var prevSwapEl = lastSwapEl;
                if (onMove(target) !== false) {
                    toggleClass(target, options.swapClass, true);
                    lastSwapEl = target;
                } else lastSwapEl = null;
                if (prevSwapEl && prevSwapEl !== lastSwapEl) toggleClass(prevSwapEl, options.swapClass, false);
            }
            changed();
            completed(true);
            cancel();
        },
        drop: function drop(_ref3) {
            var activeSortable = _ref3.activeSortable, putSortable = _ref3.putSortable, dragEl = _ref3.dragEl;
            var toSortable = putSortable || this.sortable;
            var options = this.options;
            lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
            if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
                if (dragEl !== lastSwapEl) {
                    toSortable.captureAnimationState();
                    if (toSortable !== activeSortable) activeSortable.captureAnimationState();
                    swapNodes(dragEl, lastSwapEl);
                    toSortable.animateAll();
                    if (toSortable !== activeSortable) activeSortable.animateAll();
                }
            }
        },
        nulling: function nulling() {
            lastSwapEl = null;
        }
    };
    return _extends(Swap, {
        pluginName: "swap",
        eventProperties: function eventProperties() {
            return {
                swapItem: lastSwapEl
            };
        }
    });
}
function swapNodes(n1, n2) {
    var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
    if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
    i1 = index(n1);
    i2 = index(n2);
    if (p1.isEqualNode(p2) && i1 < i2) i2++;
    p1.insertBefore(n2, p1.children[i1]);
    p2.insertBefore(n1, p2.children[i2]);
}
var multiDragElements = [], multiDragClones = [], lastMultiDragSelect, // for selection with modifier key down (SHIFT)
multiDragSortable, initialFolding = false, // Initial multi-drag fold when drag started
folding = false, // Folding any other time
dragStarted = false, dragEl$1, clonesFromRect, clonesHidden;
function MultiDragPlugin() {
    function MultiDrag(sortable) {
        // Bind all private methods
        for(var fn in this)if (fn.charAt(0) === "_" && typeof this[fn] === "function") this[fn] = this[fn].bind(this);
        if (sortable.options.supportPointer) on(document, "pointerup", this._deselectMultiDrag);
        else {
            on(document, "mouseup", this._deselectMultiDrag);
            on(document, "touchend", this._deselectMultiDrag);
        }
        on(document, "keydown", this._checkKeyDown);
        on(document, "keyup", this._checkKeyUp);
        this.defaults = {
            selectedClass: "sortable-selected",
            multiDragKey: null,
            setData: function setData(dataTransfer, dragEl) {
                var data = "";
                if (multiDragElements.length && multiDragSortable === sortable) multiDragElements.forEach(function(multiDragElement, i) {
                    data += (!i ? "" : ", ") + multiDragElement.textContent;
                });
                else data = dragEl.textContent;
                dataTransfer.setData("Text", data);
            }
        };
    }
    MultiDrag.prototype = {
        multiDragKeyDown: false,
        isMultiDrag: false,
        delayStartGlobal: function delayStartGlobal(_ref) {
            var dragged = _ref.dragEl;
            dragEl$1 = dragged;
        },
        delayEnded: function delayEnded() {
            this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
        },
        setupClone: function setupClone(_ref2) {
            var sortable = _ref2.sortable, cancel = _ref2.cancel;
            if (!this.isMultiDrag) return;
            for(var i = 0; i < multiDragElements.length; i++){
                multiDragClones.push(clone(multiDragElements[i]));
                multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
                multiDragClones[i].draggable = false;
                multiDragClones[i].style["will-change"] = "";
                toggleClass(multiDragClones[i], this.options.selectedClass, false);
                multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
            }
            sortable._hideClone();
            cancel();
        },
        clone: function clone(_ref3) {
            var sortable = _ref3.sortable, rootEl = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
            if (!this.isMultiDrag) return;
            if (!this.options.removeCloneOnHide) {
                if (multiDragElements.length && multiDragSortable === sortable) {
                    insertMultiDragClones(true, rootEl);
                    dispatchSortableEvent("clone");
                    cancel();
                }
            }
        },
        showClone: function showClone(_ref4) {
            var cloneNowShown = _ref4.cloneNowShown, rootEl = _ref4.rootEl, cancel = _ref4.cancel;
            if (!this.isMultiDrag) return;
            insertMultiDragClones(false, rootEl);
            multiDragClones.forEach(function(clone) {
                css(clone, "display", "");
            });
            cloneNowShown();
            clonesHidden = false;
            cancel();
        },
        hideClone: function hideClone(_ref5) {
            var _this = this;
            var sortable = _ref5.sortable, cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
            if (!this.isMultiDrag) return;
            multiDragClones.forEach(function(clone) {
                css(clone, "display", "none");
                if (_this.options.removeCloneOnHide && clone.parentNode) clone.parentNode.removeChild(clone);
            });
            cloneNowHidden();
            clonesHidden = true;
            cancel();
        },
        dragStartGlobal: function dragStartGlobal(_ref6) {
            var sortable = _ref6.sortable;
            if (!this.isMultiDrag && multiDragSortable) multiDragSortable.multiDrag._deselectMultiDrag();
            multiDragElements.forEach(function(multiDragElement) {
                multiDragElement.sortableIndex = index(multiDragElement);
            }); // Sort multi-drag elements
            multiDragElements = multiDragElements.sort(function(a, b) {
                return a.sortableIndex - b.sortableIndex;
            });
            dragStarted = true;
        },
        dragStarted: function dragStarted(_ref7) {
            var _this2 = this;
            var sortable = _ref7.sortable;
            if (!this.isMultiDrag) return;
            if (this.options.sort) {
                // Capture rects,
                // hide multi drag elements (by positioning them absolute),
                // set multi drag elements rects to dragRect,
                // show multi drag elements,
                // animate to rects,
                // unset rects & remove from DOM
                sortable.captureAnimationState();
                if (this.options.animation) {
                    multiDragElements.forEach(function(multiDragElement) {
                        if (multiDragElement === dragEl$1) return;
                        css(multiDragElement, "position", "absolute");
                    });
                    var dragRect = getRect(dragEl$1, false, true, true);
                    multiDragElements.forEach(function(multiDragElement) {
                        if (multiDragElement === dragEl$1) return;
                        setRect(multiDragElement, dragRect);
                    });
                    folding = true;
                    initialFolding = true;
                }
            }
            sortable.animateAll(function() {
                folding = false;
                initialFolding = false;
                if (_this2.options.animation) multiDragElements.forEach(function(multiDragElement) {
                    unsetRect(multiDragElement);
                });
                 // Remove all auxiliary multidrag items from el, if sorting enabled
                if (_this2.options.sort) removeMultiDragElements();
            });
        },
        dragOver: function dragOver(_ref8) {
            var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
            if (folding && ~multiDragElements.indexOf(target)) {
                completed(false);
                cancel();
            }
        },
        revert: function revert(_ref9) {
            var fromSortable = _ref9.fromSortable, rootEl = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
            if (multiDragElements.length > 1) {
                // Setup unfold animation
                multiDragElements.forEach(function(multiDragElement) {
                    sortable.addAnimationState({
                        target: multiDragElement,
                        rect: folding ? getRect(multiDragElement) : dragRect
                    });
                    unsetRect(multiDragElement);
                    multiDragElement.fromRect = dragRect;
                    fromSortable.removeAnimationState(multiDragElement);
                });
                folding = false;
                insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
            }
        },
        dragOverCompleted: function dragOverCompleted(_ref10) {
            var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl = _ref10.parentEl, putSortable = _ref10.putSortable;
            var options = this.options;
            if (insertion) {
                // Clones must be hidden before folding animation to capture dragRectAbsolute properly
                if (isOwner) activeSortable._hideClone();
                initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location
                if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
                    // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
                    var dragRectAbsolute = getRect(dragEl$1, false, true, true);
                    multiDragElements.forEach(function(multiDragElement) {
                        if (multiDragElement === dragEl$1) return;
                        setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
                        // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
                        parentEl.appendChild(multiDragElement);
                    });
                    folding = true;
                } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
                if (!isOwner) {
                    // Only remove if not folding (folding will remove them anyways)
                    if (!folding) removeMultiDragElements();
                    if (multiDragElements.length > 1) {
                        var clonesHiddenBefore = clonesHidden;
                        activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden
                        if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) multiDragClones.forEach(function(clone) {
                            activeSortable.addAnimationState({
                                target: clone,
                                rect: clonesFromRect
                            });
                            clone.fromRect = clonesFromRect;
                            clone.thisAnimationDuration = null;
                        });
                    } else activeSortable._showClone(sortable);
                }
            }
        },
        dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
            var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
            multiDragElements.forEach(function(multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
            });
            if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
                clonesFromRect = _extends({}, dragRect);
                var dragMatrix = matrix(dragEl$1, true);
                clonesFromRect.top -= dragMatrix.f;
                clonesFromRect.left -= dragMatrix.e;
            }
        },
        dragOverAnimationComplete: function dragOverAnimationComplete() {
            if (folding) {
                folding = false;
                removeMultiDragElements();
            }
        },
        drop: function drop(_ref12) {
            var evt = _ref12.originalEvent, rootEl = _ref12.rootEl, parentEl = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex = _ref12.oldIndex, putSortable = _ref12.putSortable;
            var toSortable = putSortable || this.sortable;
            if (!evt) return;
            var options = this.options, children = parentEl.children; // Multi-drag selection
            if (!dragStarted) {
                if (options.multiDragKey && !this.multiDragKeyDown) this._deselectMultiDrag();
                toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
                if (!~multiDragElements.indexOf(dragEl$1)) {
                    multiDragElements.push(dragEl$1);
                    dispatchEvent({
                        sortable: sortable,
                        rootEl: rootEl,
                        name: "select",
                        targetEl: dragEl$1,
                        originalEvt: evt
                    }); // Modifier activated, select from last to dragEl
                    if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
                        var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
                        if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                            // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                            // (but previous selection existed)
                            var n, i;
                            if (currentIndex > lastIndex) {
                                i = lastIndex;
                                n = currentIndex;
                            } else {
                                i = currentIndex;
                                n = lastIndex + 1;
                            }
                            for(; i < n; i++){
                                if (~multiDragElements.indexOf(children[i])) continue;
                                toggleClass(children[i], options.selectedClass, true);
                                multiDragElements.push(children[i]);
                                dispatchEvent({
                                    sortable: sortable,
                                    rootEl: rootEl,
                                    name: "select",
                                    targetEl: children[i],
                                    originalEvt: evt
                                });
                            }
                        }
                    } else lastMultiDragSelect = dragEl$1;
                    multiDragSortable = toSortable;
                } else {
                    multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
                    lastMultiDragSelect = null;
                    dispatchEvent({
                        sortable: sortable,
                        rootEl: rootEl,
                        name: "deselect",
                        targetEl: dragEl$1,
                        originalEvt: evt
                    });
                }
            } // Multi-drag drop
            if (dragStarted && this.isMultiDrag) {
                folding = false; // Do not "unfold" after around dragEl if reverted
                if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
                    var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
                    if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
                    toSortable.captureAnimationState();
                    if (!initialFolding) {
                        if (options.animation) {
                            dragEl$1.fromRect = dragRect;
                            multiDragElements.forEach(function(multiDragElement) {
                                multiDragElement.thisAnimationDuration = null;
                                if (multiDragElement !== dragEl$1) {
                                    var rect = folding ? getRect(multiDragElement) : dragRect;
                                    multiDragElement.fromRect = rect; // Prepare unfold animation
                                    toSortable.addAnimationState({
                                        target: multiDragElement,
                                        rect: rect
                                    });
                                }
                            });
                        } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
                        // properly they must all be removed
                        removeMultiDragElements();
                        multiDragElements.forEach(function(multiDragElement) {
                            if (children[multiDragIndex]) parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
                            else parentEl.appendChild(multiDragElement);
                            multiDragIndex++;
                        }); // If initial folding is done, the elements may have changed position because they are now
                        // unfolding around dragEl, even though dragEl may not have his index changed, so update event
                        // must be fired here as Sortable will not.
                        if (oldIndex === index(dragEl$1)) {
                            var update = false;
                            multiDragElements.forEach(function(multiDragElement) {
                                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                                    update = true;
                                    return;
                                }
                            });
                            if (update) dispatchSortableEvent("update");
                        }
                    } // Must be done after capturing individual rects (scroll bar)
                    multiDragElements.forEach(function(multiDragElement) {
                        unsetRect(multiDragElement);
                    });
                    toSortable.animateAll();
                }
                multiDragSortable = toSortable;
            } // Remove clones if necessary
            if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") multiDragClones.forEach(function(clone) {
                clone.parentNode && clone.parentNode.removeChild(clone);
            });
        },
        nullingGlobal: function nullingGlobal() {
            this.isMultiDrag = dragStarted = false;
            multiDragClones.length = 0;
        },
        destroyGlobal: function destroyGlobal() {
            this._deselectMultiDrag();
            off(document, "pointerup", this._deselectMultiDrag);
            off(document, "mouseup", this._deselectMultiDrag);
            off(document, "touchend", this._deselectMultiDrag);
            off(document, "keydown", this._checkKeyDown);
            off(document, "keyup", this._checkKeyUp);
        },
        _deselectMultiDrag: function _deselectMultiDrag(evt) {
            if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable
            if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable
            if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click
            if (evt && evt.button !== 0) return;
            while(multiDragElements.length){
                var el = multiDragElements[0];
                toggleClass(el, this.options.selectedClass, false);
                multiDragElements.shift();
                dispatchEvent({
                    sortable: this.sortable,
                    rootEl: this.sortable.el,
                    name: "deselect",
                    targetEl: el,
                    originalEvt: evt
                });
            }
        },
        _checkKeyDown: function _checkKeyDown(evt) {
            if (evt.key === this.options.multiDragKey) this.multiDragKeyDown = true;
        },
        _checkKeyUp: function _checkKeyUp(evt) {
            if (evt.key === this.options.multiDragKey) this.multiDragKeyDown = false;
        }
    };
    return _extends(MultiDrag, {
        // Static methods & properties
        pluginName: "multiDrag",
        utils: {
            /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */ select: function select(el) {
                var sortable = el.parentNode[expando];
                if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
                if (multiDragSortable && multiDragSortable !== sortable) {
                    multiDragSortable.multiDrag._deselectMultiDrag();
                    multiDragSortable = sortable;
                }
                toggleClass(el, sortable.options.selectedClass, true);
                multiDragElements.push(el);
            },
            /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */ deselect: function deselect(el) {
                var sortable = el.parentNode[expando], index = multiDragElements.indexOf(el);
                if (!sortable || !sortable.options.multiDrag || !~index) return;
                toggleClass(el, sortable.options.selectedClass, false);
                multiDragElements.splice(index, 1);
            }
        },
        eventProperties: function eventProperties() {
            var _this3 = this;
            var oldIndicies = [], newIndicies = [];
            multiDragElements.forEach(function(multiDragElement) {
                oldIndicies.push({
                    multiDragElement: multiDragElement,
                    index: multiDragElement.sortableIndex
                }); // multiDragElements will already be sorted if folding
                var newIndex;
                if (folding && multiDragElement !== dragEl$1) newIndex = -1;
                else if (folding) newIndex = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
                else newIndex = index(multiDragElement);
                newIndicies.push({
                    multiDragElement: multiDragElement,
                    index: newIndex
                });
            });
            return {
                items: _toConsumableArray(multiDragElements),
                clones: [].concat(multiDragClones),
                oldIndicies: oldIndicies,
                newIndicies: newIndicies
            };
        },
        optionListeners: {
            multiDragKey: function multiDragKey(key) {
                key = key.toLowerCase();
                if (key === "ctrl") key = "Control";
                else if (key.length > 1) key = key.charAt(0).toUpperCase() + key.substr(1);
                return key;
            }
        }
    });
}
function insertMultiDragElements(clonesInserted, rootEl) {
    multiDragElements.forEach(function(multiDragElement, i) {
        var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
        if (target) rootEl.insertBefore(multiDragElement, target);
        else rootEl.appendChild(multiDragElement);
    });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */ function insertMultiDragClones(elementsInserted, rootEl) {
    multiDragClones.forEach(function(clone, i) {
        var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
        if (target) rootEl.insertBefore(clone, target);
        else rootEl.appendChild(clone);
    });
}
function removeMultiDragElements() {
    multiDragElements.forEach(function(multiDragElement) {
        if (multiDragElement === dragEl$1) return;
        multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
    });
}
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
exports.default = Sortable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lI6Ao":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("d925b301952a2dd6");
    if (script.__esModule) script = script.default;
    script.render = require("551880ccb9f741cb").render;
    require("64f23dcbe83fa96f").default(script);
    script.__scopeId = "data-v-77a97c";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Module.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "77a97c-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("77a97c-hmr", script)) __VUE_HMR_RUNTIME__.reload("77a97c-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"d925b301952a2dd6":"7Ao8J","551880ccb9f741cb":"etgNz","64f23dcbe83fa96f":"isv3H","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7Ao8J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _editorVue = require("./Editor.vue");
var _editorVueDefault = parcelHelpers.interopDefault(_editorVue);
exports.default = {
    name: "Settings-Module",
    props: {
        module: {
            type: Object,
            required: true
        }
    },
    data () {
        if (!this.module.showInCustom) this.module.showInCustom = "*";
        return {};
    },
    components: {
        Editor: (0, _editorVueDefault.default)
    }
};

},{"./Editor.vue":"3ie54","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3ie54":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("336890592593d4a8");
    if (script.__esModule) script = script.default;
    script.render = require("77c103c1296b78e0").render;
    require("ecf210d5023290e0").default(script);
    script.__scopeId = "data-v-994027";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Editor.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "994027-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("994027-hmr", script)) __VUE_HMR_RUNTIME__.reload("994027-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"336890592593d4a8":"1TNou","77c103c1296b78e0":"1yscZ","ecf210d5023290e0":"5qnCy","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1TNou":[function(require,module,exports) {
// @ts-ignore
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vuePrismEditor = require("vue-prism-editor");
var _prismeditorMinCss = require("vue-prism-editor/dist/prismeditor.min.css"); // import the styles somewhere
// import highlighting library (you can use any library you want just return html string)
// @ts-ignore
var _prismCore = require("prismjs/components/prism-core");
var _prismJson = require("prismjs/components/prism-json");
var _prismYaml = require("prismjs/components/prism-yaml");
var _prismTomorrowCss = require("prismjs/themes/prism-tomorrow.css"); // import syntax highlighting styles
var _utils = require("../../ts/Utils");
exports.default = {
    name: "Editor",
    props: {
        config: {
            type: [
                Object,
                String
            ],
            required: true
        },
        title: {
            type: String,
            required: true
        },
        icon: {
            type: String,
            required: true
        }
    },
    data () {
        const input = typeof this.config === "string" ? this.config : (0, _utils.stringify)(this.config);
        return {
            code: input === "''\n" ? "" : input,
            errorMessage: ""
        };
    },
    watch: {
        code () {
            this.check();
        }
    },
    methods: {
        highlighter (code) {
            // js highlight example
            return (0, _prismCore.highlight)(code, (0, _prismCore.languages).yaml, "yaml");
        },
        check () {
            try {
                const config = (0, _utils.parse)(this.code);
                this.errorMessage = "";
                this.$emit("update:config", config);
            } catch (e) {
                this.errorMessage = e.message;
                this.$emit("update:config", this.code);
            }
        }
    },
    components: {
        PrismEditor: (0, _vuePrismEditor.PrismEditor)
    }
};

},{"vue-prism-editor":"cM1BT","vue-prism-editor/dist/prismeditor.min.css":"bmzr9","prismjs/components/prism-core":"2QbsX","prismjs/components/prism-json":"7ZHuI","prismjs/components/prism-yaml":"9UWIS","prismjs/themes/prism-tomorrow.css":"5uaoy","../../ts/Utils":"j822r","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cM1BT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PrismEditor", ()=>PrismEditor);
var _vue = require("vue");
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var KEYCODE_ENTER = 13;
var KEYCODE_TAB = 9;
var KEYCODE_BACKSPACE = 8;
var KEYCODE_Y = 89;
var KEYCODE_Z = 90;
var KEYCODE_M = 77;
var KEYCODE_PARENS = 57;
var KEYCODE_BRACKETS = 219;
var KEYCODE_QUOTE = 222;
var KEYCODE_BACK_QUOTE = 192;
var KEYCODE_ESCAPE = 27;
var HISTORY_LIMIT = 100;
var HISTORY_TIME_GAP = 3000;
var isWindows = typeof window !== "undefined" && navigator && /*#__PURE__*/ /Win/i.test(navigator.platform);
var isMacLike = typeof window !== "undefined" && navigator && /*#__PURE__*/ /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
var PrismEditor = /*#__PURE__*/ (0, _vue.defineComponent)({
    props: {
        lineNumbers: {
            type: Boolean,
            "default": false
        },
        autoStyleLineNumbers: {
            type: Boolean,
            "default": true
        },
        readonly: {
            type: Boolean,
            "default": false
        },
        modelValue: {
            type: String,
            "default": ""
        },
        highlight: {
            type: Function,
            required: true
        },
        tabSize: {
            type: Number,
            "default": 2
        },
        insertSpaces: {
            type: Boolean,
            "default": true
        },
        ignoreTabKey: {
            type: Boolean,
            "default": false
        },
        placeholder: {
            type: String,
            "default": ""
        }
    },
    data: function data() {
        return {
            capture: true,
            history: {
                stack: [],
                offset: -1
            },
            lineNumbersHeight: "20px",
            codeData: ""
        };
    },
    watch: {
        modelValue: {
            immediate: true,
            handler: function handler(newVal) {
                if (!newVal) this.codeData = "";
                else this.codeData = newVal;
            }
        },
        content: {
            immediate: true,
            handler: function handler() {
                var _this = this;
                if (this.lineNumbers) this.$nextTick(function() {
                    _this.setLineNumbersHeight();
                });
            }
        },
        lineNumbers: function lineNumbers() {
            var _this2 = this;
            this.$nextTick(function() {
                _this2.styleLineNumbers();
                _this2.setLineNumbersHeight();
            });
        }
    },
    computed: {
        isEmpty: function isEmpty() {
            return this.codeData.length === 0;
        },
        content: function content() {
            var result = this.highlight(this.codeData) + "<br />"; // todo: VNode support?
            return result;
        },
        lineNumbersCount: function lineNumbersCount() {
            var totalLines = this.codeData.split(/\r\n|\n/).length;
            return totalLines;
        }
    },
    mounted: function mounted() {
        this._recordCurrentState();
        this.styleLineNumbers();
    },
    methods: {
        setLineNumbersHeight: function setLineNumbersHeight() {
            this.lineNumbersHeight = getComputedStyle(this.$refs.pre).height;
        },
        styleLineNumbers: function styleLineNumbers() {
            if (!this.lineNumbers || !this.autoStyleLineNumbers) return;
            var $editor = this.$refs.pre;
            var $lineNumbers = this.$el.querySelector(".prism-editor__line-numbers");
            var editorStyles = window.getComputedStyle($editor);
            this.$nextTick(function() {
                var btlr = "border-top-left-radius";
                var bblr = "border-bottom-left-radius";
                if (!$lineNumbers) return;
                $lineNumbers.style[btlr] = editorStyles[btlr];
                $lineNumbers.style[bblr] = editorStyles[bblr];
                $editor.style[btlr] = "0";
                $editor.style[bblr] = "0";
                var stylesList = [
                    "background-color",
                    "margin-top",
                    "padding-top",
                    "font-family",
                    "font-size",
                    "line-height"
                ];
                stylesList.forEach(function(style) {
                    $lineNumbers.style[style] = editorStyles[style];
                });
                $lineNumbers.style["margin-bottom"] = "-" + editorStyles["padding-top"];
            });
        },
        _recordCurrentState: function _recordCurrentState() {
            var input = this.$refs.textarea;
            if (!input) return; // Save current state of the input
            var value = input.value, selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;
            this._recordChange({
                value: value,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd
            });
        },
        _getLines: function _getLines(text, position) {
            return text.substring(0, position).split("\n");
        },
        _applyEdits: function _applyEdits(record) {
            // Save last selection state
            var input = this.$refs.textarea;
            var last = this.history.stack[this.history.offset];
            if (last && input) this.history.stack[this.history.offset] = _extends({}, last, {
                selectionStart: input.selectionStart,
                selectionEnd: input.selectionEnd
            });
             // Save the changes
            this._recordChange(record);
            this._updateInput(record);
        },
        _recordChange: function _recordChange(record, overwrite) {
            if (overwrite === void 0) overwrite = false;
            var _this$history = this.history, stack = _this$history.stack, offset = _this$history.offset;
            if (stack.length && offset > -1) {
                // When something updates, drop the redo operations
                this.history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100
                var count = this.history.stack.length;
                if (count > HISTORY_LIMIT) {
                    var extras = count - HISTORY_LIMIT;
                    this.history.stack = stack.slice(extras, count);
                    this.history.offset = Math.max(this.history.offset - extras, 0);
                }
            }
            var timestamp = Date.now();
            if (overwrite) {
                var last = this.history.stack[this.history.offset];
                if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {
                    var _this$_getLines$pop, _this$_getLines$pop2;
                    // A previous entry exists and was in short interval
                    // Match the last word in the line
                    var re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line
                    var previous = (_this$_getLines$pop = this._getLines(last.value, last.selectionStart).pop()) === null || _this$_getLines$pop === void 0 ? void 0 : _this$_getLines$pop.match(re); // Get the current line
                    var current = (_this$_getLines$pop2 = this._getLines(record.value, record.selectionStart).pop()) === null || _this$_getLines$pop2 === void 0 ? void 0 : _this$_getLines$pop2.match(re);
                    if (previous && current && current[1].startsWith(previous[1])) {
                        // The last word of the previous line and current line match
                        // Overwrite previous entry so that undo will remove whole word
                        this.history.stack[this.history.offset] = _extends({}, record, {
                            timestamp: timestamp
                        });
                        return;
                    }
                }
            } // Add the new operation to the stack
            this.history.stack.push(_extends({}, record, {
                timestamp: timestamp
            }));
            this.history.offset++;
        },
        _updateInput: function _updateInput(record) {
            var input = this.$refs.textarea;
            if (!input) return; // Update values and selection state
            input.value = record.value;
            input.selectionStart = record.selectionStart;
            input.selectionEnd = record.selectionEnd;
            this.$emit("update:modelValue", record.value); // this.props.onValueChange(record.value);
        },
        handleChange: function handleChange(e) {
            var _e$target = e.target, value = _e$target.value, selectionStart = _e$target.selectionStart, selectionEnd = _e$target.selectionEnd;
            this._recordChange({
                value: value,
                selectionStart: selectionStart,
                selectionEnd: selectionEnd
            }, true);
            this.$emit("update:modelValue", value); // this.props.onValueChange(value);
        },
        _undoEdit: function _undoEdit() {
            var _this$history2 = this.history, stack = _this$history2.stack, offset = _this$history2.offset; // Get the previous edit
            var record = stack[offset - 1];
            if (record) {
                // Apply the changes and update the offset
                this._updateInput(record);
                this.history.offset = Math.max(offset - 1, 0);
            }
        },
        _redoEdit: function _redoEdit() {
            var _this$history3 = this.history, stack = _this$history3.stack, offset = _this$history3.offset; // Get the next edit
            var record = stack[offset + 1];
            if (record) {
                // Apply the changes and update the offset
                this._updateInput(record);
                this.history.offset = Math.min(offset + 1, stack.length - 1);
            }
        },
        handleKeyDown: function handleKeyDown(e) {
            // console.log(navigator.platform);
            var tabSize = this.tabSize, insertSpaces = this.insertSpaces, ignoreTabKey = this.ignoreTabKey; // onKeyDown(e);
            this.$emit("keydown", e);
            if (e.defaultPrevented) return;
            if (e.keyCode === KEYCODE_ESCAPE) {
                e.target.blur();
                this.$emit("blur", e);
            }
            var _e$target2 = e.target, value = _e$target2.value, selectionStart = _e$target2.selectionStart, selectionEnd = _e$target2.selectionEnd;
            var tabCharacter = (insertSpaces ? " " : "	").repeat(tabSize);
            if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {
                // Prevent focus change
                e.preventDefault();
                if (e.shiftKey) {
                    // Unindent selected lines
                    var linesBeforeCaret = this._getLines(value, selectionStart);
                    var startLine = linesBeforeCaret.length - 1;
                    var endLine = this._getLines(value, selectionEnd).length - 1;
                    var nextValue = value.split("\n").map(function(line, i) {
                        if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) return line.substring(tabCharacter.length);
                        return line;
                    }).join("\n");
                    if (value !== nextValue) {
                        var startLineText = linesBeforeCaret[startLine];
                        this._applyEdits({
                            value: nextValue,
                            // Move the start cursor if first line in selection was modified
                            // It was modified only if it started with a tab
                            selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,
                            // Move the end cursor by total number of characters removed
                            selectionEnd: selectionEnd - (value.length - nextValue.length)
                        });
                    }
                } else if (selectionStart !== selectionEnd) {
                    // Indent selected lines
                    var _linesBeforeCaret = this._getLines(value, selectionStart);
                    var _startLine = _linesBeforeCaret.length - 1;
                    var _endLine = this._getLines(value, selectionEnd).length - 1;
                    var _startLineText = _linesBeforeCaret[_startLine];
                    this._applyEdits({
                        value: value.split("\n").map(function(line, i) {
                            if (i >= _startLine && i <= _endLine) return tabCharacter + line;
                            return line;
                        }).join("\n"),
                        // Move the start cursor by number of characters added in first line of selection
                        // Don't move it if it there was no text before cursor
                        selectionStart: /\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,
                        // Move the end cursor by total number of characters added
                        selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)
                    });
                } else {
                    var updatedSelection = selectionStart + tabCharacter.length;
                    this._applyEdits({
                        // Insert tab character at caret
                        value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),
                        // Update caret position
                        selectionStart: updatedSelection,
                        selectionEnd: updatedSelection
                    });
                }
            } else if (e.keyCode === KEYCODE_BACKSPACE) {
                var hasSelection = selectionStart !== selectionEnd;
                var textBeforeCaret = value.substring(0, selectionStart);
                if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {
                    // Prevent default delete behaviour
                    e.preventDefault();
                    var _updatedSelection = selectionStart - tabCharacter.length;
                    this._applyEdits({
                        // Remove tab character at caret
                        value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),
                        // Update caret position
                        selectionStart: _updatedSelection,
                        selectionEnd: _updatedSelection
                    });
                }
            } else if (e.keyCode === KEYCODE_ENTER) // Ignore selections
            {
                if (selectionStart === selectionEnd) {
                    // Get the current line
                    var line = this._getLines(value, selectionStart).pop();
                    var matches = line === null || line === void 0 ? void 0 : line.match(/^\s+/);
                    if (matches && matches[0]) {
                        e.preventDefault(); // Preserve indentation on inserting a new line
                        var indent = "\n" + matches[0];
                        var _updatedSelection2 = selectionStart + indent.length;
                        this._applyEdits({
                            // Insert indentation character at caret
                            value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),
                            // Update caret position
                            selectionStart: _updatedSelection2,
                            selectionEnd: _updatedSelection2
                        });
                    }
                }
            } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {
                var chars;
                if (e.keyCode === KEYCODE_PARENS && e.shiftKey) chars = [
                    "(",
                    ")"
                ];
                else if (e.keyCode === KEYCODE_BRACKETS) {
                    if (e.shiftKey) chars = [
                        "{",
                        "}"
                    ];
                    else chars = [
                        "[",
                        "]"
                    ];
                } else if (e.keyCode === KEYCODE_QUOTE) {
                    if (e.shiftKey) chars = [
                        '"',
                        '"'
                    ];
                    else chars = [
                        "'",
                        "'"
                    ];
                } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) chars = [
                    "`",
                    "`"
                ];
                 // console.log(isMacLike, "navigator" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));
                // If text is selected, wrap them in the characters
                if (selectionStart !== selectionEnd && chars) {
                    e.preventDefault();
                    this._applyEdits({
                        value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),
                        // Update caret position
                        selectionStart: selectionStart,
                        selectionEnd: selectionEnd + 2
                    });
                }
            } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z : e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {
                e.preventDefault();
                this._undoEdit();
            } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? e.ctrlKey && e.keyCode === KEYCODE_Y : e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {
                e.preventDefault();
                this._redoEdit();
            } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {
                e.preventDefault(); // Toggle capturing tab key so users can focus away
                this.capture = !this.capture;
            }
        }
    },
    render: function render() {
        var _this3 = this;
        var lineNumberWidthCalculator = (0, _vue.h)("div", {
            "class": "prism-editor__line-width-calc",
            style: "height: 0px; visibility: hidden; pointer-events: none;"
        }, "999");
        var lineNumbers = (0, _vue.h)("div", {
            "class": "prism-editor__line-numbers",
            style: {
                "min-height": this.lineNumbersHeight
            },
            "aria-hidden": "true"
        }, [
            lineNumberWidthCalculator,
            Array.from(Array(this.lineNumbersCount).keys()).map(function(_, index) {
                return (0, _vue.h)("div", {
                    "class": "prism-editor__line-number token comment"
                }, "" + ++index);
            })
        ]);
        var textarea = (0, _vue.h)("textarea", {
            ref: "textarea",
            onInput: this.handleChange,
            onKeydown: this.handleKeyDown,
            onClick: function onClick($event) {
                _this3.$emit("click", $event);
            },
            onKeyup: function onKeyup($event) {
                _this3.$emit("keyup", $event);
            },
            onFocus: function onFocus($event) {
                _this3.$emit("focus", $event);
            },
            onBlur: function onBlur($event) {
                _this3.$emit("blur", $event);
            },
            "class": {
                "prism-editor__textarea": true,
                "prism-editor__textarea--empty": this.isEmpty
            },
            spellCheck: "false",
            autocapitalize: "off",
            autocomplete: "off",
            autocorrect: "off",
            "data-gramm": "false",
            placeholder: this.placeholder,
            "data-testid": "textarea",
            readonly: this.readonly,
            value: this.codeData
        });
        var preview = (0, _vue.h)("pre", {
            ref: "pre",
            "class": "prism-editor__editor",
            "data-testid": "preview",
            innerHTML: this.content
        });
        var editorContainer = (0, _vue.h)("div", {
            "class": "prism-editor__container"
        }, [
            textarea,
            preview
        ]);
        return (0, _vue.h)("div", {
            "class": "prism-editor-wrapper"
        }, [
            this.lineNumbers && lineNumbers,
            editorContainer
        ]);
    }
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bmzr9":[function() {},{}],"2QbsX":[function(require,module,exports) {
/// <reference lib="WebWorker"/>
var global = arguments[3];
var _self = typeof window !== "undefined" ? window // if in browser
 : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self // if in worker
 : {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var Prism = function(_self) {
    // Private helper vars
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    // The grammar object for plaintext
    var plainTextGrammar = {};
    var _ = {
        /**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ manual: _self.Prism && _self.Prism.manual,
        /**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        /**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */ util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) return new Token(tokens.type, encode(tokens.content), tokens.alias);
                else if (Array.isArray(tokens)) return tokens.map(encode);
                else return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            /**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */ type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */ objId: function(obj) {
                if (!obj["__id"]) Object.defineProperty(obj, "__id", {
                    value: ++uniqueId
                });
                return obj["__id"];
            },
            /**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */ clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone;
                var id;
                switch(_.util.type(o)){
                    case "Object":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = /** @type {Record<string, any>} */ {};
                        visited[id] = clone;
                        for(var key in o)if (o.hasOwnProperty(key)) clone[key] = deepClone(o[key], visited);
                        return /** @type {any} */ clone;
                    case "Array":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = [];
                        visited[id] = clone;
                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {
                            clone[i] = deepClone(v, visited);
                        });
                        return /** @type {any} */ clone;
                    default:
                        return o;
                }
            },
            /**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */ getLanguage: function(element) {
                while(element){
                    var m = lang.exec(element.className);
                    if (m) return m[1].toLowerCase();
                    element = element.parentElement;
                }
                return "none";
            },
            /**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */ setLanguage: function(element, language) {
                // remove all `language-xxxx` classes
                // (this might leave behind a leading space)
                element.className = element.className.replace(RegExp(lang, "gi"), "");
                // add the new `language-xxxx` class
                // (using `classList` will automatically clean up spaces for us)
                element.classList.add("language-" + language);
            },
            /**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */ currentScript: function() {
                if (typeof document === "undefined") return null;
                if ("currentScript" in document && true /* hack to trip TS' flow analysis */ ) return /** @type {any} */ document.currentScript;
                // IE11 workaround
                // we'll get the src of the current script by parsing IE11's error stack trace
                // this will not work for inline scripts
                try {
                    throw new Error();
                } catch (err) {
                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                    // A stack will look like this:
                    //
                    // Error
                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for(var i in scripts){
                            if (scripts[i].src == src) return scripts[i];
                        }
                    }
                    return null;
                }
            },
            /**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */ isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while(element){
                    var classList = element.classList;
                    if (classList.contains(className)) return true;
                    if (classList.contains(no)) return false;
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        /**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ languages: {
            /**
			 * The grammar for plain, unformatted text.
			 */ plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */ extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for(var key in redef)lang[key] = redef[key];
                return lang;
            },
            /**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */ insertBefore: function(inside, before, insert, root) {
                root = root || /** @type {any} */ _.languages;
                var grammar = root[inside];
                /** @type {Grammar} */ var ret = {};
                for(var token in grammar)if (grammar.hasOwnProperty(token)) {
                    if (token == before) {
                        for(var newToken in insert)if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];
                    }
                    // Do not insert token which also occur in insert. See #1525
                    if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];
                }
                var old = root[inside];
                root[inside] = ret;
                // Update references in other language definitions
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) this[key] = ret;
                });
                return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for(var i in o)if (o.hasOwnProperty(i)) {
                    callback.call(o, i, o[i], type || i);
                    var property = o[i];
                    var propertyType = _.util.type(property);
                    if (propertyType === "Object" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, null, visited);
                    } else if (propertyType === "Array" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, i, visited);
                    }
                }
            }
        },
        plugins: {},
        /**
		 * This is the most high-level function in Prism‚Äôs API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */ highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        /**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */ highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for(var i = 0, element; element = env.elements[i++];)_.highlightElement(element, async === true, env.callback);
        },
        /**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */ highlightElement: function(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            // Set language on the element, if not present
            _.util.setLanguage(element, language);
            // Set language on the parent, for styling
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") _.util.setLanguage(parent, language);
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            // plugins may change/add the parent/element
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) parent.setAttribute("tabindex", "0");
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        },
        /**
		 * Low-level function, only use if you know what you‚Äôre doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */ highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) throw new Error('The language "' + env.language + '" has no grammar.');
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */ tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for(var token in rest)grammar[token] = rest[token];
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        /**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ hooks: {
            all: {},
            /**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */ add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            /**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */ run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) return;
                for(var i = 0, callback; callback = callbacks[i++];)callback(env);
            }
        },
        Token: Token
    };
    _self.Prism = _;
    // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
    /**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */ function Token(type, content, alias, matchedStr) {
        /**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */ this.type = type;
        /**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */ this.content = content;
        /**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */ this.alias = alias;
        // Copy of the full string this token was created from
        this.length = (matchedStr || "").length | 0;
    }
    /**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */ /**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */ Token.stringify = function stringify(o, language) {
        if (typeof o == "string") return o;
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [
                "token",
                o.type
            ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) Array.prototype.push.apply(env.classes, aliases);
            else env.classes.push(aliases);
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for(var name in env.attributes)attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    /**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */ function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    /**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for(var token in grammar){
            if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [
                patterns
            ];
            for(var j = 0; j < patterns.length; ++j){
                if (rematch && rematch.cause == token + "," + j) return;
                var patternObj = patterns[j];
                var inside = patternObj.inside;
                var lookbehind = !!patternObj.lookbehind;
                var greedy = !!patternObj.greedy;
                var alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    // Without the global flag, lastIndex won't work
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;
                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){
                    if (rematch && pos >= rematch.reach) break;
                    var str = currentNode.value;
                    if (tokenList.length > text.length) // Something went terribly wrong, ABORT, ABORT!
                    return;
                    if (str instanceof Token) continue;
                    var removeCount = 1; // this is the to parameter of removeBetween
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match || match.index >= text.length) break;
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        // find the node that contains the match
                        p += currentNode.value.length;
                        while(from >= p){
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        // adjust pos (and p)
                        p -= currentNode.value.length;
                        pos = p;
                        // the current node is a Token, then the match starts inside another Token, which is invalid
                        if (currentNode.value instanceof Token) continue;
                        // find the last node which is affected by this match
                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next){
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        // replace with the new match
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) continue;
                    }
                    // eslint-disable-next-line no-redeclare
                    var from = match.index;
                    var matchStr = match[0];
                    var before = str.slice(0, from);
                    var after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) rematch.reach = reach;
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) addAfter(tokenList, currentNode, after);
                    if (removeCount > 1) {
                        // at least one Token object was removed, so we have to do some rematching
                        // this can only happen if the current pattern is greedy
                        /** @type {RematchOptions} */ var nestedRematch = {
                            cause: token + "," + j,
                            reach: reach
                        };
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                        // the reach might have been extended because of the rematching
                        if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;
                    }
                }
            }
        }
    }
    /**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */ /**
	 * @template T
	 * @private
	 */ function LinkedList() {
        /** @type {LinkedListNode<T>} */ var head = {
            value: null,
            prev: null,
            next: null
        };
        /** @type {LinkedListNode<T>} */ var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        /** @type {LinkedListNode<T>} */ this.head = head;
        /** @type {LinkedListNode<T>} */ this.tail = tail;
        this.length = 0;
    }
    /**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */ function addAfter(list, node, value) {
        // assumes that node != list.tail && values.length >= 0
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    /**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */ function removeRange(list, node, count) {
        var next = node.next;
        for(var i = 0; i < count && next !== list.tail; i++)next = next.next;
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    /**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */ function toArray(list) {
        var array = [];
        var node = list.head.next;
        while(node !== list.tail){
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self.document) {
        if (!_self.addEventListener) // in Node.js
        return _;
        if (!_.disableWorkerMessageHandler) // In worker
        _self.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self.postMessage(_.highlight(code, _.languages[lang], lang));
            if (immediateClose) _self.close();
        }, false);
        return _;
    }
    // Get current script and highlight
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) _.manual = true;
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) _.highlightAll();
    }
    if (!_.manual) {
        // If the document state is "loading", then we'll use DOMContentLoaded.
        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
        // might take longer one animation frame to execute which can create a race condition where only some plugins have
        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
        // See https://github.com/PrismJS/prism/issues/2102
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        else if (window.requestAnimationFrame) window.requestAnimationFrame(highlightAutomaticallyCallback);
        else window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
}(_self);
if (0, module.exports) module.exports = Prism;
// hack for components to work correctly in node.js
if (typeof global !== "undefined") global.Prism = Prism;
 // some additional documentation/types
 /**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */  /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */  /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */  /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */ 

},{}],"7ZHuI":[function(require,module,exports) {
// https://www.json.org/json-en.html
Prism.languages.json = {
    "property": {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: true,
        greedy: true
    },
    "string": {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: true,
        greedy: true
    },
    "comment": {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
    },
    "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    "punctuation": /[{}[\],]/,
    "operator": /:/,
    "boolean": /\b(?:false|true)\b/,
    "null": {
        pattern: /\bnull\b/,
        alias: "keyword"
    }
};
Prism.languages.webmanifest = Prism.languages.json;

},{}],"9UWIS":[function(require,module,exports) {
(function(Prism1) {
    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
    var anchorOrAlias = /[*&][^\s[\]{},]+/;
    // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
    var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
    // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
    var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
    // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
    // This is a simplified version that doesn't support "#" and multiline keys
    // All these long scarry character classes are simplified versions of YAML's characters
    var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
        return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    });
    var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    /**
	 *
	 * @param {string} value
	 * @param {string} [flags]
	 * @returns {RegExp}
	 */ function createValuePattern(value, flags) {
        flags = (flags || "").replace(/m/g, "") + "m"; // add m flag
        var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
            return properties;
        }).replace(/<<value>>/g, function() {
            return value;
        });
        return RegExp(pattern, flags);
    }
    Prism1.languages.yaml = {
        "scalar": {
            pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
                return properties;
            })),
            lookbehind: true,
            alias: "string"
        },
        "comment": /#.*/,
        "key": {
            pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                return properties;
            }).replace(/<<key>>/g, function() {
                return "(?:" + plainKey + "|" + string + ")";
            })),
            lookbehind: true,
            greedy: true,
            alias: "atrule"
        },
        "directive": {
            pattern: /(^[ \t]*)%.+/m,
            lookbehind: true,
            alias: "important"
        },
        "datetime": {
            pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
            lookbehind: true,
            alias: "number"
        },
        "boolean": {
            pattern: createValuePattern(/false|true/.source, "i"),
            lookbehind: true,
            alias: "important"
        },
        "null": {
            pattern: createValuePattern(/null|~/.source, "i"),
            lookbehind: true,
            alias: "important"
        },
        "string": {
            pattern: createValuePattern(string),
            lookbehind: true,
            greedy: true
        },
        "number": {
            pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
            lookbehind: true
        },
        "tag": tag,
        "important": anchorOrAlias,
        "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
    };
    Prism1.languages.yml = Prism1.languages.yaml;
})(Prism);

},{}],"5uaoy":[function() {},{}],"1yscZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_expansion_panel_title = (0, _vue.resolveComponent)("v-expansion-panel-title");
    const _component_v_divider = (0, _vue.resolveComponent)("v-divider");
    const _component_prism_editor = (0, _vue.resolveComponent)("prism-editor");
    const _component_v_expansion_panel_text = (0, _vue.resolveComponent)("v-expansion-panel-text");
    const _component_v_expansion_panel = (0, _vue.resolveComponent)("v-expansion-panel");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_expansion_panel, null, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_expansion_panel_title, null, {
                    actions: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_icon, {
                                style: (0, _vue.normalizeStyle)($data.errorMessage ? "color: red;" : "")
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)($props.icon), 1 /* TEXT */ )
                                    ]),
                                _: 1 /* STABLE */ 
                            }, 8 /* PROPS */ , [
                                "style"
                            ])
                        ]),
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)($props.title) + " ", 1 /* TEXT */ )
                        ]),
                    _: 1 /* STABLE */ 
                }),
                (0, _vue.createVNode)(_component_v_expansion_panel_text, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createElementVNode)("div", {
                                style: (0, _vue.normalizeStyle)([
                                    {
                                        "font-size": "small",
                                        "margin-bottom": "0.25rem"
                                    },
                                    $data.errorMessage ? "color: red;" : "color: gray;"
                                ])
                            }, (0, _vue.toDisplayString)($data.errorMessage || "Valid YAML or JSON configuration"), 5 /* TEXT, STYLE */ ),
                            (0, _vue.createVNode)(_component_v_divider, {
                                style: {
                                    "margin-bottom": "0.5rem"
                                }
                            }),
                            (0, _vue.createVNode)(_component_prism_editor, {
                                modelValue: $data.code,
                                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$data.code = $event),
                                highlight: $options.highlighter,
                                "line-numbers": ""
                            }, null, 8 /* PROPS */ , [
                                "modelValue",
                                "highlight"
                            ])
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("994027-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5qnCy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"etgNz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_expansion_panel_title = (0, _vue.resolveComponent)("v-expansion-panel-title");
    const _component_v_text_field = (0, _vue.resolveComponent)("v-text-field");
    const _component_v_expansion_panel_text = (0, _vue.resolveComponent)("v-expansion-panel-text");
    const _component_v_expansion_panel = (0, _vue.resolveComponent)("v-expansion-panel");
    const _component_Editor = (0, _vue.resolveComponent)("Editor");
    const _component_v_expansion_panels = (0, _vue.resolveComponent)("v-expansion-panels");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_expansion_panels, {
        variant: "accordion",
        style: {
            "min-width": "400px"
        }
    }, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_expansion_panel, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_expansion_panel_title, null, {
                                actions: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_icon, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createTextVNode)(" mdi-link ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" URL ")
                                    ]),
                                _: 1 /* STABLE */ 
                            }),
                            (0, _vue.createVNode)(_component_v_expansion_panel_text, null, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_text_field, {
                                            variant: "underlined",
                                            label: "Module URL",
                                            modelValue: $props.module.url,
                                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$props.module.url = $event)
                                        }, null, 8 /* PROPS */ , [
                                            "modelValue"
                                        ])
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                }),
                (0, _vue.createVNode)(_component_Editor, {
                    title: "General settings",
                    icon: "mdi-script-text",
                    config: $props.module.config,
                    "onUpdate:config": _cache[1] || (_cache[1] = ($event)=>$props.module.config = $event)
                }, null, 8 /* PROPS */ , [
                    "config"
                ]),
                (0, _vue.createVNode)(_component_Editor, {
                    title: "Student settings",
                    icon: "mdi-account-circle-outline",
                    config: $props.module.studentConfig,
                    "onUpdate:config": _cache[2] || (_cache[2] = ($event)=>$props.module.studentConfig = $event)
                }, null, 8 /* PROPS */ , [
                    "config"
                ]),
                (0, _vue.createVNode)(_component_Editor, {
                    title: "Teacher settings",
                    icon: "mdi-clipboard-account-outline",
                    config: $props.module.teacherConfig,
                    "onUpdate:config": _cache[3] || (_cache[3] = ($event)=>$props.module.teacherConfig = $event)
                }, null, 8 /* PROPS */ , [
                    "config"
                ]),
                (0, _vue.createVNode)(_component_Editor, {
                    title: "Station settings",
                    icon: "mdi-router-wireless",
                    config: $props.module.stationConfig,
                    "onUpdate:config": _cache[4] || (_cache[4] = ($event)=>$props.module.stationConfig = $event)
                }, null, 8 /* PROPS */ , [
                    "config"
                ]),
                (0, _vue.createVNode)(_component_v_expansion_panel, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_expansion_panel_title, null, {
                                actions: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_icon, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createTextVNode)(" mdi-eye ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)(" Show in ")
                                    ]),
                                _: 1 /* STABLE */ 
                            }),
                            (0, _vue.createVNode)(_component_v_expansion_panel_text, null, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_text_field, {
                                            variant: "underlined",
                                            label: "Comma separated list of rooms, or: lobby, * for all, teacher-only, station",
                                            modelValue: $props.module.showInCustom,
                                            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event)=>$props.module.showInCustom = $event)
                                        }, null, 8 /* PROPS */ , [
                                            "modelValue"
                                        ])
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("77a97c-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"isv3H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"39aO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_chip = (0, _vue.resolveComponent)("v-chip");
    const _component_v_list_item_title = (0, _vue.resolveComponent)("v-list-item-title");
    const _component_v_list_item_subtitle = (0, _vue.resolveComponent)("v-list-item-subtitle");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_Module = (0, _vue.resolveComponent)("Module");
    const _component_v_menu = (0, _vue.resolveComponent)("v-menu");
    const _component_v_list_item = (0, _vue.resolveComponent)("v-list-item");
    const _component_draggable = (0, _vue.resolveComponent)("draggable");
    const _component_v_text_field = (0, _vue.resolveComponent)("v-text-field");
    const _component_v_list = (0, _vue.resolveComponent)("v-list");
    const _component_v_divider = (0, _vue.resolveComponent)("v-divider");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        (0, _vue.createVNode)(_component_v_list, {
            lines: "three"
        }, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createVNode)(_component_draggable, {
                        list: $props.config.modules,
                        "item-key": "id",
                        onEnd: $options.move,
                        class: "list-group"
                    }, {
                        item: (0, _vue.withCtx)(({ element, index })=>[
                                ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_list_item, {
                                    key: index,
                                    class: "list-group-item"
                                }, {
                                    prepend: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_icon, {
                                                icon: $props.scrapedModules[index].icon || "mdi-package"
                                            }, null, 8 /* PROPS */ , [
                                                "icon"
                                            ])
                                        ]),
                                    append: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_menu, {
                                                "close-on-content-click": false
                                            }, {
                                                activator: (0, _vue.withCtx)(({ props })=>[
                                                        (0, _vue.createVNode)(_component_v_btn, (0, _vue.mergeProps)({
                                                            icon: "mdi-cog",
                                                            variant: "text"
                                                        }, props), null, 16 /* FULL_PROPS */ )
                                                    ]),
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createVNode)(_component_Module, {
                                                            id_: index,
                                                            module: element
                                                        }, null, 8 /* PROPS */ , [
                                                            "id_",
                                                            "module"
                                                        ])
                                                    ]),
                                                _: 2 /* DYNAMIC */ 
                                            }, 1024 /* DYNAMIC_SLOTS */ ),
                                            (0, _vue.createVNode)(_component_v_btn, {
                                                icon: "mdi-delete",
                                                variant: "text"
                                            })
                                        ]),
                                    default: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_list_item_title, null, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createTextVNode)((0, _vue.toDisplayString)($props.scrapedModules[index].name) + " ", 1 /* TEXT */ ),
                                                        (0, _vue.createVNode)(_component_v_chip, {
                                                            size: "x-small"
                                                        }, {
                                                            default: (0, _vue.withCtx)(()=>[
                                                                    (0, _vue.createTextVNode)((0, _vue.toDisplayString)(element.showInCustom || "*"), 1 /* TEXT */ )
                                                                ]),
                                                            _: 2 /* DYNAMIC */ 
                                                        }, 1024 /* DYNAMIC_SLOTS */ )
                                                    ]),
                                                _: 2 /* DYNAMIC */ 
                                            }, 1024 /* DYNAMIC_SLOTS */ ),
                                            (0, _vue.createVNode)(_component_v_list_item_subtitle, {
                                                innerHTML: $props.scrapedModules[index].description,
                                                style: {
                                                    "white-space": "break-spaces"
                                                }
                                            }, null, 8 /* PROPS */ , [
                                                "innerHTML"
                                            ])
                                        ]),
                                    _: 2 /* DYNAMIC */ 
                                }, 1024 /* DYNAMIC_SLOTS */ ))
                            ]),
                        _: 1 /* STABLE */ 
                    }, 8 /* PROPS */ , [
                        "list",
                        "onEnd"
                    ]),
                    (0, _vue.createVNode)(_component_v_list_item, null, {
                        prepend: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_icon, {
                                    icon: "mdi-link"
                                })
                            ]),
                        append: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_btn, {
                                    onClick: $options.loadURL,
                                    disabled: !$options.validate_url($data.moduleImportUrl)
                                }, {
                                    default: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_icon, {
                                                left: ""
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createTextVNode)(" mdi-view-grid-plus ")
                                                    ]),
                                                _: 1 /* STABLE */ 
                                            }),
                                            (0, _vue.createTextVNode)(" Add ")
                                        ]),
                                    _: 1 /* STABLE */ 
                                }, 8 /* PROPS */ , [
                                    "onClick",
                                    "disabled"
                                ])
                            ]),
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_text_field, {
                                    modelValue: $data.moduleImportUrl,
                                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event)=>$data.moduleImportUrl = $event),
                                    label: "Module URL",
                                    variant: "underlined",
                                    required: "",
                                    style: {
                                        "width": "calc(100% - 40px)"
                                    }
                                }, null, 8 /* PROPS */ , [
                                    "modelValue"
                                ])
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ]),
            _: 1 /* STABLE */ 
        }),
        (0, _vue.createVNode)(_component_v_divider, {
            class: "pb-2"
        }),
        (0, _vue.createVNode)(_component_v_btn, {
            href: "https://github.com/topics/edrys-module",
            target: "_blank"
        }, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createVNode)(_component_v_icon, {
                        left: ""
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" mdi-github ")
                            ]),
                        _: 1 /* STABLE */ 
                    }),
                    (0, _vue.createTextVNode)(" Explore on GitHub ")
                ]),
            _: 1 /* STABLE */ 
        })
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("e5658a-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ci6rT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"haH5e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("9850eabe18cda82d");
    if (script.__esModule) script = script.default;
    script.render = require("a1068a92f3dd8a21").render;
    require("b4ca89b663104ad8").default(script);
    script.__scopeId = "data-v-5a47f3";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Stations.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "5a47f3-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("5a47f3-hmr", script)) __VUE_HMR_RUNTIME__.reload("5a47f3-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"9850eabe18cda82d":"d9cgf","a1068a92f3dd8a21":"f8IDR","b4ca89b663104ad8":"8Zo8H","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"d9cgf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../../ts/Utils");
exports.default = {
    name: "Settings-Stations",
    props: {
        config: {
            type: Object,
            required: true
        }
    },
    data () {
        return {
            url: window.location.toString().replace("classroom", "station")
        };
    },
    methods: {
        copyUrl () {
            (0, _utils.copyUrl)(this.url);
        }
    }
};

},{"../../ts/Utils":"j822r","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"f8IDR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = [
    "href"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_container = (0, _vue.resolveComponent)("v-container");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_alert = (0, _vue.resolveComponent)("v-alert");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_alert, {
        outlined: "",
        dense: "",
        type: "info",
        text: "To add a new station, simply open this link on the client device: "
    }, {
        append: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_btn, {
                    icon: "mdi-content-copy",
                    onClick: $options.copyUrl,
                    variant: "text"
                }, null, 8 /* PROPS */ , [
                    "onClick"
                ])
            ]),
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_container, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createElementVNode)("a", {
                                href: $data.url,
                                target: "_blank"
                            }, (0, _vue.toDisplayString)($data.url), 9 /* TEXT, PROPS */ , _hoisted_1)
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("5a47f3-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8Zo8H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jIHxD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("42d919796223136b");
    if (script.__esModule) script = script.default;
    script.render = require("4513ce1e082125a").render;
    require("45cd58fe57a56fa5").default(script);
    script.__scopeId = "data-v-caf937";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Settings/Share.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "caf937-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("caf937-hmr", script)) __VUE_HMR_RUNTIME__.reload("caf937-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"42d919796223136b":"gaBcg","4513ce1e082125a":"iNdx8","45cd58fe57a56fa5":"hAVST","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gaBcg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _jsYaml = require("js-yaml");
var _utils = require("../../ts/Utils");
exports.default = {
    name: "Settings-Share",
    props: {
        config: {
            type: Object,
            required: true
        }
    },
    data () {
        console.log("Classroom config", JSON.stringify(this.config, null, 2));
        return {
            url: window.location.toString(),
            selectedURL: "",
            selectedFile: [],
            restoreSuccess: false,
            saveError: false,
            errorMessage: "",
            restoreFileRules: [
                (value)=>!value || value.size < 2000000 || "File should be less than 2 MB!"
            ]
        };
    },
    methods: {
        updateConfig (newConfig) {
            if (!newConfig.meta) newConfig.meta = {
                logo: "",
                description: "",
                selfAssign: false,
                defaultNumberOfRooms: 0
            };
            this.config.name = newConfig.name;
            this.config.createdBy = newConfig.createdBy;
            this.config.meta = newConfig.meta;
            this.config.createdBy = newConfig.createdBy;
            this.config.dateCreated = newConfig.dateCreated;
            this.config.members = newConfig.members;
            this.config.modules = newConfig.modules;
        },
        updateModules () {
            console.warn("updateModules", this.scrapedModules);
        },
        downloadClass (format) {
            const data = format === "yaml" ? _jsYaml.dump(this.config) : JSON.stringify(this.config, null, 2);
            const name = "class-" + this.config.id + (format === "yaml" ? ".yml" : ".json");
            const blob = new Blob([
                data
            ], {
                type: "text/" + format
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = name;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        },
        async restoreURL () {
            this.restoreSuccess = false;
            this.saveError = false;
            const response = await fetch(this.selectedURL);
            if (response.ok) {
                const text = await response.text();
                const newClass = (0, _utils.parseClassroom)(text);
                if (newClass) {
                    this.updateConfig(newClass);
                    this.restoreSuccess = true;
                    return;
                }
            }
            this.saveError = true;
            this.errorMessage = `Could not parse the content within the URL: ${this.selectedURL}`;
            console.warn("Could not parse the content within the URL:", this.selectedURL);
        },
        restoreFile () {
            this.restoreSuccess = false;
            this.saveError = false;
            const reader = new FileReader();
            reader.readAsText(this.selectedFile[0]);
            reader.onload = (res)=>{
                // will load yaml and json as well
                const newClass = (0, _utils.parseClassroom)(reader.result?.toString() || "");
                if (newClass) {
                    //this.updateState(newClass);
                    this.updateConfig(newClass);
                    this.restoreSuccess = true;
                } else {
                    this.restoreSuccess = false;
                    this.saveError = true;
                    this.errorMessage = `Failed to restore classroom configuration from file.`;
                    console.warn("restoreFile: failed to load class", newClass);
                }
            };
            reader.onerror = (err)=>{
                this.restoreSuccess = false;
                this.saveError = true;
                console.warn("restoreFile", err);
            };
        }
    },
    computed: {
        selectedURLIcon () {
            return this.selectedURL ? "mdi-upload" : "mdi-link";
        },
        selectedFileIcon () {
            return this.selectedFile[0] !== undefined ? "mdi-upload" : "mdi-file";
        }
    }
};

},{"js-yaml":"9ulSV","../../ts/Utils":"j822r","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iNdx8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_col = (0, _vue.resolveComponent)("v-col");
    const _component_v_row = (0, _vue.resolveComponent)("v-row");
    const _component_v_file_input = (0, _vue.resolveComponent)("v-file-input");
    const _component_v_text_field = (0, _vue.resolveComponent)("v-text-field");
    const _component_v_divider = (0, _vue.resolveComponent)("v-divider");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)((0, _vue.Fragment), null, [
        (0, _vue.createVNode)(_component_v_row, null, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createVNode)(_component_v_col, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_btn, {
                                    depressed: "",
                                    block: "",
                                    onClick: _cache[0] || (_cache[0] = ($event)=>$options.downloadClass("yaml"))
                                }, {
                                    default: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_icon, {
                                                left: ""
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createTextVNode)(" mdi-download ")
                                                    ]),
                                                _: 1 /* STABLE */ 
                                            }),
                                            (0, _vue.createTextVNode)(" Download class file (.yml) ")
                                        ]),
                                    _: 1 /* STABLE */ 
                                })
                            ]),
                        _: 1 /* STABLE */ 
                    }),
                    (0, _vue.createVNode)(_component_v_col, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_btn, {
                                    depressed: "",
                                    block: "",
                                    onClick: _cache[1] || (_cache[1] = ($event)=>$options.downloadClass("json"))
                                }, {
                                    default: (0, _vue.withCtx)(()=>[
                                            (0, _vue.createVNode)(_component_v_icon, {
                                                left: ""
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createTextVNode)(" mdi-download ")
                                                    ]),
                                                _: 1 /* STABLE */ 
                                            }),
                                            (0, _vue.createTextVNode)(" Download class file (.json) ")
                                        ]),
                                    _: 1 /* STABLE */ 
                                })
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ]),
            _: 1 /* STABLE */ 
        }),
        (0, _vue.createVNode)(_component_v_row, null, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createVNode)(_component_v_col, {
                        fluid: ""
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_file_input, {
                                    dense: "",
                                    accept: ".yml,.yaml,.json,application/yaml,application/json",
                                    label: "Restore class from file (yaml, json)",
                                    modelValue: $data.selectedFile,
                                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>$data.selectedFile = $event),
                                    "prepend-icon": $options.selectedFileIcon,
                                    "onClick:prepend": $options.restoreFile
                                }, null, 8 /* PROPS */ , [
                                    "modelValue",
                                    "prepend-icon",
                                    "onClick:prepend"
                                ])
                            ]),
                        _: 1 /* STABLE */ 
                    }),
                    (0, _vue.createVNode)(_component_v_col, null, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createVNode)(_component_v_text_field, {
                                    dense: "",
                                    label: "Restore class from URL (http, https)",
                                    modelValue: $data.selectedURL,
                                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event)=>$data.selectedURL = $event),
                                    "prepend-icon": $options.selectedURLIcon,
                                    "onClick:prepend": $options.restoreURL
                                }, null, 8 /* PROPS */ , [
                                    "modelValue",
                                    "prepend-icon",
                                    "onClick:prepend"
                                ])
                            ]),
                        _: 1 /* STABLE */ 
                    })
                ]),
            _: 1 /* STABLE */ 
        }),
        (0, _vue.createVNode)(_component_v_divider, {
            class: "pb-2"
        }),
        (0, _vue.createVNode)(_component_v_btn, {
            href: "https://github.com/topics/edrys-classroom",
            target: "_blank"
        }, {
            default: (0, _vue.withCtx)(()=>[
                    (0, _vue.createVNode)(_component_v_icon, {
                        left: ""
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" mdi-github ")
                            ]),
                        _: 1 /* STABLE */ 
                    }),
                    (0, _vue.createTextVNode)(" Explore on GitHub ")
                ]),
            _: 1 /* STABLE */ 
        })
    ], 64 /* STABLE_FRAGMENT */ );
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("caf937-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hAVST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5wQVR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_toolbar_title = (0, _vue.resolveComponent)("v-toolbar-title");
    const _component_v_spacer = (0, _vue.resolveComponent)("v-spacer");
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_tab = (0, _vue.resolveComponent)("v-tab");
    const _component_v_tabs = (0, _vue.resolveComponent)("v-tabs");
    const _component_v_toolbar = (0, _vue.resolveComponent)("v-toolbar");
    const _component_Main = (0, _vue.resolveComponent)("Main");
    const _component_v_window_item = (0, _vue.resolveComponent)("v-window-item");
    const _component_Members = (0, _vue.resolveComponent)("Members");
    const _component_Modules = (0, _vue.resolveComponent)("Modules");
    const _component_Stations = (0, _vue.resolveComponent)("Stations");
    const _component_Share = (0, _vue.resolveComponent)("Share");
    const _component_v_window = (0, _vue.resolveComponent)("v-window");
    const _component_v_card_text = (0, _vue.resolveComponent)("v-card-text");
    const _component_v_badge = (0, _vue.resolveComponent)("v-badge");
    const _component_v_list_item_title = (0, _vue.resolveComponent)("v-list-item-title");
    const _component_v_list_item = (0, _vue.resolveComponent)("v-list-item");
    const _component_v_list = (0, _vue.resolveComponent)("v-list");
    const _component_v_menu = (0, _vue.resolveComponent)("v-menu");
    const _component_v_card_actions = (0, _vue.resolveComponent)("v-card-actions");
    const _component_v_card = (0, _vue.resolveComponent)("v-card");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_card, null, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_toolbar, {
                    dark: "",
                    flat: ""
                }, {
                    extension: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_tabs, {
                                modelValue: $data.tab,
                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>$data.tab = $event),
                                "fixed-tabs": "",
                                "center-active": "",
                                "show-arrows": ""
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_tab, {
                                            active: ""
                                        }, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-book-open-outline ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Settings ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_tab, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-account-group ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Members ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_tab, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-view-dashboard ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Modules ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_tab, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-router-wireless ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Stations ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_tab, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-share-variant ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Share ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            }, 8 /* PROPS */ , [
                                "modelValue"
                            ])
                        ]),
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_toolbar_title, null, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createTextVNode)("Class Settings")
                                    ]),
                                _: 1 /* STABLE */ 
                            }),
                            (0, _vue.createVNode)(_component_v_spacer),
                            (0, _vue.createVNode)(_component_v_btn, {
                                icon: "",
                                onClick: _cache[0] || (_cache[0] = ($event)=>_ctx.$emit("close"))
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_icon, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createTextVNode)("mdi-close")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                }),
                (0, _vue.createVNode)(_component_v_card_text, {
                    style: {
                        "height": "565px"
                    }
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_window, {
                                modelValue: $data.tab,
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>$data.tab = $event),
                                class: "pt-5"
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_window_item, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_Main, {
                                                        config: $props.config
                                                    }, null, 8 /* PROPS */ , [
                                                        "config"
                                                    ])
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_window_item, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_Members, {
                                                        config: $props.config
                                                    }, null, 8 /* PROPS */ , [
                                                        "config"
                                                    ])
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_window_item, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_Modules, {
                                                        config: $props.config,
                                                        "scraped-modules": $props.scrapedModules
                                                    }, null, 8 /* PROPS */ , [
                                                        "config",
                                                        "scraped-modules"
                                                    ])
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_window_item, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_Stations, {
                                                        config: $props.config
                                                    }, null, 8 /* PROPS */ , [
                                                        "config"
                                                    ])
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_window_item, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_Share, {
                                                        config: $props.config
                                                    }, null, 8 /* PROPS */ , [
                                                        "config"
                                                    ])
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            }, 8 /* PROPS */ , [
                                "modelValue"
                            ])
                        ]),
                    _: 1 /* STABLE */ 
                }),
                (0, _vue.createVNode)(_component_v_card_actions, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_badge, {
                                overlap: "",
                                dot: "",
                                color: "red",
                                style: {
                                    "margin-top": "30px"
                                }
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_btn, {
                                            onClick: $options.saveClass,
                                            color: "primary"
                                        }, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_icon, {
                                                        left: ""
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createTextVNode)(" mdi-upload ")
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    }),
                                                    (0, _vue.createTextVNode)(" Save ")
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }, 8 /* PROPS */ , [
                                            "onClick"
                                        ])
                                    ]),
                                _: 1 /* STABLE */ 
                            }),
                            (0, _vue.createVNode)(_component_v_menu, null, {
                                activator: (0, _vue.withCtx)(({ props })=>[
                                        (0, _vue.createVNode)(_component_v_btn, (0, _vue.mergeProps)({
                                            color: ""
                                        }, props, {
                                            style: {
                                                "margin-top": "30px",
                                                "margin-right": "10px",
                                                "margin-left": "30px"
                                            },
                                            class: "float-right"
                                        }), {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createTextVNode)(" Delete Class ")
                                                ]),
                                            _: 2 /* DYNAMIC */ 
                                        }, 1040 /* FULL_PROPS, DYNAMIC_SLOTS */ )
                                    ]),
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_list, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_list_item, null, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createVNode)(_component_v_list_item_title, null, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createTextVNode)(" Are you sure? ")
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                }),
                                                                (0, _vue.createVNode)(_component_v_btn, {
                                                                    color: "red",
                                                                    depressed: "",
                                                                    onClick: $options.deleteClass,
                                                                    class: "float-right",
                                                                    style: {
                                                                        "margin-top": "10px"
                                                                    }
                                                                }, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createTextVNode)(" Yes, delete forever")
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                }, 8 /* PROPS */ , [
                                                                    "onClick"
                                                                ])
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    })
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                })
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("4f1cba-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5WNJn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ft1le":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("df70a72d082afd3d");
    if (script.__esModule) script = script.default;
    script.render = require("57ff57a13ddb1e3a").render;
    script.__cssModules = require("646109bd9f5746fa").default;
    require("fc530ae0670d4428").default(script);
    script.__scopeId = "data-v-62a37c";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Modules.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "62a37c-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("62a37c-hmr", script)) __VUE_HMR_RUNTIME__.reload("62a37c-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"df70a72d082afd3d":"i9gPA","57ff57a13ddb1e3a":"171VO","646109bd9f5746fa":"8OWmh","fc530ae0670d4428":"dv4TC","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"i9gPA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _moduleVue = require("./Module.vue");
var _moduleVueDefault = parcelHelpers.interopDefault(_moduleVue);
exports.default = {
    components: {
        Module: (0, _moduleVueDefault.default)
    },
    name: "Modules",
    props: [
        "role",
        "username_",
        "liveClassProxy",
        "scrapedModules_",
        "communication",
        "class_id"
    ],
    data () {
        return {
            username: this.username_,
            //scrapedModules: JSON.parse(JSON.stringify(this.scrapedModules_)),
            count: 0
        };
    },
    computed: {
        roomName () {
            return this.liveClassProxy.users[this.username]?.room || "Station " + this.username;
        },
        modulesType () {
            return this.roomName.startsWith("Station ") ? "station" : "chat";
        },
        scrapedModulesFilter () {
            return this.scrapedModules_.filter((m)=>{
                const showIn = m.showInCustom ? m.showInCustom.split(",").map((e)=>e.trim()) : m.shownIn;
                return (showIn.includes(this.modulesType) || showIn.map((e)=>e.toLowerCase().replace(/\*/g, ".*")).map((e)=>new RegExp(e)).map((e)=>this.roomName.toLowerCase().match(e) !== null).includes(true) || showIn == "*") && !showIn.includes("teacher-only");
            });
        }
    },
    created () {
        window.addEventListener("message", this.messageHandler);
        const iframes = document.getElementsByTagName("iframe");
        this.communication.on("message", (msg)=>{
            for(let i = 0; i < iframes.length; i++)iframes[i].contentWindow.postMessage({
                event: "message",
                ...msg
            }, "*");
        });
    },
    beforeDestroy () {
        window.removeEventListener("message", this.messageHandler);
        this.communication.on("message", undefined);
    },
    async mounted () {},
    methods: {
        messageHandler (e) {
            switch(e.data.event){
                case "message":
                    this.sendMessage(e.data.subject, e.data.body, e.data.module);
                    break;
                case "update":
                    this.setToValue(this.liveClassProxy, e.data.path, e.data.value);
                    break;
                case "echo":
                    console.log("ECHO:", e.data);
                    break;
                default:
                    break;
            }
        },
        async sendMessage (subject, body, module_url) {
            if (body !== undefined) {
                const data = {
                    from: this.username /* Email if teacher, name if station */ ,
                    subject: subject,
                    body: body,
                    module: module_url
                };
                this.communication.broadcast(data, this.roomName);
            }
        }
    }
};

},{"./Module.vue":"3BFc3","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3BFc3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let script;
let initialize = ()=>{
    script = require("bf9648ab9432d6df");
    if (script.__esModule) script = script.default;
    script.render = require("e3f281915c9e0ebb").render;
    require("777b00281dc5f6c0").default(script);
    script.__scopeId = "data-v-bacfee";
    script.__file = "/home/andre/Workspace/Projects/edrys-Lite/src/components/Module.vue";
};
initialize();
if (module.hot) {
    script.__hmrId = "bacfee-hmr";
    module.hot.accept(()=>{
        setTimeout(()=>{
            initialize();
            if (!__VUE_HMR_RUNTIME__.createRecord("bacfee-hmr", script)) __VUE_HMR_RUNTIME__.reload("bacfee-hmr", script);
        }, 0);
    });
}
exports.default = script;

},{"bf9648ab9432d6df":"fHrC2","e3f281915c9e0ebb":"eHYxb","777b00281dc5f6c0":"k7P9N","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fHrC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    name: "Module",
    props: {
        role: {
            type: String,
            required: true
        },
        username: {
            type: String,
            required: true
        },
        liveClassProxy: {
            type: Object,
            required: true
        },
        scrapedModule: {
            type: Object,
            required: true
        },
        class_id: {
            type: String,
            required: true
        }
    },
    data () {
        return {};
    },
    computed: {
        iframeOrigin () {
            return new URL(this.scrapedModule.url).origin;
        }
    },
    watch: {
        liveClassProxy () {
            this.updateIframe();
        }
    },
    methods: {
        updateIframe () {
            //console.warn("updateIframe", typeof this.liveClassProxy_);
            try {
                this.$refs.iframe.contentWindow.postMessage({
                    event: "update",
                    origin: window.origin,
                    role: this.role,
                    username: this.username,
                    liveClass: JSON.parse(JSON.stringify(this.liveClassProxy)),
                    module: JSON.parse(JSON.stringify(this.scrapedModule)),
                    class_id: this.class_id
                }, this.scrapedModule.origin || this.iframeOrigin);
            } catch (e) {
                console.warn(e);
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eHYxb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = [
    "src",
    "srcdoc"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
        style: {
            "height": "100%",
            "width": "100%"
        },
        key: $props.scrapedModule.url
    }, [
        ((0, _vue.openBlock)(), (0, _vue.createElementBlock)("iframe", {
            style: {
                "height": "100%",
                "width": "100%"
            },
            key: $props.liveClassProxy.users[$props.username].room,
            src: $props.scrapedModule.srcdoc ? $props.scrapedModule.srcdoc : $props.scrapedModule.url.startsWith("data:") ? null : $props.scrapedModule.url,
            srcdoc: !$props.scrapedModule.srcdoc ? null : $props.scrapedModule.url.startsWith("data:") ? $props.scrapedModule.url : null,
            allow: "camera; microphone; fullscreen; display-capture; accelerometer; autoplay; encrypted-media; geolocation; gyroscope; magnetometer; midi; serial; vr;",
            onLoad: _cache[0] || (_cache[0] = (...args)=>$options.updateIframe && $options.updateIframe(...args)),
            ref: "iframe",
            frameborder: "0"
        }, null, 40 /* PROPS, HYDRATE_EVENTS */ , _hoisted_1))
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("bacfee-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"k7P9N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"171VO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _withScopeId = (n)=>((0, _vue.pushScopeId)("data-v-62a37c"), n = n(), (0, _vue.popScopeId)(), n);
const _hoisted_1 = [
    "v-show"
];
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_Module = (0, _vue.resolveComponent)("Module");
    const _component_v_card_text = (0, _vue.resolveComponent)("v-card-text");
    const _component_v_card = (0, _vue.resolveComponent)("v-card");
    return (0, _vue.openBlock)(), (0, _vue.createElementBlock)("div", {
        key: $props.role
    }, [
        (0, _vue.createElementVNode)("div", {
            class: "items",
            "v-show": $props.liveClassProxy !== null ? true : false
        }, [
            (0, _vue.createCommentVNode)(" :style=\"{\n            height:\n              m.height == 'tall'\n                ? '700px'\n                : m.height == 'short'\n                ? '300px'\n                : '500px',\n          }\" "),
            ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($options.scrapedModulesFilter, (m, i)=>{
                return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_Module, {
                    class: "item",
                    key: i,
                    username: $data.username,
                    "live-class-proxy": $props.liveClassProxy,
                    scrapedModule: m,
                    role: $props.role,
                    class_id: $props.class_id
                }, null, 8 /* PROPS */ , [
                    "username",
                    "live-class-proxy",
                    "scrapedModule",
                    "role",
                    "class_id"
                ]);
            }), 128 /* KEYED_FRAGMENT */ ))
        ], 8 /* PROPS */ , _hoisted_1),
        !$props.scrapedModules_.length ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_card, {
            key: 0
        }, {
            default: (0, _vue.withCtx)(()=>[
                    $props.role == "teacher" || $props.role == "station" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_card_text, {
                        key: 0
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" Sorry, looks like you have not loaded up any " + (0, _vue.toDisplayString)($options.modulesType) + " modules. Add some in the class settings to get started. ", 1 /* TEXT */ )
                            ]),
                        _: 1 /* STABLE */ 
                    })) : (0, _vue.createCommentVNode)("v-if", true),
                    $props.role == "student" ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_card_text, {
                        key: 1
                    }, {
                        default: (0, _vue.withCtx)(()=>[
                                (0, _vue.createTextVNode)(" Sorry, it looks like the class creators have not added any modules yet. ")
                            ]),
                        _: 1 /* STABLE */ 
                    })) : (0, _vue.createCommentVNode)("v-if", true)
                ]),
            _: 1 /* STABLE */ 
        })) : (0, _vue.createCommentVNode)("v-if", true)
    ]);
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("62a37c-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8OWmh":[function() {},{}],"dv4TC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hn5oJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dexie = require("dexie");
exports.default = class {
    constructor(){
        this.db = new (0, _dexie.Dexie)("EdrysLite");
        this.db.version(1).stores({
            data: `
            &id,
            timestamp,
            data`
        });
        this.db.open().then(function(db) {
            // Database opened successfully
            console.log("Database opened successfully");
        }).catch(function(err) {
            console.warn("Database error: " + err.message);
        });
    }
    getAll() {
        return this.db["data"].orderBy("timestamp").desc().toArray();
    }
    async exists(id) {
        const item = await this.get(id);
        return item ? true : false;
    }
    async get(id) {
        return await this.db["data"].get(id);
    }
    async put(id, data, timestamp) {
        console.warn("put", id, data, timestamp);
        await this.db["data"].put({
            id: id,
            timestamp: timestamp || Date.now(),
            data
        });
    }
    update(config) {
        config.timestamp = Date.now();
        console.warn("UPDATE", config);
        this.db["data"].put(config);
    }
    drop(id) {
        this.db["data"].delete(id);
    }
};

},{"dexie":"5YABP","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5YABP":[function(require,module,exports) {
/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 3.2.4, Tue May 30 2023
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */ /*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Dexie", ()=>Dexie$1);
parcelHelpers.export(exports, "RangeSet", ()=>RangeSet);
parcelHelpers.export(exports, "default", ()=>Dexie$1);
parcelHelpers.export(exports, "liveQuery", ()=>liveQuery);
parcelHelpers.export(exports, "mergeRanges", ()=>mergeRanges);
parcelHelpers.export(exports, "rangesOverlap", ()=>rangesOverlap);
var global = arguments[3];
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys = Object.keys;
var isArray = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) _global.Promise = Promise;
function extend(obj, extension) {
    if (typeof extension !== "object") return obj;
    keys(extension).forEach(function(key) {
        obj[key] = extension[key];
    });
    return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
    return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
    if (typeof extension === "function") extension = extension(getProto(proto));
    (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function(key) {
        setProp(proto, key, extension[key]);
    });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? {
        get: functionOrGetSet.get,
        set: functionOrGetSet.set,
        configurable: true
    } : {
        value: functionOrGetSet,
        configurable: true,
        writable: true
    }, options));
}
function derive(Child) {
    return {
        from: function(Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
                extend: props.bind(null, Child.prototype)
            };
        }
    };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
    var pd = getOwnPropertyDescriptor(obj, prop);
    var proto;
    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args, start, end) {
    return _slice.call(args, start, end);
}
function override(origFunc, overridedFactory) {
    return overridedFactory(origFunc);
}
function assert(b) {
    if (!b) throw new Error("Assertion Failed");
}
function asap$1(fn) {
    if (_global.setImmediate) setImmediate(fn);
    else setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
    return array.reduce(function(result, item, i) {
        var nameAndValue = extractor(item, i);
        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];
        return result;
    }, {});
}
function tryCatch(fn, onerror, args) {
    try {
        fn.apply(null, args);
    } catch (ex) {
        onerror && onerror(ex);
    }
}
function getByKeyPath(obj, keyPath) {
    if (hasOwn(obj, keyPath)) return obj[keyPath];
    if (!keyPath) return obj;
    if (typeof keyPath !== "string") {
        var rv = [];
        for(var i = 0, l = keyPath.length; i < l; ++i){
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
        }
        return rv;
    }
    var period = keyPath.indexOf(".");
    if (period !== -1) {
        var innerObj = obj[keyPath.substr(0, period)];
        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
    }
    return undefined;
}
function setByKeyPath(obj, keyPath, value) {
    if (!obj || keyPath === undefined) return;
    if ("isFrozen" in Object && Object.isFrozen(obj)) return;
    if (typeof keyPath !== "string" && "length" in keyPath) {
        assert(typeof value !== "string" && "length" in value);
        for(var i = 0, l = keyPath.length; i < l; ++i)setByKeyPath(obj, keyPath[i], value[i]);
    } else {
        var period = keyPath.indexOf(".");
        if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "") {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);
                    else delete obj[currentKeyPath];
                } else obj[currentKeyPath] = value;
            } else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};
                setByKeyPath(innerObj, remainingKeyPath, value);
            }
        } else if (value === undefined) {
            if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);
            else delete obj[keyPath];
        } else obj[keyPath] = value;
    }
}
function delByKeyPath(obj, keyPath) {
    if (typeof keyPath === "string") setByKeyPath(obj, keyPath, undefined);
    else if ("length" in keyPath) [].map.call(keyPath, function(kp) {
        setByKeyPath(obj, kp, undefined);
    });
}
function shallowClone(obj) {
    var rv = {};
    for(var m in obj)if (hasOwn(obj, m)) rv[m] = obj[m];
    return rv;
}
var concat = [].concat;
function flatten(a) {
    return concat.apply([], a);
}
var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([
    8,
    16,
    32,
    64
].map(function(num) {
    return [
        "Int",
        "Uint",
        "Float"
    ].map(function(t) {
        return t + num + "Array";
    });
}))).filter(function(t) {
    return _global[t];
});
var intrinsicTypes = intrinsicTypeNames.map(function(t) {
    return _global[t];
});
arrayToObject(intrinsicTypeNames, function(x) {
    return [
        x,
        true
    ];
});
var circularRefs = null;
function deepClone(any) {
    circularRefs = typeof WeakMap !== "undefined" && new WeakMap();
    var rv = innerDeepClone(any);
    circularRefs = null;
    return rv;
}
function innerDeepClone(any) {
    if (!any || typeof any !== "object") return any;
    var rv = circularRefs && circularRefs.get(any);
    if (rv) return rv;
    if (isArray(any)) {
        rv = [];
        circularRefs && circularRefs.set(any, rv);
        for(var i = 0, l = any.length; i < l; ++i)rv.push(innerDeepClone(any[i]));
    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) rv = any;
    else {
        var proto = getProto(any);
        rv = proto === Object.prototype ? {} : Object.create(proto);
        circularRefs && circularRefs.set(any, rv);
        for(var prop in any)if (hasOwn(any, prop)) rv[prop] = innerDeepClone(any[prop]);
    }
    return rv;
}
var toString = {}.toString;
function toStringTag(o) {
    return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
    var i;
    return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
    return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
    var i, a, x, it;
    if (arguments.length === 1) {
        if (isArray(arrayLike)) return arrayLike.slice();
        if (this === NO_CHAR_ARRAY && typeof arrayLike === "string") return [
            arrayLike
        ];
        if (it = getIteratorOf(arrayLike)) {
            a = [];
            while(x = it.next(), !x.done)a.push(x.value);
            return a;
        }
        if (arrayLike == null) return [
            arrayLike
        ];
        i = arrayLike.length;
        if (typeof i === "number") {
            a = new Array(i);
            while(i--)a[i] = arrayLike[i];
            return a;
        }
        return [
            arrayLike
        ];
    }
    i = arguments.length;
    a = new Array(i);
    while(i--)a[i] = arguments[i];
    return a;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
} : function() {
    return false;
};
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
    debug = value;
    libraryFilter = filter;
}
var libraryFilter = function() {
    return true;
};
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
    if (NEEDS_THROW_FOR_STACK) try {
        getErrorWithStack.arguments;
        throw new Error();
    } catch (e) {
        return e;
    }
    return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
    var stack = exception.stack;
    if (!stack) return "";
    numIgnoredFrames = numIgnoredFrames || 0;
    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split("\n").length;
    return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map(function(frame) {
        return "\n" + frame;
    }).join("");
}
var dexieErrorNames = [
    "Modify",
    "Bulk",
    "OpenFailed",
    "VersionChange",
    "Schema",
    "Upgrade",
    "InvalidTable",
    "MissingAPI",
    "NoSuchDatabase",
    "InvalidArgument",
    "SubTransaction",
    "Unsupported",
    "Internal",
    "DatabaseClosed",
    "PrematureCommit",
    "ForeignAwait"
];
var idbDomErrorNames = [
    "Unknown",
    "Constraint",
    "Data",
    "TransactionInactive",
    "ReadOnly",
    "Version",
    "NotFound",
    "InvalidState",
    "InvalidAccess",
    "Abort",
    "Timeout",
    "QuotaExceeded",
    "Syntax",
    "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
    VersionChanged: "Database version changed by other database connection",
    DatabaseClosed: "Database has been closed",
    Abort: "Transaction aborted",
    TransactionInactive: "Transaction has already completed or failed",
    MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
    this._e = getErrorWithStack();
    this.name = name;
    this.message = msg;
}
derive(DexieError).from(Error).extend({
    stack: {
        get: function() {
            return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
        }
    },
    toString: function() {
        return this.name + ": " + this.message;
    }
});
function getMultiErrorMessage(msg, failures) {
    return msg + ". Errors: " + Object.keys(failures).map(function(key) {
        return failures[key].toString();
    }).filter(function(v, i, s) {
        return s.indexOf(v) === i;
    }).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
    this._e = getErrorWithStack();
    this.failures = failures;
    this.failedKeys = failedKeys;
    this.successCount = successCount;
    this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
    this._e = getErrorWithStack();
    this.name = "BulkError";
    this.failures = Object.keys(failures).map(function(pos) {
        return failures[pos];
    });
    this.failuresByPos = failures;
    this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce(function(obj, name) {
    return obj[name] = name + "Error", obj;
}, {});
var BaseException = DexieError;
var exceptions = errorList.reduce(function(obj, name) {
    var fullName = name + "Error";
    function DexieError(msgOrInner, inner) {
        this._e = getErrorWithStack();
        this.name = fullName;
        if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
        } else if (typeof msgOrInner === "string") {
            this.message = "" + msgOrInner + (!inner ? "" : "\n " + inner);
            this.inner = inner || null;
        } else if (typeof msgOrInner === "object") {
            this.message = msgOrInner.name + " " + msgOrInner.message;
            this.inner = msgOrInner;
        }
    }
    derive(DexieError).from(BaseException);
    obj[name] = DexieError;
    return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
    obj[name + "Error"] = exceptions[name];
    return obj;
}, {});
function mapError(domError, message) {
    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;
    var rv = new exceptionMap[domError.name](message || domError.message, domError);
    if ("stack" in domError) setProp(rv, "stack", {
        get: function() {
            return this.inner.stack;
        }
    });
    return rv;
}
var fullNameExceptions = errorList.reduce(function(obj, name) {
    if ([
        "Syntax",
        "Type",
        "Range"
    ].indexOf(name) === -1) obj[name + "Error"] = exceptions[name];
    return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop() {}
function mirror(val) {
    return val;
}
function pureFunctionChain(f1, f2) {
    if (f1 == null || f1 === mirror) return f2;
    return function(val) {
        return f2(f1(val));
    };
}
function callBoth(on1, on2) {
    return function() {
        on1.apply(this, arguments);
        on2.apply(this, arguments);
    };
}
function hookCreatingChain(f1, f2) {
    if (f1 === nop) return f2;
    return function() {
        var res = f1.apply(this, arguments);
        if (res !== undefined) arguments[0] = res;
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res2 !== undefined ? res2 : res;
    };
}
function hookDeletingChain(f1, f2) {
    if (f1 === nop) return f2;
    return function() {
        f1.apply(this, arguments);
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = this.onerror = null;
        f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    };
}
function hookUpdatingChain(f1, f2) {
    if (f1 === nop) return f2;
    return function(modifications) {
        var res = f1.apply(this, arguments);
        extend(modifications, res);
        var onsuccess = this.onsuccess, onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);
    };
}
function reverseStoppableEventChain(f1, f2) {
    if (f1 === nop) return f2;
    return function() {
        if (f2.apply(this, arguments) === false) return false;
        return f1.apply(this, arguments);
    };
}
function promisableChain(f1, f2) {
    if (f1 === nop) return f2;
    return function() {
        var res = f1.apply(this, arguments);
        if (res && typeof res.then === "function") {
            var thiz = this, i = arguments.length, args = new Array(i);
            while(i--)args[i] = arguments[i];
            return res.then(function() {
                return f2.apply(thiz, args);
            });
        }
        return f2.apply(this, arguments);
    };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
    var globalP = Promise.resolve();
    if (typeof crypto === "undefined" || !crypto.subtle) return [
        globalP,
        getProto(globalP),
        globalP
    ];
    var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([
        0
    ]));
    return [
        nativeP,
        getProto(nativeP),
        globalP
    ];
}(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? function() {
    resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? function() {
    var hiddenDiv = document.createElement("div");
    new MutationObserver(function() {
        physicalTick();
        hiddenDiv = null;
    }).observe(hiddenDiv, {
        attributes: true
    });
    hiddenDiv.setAttribute("i", "1");
} : function() {
    setTimeout(physicalTick, 0);
};
var asap = function(callback, args) {
    microtickQueue.push([
        callback,
        args
    ]);
    if (needsNewPhysicalTick) {
        schedulePhysicalTick();
        needsNewPhysicalTick = false;
    }
};
var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;
var globalPSD = {
    id: "global",
    global: true,
    ref: 0,
    unhandleds: [],
    onunhandled: globalError,
    pgp: false,
    env: {},
    finalize: function() {
        this.unhandleds.forEach(function(uh) {
            try {
                globalError(uh[0], uh[1]);
            } catch (e) {}
        });
    }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
    if (typeof this !== "object") throw new TypeError("Promises must be constructed via new");
    this._listeners = [];
    this.onuncatched = nop;
    this._lib = false;
    var psd = this._PSD = PSD;
    if (debug) {
        this._stackHolder = getErrorWithStack();
        this._prev = null;
        this._numPrev = 0;
    }
    if (typeof fn !== "function") {
        if (fn !== INTERNAL) throw new TypeError("Not a function");
        this._state = arguments[1];
        this._value = arguments[2];
        if (this._state === false) handleRejection(this, this._value);
        return;
    }
    this._state = null;
    this._value = null;
    ++psd.ref;
    executePromiseTask(this, fn);
}
var thenProp = {
    get: function() {
        var psd = PSD, microTaskId = totalEchoes;
        function then(onFulfilled, onRejected) {
            var _this = this;
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            var cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise(function(resolve, reject) {
                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
            });
            debug && linkToPreviousPromise(rv, this);
            return rv;
        }
        then.prototype = INTERNAL;
        return then;
    },
    set: function(value) {
        setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
            get: function() {
                return value;
            },
            set: thenProp.set
        });
    }
};
props(DexiePromise.prototype, {
    then: thenProp,
    _then: function(onFulfilled, onRejected) {
        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
    },
    catch: function(onRejected) {
        if (arguments.length === 1) return this.then(null, onRejected);
        var type = arguments[0], handler = arguments[1];
        return typeof type === "function" ? this.then(null, function(err) {
            return err instanceof type ? handler(err) : PromiseReject(err);
        }) : this.then(null, function(err) {
            return err && err.name === type ? handler(err) : PromiseReject(err);
        });
    },
    finally: function(onFinally) {
        return this.then(function(value) {
            onFinally();
            return value;
        }, function(err) {
            onFinally();
            return PromiseReject(err);
        });
    },
    stack: {
        get: function() {
            if (this._stack) return this._stack;
            try {
                stack_being_generated = true;
                var stacks = getStack(this, [], MAX_LONG_STACKS);
                var stack = stacks.join("\nFrom previous: ");
                if (this._state !== null) this._stack = stack;
                return stack;
            } finally{
                stack_being_generated = false;
            }
        }
    },
    timeout: function(ms, msg) {
        var _this = this;
        return ms < Infinity ? new DexiePromise(function(resolve, reject) {
            var handle = setTimeout(function() {
                return reject(new exceptions.Timeout(msg));
            }, ms);
            _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
        }) : this;
    }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve, reject, zone) {
    this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
    this.onRejected = typeof onRejected === "function" ? onRejected : null;
    this.resolve = resolve;
    this.reject = reject;
    this.psd = zone;
}
props(DexiePromise, {
    all: function() {
        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve, reject) {
            if (values.length === 0) resolve([]);
            var remaining = values.length;
            values.forEach(function(a, i) {
                return DexiePromise.resolve(a).then(function(x) {
                    values[i] = x;
                    if (!--remaining) resolve(values);
                }, reject);
            });
        });
    },
    resolve: function(value) {
        if (value instanceof DexiePromise) return value;
        if (value && typeof value.then === "function") return new DexiePromise(function(resolve, reject) {
            value.then(resolve, reject);
        });
        var rv = new DexiePromise(INTERNAL, true, value);
        linkToPreviousPromise(rv, currentFulfiller);
        return rv;
    },
    reject: PromiseReject,
    race: function() {
        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve, reject) {
            values.map(function(value) {
                return DexiePromise.resolve(value).then(resolve, reject);
            });
        });
    },
    PSD: {
        get: function() {
            return PSD;
        },
        set: function(value) {
            return PSD = value;
        }
    },
    totalEchoes: {
        get: function() {
            return totalEchoes;
        }
    },
    newPSD: newScope,
    usePSD: usePSD,
    scheduler: {
        get: function() {
            return asap;
        },
        set: function(value) {
            asap = value;
        }
    },
    rejectionMapper: {
        get: function() {
            return rejectionMapper;
        },
        set: function(value) {
            rejectionMapper = value;
        }
    },
    follow: function(fn, zoneProps) {
        return new DexiePromise(function(resolve, reject) {
            return newScope(function(resolve, reject) {
                var psd = PSD;
                psd.unhandleds = [];
                psd.onunhandled = reject;
                psd.finalize = callBoth(function() {
                    var _this = this;
                    run_at_end_of_this_or_next_physical_tick(function() {
                        _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                    });
                }, psd.finalize);
                fn();
            }, zoneProps, resolve, reject);
        });
    }
});
if (NativePromise) {
    if (NativePromise.allSettled) setProp(DexiePromise, "allSettled", function() {
        var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve) {
            if (possiblePromises.length === 0) resolve([]);
            var remaining = possiblePromises.length;
            var results = new Array(remaining);
            possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                    return results[i] = {
                        status: "fulfilled",
                        value: value
                    };
                }, function(reason) {
                    return results[i] = {
                        status: "rejected",
                        reason: reason
                    };
                }).then(function() {
                    return --remaining || resolve(results);
                });
            });
        });
    });
    if (NativePromise.any && typeof AggregateError !== "undefined") setProp(DexiePromise, "any", function() {
        var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise(function(resolve, reject) {
            if (possiblePromises.length === 0) reject(new AggregateError([]));
            var remaining = possiblePromises.length;
            var failures = new Array(remaining);
            possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                    return resolve(value);
                }, function(failure) {
                    failures[i] = failure;
                    if (!--remaining) reject(new AggregateError(failures));
                });
            });
        });
    });
}
function executePromiseTask(promise, fn) {
    try {
        fn(function(value) {
            if (promise._state !== null) return;
            if (value === promise) throw new TypeError("A promise cannot be resolved with itself.");
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === "function") executePromiseTask(promise, function(resolve, reject) {
                value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
            });
            else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
            }
            if (shouldExecuteTick) endMicroTickScope();
        }, handleRejection.bind(null, promise));
    } catch (ex) {
        handleRejection(promise, ex);
    }
}
function handleRejection(promise, reason) {
    rejectingErrors.push(reason);
    if (promise._state !== null) return;
    var shouldExecuteTick = promise._lib && beginMicroTickScope();
    reason = rejectionMapper(reason);
    promise._state = false;
    promise._value = reason;
    debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(function() {
        var origProp = getPropertyDescriptor(reason, "stack");
        reason._promise = promise;
        setProp(reason, "stack", {
            get: function() {
                return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;
            }
        });
    });
    addPossiblyUnhandledError(promise);
    propagateAllListeners(promise);
    if (shouldExecuteTick) endMicroTickScope();
}
function propagateAllListeners(promise) {
    var listeners = promise._listeners;
    promise._listeners = [];
    for(var i = 0, len = listeners.length; i < len; ++i)propagateToListener(promise, listeners[i]);
    var psd = promise._PSD;
    --psd.ref || psd.finalize();
    if (numScheduledCalls === 0) {
        ++numScheduledCalls;
        asap(function() {
            if (--numScheduledCalls === 0) finalizePhysicalTick();
        }, []);
    }
}
function propagateToListener(promise, listener) {
    if (promise._state === null) {
        promise._listeners.push(listener);
        return;
    }
    var cb = promise._state ? listener.onFulfilled : listener.onRejected;
    if (cb === null) return (promise._state ? listener.resolve : listener.reject)(promise._value);
    ++listener.psd.ref;
    ++numScheduledCalls;
    asap(callListener, [
        cb,
        promise,
        listener
    ]);
}
function callListener(cb, promise, listener) {
    try {
        currentFulfiller = promise;
        var ret, value = promise._value;
        if (promise._state) ret = cb(value);
        else {
            if (rejectingErrors.length) rejectingErrors = [];
            ret = cb(value);
            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);
        }
        listener.resolve(ret);
    } catch (e) {
        listener.reject(e);
    } finally{
        currentFulfiller = null;
        if (--numScheduledCalls === 0) finalizePhysicalTick();
        --listener.psd.ref || listener.psd.finalize();
    }
}
function getStack(promise, stacks, limit) {
    if (stacks.length === limit) return stacks;
    var stack = "";
    if (promise._state === false) {
        var failure = promise._value, errorName, message;
        if (failure != null) {
            errorName = failure.name || "Error";
            message = failure.message || failure;
            stack = prettyStack(failure, 0);
        } else {
            errorName = failure;
            message = "";
        }
        stacks.push(errorName + (message ? ": " + message : "") + stack);
    }
    if (debug) {
        stack = prettyStack(promise._stackHolder, 2);
        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);
        if (promise._prev) getStack(promise._prev, stacks, limit);
    }
    return stacks;
}
function linkToPreviousPromise(promise, prev) {
    var numPrev = prev ? prev._numPrev + 1 : 0;
    if (numPrev < LONG_STACKS_CLIP_LIMIT) {
        promise._prev = prev;
        promise._numPrev = numPrev;
    }
}
function physicalTick() {
    beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
    var wasRootExec = isOutsideMicroTick;
    isOutsideMicroTick = false;
    needsNewPhysicalTick = false;
    return wasRootExec;
}
function endMicroTickScope() {
    var callbacks, i, l;
    do while(microtickQueue.length > 0){
        callbacks = microtickQueue;
        microtickQueue = [];
        l = callbacks.length;
        for(i = 0; i < l; ++i){
            var item = callbacks[i];
            item[0].apply(null, item[1]);
        }
    }
    while (microtickQueue.length > 0);
    isOutsideMicroTick = true;
    needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
    var unhandledErrs = unhandledErrors;
    unhandledErrors = [];
    unhandledErrs.forEach(function(p) {
        p._PSD.onunhandled.call(null, p._value, p);
    });
    var finalizers = tickFinalizers.slice(0);
    var i = finalizers.length;
    while(i)finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
    function finalizer() {
        fn();
        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
    }
    tickFinalizers.push(finalizer);
    ++numScheduledCalls;
    asap(function() {
        if (--numScheduledCalls === 0) finalizePhysicalTick();
    }, []);
}
function addPossiblyUnhandledError(promise) {
    if (!unhandledErrors.some(function(p) {
        return p._value === promise._value;
    })) unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
    var i = unhandledErrors.length;
    while(i)if (unhandledErrors[--i]._value === promise._value) {
        unhandledErrors.splice(i, 1);
        return;
    }
}
function PromiseReject(reason) {
    return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
    var psd = PSD;
    return function() {
        var wasRootExec = beginMicroTickScope(), outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
        } catch (e) {
            errorCatcher && errorCatcher(e);
        } finally{
            switchToZone(outerScope, false);
            if (wasRootExec) endMicroTickScope();
        }
    };
}
var task = {
    awaits: 0,
    echoes: 0,
    id: 0
};
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props, a1, a2) {
    var parent = PSD, psd = Object.create(parent);
    psd.parent = parent;
    psd.ref = 0;
    psd.global = false;
    psd.id = ++zone_id_counter;
    var globalEnv = globalPSD.env;
    psd.env = patchGlobalPromise ? {
        Promise: DexiePromise,
        PromiseProp: {
            value: DexiePromise,
            configurable: true,
            writable: true
        },
        all: DexiePromise.all,
        race: DexiePromise.race,
        allSettled: DexiePromise.allSettled,
        any: DexiePromise.any,
        resolve: DexiePromise.resolve,
        reject: DexiePromise.reject,
        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
    } : {};
    if (props) extend(psd, props);
    ++parent.ref;
    psd.finalize = function() {
        --this.parent.ref || this.parent.finalize();
    };
    var rv = usePSD(psd, fn, a1, a2);
    if (psd.ref === 0) psd.finalize();
    return rv;
}
function incrementExpectedAwaits() {
    if (!task.id) task.id = ++taskCounter;
    ++task.awaits;
    task.echoes += ZONE_ECHO_LIMIT;
    return task.id;
}
function decrementExpectedAwaits() {
    if (!task.awaits) return false;
    if (--task.awaits === 0) task.id = 0;
    task.echoes = task.awaits * ZONE_ECHO_LIMIT;
    return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) incrementExpectedAwaits = decrementExpectedAwaits = nop;
function onPossibleParallellAsync(possiblePromise) {
    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
        incrementExpectedAwaits();
        return possiblePromise.then(function(x) {
            decrementExpectedAwaits();
            return x;
        }, function(e) {
            decrementExpectedAwaits();
            return rejection(e);
        });
    }
    return possiblePromise;
}
function zoneEnterEcho(targetZone) {
    ++totalEchoes;
    if (!task.echoes || --task.echoes === 0) task.echoes = task.id = 0;
    zoneStack.push(PSD);
    switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
    var zone = zoneStack[zoneStack.length - 1];
    zoneStack.pop();
    switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
    var currentZone = PSD;
    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
    if (targetZone === PSD) return;
    PSD = targetZone;
    if (currentZone === globalPSD) globalPSD.env = snapShot();
    if (patchGlobalPromise) {
        var GlobalPromise_1 = globalPSD.env.Promise;
        var targetEnv = targetZone.env;
        nativePromiseProto.then = targetEnv.nthen;
        GlobalPromise_1.prototype.then = targetEnv.gthen;
        if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
            GlobalPromise_1.all = targetEnv.all;
            GlobalPromise_1.race = targetEnv.race;
            GlobalPromise_1.resolve = targetEnv.resolve;
            GlobalPromise_1.reject = targetEnv.reject;
            if (targetEnv.allSettled) GlobalPromise_1.allSettled = targetEnv.allSettled;
            if (targetEnv.any) GlobalPromise_1.any = targetEnv.any;
        }
    }
}
function snapShot() {
    var GlobalPromise = _global.Promise;
    return patchGlobalPromise ? {
        Promise: GlobalPromise,
        PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
        all: GlobalPromise.all,
        race: GlobalPromise.race,
        allSettled: GlobalPromise.allSettled,
        any: GlobalPromise.any,
        resolve: GlobalPromise.resolve,
        reject: GlobalPromise.reject,
        nthen: nativePromiseProto.then,
        gthen: GlobalPromise.prototype.then
    } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
    var outerScope = PSD;
    try {
        switchToZone(psd, true);
        return fn(a1, a2, a3);
    } finally{
        switchToZone(outerScope, false);
    }
}
function enqueueNativeMicroTask(job) {
    nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
    return typeof fn !== "function" ? fn : function() {
        var outerZone = PSD;
        if (possibleAwait) incrementExpectedAwaits();
        switchToZone(zone, true);
        try {
            return fn.apply(this, arguments);
        } finally{
            switchToZone(outerZone, false);
            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);
        }
    };
}
function getPatchedPromiseThen(origThen, zone) {
    return function(onResolved, onRejected) {
        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
    };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
    var rv;
    try {
        rv = promise.onuncatched(err);
    } catch (e) {}
    if (rv !== false) try {
        var event, eventData = {
            promise: promise,
            reason: err
        };
        if (_global.document && document.createEvent) {
            event = document.createEvent("Event");
            event.initEvent(UNHANDLEDREJECTION, true, true);
            extend(event, eventData);
        } else if (_global.CustomEvent) {
            event = new CustomEvent(UNHANDLEDREJECTION, {
                detail: eventData
            });
            extend(event, eventData);
        }
        if (event && _global.dispatchEvent) {
            dispatchEvent(event);
            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {
                _global.onunhandledrejection(event);
            } catch (_) {}
        }
        if (debug && event && !event.defaultPrevented) console.warn("Unhandled rejection: " + (err.stack || err));
    } catch (e) {}
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn) {
    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {
        if (db._state.openComplete) return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
        if (!db._state.isBeingOpened) {
            if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());
            db.open().catch(nop);
        }
        return db._state.dbReadyPromise.then(function() {
            return tempTransaction(db, mode, storeNames, fn);
        });
    } else {
        var trans = db._createTransaction(mode, storeNames, db._dbSchema);
        try {
            trans.create();
            db._state.PR1398_maxLoop = 3;
        } catch (ex) {
            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db._close();
                return db.open().then(function() {
                    return tempTransaction(db, mode, storeNames, fn);
                });
            }
            return rejection(ex);
        }
        return trans._promise(mode, function(resolve, reject) {
            return newScope(function() {
                PSD.trans = trans;
                return fn(resolve, reject, trans);
            });
        }).then(function(result) {
            return trans._completion.then(function() {
                return result;
            });
        });
    }
}
var DEXIE_VERSION = "3.2.4";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = function(frame) {
    return !/(dexie\.js|dexie\.min\.js)/.test(frame);
};
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine(filter1, filter2) {
    return filter1 ? filter2 ? function() {
        return filter1.apply(this, arguments) && filter2.apply(this, arguments);
    } : filter1 : filter2;
}
var AnyRange = {
    type: 3,
    lower: -Infinity,
    lowerOpen: false,
    upper: [
        []
    ],
    upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
    return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
        if (obj[keyPath] === undefined && keyPath in obj) {
            obj = deepClone(obj);
            delete obj[keyPath];
        }
        return obj;
    } : function(obj) {
        return obj;
    };
}
var Table = function() {
    function Table() {}
    Table.prototype._trans = function(mode, fn, writeLocked) {
        var trans = this._tx || PSD.trans;
        var tableName = this.name;
        function checkTableInTransaction(resolve, reject, trans) {
            if (!trans.schema[tableName]) throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans.idbtrans, trans);
        }
        var wasRootExec = beginMicroTickScope();
        try {
            return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
                return trans._promise(mode, checkTableInTransaction, writeLocked);
            }, {
                trans: trans,
                transless: PSD.transless || PSD
            }) : tempTransaction(this.db, mode, [
                this.name
            ], checkTableInTransaction);
        } finally{
            if (wasRootExec) endMicroTickScope();
        }
    };
    Table.prototype.get = function(keyOrCrit, cb) {
        var _this = this;
        if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);
        return this._trans("readonly", function(trans) {
            return _this.core.get({
                trans: trans,
                key: keyOrCrit
            }).then(function(res) {
                return _this.hook.reading.fire(res);
            });
        }).then(cb);
    };
    Table.prototype.where = function(indexOrCrit) {
        if (typeof indexOrCrit === "string") return new this.db.WhereClause(this, indexOrCrit);
        if (isArray(indexOrCrit)) return new this.db.WhereClause(this, "[" + indexOrCrit.join("+") + "]");
        var keyPaths = keys(indexOrCrit);
        if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
        var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
            return ix.compound && keyPaths.every(function(keyPath) {
                return ix.keyPath.indexOf(keyPath) >= 0;
            }) && ix.keyPath.every(function(keyPath) {
                return keyPaths.indexOf(keyPath) >= 0;
            });
        })[0];
        if (compoundIndex && this.db._maxKey !== maxString) return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map(function(kp) {
            return indexOrCrit[kp];
        }));
        if (!compoundIndex && debug) console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " + ("compound index [" + keyPaths.join("+") + "]"));
        var idxByName = this.schema.idxByName;
        var idb = this.db._deps.indexedDB;
        function equals(a, b) {
            try {
                return idb.cmp(a, b) === 0;
            } catch (e) {
                return false;
            }
        }
        var _a = keyPaths.reduce(function(_a, keyPath) {
            var prevIndex = _a[0], prevFilterFn = _a[1];
            var index = idxByName[keyPath];
            var value = indexOrCrit[keyPath];
            return [
                prevIndex || index,
                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                    var prop = getByKeyPath(x, keyPath);
                    return isArray(prop) && prop.some(function(item) {
                        return equals(value, item);
                    });
                } : function(x) {
                    return equals(value, getByKeyPath(x, keyPath));
                }) : prevFilterFn
            ];
        }, [
            null,
            null
        ]), idx = _a[0], filterFunction = _a[1];
        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
    };
    Table.prototype.filter = function(filterFunction) {
        return this.toCollection().and(filterFunction);
    };
    Table.prototype.count = function(thenShortcut) {
        return this.toCollection().count(thenShortcut);
    };
    Table.prototype.offset = function(offset) {
        return this.toCollection().offset(offset);
    };
    Table.prototype.limit = function(numRows) {
        return this.toCollection().limit(numRows);
    };
    Table.prototype.each = function(callback) {
        return this.toCollection().each(callback);
    };
    Table.prototype.toArray = function(thenShortcut) {
        return this.toCollection().toArray(thenShortcut);
    };
    Table.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
    };
    Table.prototype.orderBy = function(index) {
        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? "[" + index.join("+") + "]" : index));
    };
    Table.prototype.reverse = function() {
        return this.toCollection().reverse();
    };
    Table.prototype.mapToClass = function(constructor) {
        this.schema.mappedClass = constructor;
        var readHook = function(obj) {
            if (!obj) return obj;
            var res = Object.create(constructor.prototype);
            for(var m in obj)if (hasOwn(obj, m)) try {
                res[m] = obj[m];
            } catch (_) {}
            return res;
        };
        if (this.schema.readHook) this.hook.reading.unsubscribe(this.schema.readHook);
        this.schema.readHook = readHook;
        this.hook("reading", readHook);
        return constructor;
    };
    Table.prototype.defineClass = function() {
        function Class(content) {
            extend(this, content);
        }
        return this.mapToClass(Class);
    };
    Table.prototype.add = function(obj, key) {
        var _this = this;
        var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
        var objToAdd = obj;
        if (keyPath && auto) objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        return this._trans("readwrite", function(trans) {
            return _this.core.mutate({
                trans: trans,
                type: "add",
                keys: key != null ? [
                    key
                ] : null,
                values: [
                    objToAdd
                ]
            });
        }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
        }).then(function(lastResult) {
            if (keyPath) try {
                setByKeyPath(obj, keyPath, lastResult);
            } catch (_) {}
            return lastResult;
        });
    };
    Table.prototype.update = function(keyOrObject, modifications) {
        if (typeof keyOrObject === "object" && !isArray(keyOrObject)) {
            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === undefined) return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            try {
                if (typeof modifications !== "function") keys(modifications).forEach(function(keyPath) {
                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                });
                else modifications(keyOrObject, {
                    value: keyOrObject,
                    primKey: key
                });
            } catch (_a) {}
            return this.where(":id").equals(key).modify(modifications);
        } else return this.where(":id").equals(keyOrObject).modify(modifications);
    };
    Table.prototype.put = function(obj, key) {
        var _this = this;
        var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
        var objToAdd = obj;
        if (keyPath && auto) objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        return this._trans("readwrite", function(trans) {
            return _this.core.mutate({
                trans: trans,
                type: "put",
                values: [
                    objToAdd
                ],
                keys: key != null ? [
                    key
                ] : null
            });
        }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
        }).then(function(lastResult) {
            if (keyPath) try {
                setByKeyPath(obj, keyPath, lastResult);
            } catch (_) {}
            return lastResult;
        });
    };
    Table.prototype.delete = function(key) {
        var _this = this;
        return this._trans("readwrite", function(trans) {
            return _this.core.mutate({
                trans: trans,
                type: "delete",
                keys: [
                    key
                ]
            });
        }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
        });
    };
    Table.prototype.clear = function() {
        var _this = this;
        return this._trans("readwrite", function(trans) {
            return _this.core.mutate({
                trans: trans,
                type: "deleteRange",
                range: AnyRange
            });
        }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined;
        });
    };
    Table.prototype.bulkGet = function(keys) {
        var _this = this;
        return this._trans("readonly", function(trans) {
            return _this.core.getMany({
                keys: keys,
                trans: trans
            }).then(function(result) {
                return result.map(function(res) {
                    return _this.hook.reading.fire(res);
                });
            });
        });
    };
    Table.prototype.bulkAdd = function(objects, keysOrOptions, options) {
        var _this = this;
        var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
        options = options || (keys ? undefined : keysOrOptions);
        var wantResults = options ? options.allKeys : undefined;
        return this._trans("readwrite", function(trans) {
            var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            if (keyPath && keys) throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({
                trans: trans,
                type: "add",
                keys: keys,
                values: objectsToAdd,
                wantResults: wantResults
            }).then(function(_a) {
                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0) return result;
                throw new BulkError(_this.name + ".bulkAdd(): " + numFailures + " of " + numObjects + " operations failed", failures);
            });
        });
    };
    Table.prototype.bulkPut = function(objects, keysOrOptions, options) {
        var _this = this;
        var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
        options = options || (keys ? undefined : keysOrOptions);
        var wantResults = options ? options.allKeys : undefined;
        return this._trans("readwrite", function(trans) {
            var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            if (keyPath && keys) throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({
                trans: trans,
                type: "put",
                keys: keys,
                values: objectsToPut,
                wantResults: wantResults
            }).then(function(_a) {
                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                var result = wantResults ? results : lastResult;
                if (numFailures === 0) return result;
                throw new BulkError(_this.name + ".bulkPut(): " + numFailures + " of " + numObjects + " operations failed", failures);
            });
        });
    };
    Table.prototype.bulkDelete = function(keys) {
        var _this = this;
        var numKeys = keys.length;
        return this._trans("readwrite", function(trans) {
            return _this.core.mutate({
                trans: trans,
                type: "delete",
                keys: keys
            });
        }).then(function(_a) {
            var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
            if (numFailures === 0) return lastResult;
            throw new BulkError(_this.name + ".bulkDelete(): " + numFailures + " of " + numKeys + " operations failed", failures);
        });
    };
    return Table;
}();
function Events(ctx) {
    var evs = {};
    var rv = function(eventName, subscriber) {
        if (subscriber) {
            var i = arguments.length, args = new Array(i - 1);
            while(--i)args[i - 1] = arguments[i];
            evs[eventName].subscribe.apply(null, args);
            return ctx;
        } else if (typeof eventName === "string") return evs[eventName];
    };
    rv.addEventType = add;
    for(var i = 1, l = arguments.length; i < l; ++i)add(arguments[i]);
    return rv;
    function add(eventName, chainFunction, defaultFunction) {
        if (typeof eventName === "object") return addConfiguredEvents(eventName);
        if (!chainFunction) chainFunction = reverseStoppableEventChain;
        if (!defaultFunction) defaultFunction = nop;
        var context = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: function(cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                    context.subscribers.push(cb);
                    context.fire = chainFunction(context.fire, cb);
                }
            },
            unsubscribe: function(cb) {
                context.subscribers = context.subscribers.filter(function(fn) {
                    return fn !== cb;
                });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
            }
        };
        evs[eventName] = rv[eventName] = context;
        return context;
    }
    function addConfiguredEvents(cfg) {
        keys(cfg).forEach(function(eventName) {
            var args = cfg[eventName];
            if (isArray(args)) add(eventName, cfg[eventName][0], cfg[eventName][1]);
            else if (args === "asap") var context = add(eventName, mirror, function fire() {
                var i = arguments.length, args = new Array(i);
                while(i--)args[i] = arguments[i];
                context.subscribers.forEach(function(fn) {
                    asap$1(function fireEvent() {
                        fn.apply(null, args);
                    });
                });
            });
            else throw new exceptions.InvalidArgument("Invalid event config");
        });
    }
}
function makeClassConstructor(prototype, constructor) {
    derive(constructor).from({
        prototype: prototype
    });
    return constructor;
}
function createTableConstructor(db) {
    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
        this.db = db;
        this._tx = trans;
        this.name = name;
        this.schema = tableSchema;
        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
            "creating": [
                hookCreatingChain,
                nop
            ],
            "reading": [
                pureFunctionChain,
                mirror
            ],
            "updating": [
                hookUpdatingChain,
                nop
            ],
            "deleting": [
                hookDeletingChain,
                nop
            ]
        });
    });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
    ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
    var curr = ctx.replayFilter;
    ctx.replayFilter = curr ? function() {
        return combine(curr(), factory());
    } : factory;
    ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
    ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
    if (ctx.isPrimKey) return coreSchema.primaryKey;
    var index = coreSchema.getIndexByKeyPath(ctx.index);
    if (!index) throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
    return index;
}
function openCursor(ctx, coreTable, trans) {
    var index = getIndexOrStore(ctx, coreTable.schema);
    return coreTable.openCursor({
        trans: trans,
        values: !ctx.keysOnly,
        reverse: ctx.dir === "prev",
        unique: !!ctx.unique,
        query: {
            index: index,
            range: ctx.range
        }
    });
}
function iter(ctx, fn, coreTrans, coreTable) {
    var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
    if (!ctx.or) return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
    else {
        var set_1 = {};
        var union = function(item, cursor, advance) {
            if (!filter || filter(cursor, advance, function(result) {
                return cursor.stop(result);
            }, function(err) {
                return cursor.fail(err);
            })) {
                var primaryKey = cursor.primaryKey;
                var key = "" + primaryKey;
                if (key === "[object ArrayBuffer]") key = "" + new Uint8Array(primaryKey);
                if (!hasOwn(set_1, key)) {
                    set_1[key] = true;
                    fn(item, cursor, advance);
                }
            }
        };
        return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
        ]);
    }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
    var mappedFn = valueMapper ? function(x, c, a) {
        return fn(valueMapper(x), c, a);
    } : fn;
    var wrappedFn = wrap(mappedFn);
    return cursorPromise.then(function(cursor) {
        if (cursor) return cursor.start(function() {
            var c = function() {
                return cursor.continue();
            };
            if (!filter || filter(cursor, function(advancer) {
                return c = advancer;
            }, function(val) {
                cursor.stop(val);
                c = nop;
            }, function(e) {
                cursor.fail(e);
                c = nop;
            })) wrappedFn(cursor.value, cursor, function(advancer) {
                return c = advancer;
            });
            c();
        });
    });
}
function cmp(a, b) {
    try {
        var ta = type(a);
        var tb = type(b);
        if (ta !== tb) {
            if (ta === "Array") return 1;
            if (tb === "Array") return -1;
            if (ta === "binary") return 1;
            if (tb === "binary") return -1;
            if (ta === "string") return 1;
            if (tb === "string") return -1;
            if (ta === "Date") return 1;
            if (tb !== "Date") return NaN;
            return -1;
        }
        switch(ta){
            case "number":
            case "Date":
            case "string":
                return a > b ? 1 : a < b ? -1 : 0;
            case "binary":
                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
            case "Array":
                return compareArrays(a, b);
        }
    } catch (_a) {}
    return NaN;
}
function compareArrays(a, b) {
    var al = a.length;
    var bl = b.length;
    var l = al < bl ? al : bl;
    for(var i = 0; i < l; ++i){
        var res = cmp(a[i], b[i]);
        if (res !== 0) return res;
    }
    return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
    var al = a.length;
    var bl = b.length;
    var l = al < bl ? al : bl;
    for(var i = 0; i < l; ++i){
        if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;
    }
    return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
    var t = typeof x;
    if (t !== "object") return t;
    if (ArrayBuffer.isView(x)) return "binary";
    var tsTag = toStringTag(x);
    return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
    if (a instanceof Uint8Array) return a;
    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    return new Uint8Array(a);
}
var Collection = function() {
    function Collection() {}
    Collection.prototype._read = function(fn, cb) {
        var ctx = this._ctx;
        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
    };
    Collection.prototype._write = function(fn) {
        var ctx = this._ctx;
        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
    };
    Collection.prototype._addAlgorithm = function(fn) {
        var ctx = this._ctx;
        ctx.algorithm = combine(ctx.algorithm, fn);
    };
    Collection.prototype._iterate = function(fn, coreTrans) {
        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
    };
    Collection.prototype.clone = function(props) {
        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
        if (props) extend(ctx, props);
        rv._ctx = ctx;
        return rv;
    };
    Collection.prototype.raw = function() {
        this._ctx.valueMapper = null;
        return this;
    };
    Collection.prototype.each = function(fn) {
        var ctx = this._ctx;
        return this._read(function(trans) {
            return iter(ctx, fn, trans, ctx.table.core);
        });
    };
    Collection.prototype.count = function(cb) {
        var _this = this;
        return this._read(function(trans) {
            var ctx = _this._ctx;
            var coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) return coreTable.count({
                trans: trans,
                query: {
                    index: getIndexOrStore(ctx, coreTable.schema),
                    range: ctx.range
                }
            }).then(function(count) {
                return Math.min(count, ctx.limit);
            });
            else {
                var count = 0;
                return iter(ctx, function() {
                    ++count;
                    return false;
                }, trans, coreTable).then(function() {
                    return count;
                });
            }
        }).then(cb);
    };
    Collection.prototype.sortBy = function(keyPath, cb) {
        var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
        function getval(obj, i) {
            if (i) return getval(obj[parts[i]], i - 1);
            return obj[lastPart];
        }
        var order = this._ctx.dir === "next" ? 1 : -1;
        function sorter(a, b) {
            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
            return aVal < bVal ? -order : aVal > bVal ? order : 0;
        }
        return this.toArray(function(a) {
            return a.sort(sorter);
        }).then(cb);
    };
    Collection.prototype.toArray = function(cb) {
        var _this = this;
        return this._read(function(trans) {
            var ctx = _this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                var valueMapper_1 = ctx.valueMapper;
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                    trans: trans,
                    limit: ctx.limit,
                    values: true,
                    query: {
                        index: index,
                        range: ctx.range
                    }
                }).then(function(_a) {
                    var result = _a.result;
                    return valueMapper_1 ? result.map(valueMapper_1) : result;
                });
            } else {
                var a_1 = [];
                return iter(ctx, function(item) {
                    return a_1.push(item);
                }, trans, ctx.table.core).then(function() {
                    return a_1;
                });
            }
        }, cb);
    };
    Collection.prototype.offset = function(offset) {
        var ctx = this._ctx;
        if (offset <= 0) return this;
        ctx.offset += offset;
        if (isPlainKeyRange(ctx)) addReplayFilter(ctx, function() {
            var offsetLeft = offset;
            return function(cursor, advance) {
                if (offsetLeft === 0) return true;
                if (offsetLeft === 1) {
                    --offsetLeft;
                    return false;
                }
                advance(function() {
                    cursor.advance(offsetLeft);
                    offsetLeft = 0;
                });
                return false;
            };
        });
        else addReplayFilter(ctx, function() {
            var offsetLeft = offset;
            return function() {
                return --offsetLeft < 0;
            };
        });
        return this;
    };
    Collection.prototype.limit = function(numRows) {
        this._ctx.limit = Math.min(this._ctx.limit, numRows);
        addReplayFilter(this._ctx, function() {
            var rowsLeft = numRows;
            return function(cursor, advance, resolve) {
                if (--rowsLeft <= 0) advance(resolve);
                return rowsLeft >= 0;
            };
        }, true);
        return this;
    };
    Collection.prototype.until = function(filterFunction, bIncludeStopEntry) {
        addFilter(this._ctx, function(cursor, advance, resolve) {
            if (filterFunction(cursor.value)) {
                advance(resolve);
                return bIncludeStopEntry;
            } else return true;
        });
        return this;
    };
    Collection.prototype.first = function(cb) {
        return this.limit(1).toArray(function(a) {
            return a[0];
        }).then(cb);
    };
    Collection.prototype.last = function(cb) {
        return this.reverse().first(cb);
    };
    Collection.prototype.filter = function(filterFunction) {
        addFilter(this._ctx, function(cursor) {
            return filterFunction(cursor.value);
        });
        addMatchFilter(this._ctx, filterFunction);
        return this;
    };
    Collection.prototype.and = function(filter) {
        return this.filter(filter);
    };
    Collection.prototype.or = function(indexName) {
        return new this.db.WhereClause(this._ctx.table, indexName, this);
    };
    Collection.prototype.reverse = function() {
        this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
        if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);
        return this;
    };
    Collection.prototype.desc = function() {
        return this.reverse();
    };
    Collection.prototype.eachKey = function(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function(val, cursor) {
            cb(cursor.key, cursor);
        });
    };
    Collection.prototype.eachUniqueKey = function(cb) {
        this._ctx.unique = "unique";
        return this.eachKey(cb);
    };
    Collection.prototype.eachPrimaryKey = function(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function(val, cursor) {
            cb(cursor.primaryKey, cursor);
        });
    };
    Collection.prototype.keys = function(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function(item, cursor) {
            a.push(cursor.key);
        }).then(function() {
            return a;
        }).then(cb);
    };
    Collection.prototype.primaryKeys = function(cb) {
        var ctx = this._ctx;
        if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) return this._read(function(trans) {
            var index = getIndexOrStore(ctx, ctx.table.core.schema);
            return ctx.table.core.query({
                trans: trans,
                values: false,
                limit: ctx.limit,
                query: {
                    index: index,
                    range: ctx.range
                }
            });
        }).then(function(_a) {
            var result = _a.result;
            return result;
        }).then(cb);
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function(item, cursor) {
            a.push(cursor.primaryKey);
        }).then(function() {
            return a;
        }).then(cb);
    };
    Collection.prototype.uniqueKeys = function(cb) {
        this._ctx.unique = "unique";
        return this.keys(cb);
    };
    Collection.prototype.firstKey = function(cb) {
        return this.limit(1).keys(function(a) {
            return a[0];
        }).then(cb);
    };
    Collection.prototype.lastKey = function(cb) {
        return this.reverse().firstKey(cb);
    };
    Collection.prototype.distinct = function() {
        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
        if (!idx || !idx.multi) return this;
        var set = {};
        addFilter(this._ctx, function(cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set, strKey);
            set[strKey] = true;
            return !found;
        });
        return this;
    };
    Collection.prototype.modify = function(changes) {
        var _this = this;
        var ctx = this._ctx;
        return this._write(function(trans) {
            var modifyer;
            if (typeof changes === "function") modifyer = changes;
            else {
                var keyPaths = keys(changes);
                var numKeys = keyPaths.length;
                modifyer = function(item) {
                    var anythingModified = false;
                    for(var i = 0; i < numKeys; ++i){
                        var keyPath = keyPaths[i], val = changes[keyPath];
                        if (getByKeyPath(item, keyPath) !== val) {
                            setByKeyPath(item, keyPath, val);
                            anythingModified = true;
                        }
                    }
                    return anythingModified;
                };
            }
            var coreTable = ctx.table.core;
            var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
            var limit = _this.db._options.modifyChunkSize || 200;
            var totalFailures = [];
            var successCount = 0;
            var failedKeys = [];
            var applyMutateResult = function(expectedCount, res) {
                var failures = res.failures, numFailures = res.numFailures;
                successCount += expectedCount - numFailures;
                for(var _i = 0, _a = keys(failures); _i < _a.length; _i++){
                    var pos = _a[_i];
                    totalFailures.push(failures[pos]);
                }
            };
            return _this.clone().primaryKeys().then(function(keys) {
                var nextChunk = function(offset) {
                    var count = Math.min(limit, keys.length - offset);
                    return coreTable.getMany({
                        trans: trans,
                        keys: keys.slice(offset, offset + count),
                        cache: "immutable"
                    }).then(function(values) {
                        var addValues = [];
                        var putValues = [];
                        var putKeys = outbound ? [] : null;
                        var deleteKeys = [];
                        for(var i = 0; i < count; ++i){
                            var origValue = values[i];
                            var ctx_1 = {
                                value: deepClone(origValue),
                                primKey: keys[offset + i]
                            };
                            if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                if (ctx_1.value == null) deleteKeys.push(keys[offset + i]);
                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                    deleteKeys.push(keys[offset + i]);
                                    addValues.push(ctx_1.value);
                                } else {
                                    putValues.push(ctx_1.value);
                                    if (outbound) putKeys.push(keys[offset + i]);
                                }
                            }
                        }
                        var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                            index: ctx.index,
                            range: ctx.range
                        };
                        return Promise.resolve(addValues.length > 0 && coreTable.mutate({
                            trans: trans,
                            type: "add",
                            values: addValues
                        }).then(function(res) {
                            for(var pos in res.failures)deleteKeys.splice(parseInt(pos), 1);
                            applyMutateResult(addValues.length, res);
                        })).then(function() {
                            return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                                trans: trans,
                                type: "put",
                                keys: putKeys,
                                values: putValues,
                                criteria: criteria,
                                changeSpec: typeof changes !== "function" && changes
                            }).then(function(res) {
                                return applyMutateResult(putValues.length, res);
                            });
                        }).then(function() {
                            return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                                trans: trans,
                                type: "delete",
                                keys: deleteKeys,
                                criteria: criteria
                            }).then(function(res) {
                                return applyMutateResult(deleteKeys.length, res);
                            });
                        }).then(function() {
                            return keys.length > offset + count && nextChunk(offset + limit);
                        });
                    });
                };
                return nextChunk(0).then(function() {
                    if (totalFailures.length > 0) throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                    return keys.length;
                });
            });
        });
    };
    Collection.prototype.delete = function() {
        var ctx = this._ctx, range = ctx.range;
        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) return this._write(function(trans) {
            var primaryKey = ctx.table.core.schema.primaryKey;
            var coreRange = range;
            return ctx.table.core.count({
                trans: trans,
                query: {
                    index: primaryKey,
                    range: coreRange
                }
            }).then(function(count) {
                return ctx.table.core.mutate({
                    trans: trans,
                    type: "deleteRange",
                    range: coreRange
                }).then(function(_a) {
                    var failures = _a.failures;
                    _a.lastResult;
                    _a.results;
                    var numFailures = _a.numFailures;
                    if (numFailures) throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                        return failures[pos];
                    }), count - numFailures);
                    return count - numFailures;
                });
            });
        });
        return this.modify(deleteCallback);
    };
    return Collection;
}();
var deleteCallback = function(value, ctx) {
    return ctx.value = null;
};
function createCollectionConstructor(db) {
    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
        this.db = db;
        var keyRange = AnyRange, error = null;
        if (keyRangeGenerator) try {
            keyRange = keyRangeGenerator();
        } catch (ex) {
            error = ex;
        }
        var whereCtx = whereClause._ctx;
        var table = whereCtx.table;
        var readingHook = table.hook.reading.fire;
        this._ctx = {
            table: table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error: error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
        };
    });
}
function simpleCompare(a, b) {
    return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
    return a > b ? -1 : a === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
    collection._ctx.error = T ? new T(err) : new TypeError(err);
    return collection;
}
function emptyCollection(whereClause) {
    return new whereClause.Collection(whereClause, function() {
        return rangeEqual("");
    }).limit(0);
}
function upperFactory(dir) {
    return dir === "next" ? function(s) {
        return s.toUpperCase();
    } : function(s) {
        return s.toLowerCase();
    };
}
function lowerFactory(dir) {
    return dir === "next" ? function(s) {
        return s.toLowerCase();
    } : function(s) {
        return s.toUpperCase();
    };
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
    var length = Math.min(key.length, lowerNeedle.length);
    var llp = -1;
    for(var i = 0; i < length; ++i){
        var lwrKeyChar = lowerKey[i];
        if (lwrKeyChar !== lowerNeedle[i]) {
            if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
            if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
            if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
        }
        if (cmp(key[i], lwrKeyChar) < 0) llp = i;
    }
    if (length < lowerNeedle.length && dir === "next") return key + upperNeedle.substr(key.length);
    if (length < key.length && dir === "prev") return key.substr(0, upperNeedle.length);
    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
    if (!needles.every(function(s) {
        return typeof s === "string";
    })) return fail(whereClause, STRING_EXPECTED);
    function initDirection(dir) {
        upper = upperFactory(dir);
        lower = lowerFactory(dir);
        compare = dir === "next" ? simpleCompare : simpleCompareReverse;
        var needleBounds = needles.map(function(needle) {
            return {
                lower: lower(needle),
                upper: upper(needle)
            };
        }).sort(function(a, b) {
            return compare(a.lower, b.lower);
        });
        upperNeedles = needleBounds.map(function(nb) {
            return nb.upper;
        });
        lowerNeedles = needleBounds.map(function(nb) {
            return nb.lower;
        });
        direction = dir;
        nextKeySuffix = dir === "next" ? "" : suffix;
    }
    initDirection("next");
    var c = new whereClause.Collection(whereClause, function() {
        return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
    });
    c._ondirectionchange = function(direction) {
        initDirection(direction);
    };
    var firstPossibleNeedle = 0;
    c._addAlgorithm(function(cursor, advance, resolve) {
        var key = cursor.key;
        if (typeof key !== "string") return false;
        var lowerKey = lower(key);
        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) return true;
        else {
            var lowestPossibleCasing = null;
            for(var i = firstPossibleNeedle; i < needlesLen; ++i){
                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;
                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) lowestPossibleCasing = casing;
            }
            if (lowestPossibleCasing !== null) advance(function() {
                cursor.continue(lowestPossibleCasing + nextKeySuffix);
            });
            else advance(resolve);
            return false;
        }
    });
    return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
    return {
        type: 2,
        lower: lower,
        upper: upper,
        lowerOpen: lowerOpen,
        upperOpen: upperOpen
    };
}
function rangeEqual(value) {
    return {
        type: 1,
        lower: value,
        upper: value
    };
}
var WhereClause = function() {
    function WhereClause() {}
    Object.defineProperty(WhereClause.prototype, "Collection", {
        get: function() {
            return this._ctx.table.db.Collection;
        },
        enumerable: false,
        configurable: true
    });
    WhereClause.prototype.between = function(lower, upper, includeLower, includeUpper) {
        includeLower = includeLower !== false;
        includeUpper = includeUpper === true;
        try {
            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);
            return new this.Collection(this, function() {
                return createRange(lower, upper, !includeLower, !includeUpper);
            });
        } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
    };
    WhereClause.prototype.equals = function(value) {
        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
            return rangeEqual(value);
        });
    };
    WhereClause.prototype.above = function(value) {
        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
            return createRange(value, undefined, true);
        });
    };
    WhereClause.prototype.aboveOrEqual = function(value) {
        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
            return createRange(value, undefined, false);
        });
    };
    WhereClause.prototype.below = function(value) {
        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
            return createRange(undefined, value, false, true);
        });
    };
    WhereClause.prototype.belowOrEqual = function(value) {
        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, function() {
            return createRange(undefined, value);
        });
    };
    WhereClause.prototype.startsWith = function(str) {
        if (typeof str !== "string") return fail(this, STRING_EXPECTED);
        return this.between(str, str + maxString, true, true);
    };
    WhereClause.prototype.startsWithIgnoreCase = function(str) {
        if (str === "") return this.startsWith(str);
        return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x.indexOf(a[0]) === 0;
        }, [
            str
        ], maxString);
    };
    WhereClause.prototype.equalsIgnoreCase = function(str) {
        return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x === a[0];
        }, [
            str
        ], "");
    };
    WhereClause.prototype.anyOfIgnoreCase = function() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0) return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.indexOf(x) !== -1;
        }, set, "");
    };
    WhereClause.prototype.startsWithAnyOfIgnoreCase = function() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0) return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.some(function(n) {
                return x.indexOf(n) === 0;
            });
        }, set, maxString);
    };
    WhereClause.prototype.anyOf = function() {
        var _this = this;
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        var compare = this._cmp;
        try {
            set.sort(compare);
        } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        if (set.length === 0) return emptyCollection(this);
        var c = new this.Collection(this, function() {
            return createRange(set[0], set[set.length - 1]);
        });
        c._ondirectionchange = function(direction) {
            compare = direction === "next" ? _this._ascending : _this._descending;
            set.sort(compare);
        };
        var i = 0;
        c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while(compare(key, set[i]) > 0){
                ++i;
                if (i === set.length) {
                    advance(resolve);
                    return false;
                }
            }
            if (compare(key, set[i]) === 0) return true;
            else {
                advance(function() {
                    cursor.continue(set[i]);
                });
                return false;
            }
        });
        return c;
    };
    WhereClause.prototype.notEqual = function(value) {
        return this.inAnyRange([
            [
                minKey,
                value
            ],
            [
                value,
                this.db._maxKey
            ]
        ], {
            includeLowers: false,
            includeUppers: false
        });
    };
    WhereClause.prototype.noneOf = function() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0) return new this.Collection(this);
        try {
            set.sort(this._ascending);
        } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        var ranges = set.reduce(function(res, val) {
            return res ? res.concat([
                [
                    res[res.length - 1][1],
                    val
                ]
            ]) : [
                [
                    minKey,
                    val
                ]
            ];
        }, null);
        ranges.push([
            set[set.length - 1],
            this.db._maxKey
        ]);
        return this.inAnyRange(ranges, {
            includeLowers: false,
            includeUppers: false
        });
    };
    WhereClause.prototype.inAnyRange = function(ranges, options) {
        var _this = this;
        var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
        if (ranges.length === 0) return emptyCollection(this);
        if (!ranges.every(function(range) {
            return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;
        })) return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
        var includeLowers = !options || options.includeLowers !== false;
        var includeUppers = options && options.includeUppers === true;
        function addRange(ranges, newRange) {
            var i = 0, l = ranges.length;
            for(; i < l; ++i){
                var range = ranges[i];
                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                    range[0] = min(range[0], newRange[0]);
                    range[1] = max(range[1], newRange[1]);
                    break;
                }
            }
            if (i === l) ranges.push(newRange);
            return ranges;
        }
        var sortDirection = ascending;
        function rangeSorter(a, b) {
            return sortDirection(a[0], b[0]);
        }
        var set;
        try {
            set = ranges.reduce(addRange, []);
            set.sort(rangeSorter);
        } catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        var rangePos = 0;
        var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
            return ascending(key, set[rangePos][1]) > 0;
        } : function(key) {
            return ascending(key, set[rangePos][1]) >= 0;
        };
        var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
            return descending(key, set[rangePos][0]) > 0;
        } : function(key) {
            return descending(key, set[rangePos][0]) >= 0;
        };
        function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
        }
        var checkKey = keyIsBeyondCurrentEntry;
        var c = new this.Collection(this, function() {
            return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
        });
        c._ondirectionchange = function(direction) {
            if (direction === "next") {
                checkKey = keyIsBeyondCurrentEntry;
                sortDirection = ascending;
            } else {
                checkKey = keyIsBeforeCurrentEntry;
                sortDirection = descending;
            }
            set.sort(rangeSorter);
        };
        c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while(checkKey(key)){
                ++rangePos;
                if (rangePos === set.length) {
                    advance(resolve);
                    return false;
                }
            }
            if (keyWithinCurrentRange(key)) return true;
            else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) return false;
            else {
                advance(function() {
                    if (sortDirection === ascending) cursor.continue(set[rangePos][0]);
                    else cursor.continue(set[rangePos][1]);
                });
                return false;
            }
        });
        return c;
    };
    WhereClause.prototype.startsWithAnyOf = function() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (!set.every(function(s) {
            return typeof s === "string";
        })) return fail(this, "startsWithAnyOf() only works with strings");
        if (set.length === 0) return emptyCollection(this);
        return this.inAnyRange(set.map(function(str) {
            return [
                str,
                str + maxString
            ];
        }));
    };
    return WhereClause;
}();
function createWhereClauseConstructor(db) {
    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
        this.db = db;
        this._ctx = {
            table: table,
            index: index === ":id" ? null : index,
            or: orCollection
        };
        var indexedDB1 = db._deps.indexedDB;
        if (!indexedDB1) throw new exceptions.MissingAPI();
        this._cmp = this._ascending = indexedDB1.cmp.bind(indexedDB1);
        this._descending = function(a, b) {
            return indexedDB1.cmp(b, a);
        };
        this._max = function(a, b) {
            return indexedDB1.cmp(a, b) > 0 ? a : b;
        };
        this._min = function(a, b) {
            return indexedDB1.cmp(a, b) < 0 ? a : b;
        };
        this._IDBKeyRange = db._deps.IDBKeyRange;
    });
}
function eventRejectHandler(reject) {
    return wrap(function(event) {
        preventDefault(event);
        reject(event.target.error);
        return false;
    });
}
function preventDefault(event) {
    if (event.stopPropagation) event.stopPropagation();
    if (event.preventDefault) event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction = function() {
    function Transaction() {}
    Transaction.prototype._lock = function() {
        assert(!PSD.global);
        ++this._reculock;
        if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;
        return this;
    };
    Transaction.prototype._unlock = function() {
        assert(!PSD.global);
        if (--this._reculock === 0) {
            if (!PSD.global) PSD.lockOwnerFor = null;
            while(this._blockedFuncs.length > 0 && !this._locked()){
                var fnAndPSD = this._blockedFuncs.shift();
                try {
                    usePSD(fnAndPSD[1], fnAndPSD[0]);
                } catch (e) {}
            }
        }
        return this;
    };
    Transaction.prototype._locked = function() {
        return this._reculock && PSD.lockOwnerFor !== this;
    };
    Transaction.prototype.create = function(idbtrans) {
        var _this = this;
        if (!this.mode) return this;
        var idbdb = this.db.idbdb;
        var dbOpenError = this.db._state.dbOpenError;
        assert(!this.idbtrans);
        if (!idbtrans && !idbdb) switch(dbOpenError && dbOpenError.name){
            case "DatabaseClosedError":
                throw new exceptions.DatabaseClosed(dbOpenError);
            case "MissingAPIError":
                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
            default:
                throw new exceptions.OpenFailed(dbOpenError);
        }
        if (!this.active) throw new exceptions.TransactionInactive();
        assert(this._completion._state === null);
        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {
            durability: this.chromeTransactionDurability
        }) : idbdb.transaction(this.storeNames, this.mode, {
            durability: this.chromeTransactionDurability
        }));
        idbtrans.onerror = wrap(function(ev) {
            preventDefault(ev);
            _this._reject(idbtrans.error);
        });
        idbtrans.onabort = wrap(function(ev) {
            preventDefault(ev);
            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
            _this.active = false;
            _this.on("abort").fire(ev);
        });
        idbtrans.oncomplete = wrap(function() {
            _this.active = false;
            _this._resolve();
            if ("mutatedParts" in idbtrans) globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
        });
        return this;
    };
    Transaction.prototype._promise = function(mode, fn, bWriteLock) {
        var _this = this;
        if (mode === "readwrite" && this.mode !== "readwrite") return rejection(new exceptions.ReadOnly("Transaction is readonly"));
        if (!this.active) return rejection(new exceptions.TransactionInactive());
        if (this._locked()) return new DexiePromise(function(resolve, reject) {
            _this._blockedFuncs.push([
                function() {
                    _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                },
                PSD
            ]);
        });
        else if (bWriteLock) return newScope(function() {
            var p = new DexiePromise(function(resolve, reject) {
                _this._lock();
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then) rv.then(resolve, reject);
            });
            p.finally(function() {
                return _this._unlock();
            });
            p._lib = true;
            return p;
        });
        else {
            var p = new DexiePromise(function(resolve, reject) {
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then) rv.then(resolve, reject);
            });
            p._lib = true;
            return p;
        }
    };
    Transaction.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
    };
    Transaction.prototype.waitFor = function(promiseLike) {
        var root = this._root();
        var promise = DexiePromise.resolve(promiseLike);
        if (root._waitingFor) root._waitingFor = root._waitingFor.then(function() {
            return promise;
        });
        else {
            root._waitingFor = promise;
            root._waitingQueue = [];
            var store = root.idbtrans.objectStore(root.storeNames[0]);
            (function spin() {
                ++root._spinCount;
                while(root._waitingQueue.length)root._waitingQueue.shift()();
                if (root._waitingFor) store.get(-Infinity).onsuccess = spin;
            })();
        }
        var currentWaitPromise = root._waitingFor;
        return new DexiePromise(function(resolve, reject) {
            promise.then(function(res) {
                return root._waitingQueue.push(wrap(resolve.bind(null, res)));
            }, function(err) {
                return root._waitingQueue.push(wrap(reject.bind(null, err)));
            }).finally(function() {
                if (root._waitingFor === currentWaitPromise) root._waitingFor = null;
            });
        });
    };
    Transaction.prototype.abort = function() {
        if (this.active) {
            this.active = false;
            if (this.idbtrans) this.idbtrans.abort();
            this._reject(new exceptions.Abort());
        }
    };
    Transaction.prototype.table = function(tableName) {
        var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
        if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];
        var tableSchema = this.schema[tableName];
        if (!tableSchema) throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
        var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
        transactionBoundTable.core = this.db.core.table(tableName);
        memoizedTables[tableName] = transactionBoundTable;
        return transactionBoundTable;
    };
    return Transaction;
}();
function createTransactionConstructor(db) {
    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
        var _this = this;
        this.db = db;
        this.mode = mode;
        this.storeNames = storeNames;
        this.schema = dbschema;
        this.chromeTransactionDurability = chromeTransactionDurability;
        this.idbtrans = null;
        this.on = Events(this, "complete", "error", "abort");
        this.parent = parent || null;
        this.active = true;
        this._reculock = 0;
        this._blockedFuncs = [];
        this._resolve = null;
        this._reject = null;
        this._waitingFor = null;
        this._waitingQueue = null;
        this._spinCount = 0;
        this._completion = new DexiePromise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
        this._completion.then(function() {
            _this.active = false;
            _this.on.complete.fire();
        }, function(e) {
            var wasActive = _this.active;
            _this.active = false;
            _this.on.error.fire(e);
            _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
            return rejection(e);
        });
    });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
    return {
        name: name,
        keyPath: keyPath,
        unique: unique,
        multi: multi,
        auto: auto,
        compound: compound,
        src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
    };
}
function nameFromKeyPath(keyPath) {
    return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
    return {
        name: name,
        primKey: primKey,
        indexes: indexes,
        mappedClass: null,
        idxByName: arrayToObject(indexes, function(index) {
            return [
                index.name,
                index
            ];
        })
    };
}
function safariMultiStoreFix(storeNames) {
    return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = function(IdbKeyRange) {
    try {
        IdbKeyRange.only([
            []
        ]);
        getMaxKey = function() {
            return [
                []
            ];
        };
        return [
            []
        ];
    } catch (e) {
        getMaxKey = function() {
            return maxString;
        };
        return maxString;
    }
};
function getKeyExtractor(keyPath) {
    if (keyPath == null) return function() {
        return undefined;
    };
    else if (typeof keyPath === "string") return getSinglePathKeyExtractor(keyPath);
    else return function(obj) {
        return getByKeyPath(obj, keyPath);
    };
}
function getSinglePathKeyExtractor(keyPath) {
    var split = keyPath.split(".");
    if (split.length === 1) return function(obj) {
        return obj[keyPath];
    };
    else return function(obj) {
        return getByKeyPath(obj, keyPath);
    };
}
function arrayify(arrayLike) {
    return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
    return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[" + keyPath.join("+") + "]";
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
    function extractSchema(db, trans) {
        var tables = arrayify(db.objectStoreNames);
        return {
            schema: {
                name: db.name,
                tables: tables.map(function(table) {
                    return trans.objectStore(table);
                }).map(function(store) {
                    var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                    var compound = isArray(keyPath);
                    var outbound = keyPath == null;
                    var indexByKeyPath = {};
                    var result = {
                        name: store.name,
                        primaryKey: {
                            name: null,
                            isPrimaryKey: true,
                            outbound: outbound,
                            compound: compound,
                            keyPath: keyPath,
                            autoIncrement: autoIncrement,
                            unique: true,
                            extractKey: getKeyExtractor(keyPath)
                        },
                        indexes: arrayify(store.indexNames).map(function(indexName) {
                            return store.index(indexName);
                        }).map(function(index) {
                            var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                            var compound = isArray(keyPath);
                            var result = {
                                name: name,
                                compound: compound,
                                keyPath: keyPath,
                                unique: unique,
                                multiEntry: multiEntry,
                                extractKey: getKeyExtractor(keyPath)
                            };
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                            return result;
                        }),
                        getIndexByKeyPath: function(keyPath) {
                            return indexByKeyPath[getKeyPathAlias(keyPath)];
                        }
                    };
                    indexByKeyPath[":id"] = result.primaryKey;
                    if (keyPath != null) indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                    return result;
                })
            },
            hasGetAll: tables.length > 0 && "getAll" in trans.objectStore(tables[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
        };
    }
    function makeIDBKeyRange(range) {
        if (range.type === 3) return null;
        if (range.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
        var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
        var idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
        return idbRange;
    }
    function createDbCoreTable(tableSchema) {
        var tableName = tableSchema.name;
        function mutate(_a) {
            var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
            return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var outbound = store.keyPath == null;
                var isAddOrPut = type === "put" || type === "add";
                if (!isAddOrPut && type !== "delete" && type !== "deleteRange") throw new Error("Invalid operation type: " + type);
                var length = (keys || values || {
                    length: 1
                }).length;
                if (keys && values && keys.length !== values.length) throw new Error("Given keys array must have same length as given values array.");
                if (length === 0) return resolve({
                    numFailures: 0,
                    failures: {},
                    results: [],
                    lastResult: undefined
                });
                var req;
                var reqs = [];
                var failures = [];
                var numFailures = 0;
                var errorHandler = function(event) {
                    ++numFailures;
                    preventDefault(event);
                };
                if (type === "deleteRange") {
                    if (range.type === 4) return resolve({
                        numFailures: numFailures,
                        failures: failures,
                        results: [],
                        lastResult: undefined
                    });
                    if (range.type === 3) reqs.push(req = store.clear());
                    else reqs.push(req = store.delete(makeIDBKeyRange(range)));
                } else {
                    var _a = isAddOrPut ? outbound ? [
                        values,
                        keys
                    ] : [
                        values,
                        null
                    ] : [
                        keys,
                        null
                    ], args1 = _a[0], args2 = _a[1];
                    if (isAddOrPut) for(var i = 0; i < length; ++i){
                        reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));
                        req.onerror = errorHandler;
                    }
                    else for(var i = 0; i < length; ++i){
                        reqs.push(req = store[type](args1[i]));
                        req.onerror = errorHandler;
                    }
                }
                var done = function(event) {
                    var lastResult = event.target.result;
                    reqs.forEach(function(req, i) {
                        return req.error != null && (failures[i] = req.error);
                    });
                    resolve({
                        numFailures: numFailures,
                        failures: failures,
                        results: type === "delete" ? keys : reqs.map(function(req) {
                            return req.result;
                        }),
                        lastResult: lastResult
                    });
                };
                req.onerror = function(event) {
                    errorHandler(event);
                    done(event);
                };
                req.onsuccess = done;
            });
        }
        function openCursor(_a) {
            var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
            return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var index = query.index, range = query.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
                var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap(function(ev) {
                    var cursor = req.result;
                    if (!cursor) {
                        resolve(null);
                        return;
                    }
                    cursor.___id = ++_id_counter;
                    cursor.done = false;
                    var _cursorContinue = cursor.continue.bind(cursor);
                    var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                    if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                    var _cursorAdvance = cursor.advance.bind(cursor);
                    var doThrowCursorIsNotStarted = function() {
                        throw new Error("Cursor not started");
                    };
                    var doThrowCursorIsStopped = function() {
                        throw new Error("Cursor not stopped");
                    };
                    cursor.trans = trans;
                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                    cursor.fail = wrap(reject);
                    cursor.next = function() {
                        var _this = this;
                        var gotOne = 1;
                        return this.start(function() {
                            return gotOne-- ? _this.continue() : _this.stop();
                        }).then(function() {
                            return _this;
                        });
                    };
                    cursor.start = function(callback) {
                        var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                            resolveIteration = wrap(resolveIteration);
                            req.onerror = eventRejectHandler(rejectIteration);
                            cursor.fail = rejectIteration;
                            cursor.stop = function(value) {
                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                resolveIteration(value);
                            };
                        });
                        var guardedCallback = function() {
                            if (req.result) try {
                                callback();
                            } catch (err) {
                                cursor.fail(err);
                            }
                            else {
                                cursor.done = true;
                                cursor.start = function() {
                                    throw new Error("Cursor behind last entry");
                                };
                                cursor.stop();
                            }
                        };
                        req.onsuccess = wrap(function(ev) {
                            req.onsuccess = guardedCallback;
                            guardedCallback();
                        });
                        cursor.continue = _cursorContinue;
                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                        cursor.advance = _cursorAdvance;
                        guardedCallback();
                        return iterationPromise;
                    };
                    resolve(cursor);
                }, reject);
            });
        }
        function query(hasGetAll) {
            return function(request) {
                return new Promise(function(resolve, reject) {
                    resolve = wrap(resolve);
                    var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                    var nonInfinitLimit = limit === Infinity ? undefined : limit;
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ? store : store.index(index.name);
                    var idbKeyRange = makeIDBKeyRange(range);
                    if (limit === 0) return resolve({
                        result: []
                    });
                    if (hasGetAll) {
                        var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                        req.onsuccess = function(event) {
                            return resolve({
                                result: event.target.result
                            });
                        };
                        req.onerror = eventRejectHandler(reject);
                    } else {
                        var count_1 = 0;
                        var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                        var result_1 = [];
                        req_1.onsuccess = function(event) {
                            var cursor = req_1.result;
                            if (!cursor) return resolve({
                                result: result_1
                            });
                            result_1.push(values ? cursor.value : cursor.primaryKey);
                            if (++count_1 === limit) return resolve({
                                result: result_1
                            });
                            cursor.continue();
                        };
                        req_1.onerror = eventRejectHandler(reject);
                    }
                });
            };
        }
        return {
            name: tableName,
            schema: tableSchema,
            mutate: mutate,
            getMany: function(_a) {
                var trans = _a.trans, keys = _a.keys;
                return new Promise(function(resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var length = keys.length;
                    var result = new Array(length);
                    var keyCount = 0;
                    var callbackCount = 0;
                    var req;
                    var successHandler = function(event) {
                        var req = event.target;
                        result[req._pos] = req.result;
                        if (++callbackCount === keyCount) resolve(result);
                    };
                    var errorHandler = eventRejectHandler(reject);
                    for(var i = 0; i < length; ++i){
                        var key = keys[i];
                        if (key != null) {
                            req = store.get(keys[i]);
                            req._pos = i;
                            req.onsuccess = successHandler;
                            req.onerror = errorHandler;
                            ++keyCount;
                        }
                    }
                    if (keyCount === 0) resolve(result);
                });
            },
            get: function(_a) {
                var trans = _a.trans, key = _a.key;
                return new Promise(function(resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var req = store.get(key);
                    req.onsuccess = function(event) {
                        return resolve(event.target.result);
                    };
                    req.onerror = eventRejectHandler(reject);
                });
            },
            query: query(hasGetAll),
            openCursor: openCursor,
            count: function(_a) {
                var query = _a.query, trans = _a.trans;
                var index = query.index, range = query.range;
                return new Promise(function(resolve, reject) {
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ? store : store.index(index.name);
                    var idbKeyRange = makeIDBKeyRange(range);
                    var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                    req.onsuccess = wrap(function(ev) {
                        return resolve(ev.target.result);
                    });
                    req.onerror = eventRejectHandler(reject);
                });
            }
        };
    }
    var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
    var tables = schema.tables.map(function(tableSchema) {
        return createDbCoreTable(tableSchema);
    });
    var tableMap = {};
    tables.forEach(function(table) {
        return tableMap[table.name] = table;
    });
    return {
        stack: "dbcore",
        transaction: db.transaction.bind(db),
        table: function(name) {
            var result = tableMap[name];
            if (!result) throw new Error("Table '" + name + "' not found");
            return tableMap[name];
        },
        MIN_KEY: -Infinity,
        MAX_KEY: getMaxKey(IdbKeyRange),
        schema: schema
    };
}
function createMiddlewareStack(stackImpl, middlewares) {
    return middlewares.reduce(function(down, _a) {
        var create = _a.create;
        return __assign(__assign({}, down), create(down));
    }, stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
    var IDBKeyRange = _a.IDBKeyRange;
    _a.indexedDB;
    var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
    return {
        dbcore: dbcore
    };
}
function generateMiddlewareStacks(_a, tmpTrans) {
    var db = _a._novip;
    var idbdb = tmpTrans.db;
    var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
    db.core = stacks.dbcore;
    db.tables.forEach(function(table) {
        var tableName = table.name;
        if (db.core.schema.tables.some(function(tbl) {
            return tbl.name === tableName;
        })) {
            table.core = db.core.table(tableName);
            if (db[tableName] instanceof db.Table) db[tableName].core = table.core;
        }
    });
}
function setApiOnPlace(_a, objs, tableNames, dbschema) {
    var db = _a._novip;
    tableNames.forEach(function(tableName) {
        var schema = dbschema[tableName];
        objs.forEach(function(obj) {
            var propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || "value" in propDesc && propDesc.value === undefined) {
                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) setProp(obj, tableName, {
                    get: function() {
                        return this.table(tableName);
                    },
                    set: function(value) {
                        defineProperty(this, tableName, {
                            value: value,
                            writable: true,
                            configurable: true,
                            enumerable: true
                        });
                    }
                });
                else obj[tableName] = new db.Table(tableName, schema);
            }
        });
    });
}
function removeTablesApi(_a, objs) {
    var db = _a._novip;
    objs.forEach(function(obj) {
        for(var key in obj)if (obj[key] instanceof db.Table) delete obj[key];
    });
}
function lowerVersionFirst(a, b) {
    return a._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
    var globalSchema = db._dbSchema;
    var trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
    trans.create(idbUpgradeTrans);
    trans._completion.catch(reject);
    var rejectTransaction = trans._reject.bind(trans);
    var transless = PSD.transless || PSD;
    newScope(function() {
        PSD.trans = trans;
        PSD.transless = transless;
        if (oldVersion === 0) {
            keys(globalSchema).forEach(function(tableName) {
                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db, idbUpgradeTrans);
            DexiePromise.follow(function() {
                return db.on.populate.fire(trans);
            }).catch(rejectTransaction);
        } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
    });
}
function updateTablesAndIndexes(_a, oldVersion, trans, idbUpgradeTrans) {
    var db = _a._novip;
    var queue = [];
    var versions = db._versions;
    var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
    var anyContentUpgraderHasRun = false;
    var versToRun = versions.filter(function(v) {
        return v._cfg.version >= oldVersion;
    });
    versToRun.forEach(function(version) {
        queue.push(function() {
            var oldSchema = globalSchema;
            var newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
            globalSchema = db._dbSchema = newSchema;
            var diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(function(tuple) {
                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(function(change) {
                if (change.recreate) throw new exceptions.Upgrade("Not yet support for changing primary key");
                else {
                    var store_1 = idbUpgradeTrans.objectStore(change.name);
                    change.add.forEach(function(idx) {
                        return addIndex(store_1, idx);
                    });
                    change.change.forEach(function(idx) {
                        store_1.deleteIndex(idx.name);
                        addIndex(store_1, idx);
                    });
                    change.del.forEach(function(idxName) {
                        return store_1.deleteIndex(idxName);
                    });
                }
            });
            var contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
                generateMiddlewareStacks(db, idbUpgradeTrans);
                trans._memoizedTables = {};
                anyContentUpgraderHasRun = true;
                var upgradeSchema_1 = shallowClone(newSchema);
                diff.del.forEach(function(table) {
                    upgradeSchema_1[table] = oldSchema[table];
                });
                removeTablesApi(db, [
                    db.Transaction.prototype
                ]);
                setApiOnPlace(db, [
                    db.Transaction.prototype
                ], keys(upgradeSchema_1), upgradeSchema_1);
                trans.schema = upgradeSchema_1;
                var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                if (contentUpgradeIsAsync_1) incrementExpectedAwaits();
                var returnValue_1;
                var promiseFollowed = DexiePromise.follow(function() {
                    returnValue_1 = contentUpgrade(trans);
                    if (returnValue_1) {
                        if (contentUpgradeIsAsync_1) {
                            var decrementor = decrementExpectedAwaits.bind(null, null);
                            returnValue_1.then(decrementor, decrementor);
                        }
                    }
                });
                return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                    return returnValue_1;
                });
            }
        });
        queue.push(function(idbtrans) {
            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                var newSchema = version._cfg.dbschema;
                deleteRemovedTables(newSchema, idbtrans);
            }
            removeTablesApi(db, [
                db.Transaction.prototype
            ]);
            setApiOnPlace(db, [
                db.Transaction.prototype
            ], db._storeNames, db._dbSchema);
            trans.schema = db._dbSchema;
        });
    });
    function runQueue() {
        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
    }
    return runQueue().then(function() {
        createMissingTables(globalSchema, idbUpgradeTrans);
    });
}
function getSchemaDiff(oldSchema, newSchema) {
    var diff = {
        del: [],
        add: [],
        change: []
    };
    var table;
    for(table in oldSchema)if (!newSchema[table]) diff.del.push(table);
    for(table in newSchema){
        var oldDef = oldSchema[table], newDef = newSchema[table];
        if (!oldDef) diff.add.push([
            table,
            newDef
        ]);
        else {
            var change = {
                name: table,
                def: newDef,
                recreate: false,
                del: [],
                add: [],
                change: []
            };
            if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
                change.recreate = true;
                diff.change.push(change);
            } else {
                var oldIndexes = oldDef.idxByName;
                var newIndexes = newDef.idxByName;
                var idxName = void 0;
                for(idxName in oldIndexes)if (!newIndexes[idxName]) change.del.push(idxName);
                for(idxName in newIndexes){
                    var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                    if (!oldIdx) change.add.push(newIdx);
                    else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);
                }
                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) diff.change.push(change);
            }
        }
    }
    return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
    var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {
        keyPath: primKey.keyPath,
        autoIncrement: primKey.auto
    } : {
        autoIncrement: primKey.auto
    });
    indexes.forEach(function(idx) {
        return addIndex(store, idx);
    });
    return store;
}
function createMissingTables(newSchema, idbtrans) {
    keys(newSchema).forEach(function(tableName) {
        if (!idbtrans.db.objectStoreNames.contains(tableName)) createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    });
}
function deleteRemovedTables(newSchema, idbtrans) {
    [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
        return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
    });
}
function addIndex(store, idx) {
    store.createIndex(idx.name, idx.keyPath, {
        unique: idx.unique,
        multiEntry: idx.multi
    });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
    var globalSchema = {};
    var dbStoreNames = slice(idbdb.objectStoreNames, 0);
    dbStoreNames.forEach(function(storeName) {
        var store = tmpTrans.objectStore(storeName);
        var keyPath = store.keyPath;
        var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
        var indexes = [];
        for(var j = 0; j < store.indexNames.length; ++j){
            var idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index);
        }
        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
    });
    return globalSchema;
}
function readGlobalSchema(_a, idbdb, tmpTrans) {
    var db = _a._novip;
    db.verno = idbdb.version / 10;
    var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
    db._storeNames = slice(idbdb.objectStoreNames, 0);
    setApiOnPlace(db, [
        db._allTables
    ], keys(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
    var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
    var diff = getSchemaDiff(installedSchema, db._dbSchema);
    return !(diff.add.length || diff.change.some(function(ch) {
        return ch.add.length || ch.change.length;
    }));
}
function adjustToExistingIndexNames(_a, schema, idbtrans) {
    var db = _a._novip;
    var storeNames = idbtrans.db.objectStoreNames;
    for(var i = 0; i < storeNames.length; ++i){
        var storeName = storeNames[i];
        var store = idbtrans.objectStore(storeName);
        db._hasGetAll = "getAll" in store;
        for(var j = 0; j < store.indexNames.length; ++j){
            var indexName = store.indexNames[j];
            var keyPath = store.index(indexName).keyPath;
            var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
            if (schema[storeName]) {
                var indexSpec = schema[storeName].idxByName[dexieName];
                if (indexSpec) {
                    indexSpec.name = indexName;
                    delete schema[storeName].idxByName[dexieName];
                    schema[storeName].idxByName[indexName] = indexSpec;
                }
            }
        }
    }
    if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) db._hasGetAll = false;
}
function parseIndexSyntax(primKeyAndIndexes) {
    return primKeyAndIndexes.split(",").map(function(index, indexNum) {
        index = index.trim();
        var name = index.replace(/([&*]|\+\+)/g, "");
        var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
        return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
    });
}
var Version = function() {
    function Version() {}
    Version.prototype._parseStoresSpec = function(stores, outSchema) {
        keys(stores).forEach(function(tableName) {
            if (stores[tableName] !== null) {
                var indexes = parseIndexSyntax(stores[tableName]);
                var primKey = indexes.shift();
                if (primKey.multi) throw new exceptions.Schema("Primary key cannot be multi-valued");
                indexes.forEach(function(idx) {
                    if (idx.auto) throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                    if (!idx.keyPath) throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                });
                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
        });
    };
    Version.prototype.stores = function(stores) {
        var db = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
        var versions = db._versions;
        var storesSpec = {};
        var dbschema = {};
        versions.forEach(function(version) {
            extend(storesSpec, version._cfg.storesSource);
            dbschema = version._cfg.dbschema = {};
            version._parseStoresSpec(storesSpec, dbschema);
        });
        db._dbSchema = dbschema;
        removeTablesApi(db, [
            db._allTables,
            db,
            db.Transaction.prototype
        ]);
        setApiOnPlace(db, [
            db._allTables,
            db,
            db.Transaction.prototype,
            this._cfg.tables
        ], keys(dbschema), dbschema);
        db._storeNames = keys(dbschema);
        return this;
    };
    Version.prototype.upgrade = function(upgradeFunction) {
        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
        return this;
    };
    return Version;
}();
function createVersionConstructor(db) {
    return makeClassConstructor(Version.prototype, function Version(versionNumber) {
        this.db = db;
        this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
        };
    });
}
function getDbNamesTable(indexedDB1, IDBKeyRange) {
    var dbNamesDB = indexedDB1["_dbNamesDB"];
    if (!dbNamesDB) {
        dbNamesDB = indexedDB1["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB: indexedDB1,
            IDBKeyRange: IDBKeyRange
        });
        dbNamesDB.version(1).stores({
            dbnames: "name"
        });
    }
    return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB1) {
    return indexedDB1 && typeof indexedDB1.databases === "function";
}
function getDatabaseNames(_a) {
    var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
    return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then(function(infos) {
        return infos.map(function(info) {
            return info.name;
        }).filter(function(name) {
            return name !== DBNAMES_DB;
        });
    }) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();
}
function _onDatabaseCreated(_a, name) {
    var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({
        name: name
    }).catch(nop);
}
function _onDatabaseDeleted(_a, name) {
    var indexedDB1 = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);
}
function vip(fn) {
    return newScope(function() {
        PSD.letThrough = true;
        return fn();
    });
}
function idbReady() {
    var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
    if (!isSafari || !indexedDB.databases) return Promise.resolve();
    var intervalId;
    return new Promise(function(resolve) {
        var tryIdb = function() {
            return indexedDB.databases().finally(resolve);
        };
        intervalId = setInterval(tryIdb, 100);
        tryIdb();
    }).finally(function() {
        return clearInterval(intervalId);
    });
}
function dexieOpen(db) {
    var state = db._state;
    var indexedDB1 = db._deps.indexedDB;
    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(function() {
        return state.dbOpenError ? rejection(state.dbOpenError) : db;
    });
    debug && (state.openCanceller._stackHolder = getErrorWithStack());
    state.isBeingOpened = true;
    state.dbOpenError = null;
    state.openComplete = false;
    var openCanceller = state.openCanceller;
    function throwIfCancelled() {
        if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed("db.open() was cancelled");
    }
    var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
    return DexiePromise.race([
        openCanceller,
        (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(function() {
            return new DexiePromise(function(resolve, reject) {
                throwIfCancelled();
                if (!indexedDB1) throw new exceptions.MissingAPI();
                var dbName = db.name;
                var req = state.autoSchema ? indexedDB1.open(dbName) : indexedDB1.open(dbName, Math.round(db.verno * 10));
                if (!req) throw new exceptions.MissingAPI();
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(db._fireOnBlocked);
                req.onupgradeneeded = wrap(function(e) {
                    upgradeTransaction = req.transaction;
                    if (state.autoSchema && !db._options.allowEmptyDB) {
                        req.onerror = preventDefault;
                        upgradeTransaction.abort();
                        req.result.close();
                        var delreq = indexedDB1.deleteDatabase(dbName);
                        delreq.onsuccess = delreq.onerror = wrap(function() {
                            reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
                        });
                    } else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                        wasCreated = oldVer < 1;
                        db._novip.idbdb = req.result;
                        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                    }
                }, reject);
                req.onsuccess = wrap(function() {
                    upgradeTransaction = null;
                    var idbdb = db._novip.idbdb = req.result;
                    var objectStoreNames = slice(idbdb.objectStoreNames);
                    if (objectStoreNames.length > 0) try {
                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                        if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);
                        else {
                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                            if (!verifyInstalledSchema(db, tmpTrans)) console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
                        }
                        generateMiddlewareStacks(db, tmpTrans);
                    } catch (e) {}
                    connections.push(db);
                    idbdb.onversionchange = wrap(function(ev) {
                        state.vcFired = true;
                        db.on("versionchange").fire(ev);
                    });
                    idbdb.onclose = wrap(function(ev) {
                        db.on("close").fire(ev);
                    });
                    if (wasCreated) _onDatabaseCreated(db._deps, dbName);
                    resolve();
                }, reject);
            });
        })
    ]).then(function() {
        throwIfCancelled();
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(function() {
            return db.on.ready.fire(db.vip);
        })).then(function fireRemainders() {
            if (state.onReadyBeingFired.length > 0) {
                var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                state.onReadyBeingFired = [];
                return DexiePromise.resolve(vip(function() {
                    return remainders_1(db.vip);
                })).then(fireRemainders);
            }
        });
    }).finally(function() {
        state.onReadyBeingFired = null;
        state.isBeingOpened = false;
    }).then(function() {
        return db;
    }).catch(function(err) {
        state.dbOpenError = err;
        try {
            upgradeTransaction && upgradeTransaction.abort();
        } catch (_a) {}
        if (openCanceller === state.openCanceller) db._close();
        return rejection(err);
    }).finally(function() {
        state.openComplete = true;
        resolveDbReady();
    });
}
function awaitIterator(iterator) {
    var callNext = function(result) {
        return iterator.next(result);
    }, doThrow = function(error) {
        return iterator.throw(error);
    }, onSuccess = step(callNext), onError = step(doThrow);
    function step(getNext) {
        return function(val) {
            var next = getNext(val), value = next.value;
            return next.done ? value : !value || typeof value.then !== "function" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
        };
    }
    return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
    var i = arguments.length;
    if (i < 2) throw new exceptions.InvalidArgument("Too few arguments");
    var args = new Array(i - 1);
    while(--i)args[i - 1] = arguments[i];
    scopeFunc = args.pop();
    var tables = flatten(args);
    return [
        mode,
        tables,
        scopeFunc
    ];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
    return DexiePromise.resolve().then(function() {
        var transless = PSD.transless || PSD;
        var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
        var zoneProps = {
            trans: trans,
            transless: transless
        };
        if (parentTransaction) trans.idbtrans = parentTransaction.idbtrans;
        else try {
            trans.create();
            db._state.PR1398_maxLoop = 3;
        } catch (ex) {
            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db._close();
                return db.open().then(function() {
                    return enterTransactionScope(db, mode, storeNames, null, scopeFunc);
                });
            }
            return rejection(ex);
        }
        var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
        if (scopeFuncIsAsync) incrementExpectedAwaits();
        var returnValue;
        var promiseFollowed = DexiePromise.follow(function() {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
                if (scopeFuncIsAsync) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue.then(decrementor, decrementor);
                } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") returnValue = awaitIterator(returnValue);
            }
        }, zoneProps);
        return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
            return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
        }) : promiseFollowed.then(function() {
            return returnValue;
        })).then(function(x) {
            if (parentTransaction) trans._resolve();
            return trans._completion.then(function() {
                return x;
            });
        }).catch(function(e) {
            trans._reject(e);
            return rejection(e);
        });
    });
}
function pad(a, value, count) {
    var result = isArray(a) ? a.slice() : [
        a
    ];
    for(var i = 0; i < count; ++i)result.push(value);
    return result;
}
function createVirtualIndexMiddleware(down) {
    return __assign(__assign({}, down), {
        table: function(tableName) {
            var table = down.table(tableName);
            var schema = table.schema;
            var indexLookup = {};
            var allVirtualIndexes = [];
            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                var keyPathAlias = getKeyPathAlias(keyPath);
                var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
                var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
                var isVirtual = keyTail > 0;
                var virtualIndex = __assign(__assign({}, lowLevelIndex), {
                    isVirtual: isVirtual,
                    keyTail: keyTail,
                    keyLength: keyLength,
                    extractKey: getKeyExtractor(keyPath),
                    unique: !isVirtual && lowLevelIndex.unique
                });
                indexList.push(virtualIndex);
                if (!virtualIndex.isPrimaryKey) allVirtualIndexes.push(virtualIndex);
                if (keyLength > 1) {
                    var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                }
                indexList.sort(function(a, b) {
                    return a.keyTail - b.keyTail;
                });
                return virtualIndex;
            }
            var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
            indexLookup[":id"] = [
                primaryKey
            ];
            for(var _i = 0, _a = schema.indexes; _i < _a.length; _i++){
                var index = _a[_i];
                addVirtualIndexes(index.keyPath, 0, index);
            }
            function findBestIndex(keyPath) {
                var result = indexLookup[getKeyPathAlias(keyPath)];
                return result && result[0];
            }
            function translateRange(range, keyTail) {
                return {
                    type: range.type === 1 ? 2 : range.type,
                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                    lowerOpen: true,
                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                    upperOpen: true
                };
            }
            function translateRequest(req) {
                var index = req.query.index;
                return index.isVirtual ? __assign(__assign({}, req), {
                    query: {
                        index: index,
                        range: translateRange(req.query.range, index.keyTail)
                    }
                }) : req;
            }
            var result = __assign(__assign({}, table), {
                schema: __assign(__assign({}, schema), {
                    primaryKey: primaryKey,
                    indexes: allVirtualIndexes,
                    getIndexByKeyPath: findBestIndex
                }),
                count: function(req) {
                    return table.count(translateRequest(req));
                },
                query: function(req) {
                    return table.query(translateRequest(req));
                },
                openCursor: function(req) {
                    var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                    if (!isVirtual) return table.openCursor(req);
                    function createVirtualCursor(cursor) {
                        function _continue(key) {
                            key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
                        }
                        var virtualCursor = Object.create(cursor, {
                            continue: {
                                value: _continue
                            },
                            continuePrimaryKey: {
                                value: function(key, primaryKey) {
                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                }
                            },
                            primaryKey: {
                                get: function() {
                                    return cursor.primaryKey;
                                }
                            },
                            key: {
                                get: function() {
                                    var key = cursor.key;
                                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                                }
                            },
                            value: {
                                get: function() {
                                    return cursor.value;
                                }
                            }
                        });
                        return virtualCursor;
                    }
                    return table.openCursor(translateRequest(req)).then(function(cursor) {
                        return cursor && createVirtualCursor(cursor);
                    });
                }
            });
            return result;
        }
    });
}
var virtualIndexMiddleware = {
    stack: "dbcore",
    name: "VirtualIndexMiddleware",
    level: 1,
    create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b, rv, prfx) {
    rv = rv || {};
    prfx = prfx || "";
    keys(a).forEach(function(prop) {
        if (!hasOwn(b, prop)) rv[prfx + prop] = undefined;
        else {
            var ap = a[prop], bp = b[prop];
            if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
                var apTypeName = toStringTag(ap);
                var bpTypeName = toStringTag(bp);
                if (apTypeName !== bpTypeName) rv[prfx + prop] = b[prop];
                else if (apTypeName === "Object") getObjectDiff(ap, bp, rv, prfx + prop + ".");
                else if (ap !== bp) rv[prfx + prop] = b[prop];
            } else if (ap !== bp) rv[prfx + prop] = b[prop];
        }
    });
    keys(b).forEach(function(prop) {
        if (!hasOwn(a, prop)) rv[prfx + prop] = b[prop];
    });
    return rv;
}
function getEffectiveKeys(primaryKey, req) {
    if (req.type === "delete") return req.keys;
    return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
    stack: "dbcore",
    name: "HooksMiddleware",
    level: 2,
    create: function(downCore) {
        return __assign(__assign({}, downCore), {
            table: function(tableName) {
                var downTable = downCore.table(tableName);
                var primaryKey = downTable.schema.primaryKey;
                var tableMiddleware = __assign(__assign({}, downTable), {
                    mutate: function(req) {
                        var dxTrans = PSD.trans;
                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                        switch(req.type){
                            case "add":
                                if (creating.fire === nop) break;
                                return dxTrans._promise("readwrite", function() {
                                    return addPutOrDelete(req);
                                }, true);
                            case "put":
                                if (creating.fire === nop && updating.fire === nop) break;
                                return dxTrans._promise("readwrite", function() {
                                    return addPutOrDelete(req);
                                }, true);
                            case "delete":
                                if (deleting.fire === nop) break;
                                return dxTrans._promise("readwrite", function() {
                                    return addPutOrDelete(req);
                                }, true);
                            case "deleteRange":
                                if (deleting.fire === nop) break;
                                return dxTrans._promise("readwrite", function() {
                                    return deleteRange(req);
                                }, true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            var dxTrans = PSD.trans;
                            var keys = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys) throw new Error("Keys missing");
                            req = req.type === "add" || req.type === "put" ? __assign(__assign({}, req), {
                                keys: keys
                            }) : __assign({}, req);
                            if (req.type !== "delete") req.values = __spreadArray([], req.values, true);
                            if (req.keys) req.keys = __spreadArray([], req.keys, true);
                            return getExistingValues(downTable, req, keys).then(function(existingValues) {
                                var contexts = keys.map(function(key, i) {
                                    var existingValue = existingValues[i];
                                    var ctx = {
                                        onerror: null,
                                        onsuccess: null
                                    };
                                    if (req.type === "delete") deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    else if (req.type === "add" || existingValue === undefined) {
                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                        }
                                    } else {
                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges_1) {
                                            var requestedValue_1 = req.values[i];
                                            Object.keys(additionalChanges_1).forEach(function(keyPath) {
                                                if (hasOwn(requestedValue_1, keyPath)) requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                else setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(function(_a) {
                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                    for(var i = 0; i < keys.length; ++i){
                                        var primKey = results ? results[i] : keys[i];
                                        var ctx = contexts[i];
                                        if (primKey == null) ctx.onerror && ctx.onerror(failures[i]);
                                        else ctx.onsuccess && ctx.onsuccess(req.type === "put" && existingValues[i] ? req.values[i] : primKey);
                                    }
                                    return {
                                        failures: failures,
                                        results: results,
                                        numFailures: numFailures,
                                        lastResult: lastResult
                                    };
                                }).catch(function(error) {
                                    contexts.forEach(function(ctx) {
                                        return ctx.onerror && ctx.onerror(error);
                                    });
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({
                                trans: trans,
                                values: false,
                                query: {
                                    index: primaryKey,
                                    range: range
                                },
                                limit: limit
                            }).then(function(_a) {
                                var result = _a.result;
                                return addPutOrDelete({
                                    type: "delete",
                                    keys: result,
                                    trans: trans
                                }).then(function(res) {
                                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);
                                    if (result.length < limit) return {
                                        failures: [],
                                        numFailures: 0,
                                        lastResult: undefined
                                    };
                                    else return deleteNextChunk(trans, __assign(__assign({}, range), {
                                        lower: result[result.length - 1],
                                        lowerOpen: true
                                    }), limit);
                                });
                            });
                        }
                    }
                });
                return tableMiddleware;
            }
        });
    }
};
function getExistingValues(table, req, effectiveKeys) {
    return req.type === "add" ? Promise.resolve([]) : table.getMany({
        trans: req.trans,
        keys: effectiveKeys,
        cache: "immutable"
    });
}
function getFromTransactionCache(keys, cache, clone) {
    try {
        if (!cache) return null;
        if (cache.keys.length < keys.length) return null;
        var result = [];
        for(var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){
            if (cmp(cache.keys[i], keys[j]) !== 0) continue;
            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
            ++j;
        }
        return result.length === keys.length ? result : null;
    } catch (_a) {
        return null;
    }
}
var cacheExistingValuesMiddleware = {
    stack: "dbcore",
    level: -1,
    create: function(core) {
        return {
            table: function(tableName) {
                var table = core.table(tableName);
                return __assign(__assign({}, table), {
                    getMany: function(req) {
                        if (!req.cache) return table.getMany(req);
                        var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                        if (cachedResult) return DexiePromise.resolve(cachedResult);
                        return table.getMany(req).then(function(res) {
                            req.trans["_cache"] = {
                                keys: req.keys,
                                values: req.cache === "clone" ? deepClone(res) : res
                            };
                            return res;
                        });
                    },
                    mutate: function(req) {
                        if (req.type !== "add") req.trans["_cache"] = null;
                        return table.mutate(req);
                    }
                });
            }
        };
    }
};
var _a;
function isEmptyRange(node) {
    return !("from" in node);
}
var RangeSet = function(fromOrTree, to) {
    if (this) extend(this, arguments.length ? {
        d: 1,
        from: fromOrTree,
        to: arguments.length > 1 ? to : fromOrTree
    } : {
        d: 0
    });
    else {
        var rv = new RangeSet();
        if (fromOrTree && "d" in fromOrTree) extend(rv, fromOrTree);
        return rv;
    }
};
props(RangeSet.prototype, (_a = {
    add: function(rangeSet) {
        mergeRanges(this, rangeSet);
        return this;
    },
    addKey: function(key) {
        addRange(this, key, key);
        return this;
    },
    addKeys: function(keys) {
        var _this = this;
        keys.forEach(function(key) {
            return addRange(_this, key, key);
        });
        return this;
    }
}, _a[iteratorSymbol] = function() {
    return getRangeSetIterator(this);
}, _a));
function addRange(target, from, to) {
    var diff = cmp(from, to);
    if (isNaN(diff)) return;
    if (diff > 0) throw RangeError();
    if (isEmptyRange(target)) return extend(target, {
        from: from,
        to: to,
        d: 1
    });
    var left = target.l;
    var right = target.r;
    if (cmp(to, target.from) < 0) {
        left ? addRange(left, from, to) : target.l = {
            from: from,
            to: to,
            d: 1,
            l: null,
            r: null
        };
        return rebalance(target);
    }
    if (cmp(from, target.to) > 0) {
        right ? addRange(right, from, to) : target.r = {
            from: from,
            to: to,
            d: 1,
            l: null,
            r: null
        };
        return rebalance(target);
    }
    if (cmp(from, target.from) < 0) {
        target.from = from;
        target.l = null;
        target.d = right ? right.d + 1 : 1;
    }
    if (cmp(to, target.to) > 0) {
        target.to = to;
        target.r = null;
        target.d = target.l ? target.l.d + 1 : 1;
    }
    var rightWasCutOff = !target.r;
    if (left && !target.l) mergeRanges(target, left);
    if (right && rightWasCutOff) mergeRanges(target, right);
}
function mergeRanges(target, newSet) {
    function _addRangeSet(target, _a) {
        var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
        addRange(target, from, to);
        if (l) _addRangeSet(target, l);
        if (r) _addRangeSet(target, r);
    }
    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
    var i1 = getRangeSetIterator(rangeSet2);
    var nextResult1 = i1.next();
    if (nextResult1.done) return false;
    var a = nextResult1.value;
    var i2 = getRangeSetIterator(rangeSet1);
    var nextResult2 = i2.next(a.from);
    var b = nextResult2.value;
    while(!nextResult1.done && !nextResult2.done){
        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;
        cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
    }
    return false;
}
function getRangeSetIterator(node) {
    var state = isEmptyRange(node) ? null : {
        s: 0,
        n: node
    };
    return {
        next: function(key) {
            var keyProvided = arguments.length > 0;
            while(state)switch(state.s){
                case 0:
                    state.s = 1;
                    if (keyProvided) while(state.n.l && cmp(key, state.n.from) < 0)state = {
                        up: state,
                        n: state.n.l,
                        s: 1
                    };
                    else while(state.n.l)state = {
                        up: state,
                        n: state.n.l,
                        s: 1
                    };
                case 1:
                    state.s = 2;
                    if (!keyProvided || cmp(key, state.n.to) <= 0) return {
                        value: state.n,
                        done: false
                    };
                case 2:
                    if (state.n.r) {
                        state.s = 3;
                        state = {
                            up: state,
                            n: state.n.r,
                            s: 0
                        };
                        continue;
                    }
                case 3:
                    state = state.up;
            }
            return {
                done: true
            };
        }
    };
}
function rebalance(target) {
    var _a, _b;
    var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
    var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
    if (r) {
        var l = r === "r" ? "l" : "r";
        var rootClone = __assign({}, target);
        var oldRootRight = target[r];
        target.from = oldRootRight.from;
        target.to = oldRootRight.to;
        target[r] = oldRootRight[r];
        rootClone[r] = oldRootRight[l];
        target[l] = rootClone;
        rootClone.d = computeDepth(rootClone);
    }
    target.d = computeDepth(target);
}
function computeDepth(_a) {
    var r = _a.r, l = _a.l;
    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
var observabilityMiddleware = {
    stack: "dbcore",
    level: 0,
    create: function(core) {
        var dbName = core.schema.name;
        var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
        return __assign(__assign({}, core), {
            table: function(tableName) {
                var table = core.table(tableName);
                var schema = table.schema;
                var primaryKey = schema.primaryKey;
                var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                var tableClone = __assign(__assign({}, table), {
                    mutate: function(req) {
                        var trans = req.trans;
                        var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
                        var getRangeSet = function(indexName) {
                            var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
                            return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
                        };
                        var pkRangeSet = getRangeSet("");
                        var delsRangeSet = getRangeSet(":dels");
                        var type = req.type;
                        var _a = req.type === "deleteRange" ? [
                            req.range
                        ] : req.type === "delete" ? [
                            req.keys
                        ] : req.values.length < 50 ? [
                            [],
                            req.values
                        ] : [], keys = _a[0], newObjs = _a[1];
                        var oldCache = req.trans["_cache"];
                        return table.mutate(req).then(function(res) {
                            if (isArray(keys)) {
                                if (type !== "delete") keys = res.results;
                                pkRangeSet.addKeys(keys);
                                var oldObjs = getFromTransactionCache(keys, oldCache);
                                if (!oldObjs && type !== "add") delsRangeSet.addKeys(keys);
                                if (oldObjs || newObjs) trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                            } else if (keys) {
                                var range = {
                                    from: keys.lower,
                                    to: keys.upper
                                };
                                delsRangeSet.add(range);
                                pkRangeSet.add(range);
                            } else {
                                pkRangeSet.add(FULL_RANGE);
                                delsRangeSet.add(FULL_RANGE);
                                schema.indexes.forEach(function(idx) {
                                    return getRangeSet(idx.name).add(FULL_RANGE);
                                });
                            }
                            return res;
                        });
                    }
                });
                var getRange = function(_a) {
                    var _b, _c;
                    var _d = _a.query, index = _d.index, range = _d.range;
                    return [
                        index,
                        new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
                    ];
                };
                var readSubscribers = {
                    get: function(req) {
                        return [
                            primaryKey,
                            new RangeSet(req.key)
                        ];
                    },
                    getMany: function(req) {
                        return [
                            primaryKey,
                            new RangeSet().addKeys(req.keys)
                        ];
                    },
                    count: getRange,
                    query: getRange,
                    openCursor: getRange
                };
                keys(readSubscribers).forEach(function(method) {
                    tableClone[method] = function(req) {
                        var subscr = PSD.subscr;
                        if (subscr) {
                            var getRangeSet = function(indexName) {
                                var part = "idb://" + dbName + "/" + tableName + "/" + indexName;
                                return subscr[part] || (subscr[part] = new RangeSet());
                            };
                            var pkRangeSet_1 = getRangeSet("");
                            var delsRangeSet_1 = getRangeSet(":dels");
                            var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                            getRangeSet(queriedIndex.name || "").add(queriedRanges);
                            if (!queriedIndex.isPrimaryKey) {
                                if (method === "count") delsRangeSet_1.add(FULL_RANGE);
                                else {
                                    var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), {
                                        values: false
                                    }));
                                    return table[method].apply(this, arguments).then(function(res) {
                                        if (method === "query") {
                                            if (outbound && req.values) return keysPromise_1.then(function(_a) {
                                                var resultingKeys = _a.result;
                                                pkRangeSet_1.addKeys(resultingKeys);
                                                return res;
                                            });
                                            var pKeys = req.values ? res.result.map(extractKey) : res.result;
                                            if (req.values) pkRangeSet_1.addKeys(pKeys);
                                            else delsRangeSet_1.addKeys(pKeys);
                                        } else if (method === "openCursor") {
                                            var cursor_1 = res;
                                            var wantValues_1 = req.values;
                                            return cursor_1 && Object.create(cursor_1, {
                                                key: {
                                                    get: function() {
                                                        delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                        return cursor_1.key;
                                                    }
                                                },
                                                primaryKey: {
                                                    get: function() {
                                                        var pkey = cursor_1.primaryKey;
                                                        delsRangeSet_1.addKey(pkey);
                                                        return pkey;
                                                    }
                                                },
                                                value: {
                                                    get: function() {
                                                        wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                        return cursor_1.value;
                                                    }
                                                }
                                            });
                                        }
                                        return res;
                                    });
                                }
                            }
                        }
                        return table[method].apply(this, arguments);
                    };
                });
                return tableClone;
            }
        });
    }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
    function addAffectedIndex(ix) {
        var rangeSet = getRangeSet(ix.name || "");
        function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
        }
        var addKeyOrKeys = function(key) {
            return ix.multiEntry && isArray(key) ? key.forEach(function(key) {
                return rangeSet.addKey(key);
            }) : rangeSet.addKey(key);
        };
        (oldObjs || newObjs).forEach(function(_, i) {
            var oldKey = oldObjs && extractKey(oldObjs[i]);
            var newKey = newObjs && extractKey(newObjs[i]);
            if (cmp(oldKey, newKey) !== 0) {
                if (oldKey != null) addKeyOrKeys(oldKey);
                if (newKey != null) addKeyOrKeys(newKey);
            }
        });
    }
    schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = function() {
    function Dexie(name, options) {
        var _this = this;
        this._middlewares = {};
        this.verno = 0;
        var deps = Dexie.dependencies;
        this._options = options = __assign({
            addons: Dexie.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange
        }, options);
        this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
        };
        var addons = options.addons;
        this._dbSchema = {};
        this._versions = [];
        this._storeNames = [];
        this._allTables = {};
        this.idbdb = null;
        this._novip = this;
        var state = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3
        };
        state.dbReadyPromise = new DexiePromise(function(resolve) {
            state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise(function(_, reject) {
            state.cancelOpen = reject;
        });
        this._state = state;
        this.name = name;
        this.on = Events(this, "populate", "blocked", "versionchange", "close", {
            ready: [
                promisableChain,
                nop
            ]
        });
        this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
            return function(subscriber, bSticky) {
                Dexie.vip(function() {
                    var state = _this._state;
                    if (state.openComplete) {
                        if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);
                        if (bSticky) subscribe(subscriber);
                    } else if (state.onReadyBeingFired) {
                        state.onReadyBeingFired.push(subscriber);
                        if (bSticky) subscribe(subscriber);
                    } else {
                        subscribe(subscriber);
                        var db_1 = _this;
                        if (!bSticky) subscribe(function unsubscribe() {
                            db_1.on.ready.unsubscribe(subscriber);
                            db_1.on.ready.unsubscribe(unsubscribe);
                        });
                    }
                });
            };
        });
        this.Collection = createCollectionConstructor(this);
        this.Table = createTableConstructor(this);
        this.Transaction = createTransactionConstructor(this);
        this.Version = createVersionConstructor(this);
        this.WhereClause = createWhereClauseConstructor(this);
        this.on("versionchange", function(ev) {
            if (ev.newVersion > 0) console.warn("Another connection wants to upgrade database '" + _this.name + "'. Closing db now to resume the upgrade.");
            else console.warn("Another connection wants to delete database '" + _this.name + "'. Closing db now to resume the delete request.");
            _this.close();
        });
        this.on("blocked", function(ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn("Dexie.delete('" + _this.name + "') was blocked");
            else console.warn("Upgrade '" + _this.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
        });
        this._maxKey = getMaxKey(options.IDBKeyRange);
        this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
            return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
        };
        this._fireOnBlocked = function(ev) {
            _this.on("blocked").fire(ev);
            connections.filter(function(c) {
                return c.name === _this.name && c !== _this && !c._state.vcFired;
            }).map(function(c) {
                return c.on("versionchange").fire(ev);
            });
        };
        this.use(virtualIndexMiddleware);
        this.use(hooksMiddleware);
        this.use(observabilityMiddleware);
        this.use(cacheExistingValuesMiddleware);
        this.vip = Object.create(this, {
            _vip: {
                value: true
            }
        });
        addons.forEach(function(addon) {
            return addon(_this);
        });
    }
    Dexie.prototype.version = function(versionNumber) {
        if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type("Given version is not a positive number");
        versionNumber = Math.round(versionNumber * 10) / 10;
        if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, versionNumber);
        var versions = this._versions;
        var versionInstance = versions.filter(function(v) {
            return v._cfg.version === versionNumber;
        })[0];
        if (versionInstance) return versionInstance;
        versionInstance = new this.Version(versionNumber);
        versions.push(versionInstance);
        versions.sort(lowerVersionFirst);
        versionInstance.stores({});
        this._state.autoSchema = false;
        return versionInstance;
    };
    Dexie.prototype._whenReady = function(fn) {
        var _this = this;
        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
            if (_this._state.openComplete) return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
            if (!_this._state.isBeingOpened) {
                if (!_this._options.autoOpen) {
                    reject(new exceptions.DatabaseClosed());
                    return;
                }
                _this.open().catch(nop);
            }
            _this._state.dbReadyPromise.then(resolve, reject);
        }).then(fn);
    };
    Dexie.prototype.use = function(_a) {
        var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
        if (name) this.unuse({
            stack: stack,
            name: name
        });
        var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
        middlewares.push({
            stack: stack,
            create: create,
            level: level == null ? 10 : level,
            name: name
        });
        middlewares.sort(function(a, b) {
            return a.level - b.level;
        });
        return this;
    };
    Dexie.prototype.unuse = function(_a) {
        var stack = _a.stack, name = _a.name, create = _a.create;
        if (stack && this._middlewares[stack]) this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
            return create ? mw.create !== create : name ? mw.name !== name : false;
        });
        return this;
    };
    Dexie.prototype.open = function() {
        return dexieOpen(this);
    };
    Dexie.prototype._close = function() {
        var state = this._state;
        var idx = connections.indexOf(this);
        if (idx >= 0) connections.splice(idx, 1);
        if (this.idbdb) {
            try {
                this.idbdb.close();
            } catch (e) {}
            this._novip.idbdb = null;
        }
        state.dbReadyPromise = new DexiePromise(function(resolve) {
            state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise(function(_, reject) {
            state.cancelOpen = reject;
        });
    };
    Dexie.prototype.close = function() {
        this._close();
        var state = this._state;
        this._options.autoOpen = false;
        state.dbOpenError = new exceptions.DatabaseClosed();
        if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);
    };
    Dexie.prototype.delete = function() {
        var _this = this;
        var hasArguments = arguments.length > 0;
        var state = this._state;
        return new DexiePromise(function(resolve, reject) {
            var doDelete = function() {
                _this.close();
                var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                req.onsuccess = wrap(function() {
                    _onDatabaseDeleted(_this._deps, _this.name);
                    resolve();
                });
                req.onerror = eventRejectHandler(reject);
                req.onblocked = _this._fireOnBlocked;
            };
            if (hasArguments) throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
            if (state.isBeingOpened) state.dbReadyPromise.then(doDelete);
            else doDelete();
        });
    };
    Dexie.prototype.backendDB = function() {
        return this.idbdb;
    };
    Dexie.prototype.isOpen = function() {
        return this.idbdb !== null;
    };
    Dexie.prototype.hasBeenClosed = function() {
        var dbOpenError = this._state.dbOpenError;
        return dbOpenError && dbOpenError.name === "DatabaseClosed";
    };
    Dexie.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
    };
    Dexie.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
    };
    Object.defineProperty(Dexie.prototype, "tables", {
        get: function() {
            var _this = this;
            return keys(this._allTables).map(function(name) {
                return _this._allTables[name];
            });
        },
        enumerable: false,
        configurable: true
    });
    Dexie.prototype.transaction = function() {
        var args = extractTransactionArgs.apply(this, arguments);
        return this._transaction.apply(this, args);
    };
    Dexie.prototype._transaction = function(mode, tables, scopeFunc) {
        var _this = this;
        var parentTransaction = PSD.trans;
        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1) parentTransaction = null;
        var onlyIfCompatible = mode.indexOf("?") !== -1;
        mode = mode.replace("!", "").replace("?", "");
        var idbMode, storeNames;
        try {
            storeNames = tables.map(function(table) {
                var storeName = table instanceof _this.Table ? table.name : table;
                if (typeof storeName !== "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
            });
            if (mode == "r" || mode === READONLY) idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE) idbMode = READWRITE;
            else throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                    if (onlyIfCompatible) parentTransaction = null;
                    else throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) storeNames.forEach(function(storeName) {
                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                        if (onlyIfCompatible) parentTransaction = null;
                        else throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                    }
                });
                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) parentTransaction = null;
            }
        } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
                reject(e);
            }) : rejection(e);
        }
        var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
            return _this._whenReady(enterTransaction);
        }) : this._whenReady(enterTransaction);
    };
    Dexie.prototype.table = function(tableName) {
        if (!hasOwn(this._allTables, tableName)) throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
        return this._allTables[tableName];
    };
    return Dexie;
}();
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable = function() {
    function Observable(subscribe) {
        this._subscribe = subscribe;
    }
    Observable.prototype.subscribe = function(x, error, complete) {
        return this._subscribe(!x || typeof x === "function" ? {
            next: x,
            error: error,
            complete: complete
        } : x);
    };
    Observable.prototype[symbolObservable] = function() {
        return this;
    };
    return Observable;
}();
function extendObservabilitySet(target, newSet) {
    keys(newSet).forEach(function(part) {
        var rangeSet = target[part] || (target[part] = new RangeSet());
        mergeRanges(rangeSet, newSet[part]);
    });
    return target;
}
function liveQuery(querier) {
    var hasValue = false;
    var currentValue = undefined;
    var observable = new Observable(function(observer) {
        var scopeFuncIsAsync = isAsyncFunction(querier);
        function execute(subscr) {
            if (scopeFuncIsAsync) incrementExpectedAwaits();
            var exec = function() {
                return newScope(querier, {
                    subscr: subscr,
                    trans: null
                });
            };
            var rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
            if (scopeFuncIsAsync) rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
            return rv;
        }
        var closed = false;
        var accumMuts = {};
        var currentObs = {};
        var subscription = {
            get closed () {
                return closed;
            },
            unsubscribe: function() {
                closed = true;
                globalEvents.storagemutated.unsubscribe(mutationListener);
            }
        };
        observer.start && observer.start(subscription);
        var querying = false, startedListening = false;
        function shouldNotify() {
            return keys(currentObs).some(function(key) {
                return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);
            });
        }
        var mutationListener = function(parts) {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) doQuery();
        };
        var doQuery = function() {
            if (querying || closed) return;
            accumMuts = {};
            var subscr = {};
            var ret = execute(subscr);
            if (!startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
            }
            querying = true;
            Promise.resolve(ret).then(function(result) {
                hasValue = true;
                currentValue = result;
                querying = false;
                if (closed) return;
                if (shouldNotify()) doQuery();
                else {
                    accumMuts = {};
                    currentObs = subscr;
                    observer.next && observer.next(result);
                }
            }, function(err) {
                querying = false;
                hasValue = false;
                observer.error && observer.error(err);
                subscription.unsubscribe();
            });
        };
        doQuery();
        return subscription;
    });
    observable.hasValue = function() {
        return hasValue;
    };
    observable.getValue = function() {
        return currentValue;
    };
    return observable;
}
var domDeps;
try {
    domDeps = {
        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
    };
} catch (e) {
    domDeps = {
        indexedDB: null,
        IDBKeyRange: null
    };
}
var Dexie = Dexie$1;
props(Dexie, __assign(__assign({}, fullNameExceptions), {
    delete: function(databaseName) {
        var db = new Dexie(databaseName, {
            addons: []
        });
        return db.delete();
    },
    exists: function(name) {
        return new Dexie(name, {
            addons: []
        }).open().then(function(db) {
            db.close();
            return true;
        }).catch("NoSuchDatabaseError", function() {
            return false;
        });
    },
    getDatabaseNames: function(cb) {
        try {
            return getDatabaseNames(Dexie.dependencies).then(cb);
        } catch (_a) {
            return rejection(new exceptions.MissingAPI());
        }
    },
    defineClass: function() {
        function Class(content) {
            extend(this, content);
        }
        return Class;
    },
    ignoreTransaction: function(scopeFunc) {
        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
    },
    vip: vip,
    async: function(generatorFn) {
        return function() {
            try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== "function") return DexiePromise.resolve(rv);
                return rv;
            } catch (e) {
                return rejection(e);
            }
        };
    },
    spawn: function(generatorFn, args, thiz) {
        try {
            var rv = awaitIterator(generatorFn.apply(thiz, args || []));
            if (!rv || typeof rv.then !== "function") return DexiePromise.resolve(rv);
            return rv;
        } catch (e) {
            return rejection(e);
        }
    },
    currentTransaction: {
        get: function() {
            return PSD.trans || null;
        }
    },
    waitFor: function(promiseOrFunction, optionalTimeout) {
        var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);
        return PSD.trans ? PSD.trans.waitFor(promise) : promise;
    },
    Promise: DexiePromise,
    debug: {
        get: function() {
            return debug;
        },
        set: function(value) {
            setDebug(value, value === "dexie" ? function() {
                return true;
            } : dexieStackFrameFilter);
        }
    },
    derive: derive,
    extend: extend,
    props: props,
    override: override,
    Events: Events,
    on: globalEvents,
    liveQuery: liveQuery,
    extendObservabilitySet: extendObservabilitySet,
    getByKeyPath: getByKeyPath,
    setByKeyPath: setByKeyPath,
    delByKeyPath: delByKeyPath,
    shallowClone: shallowClone,
    deepClone: deepClone,
    getObjectDiff: getObjectDiff,
    cmp: cmp,
    asap: asap$1,
    minKey: minKey,
    addons: [],
    connections: connections,
    errnames: errnames,
    dependencies: domDeps,
    semVer: DEXIE_VERSION,
    version: DEXIE_VERSION.split(".").map(function(n) {
        return parseInt(n);
    }).reduce(function(p, c, i) {
        return p + c / Math.pow(10, i * 2);
    })
}));
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
        if (!propagatingLocally) {
            var event_1;
            if (isIEOrEdge) {
                event_1 = document.createEvent("CustomEvent");
                event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
            } else event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                detail: updatedParts
            });
            propagatingLocally = true;
            dispatchEvent(event_1);
            propagatingLocally = false;
        }
    });
    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a) {
        var detail = _a.detail;
        if (!propagatingLocally) propagateLocally(detail);
    });
}
function propagateLocally(updateParts) {
    var wasMe = propagatingLocally;
    try {
        propagatingLocally = true;
        globalEvents.storagemutated.fire(updateParts);
    } finally{
        propagatingLocally = wasMe;
    }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
    var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
    if (typeof bc_1.unref === "function") bc_1.unref();
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
        if (!propagatingLocally) bc_1.postMessage(changedParts);
    });
    bc_1.onmessage = function(ev) {
        if (ev.data) propagateLocally(ev.data);
    };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
        try {
            if (!propagatingLocally) {
                if (typeof localStorage !== "undefined") localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
                    trig: Math.random(),
                    changedParts: changedParts
                }));
                if (typeof self["clients"] === "object") __spreadArray([], self["clients"].matchAll({
                    includeUncontrolled: true
                }), true).forEach(function(client) {
                    return client.postMessage({
                        type: STORAGE_MUTATED_DOM_EVENT_NAME,
                        changedParts: changedParts
                    });
                });
            }
        } catch (_a) {}
    });
    if (typeof addEventListener !== "undefined") addEventListener("storage", function(ev) {
        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
            var data = JSON.parse(ev.newValue);
            if (data) propagateLocally(data.changedParts);
        }
    });
    var swContainer = self.document && navigator.serviceWorker;
    if (swContainer) swContainer.addEventListener("message", propagateMessageLocally);
}
function propagateMessageLocally(_a) {
    var data = _a.data;
    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) propagateLocally(data.changedParts);
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6TTUj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _p2Pt = require("p2pt");
var _p2PtDefault = parcelHelpers.interopDefault(_p2Pt);
var trackersAnnounceURLs = [
    "wss://tracker.openwebtorrent.com",
    "wss://tracker.webtorrent.dev",
    "wss://tracker.files.fm:7073/announce",
    "wss://tracker.openwebtorrent.com:443/announce",
    "wss://tracker.files.fm:7073/announce"
];
class Comm {
    constructor(config, update){
        this.peers = {};
        this.doUpdate = false;
        this.id = config.id;
        this.data = config.data;
        this.timestamp = config.timestamp;
        this.update_ = update;
        this.p2pt = new (0, _p2PtDefault.default)(trackersAnnounceURLs, this.id);
        this.p2pt._maxListeners = 1000000;
        const self = this;
        this.p2pt.on("trackerconnect", (tracker, stats)=>{
        //console.log('Connected to tracker : ' + tracker.announceUrl)
        //console.log('Tracker stats : ' + JSON.stringify(stats))
        });
        this.p2pt.on("peerconnect", (peer)=>{
            //console.warn('Peer connected : ' + peer.id, peer)
            self.peers[peer.id] = peer;
            self.join();
        });
        this.p2pt.on("peerclose", (peer)=>{
            //console.warn('Peer disconnected : ' + peer)
            if (self.peers[peer.id]) delete self.peers[peer.id];
        });
        this.p2pt.on("msg", (peer, msg)=>{
            console.log(`Got message from ${peer.id} : ${JSON.stringify(msg)}`);
            switch(msg.cmd){
                case "join":
                    if (msg.timestamp < self.timestamp) self.broadcast({
                        cmd: "update",
                        data: self.data,
                        timestamp: self.timestamp
                    });
                    else {
                        self.timestamp = msg.timestamp;
                        self.data = msg.data;
                        self.update();
                    }
                    break;
                case "update":
                    if (msg.timestamp > self.timestamp) {
                        self.timestamp = msg.timestamp;
                        self.data = msg.data;
                        self.update();
                    }
                    break;
                default:
                    console.warn("unknown command", msg.cmd);
            }
        });
        this.p2pt.start();
    }
    update() {
        if (this.update_) {
            this.doUpdate = false;
            this.update_({
                id: this.id,
                data: this.data,
                timestamp: this.timestamp
            });
        } else this.doUpdate = true;
    }
    updateConfig(data) {
        this.data = data;
        this.timestamp = Date.now();
        this.broadcast({
            cmd: "update",
            data: this.data,
            timestamp: this.timestamp
        });
    }
    on(event, callback) {
        switch(event){
            case "update":
                this.update_ = callback;
                if (this.doUpdate) this.update();
                break;
        }
    }
    broadcast(msg) {
        if (!this.p2pt) return;
        for(const id in this.peers)try {
            this.p2pt.send(this.peers[id], msg);
        } catch (e) {
            console.warn(e.message);
            delete this.peers[id];
        }
    }
    stop() {
        this.p2pt?.destroy();
    }
    join() {
        const message = {
            cmd: "join",
            data: this.data,
            timestamp: this.timestamp
        };
        this.broadcast(message);
    }
}
exports.default = Comm;

},{"p2pt":"FIXDk","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"FIXDk":[function(require,module,exports) {
/**
 * Peer 2 Peer WebRTC connections with WebTorrent Trackers as signalling server
 * Copyright Subin Siby <mail@subinsb.com>, 2020
 * Licensed under MIT
 */ var Buffer = require("9dd38a6d4b18afb2").Buffer;
const WebSocketTracker = require("d544520e0af4a840");
const randombytes = require("55f4d670b90650b8");
const EventEmitter = require("8f22bd8cf2a5bf75");
const sha1 = require("966f5d4f8a075bb1");
const debug = require("6d9d000999d75aa3")("p2pt");
/**
 * This character would be prepended to easily identify JSON msgs
 */ const JSON_MESSAGE_IDENTIFIER = "^";
/**
 * WebRTC data channel limit beyond which data is split into chunks
 * Chose 16KB considering Chromium
 * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels#Concerns_with_large_messages
 */ const MAX_MESSAGE_LENGTH = 16000;
class P2PT extends EventEmitter {
    /**
   *
   * @param array announceURLs List of announce tracker URLs
   * @param string identifierString Identifier used to discover peers in the network
   */ constructor(announceURLs = [], identifierString = ""){
        super();
        this.announceURLs = announceURLs;
        this.trackers = {};
        this.peers = {};
        this.msgChunks = {};
        this.responseWaiting = {};
        if (identifierString) this.setIdentifier(identifierString);
        this._peerIdBuffer = randombytes(20);
        this._peerId = this._peerIdBuffer.toString("hex");
        this._peerIdBinary = this._peerIdBuffer.toString("binary");
        debug("my peer id: " + this._peerId);
    }
    /**
   * Set the identifier string used to discover peers in the network
   * @param string identifierString
   */ setIdentifier(identifierString) {
        this.identifierString = identifierString;
        this.infoHash = sha1.sync(identifierString).toLowerCase();
        this._infoHashBuffer = Buffer.from(this.infoHash, "hex");
        this._infoHashBinary = this._infoHashBuffer.toString("binary");
    }
    /**
   * Connect to network and start discovering peers
   */ start() {
        this.on("peer", (peer)=>{
            let newpeer = false;
            if (!this.peers[peer.id]) {
                newpeer = true;
                this.peers[peer.id] = {};
                this.responseWaiting[peer.id] = {};
            }
            peer.on("connect", ()=>{
                /**
         * Multiple data channels to one peer is possible
         * The `peer` object actually refers to a peer with a data channel. Even though it may have same `id` (peerID) property, the data channel will be different. Different trackers giving the same "peer" will give the `peer` object with different channels.
         * We will store all channels as backups in case any one of them fails
         * A peer is removed if all data channels become unavailable
         */ this.peers[peer.id][peer.channelName] = peer;
                if (newpeer) this.emit("peerconnect", peer);
            });
            peer.on("data", (data)=>{
                this.emit("data", peer, data);
                data = data.toString();
                debug("got a message from " + peer.id);
                if (data[0] === JSON_MESSAGE_IDENTIFIER) try {
                    data = JSON.parse(data.slice(1));
                    // A respond function
                    peer.respond = this._peerRespond(peer, data.id);
                    let msg = this._chunkHandler(data);
                    // msg fully retrieved
                    if (msg !== false) {
                        if (data.o) msg = JSON.parse(msg);
                        /**
               * If there's someone waiting for a response, call them
               */ if (this.responseWaiting[peer.id][data.id]) {
                            this.responseWaiting[peer.id][data.id]([
                                peer,
                                msg
                            ]);
                            delete this.responseWaiting[peer.id][data.id];
                        } else this.emit("msg", peer, msg);
                        this._destroyChunks(data.id);
                    }
                } catch (e) {
                    console.log(e);
                }
            });
            peer.on("error", (err)=>{
                this._removePeer(peer);
                debug("Error in connection : " + err);
            });
            peer.on("close", ()=>{
                this._removePeer(peer);
                debug("Connection closed with " + peer.id);
            });
        });
        // Tracker responded to the announce request
        this.on("update", (response)=>{
            const tracker = this.trackers[this.announceURLs.indexOf(response.announce)];
            this.emit("trackerconnect", tracker, this.getTrackerStats());
        });
        // Errors in tracker connection
        this.on("warning", (err)=>{
            this.emit("trackerwarning", err, this.getTrackerStats());
        });
        this._fetchPeers();
    }
    /**
   * Add a tracker
   * @param string announceURL Tracker Announce URL
   */ addTracker(announceURL) {
        if (this.announceURLs.indexOf(announceURL) !== -1) throw new Error("Tracker already added");
        const key = this.announceURLs.push(announceURL);
        this.trackers[key] = new WebSocketTracker(this, announceURL);
        this.trackers[key].announce(this._defaultAnnounceOpts());
    }
    /**
   * Remove a tracker without destroying peers
   */ removeTracker(announceURL) {
        const key = this.announceURLs.indexOf(announceURL);
        if (key === -1) throw new Error("Tracker does not exist");
        // hack to not destroy peers
        this.trackers[key].peers = [];
        this.trackers[key].destroy();
        delete this.trackers[key];
        delete this.announceURLs[key];
    }
    /**
   * Remove a peer from the list if all channels are closed
   * @param integer id Peer ID
   */ _removePeer(peer) {
        if (!this.peers[peer.id]) return false;
        delete this.peers[peer.id][peer.channelName];
        // All data channels are gone. Peer lost
        if (Object.keys(this.peers[peer.id]).length === 0) {
            this.emit("peerclose", peer);
            delete this.responseWaiting[peer.id];
            delete this.peers[peer.id];
        }
    }
    /**
   * Send a msg and get response for it
   * @param Peer peer simple-peer object to send msg to
   * @param string msg Message to send
   * @param integer msgID ID of message if it's a response to a previous message
   */ send(peer, msg, msgID = "") {
        return new Promise((resolve, reject)=>{
            const data = {
                id: msgID !== "" ? msgID : Math.floor(Math.random() * 100000 + 100000),
                msg
            };
            if (typeof msg === "object") {
                data.msg = JSON.stringify(msg);
                data.o = 1 // indicating object
                ;
            }
            try {
                /**
         * Maybe peer channel is closed, so use a different channel if available
         * Array should atleast have one channel, otherwise peer connection is closed
         */ if (!peer.connected) for(const index in this.peers[peer.id]){
                    peer = this.peers[peer.id][index];
                    if (peer.connected) break;
                }
                if (!this.responseWaiting[peer.id]) this.responseWaiting[peer.id] = {};
                this.responseWaiting[peer.id][data.id] = resolve;
            } catch (e) {
                return reject(Error("Connection to peer closed" + e));
            }
            let chunks = 0;
            let remaining = "";
            while(data.msg.length > 0){
                data.c = chunks;
                remaining = data.msg.slice(MAX_MESSAGE_LENGTH);
                data.msg = data.msg.slice(0, MAX_MESSAGE_LENGTH);
                if (!remaining) data.last = true;
                peer.send(JSON_MESSAGE_IDENTIFIER + JSON.stringify(data));
                data.msg = remaining;
                chunks++;
            }
            debug("sent a message to " + peer.id);
        });
    }
    /**
   * Request more peers
   */ requestMorePeers() {
        return new Promise((resolve)=>{
            for(const key in this.trackers)this.trackers[key].announce(this._defaultAnnounceOpts());
            resolve(this.peers);
        });
    }
    /**
   * Get basic stats about tracker connections
   */ getTrackerStats() {
        let connectedCount = 0;
        for(const key in this.trackers)if (this.trackers[key].socket && this.trackers[key].socket.connected) connectedCount++;
        return {
            connected: connectedCount,
            total: this.announceURLs.length
        };
    }
    /**
   * Destroy object
   */ destroy() {
        let key;
        for(key in this.peers)for(const key2 in this.peers[key])this.peers[key][key2].destroy();
        for(key in this.trackers)this.trackers[key].destroy();
    }
    /**
   * A custom function binded on Peer object to easily respond back to message
   * @param Peer peer Peer to send msg to
   * @param integer msgID Message ID
   */ _peerRespond(peer, msgID) {
        return (msg)=>{
            return this.send(peer, msg, msgID);
        };
    }
    /**
   * Handle msg chunks. Returns false until the last chunk is received. Finally returns the entire msg
   * @param object data
   */ _chunkHandler(data) {
        if (!this.msgChunks[data.id]) this.msgChunks[data.id] = [];
        this.msgChunks[data.id][data.c] = data.msg;
        if (data.last) {
            const completeMsg = this.msgChunks[data.id].join("");
            return completeMsg;
        } else return false;
    }
    /**
   * Remove all stored chunks of a particular message
   * @param integer msgID Message ID
   */ _destroyChunks(msgID) {
        delete this.msgChunks[msgID];
    }
    /**
   * Default announce options
   * @param object opts Options
   */ _defaultAnnounceOpts(opts = {}) {
        if (opts.numwant == null) opts.numwant = 50;
        if (opts.uploaded == null) opts.uploaded = 0;
        if (opts.downloaded == null) opts.downloaded = 0;
        return opts;
    }
    /**
   * Initialize trackers and fetch peers
   */ _fetchPeers() {
        for(const key in this.announceURLs){
            this.trackers[key] = new WebSocketTracker(this, this.announceURLs[key]);
            this.trackers[key].announce(this._defaultAnnounceOpts());
        }
    }
}
module.exports = P2PT;

},{"9dd38a6d4b18afb2":"6tQNr","d544520e0af4a840":"8M2o9","55f4d670b90650b8":"5dXXm","8f22bd8cf2a5bf75":"32fHr","966f5d4f8a075bb1":"gVh2f","6d9d000999d75aa3":"3xVVi"}],"6tQNr":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"7jAMi","aceacb6a4531a9d2":"hITcF"}],"7jAMi":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"hITcF":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"8M2o9":[function(require,module,exports) {
const clone = require("1ab01658cb4ead93");
const debug = require("9a1b25fdc13b3ad2")("bittorrent-tracker:websocket-tracker");
const Peer = require("58b4e38b35bf8a6c");
const randombytes = require("7da11458c7032cd8");
const Socket = require("41b15aa41baa2b3e");
const Socks = require("2506348d74f28f11");
const common = require("a04e4f7c0283870b");
const Tracker = require("cae6a97547e7ccfa");
// Use a socket pool, so tracker clients share WebSocket objects for the same server.
// In practice, WebSockets are pretty slow to establish, so this gives a nice performance
// boost, and saves browser resources.
const socketPool = {};
const RECONNECT_MINIMUM = 10000;
const RECONNECT_MAXIMUM = 3600000;
const RECONNECT_VARIANCE = 300000;
const OFFER_TIMEOUT = 50000;
class WebSocketTracker extends Tracker {
    constructor(client, announceUrl){
        super(client, announceUrl);
        debug("new websocket tracker %s", announceUrl);
        this.peers = {} // peers (offer id -> peer)
        ;
        this.socket = null;
        this.reconnecting = false;
        this.retries = 0;
        this.reconnectTimer = null;
        // Simple boolean flag to track whether the socket has received data from
        // the websocket server since the last time socket.send() was called.
        this.expectingResponse = false;
        this._openSocket();
    }
    announce(opts) {
        if (this.destroyed || this.reconnecting) return;
        if (!this.socket.connected) {
            this.socket.once("connect", ()=>{
                this.announce(opts);
            });
            return;
        }
        const params = Object.assign({}, opts, {
            action: "announce",
            info_hash: this.client._infoHashBinary,
            peer_id: this.client._peerIdBinary
        });
        if (this._trackerId) params.trackerid = this._trackerId;
        if (opts.event === "stopped" || opts.event === "completed") // Don't include offers with 'stopped' or 'completed' event
        this._send(params);
        else {
            // Limit the number of offers that are generated, since it can be slow
            const numwant = Math.min(opts.numwant, 5);
            this._generateOffers(numwant, (offers)=>{
                params.numwant = numwant;
                params.offers = offers;
                this._send(params);
            });
        }
    }
    scrape(opts) {
        if (this.destroyed || this.reconnecting) return;
        if (!this.socket.connected) {
            this.socket.once("connect", ()=>{
                this.scrape(opts);
            });
            return;
        }
        const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash)=>infoHash.toString("binary")) : opts.infoHash && opts.infoHash.toString("binary") || this.client._infoHashBinary;
        const params = {
            action: "scrape",
            info_hash: infoHashes
        };
        this._send(params);
    }
    destroy(cb = noop) {
        if (this.destroyed) return cb(null);
        this.destroyed = true;
        clearInterval(this.interval);
        clearTimeout(this.reconnectTimer);
        // Destroy peers
        for(const peerId in this.peers){
            const peer = this.peers[peerId];
            clearTimeout(peer.trackerTimeout);
            peer.destroy();
        }
        this.peers = null;
        if (this.socket) {
            this.socket.removeListener("connect", this._onSocketConnectBound);
            this.socket.removeListener("data", this._onSocketDataBound);
            this.socket.removeListener("close", this._onSocketCloseBound);
            this.socket.removeListener("error", this._onSocketErrorBound);
            this.socket = null;
        }
        this._onSocketConnectBound = null;
        this._onSocketErrorBound = null;
        this._onSocketDataBound = null;
        this._onSocketCloseBound = null;
        if (socketPool[this.announceUrl]) socketPool[this.announceUrl].consumers -= 1;
        // Other instances are using the socket, so there's nothing left to do here
        if (socketPool[this.announceUrl].consumers > 0) return cb();
        let socket = socketPool[this.announceUrl];
        delete socketPool[this.announceUrl];
        socket.on("error", noop) // ignore all future errors
        ;
        socket.once("close", cb);
        let timeout;
        // If there is no data response expected, destroy immediately.
        if (!this.expectingResponse) return destroyCleanup();
        // Otherwise, wait a short time for potential responses to come in from the
        // server, then force close the socket.
        timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT);
        // But, if a response comes from the server before the timeout fires, do cleanup
        // right away.
        socket.once("data", destroyCleanup);
        function destroyCleanup() {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            socket.removeListener("data", destroyCleanup);
            socket.destroy();
            socket = null;
        }
    }
    _openSocket() {
        this.destroyed = false;
        if (!this.peers) this.peers = {};
        this._onSocketConnectBound = ()=>{
            this._onSocketConnect();
        };
        this._onSocketErrorBound = (err)=>{
            this._onSocketError(err);
        };
        this._onSocketDataBound = (data)=>{
            this._onSocketData(data);
        };
        this._onSocketCloseBound = ()=>{
            this._onSocketClose();
        };
        this.socket = socketPool[this.announceUrl];
        if (this.socket) {
            socketPool[this.announceUrl].consumers += 1;
            if (this.socket.connected) this._onSocketConnectBound();
        } else {
            const parsedUrl = new URL(this.announceUrl);
            let agent;
            if (this.client._proxyOpts) {
                agent = parsedUrl.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent;
                if (!agent && this.client._proxyOpts.socksProxy) agent = new Socks.Agent(clone(this.client._proxyOpts.socksProxy), parsedUrl.protocol === "wss:");
            }
            this.socket = socketPool[this.announceUrl] = new Socket({
                url: this.announceUrl,
                agent
            });
            this.socket.consumers = 1;
            this.socket.once("connect", this._onSocketConnectBound);
        }
        this.socket.on("data", this._onSocketDataBound);
        this.socket.once("close", this._onSocketCloseBound);
        this.socket.once("error", this._onSocketErrorBound);
    }
    _onSocketConnect() {
        if (this.destroyed) return;
        if (this.reconnecting) {
            this.reconnecting = false;
            this.retries = 0;
            this.announce(this.client._defaultAnnounceOpts());
        }
    }
    _onSocketData(data) {
        if (this.destroyed) return;
        this.expectingResponse = false;
        try {
            data = JSON.parse(data);
        } catch (err) {
            this.client.emit("warning", new Error("Invalid tracker response"));
            return;
        }
        if (data.action === "announce") this._onAnnounceResponse(data);
        else if (data.action === "scrape") this._onScrapeResponse(data);
        else this._onSocketError(new Error(`invalid action in WS response: ${data.action}`));
    }
    _onAnnounceResponse(data) {
        if (data.info_hash !== this.client._infoHashBinary) {
            debug("ignoring websocket data from %s for %s (looking for %s: reused socket)", this.announceUrl, common.binaryToHex(data.info_hash), this.client.infoHash);
            return;
        }
        if (data.peer_id && data.peer_id === this.client._peerIdBinary) // ignore offers/answers from this client
        return;
        debug("received %s from %s for %s", JSON.stringify(data), this.announceUrl, this.client.infoHash);
        const failure = data["failure reason"];
        if (failure) return this.client.emit("warning", new Error(failure));
        const warning = data["warning message"];
        if (warning) this.client.emit("warning", new Error(warning));
        const interval = data.interval || data["min interval"];
        if (interval) this.setInterval(interval * 1000);
        const trackerId = data["tracker id"];
        if (trackerId) // If absent, do not discard previous trackerId value
        this._trackerId = trackerId;
        if (data.complete != null) {
            const response = Object.assign({}, data, {
                announce: this.announceUrl,
                infoHash: common.binaryToHex(data.info_hash)
            });
            this.client.emit("update", response);
        }
        let peer;
        if (data.offer && data.peer_id) {
            debug("creating peer (from remote offer)");
            peer = this._createPeer();
            peer.id = common.binaryToHex(data.peer_id);
            peer.once("signal", (answer)=>{
                const params = {
                    action: "announce",
                    info_hash: this.client._infoHashBinary,
                    peer_id: this.client._peerIdBinary,
                    to_peer_id: data.peer_id,
                    answer,
                    offer_id: data.offer_id
                };
                if (this._trackerId) params.trackerid = this._trackerId;
                this._send(params);
            });
            this.client.emit("peer", peer);
            peer.signal(data.offer);
        }
        if (data.answer && data.peer_id) {
            const offerId = common.binaryToHex(data.offer_id);
            peer = this.peers[offerId];
            if (peer) {
                peer.id = common.binaryToHex(data.peer_id);
                this.client.emit("peer", peer);
                peer.signal(data.answer);
                clearTimeout(peer.trackerTimeout);
                peer.trackerTimeout = null;
                delete this.peers[offerId];
            } else debug(`got unexpected answer: ${JSON.stringify(data.answer)}`);
        }
    }
    _onScrapeResponse(data) {
        data = data.files || {};
        const keys = Object.keys(data);
        if (keys.length === 0) {
            this.client.emit("warning", new Error("invalid scrape response"));
            return;
        }
        keys.forEach((infoHash)=>{
            // TODO: optionally handle data.flags.min_request_interval
            // (separate from announce interval)
            const response = Object.assign(data[infoHash], {
                announce: this.announceUrl,
                infoHash: common.binaryToHex(infoHash)
            });
            this.client.emit("scrape", response);
        });
    }
    _onSocketClose() {
        if (this.destroyed) return;
        this.destroy();
        this._startReconnectTimer();
    }
    _onSocketError(err) {
        if (this.destroyed) return;
        this.destroy();
        // errors will often happen if a tracker is offline, so don't treat it as fatal
        this.client.emit("warning", err);
        this._startReconnectTimer();
    }
    _startReconnectTimer() {
        const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM);
        this.reconnecting = true;
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = setTimeout(()=>{
            this.retries++;
            this._openSocket();
        }, ms);
        if (this.reconnectTimer.unref) this.reconnectTimer.unref();
        debug("reconnecting socket in %s ms", ms);
    }
    _send(params) {
        if (this.destroyed) return;
        this.expectingResponse = true;
        const message = JSON.stringify(params);
        debug("send %s", message);
        this.socket.send(message);
    }
    _generateOffers(numwant, cb) {
        const self = this;
        const offers = [];
        debug("generating %s offers", numwant);
        for(let i = 0; i < numwant; ++i)generateOffer();
        checkDone();
        function generateOffer() {
            const offerId = randombytes(20).toString("hex");
            debug("creating peer (from _generateOffers)");
            const peer = self.peers[offerId] = self._createPeer({
                initiator: true
            });
            peer.once("signal", (offer)=>{
                offers.push({
                    offer,
                    offer_id: common.hexToBinary(offerId)
                });
                checkDone();
            });
            peer.trackerTimeout = setTimeout(()=>{
                debug("tracker timeout: destroying peer");
                peer.trackerTimeout = null;
                delete self.peers[offerId];
                peer.destroy();
            }, OFFER_TIMEOUT);
            if (peer.trackerTimeout.unref) peer.trackerTimeout.unref();
        }
        function checkDone() {
            if (offers.length === numwant) {
                debug("generated %s offers", numwant);
                cb(offers);
            }
        }
    }
    _createPeer(opts) {
        const self = this;
        opts = Object.assign({
            trickle: false,
            config: self.client._rtcConfig,
            wrtc: self.client._wrtc
        }, opts);
        const peer = new Peer(opts);
        peer.once("error", onError);
        peer.once("connect", onConnect);
        return peer;
        // Handle peer 'error' events that are fired *before* the peer is emitted in
        // a 'peer' event.
        function onError(err) {
            self.client.emit("warning", new Error(`Connection error: ${err.message}`));
            peer.destroy();
        }
        // Once the peer is emitted in a 'peer' event, then it's the consumer's
        // responsibility to listen for errors, so the listeners are removed here.
        function onConnect() {
            peer.removeListener("error", onError);
            peer.removeListener("connect", onConnect);
        }
    }
}
WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30000 // 30 seconds
;
// Normally this shouldn't be accessed but is occasionally useful
WebSocketTracker._socketPool = socketPool;
function noop() {}
module.exports = WebSocketTracker;

},{"1ab01658cb4ead93":"kLB3O","9a1b25fdc13b3ad2":"3xVVi","58b4e38b35bf8a6c":"3pqeI","7da11458c7032cd8":"5dXXm","41b15aa41baa2b3e":"LEdQt","2506348d74f28f11":"9C0N7","a04e4f7c0283870b":"46hr0","cae6a97547e7ccfa":"lt7VG"}],"kLB3O":[function(require,module,exports) {
var Buffer = require("6a12806bba69ad08").Buffer;
var clone = function() {
    "use strict";
    function _instanceof(obj, type) {
        return type != null && obj instanceof type;
    }
    var nativeMap;
    try {
        nativeMap = Map;
    } catch (_) {
        // maybe a reference error because no `Map`. Give it a dummy value that no
        // value will ever be an instanceof.
        nativeMap = function() {};
    }
    var nativeSet;
    try {
        nativeSet = Set;
    } catch (_) {
        nativeSet = function() {};
    }
    var nativePromise;
    try {
        nativePromise = Promise;
    } catch (_) {
        nativePromise = function() {};
    }
    /**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
            depth = circular.depth;
            prototype = circular.prototype;
            includeNonEnumerable = circular.includeNonEnumerable;
            circular = circular.circular;
        }
        // maintain two arrays for circular references, where corresponding parents
        // and children have the same index
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined") circular = true;
        if (typeof depth == "undefined") depth = Infinity;
        // recurse this function so we don't reset allParents and allChildren
        function _clone(parent, depth) {
            // cloning null always returns null
            if (parent === null) return null;
            if (depth === 0) return parent;
            var child;
            var proto;
            if (typeof parent != "object") return parent;
            if (_instanceof(parent, nativeMap)) child = new nativeMap();
            else if (_instanceof(parent, nativeSet)) child = new nativeSet();
            else if (_instanceof(parent, nativePromise)) child = new nativePromise(function(resolve, reject) {
                parent.then(function(value) {
                    resolve(_clone(value, depth - 1));
                }, function(err) {
                    reject(_clone(err, depth - 1));
                });
            });
            else if (clone.__isArray(parent)) child = [];
            else if (clone.__isRegExp(parent)) {
                child = new RegExp(parent.source, __getRegExpFlags(parent));
                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
            } else if (clone.__isDate(parent)) child = new Date(parent.getTime());
            else if (useBuffer && Buffer.isBuffer(parent)) {
                if (Buffer.allocUnsafe) // Node.js >= 4.5.0
                child = Buffer.allocUnsafe(parent.length);
                else // Older Node.js versions
                child = new Buffer(parent.length);
                parent.copy(child);
                return child;
            } else if (_instanceof(parent, Error)) child = Object.create(parent);
            else if (typeof prototype == "undefined") {
                proto = Object.getPrototypeOf(parent);
                child = Object.create(proto);
            } else {
                child = Object.create(prototype);
                proto = prototype;
            }
            if (circular) {
                var index = allParents.indexOf(parent);
                if (index != -1) return allChildren[index];
                allParents.push(parent);
                allChildren.push(child);
            }
            if (_instanceof(parent, nativeMap)) parent.forEach(function(value, key) {
                var keyChild = _clone(key, depth - 1);
                var valueChild = _clone(value, depth - 1);
                child.set(keyChild, valueChild);
            });
            if (_instanceof(parent, nativeSet)) parent.forEach(function(value) {
                var entryChild = _clone(value, depth - 1);
                child.add(entryChild);
            });
            for(var i in parent){
                var attrs;
                if (proto) attrs = Object.getOwnPropertyDescriptor(proto, i);
                if (attrs && attrs.set == null) continue;
                child[i] = _clone(parent[i], depth - 1);
            }
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(parent);
                for(var i = 0; i < symbols.length; i++){
                    // Don't need to worry about cloning a symbol because it is a primitive,
                    // like a number or string.
                    var symbol = symbols[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) continue;
                    child[symbol] = _clone(parent[symbol], depth - 1);
                    if (!descriptor.enumerable) Object.defineProperty(child, symbol, {
                        enumerable: false
                    });
                }
            }
            if (includeNonEnumerable) {
                var allPropertyNames = Object.getOwnPropertyNames(parent);
                for(var i = 0; i < allPropertyNames.length; i++){
                    var propertyName = allPropertyNames[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                    if (descriptor && descriptor.enumerable) continue;
                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                    Object.defineProperty(child, propertyName, {
                        enumerable: false
                    });
                }
            }
            return child;
        }
        return _clone(parent, depth);
    }
    /**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */ clone.clonePrototype = function clonePrototype(parent) {
        if (parent === null) return null;
        var c = function() {};
        c.prototype = parent;
        return new c();
    };
    // private utility functions
    function __objToStr(o) {
        return Object.prototype.toString.call(o);
    }
    clone.__objToStr = __objToStr;
    function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone.__isDate = __isDate;
    function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone.__isArray = __isArray;
    function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
    }
    clone.__getRegExpFlags = __getRegExpFlags;
    return clone;
}();
if (0, module.exports) module.exports = clone;

},{"6a12806bba69ad08":"6tQNr"}],"3xVVi":[function(require,module,exports) {
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var process = require("12edbb1af7d8bd3b");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === "%%") return;
        index++;
        if (match === "%c") // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem("debug");
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== "undefined" && "env" in process) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = require("d9172905aa5ed6c")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
    }
};

},{"12edbb1af7d8bd3b":"gq3cc","d9172905aa5ed6c":"gjwSX"}],"gq3cc":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"gjwSX":[function(require,module,exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require("5c5c8c8b1996f88f");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) return;
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") // Anything else let's inspect with %O
            args.unshift("%O");
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === "%%") return "%";
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) return enableOverride;
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === "function") createDebug.init(debug);
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            else createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>"-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === "*") return true;
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;

},{"5c5c8c8b1996f88f":"8cBiT"}],"8cBiT":[function(require,module,exports) {
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse(val);
    else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch(type){
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
            return n * y;
        case "weeks":
        case "week":
        case "w":
            return n * w;
        case "days":
        case "day":
        case "d":
            return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
            return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
            return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
            return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return Math.round(ms / d) + "d";
    if (msAbs >= h) return Math.round(ms / h) + "h";
    if (msAbs >= m) return Math.round(ms / m) + "m";
    if (msAbs >= s) return Math.round(ms / s) + "s";
    return ms + "ms";
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return plural(ms, msAbs, d, "day");
    if (msAbs >= h) return plural(ms, msAbs, h, "hour");
    if (msAbs >= m) return plural(ms, msAbs, m, "minute");
    if (msAbs >= s) return plural(ms, msAbs, s, "second");
    return ms + " ms";
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}

},{}],"3pqeI":[function(require,module,exports) {
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ const debug = require("f0160713a299a119")("simple-peer");
const getBrowserRTC = require("e41b3bc12f231e8e");
const randombytes = require("bd37747be1aa82e5");
const stream = require("264a1bd6e518dc9f");
const queueMicrotask = require("73a4545b1d5e9fc1") // TODO: remove when Node 10 is not supported
;
const errCode = require("e8fa0db4a87ac551");
const { Buffer } = require("daeb0a871ed118f0");
const MAX_BUFFERED_AMOUNT = 65536;
const ICECOMPLETE_TIMEOUT = 5000;
const CHANNEL_CLOSING_TIMEOUT = 5000;
// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle(sdp) {
    return sdp.replace(/a=ice-options:trickle\s\n/g, "");
}
function warn(message) {
    console.warn(message);
}
/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */ class Peer extends stream.Duplex {
    constructor(opts){
        opts = Object.assign({
            allowHalfOpen: false
        }, opts);
        super(opts);
        this._id = randombytes(4).toString("hex").slice(0, 7);
        this._debug("new peer %o", opts);
        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
        this.initiator = opts.initiator || false;
        this.channelConfig = opts.channelConfig || Peer.channelConfig;
        this.channelNegotiated = this.channelConfig.negotiated;
        this.config = Object.assign({}, Peer.config, opts.config);
        this.offerOptions = opts.offerOptions || {};
        this.answerOptions = opts.answerOptions || {};
        this.sdpTransform = opts.sdpTransform || ((sdp)=>sdp);
        this.streams = opts.streams || (opts.stream ? [
            opts.stream
        ] : [] // support old "stream" option
        );
        this.trickle = opts.trickle !== undefined ? opts.trickle : true;
        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;
        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
        this.destroyed = false;
        this.destroying = false;
        this._connected = false;
        this.remoteAddress = undefined;
        this.remoteFamily = undefined;
        this.remotePort = undefined;
        this.localAddress = undefined;
        this.localFamily = undefined;
        this.localPort = undefined;
        this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
        if (!this._wrtc) {
            if (typeof window === "undefined") throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
            else throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
        }
        this._pcReady = false;
        this._channelReady = false;
        this._iceComplete = false // ice candidate trickle done (got null candidate)
        ;
        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
        ;
        this._channel = null;
        this._pendingCandidates = [];
        this._isNegotiating = false // is this peer waiting for negotiation to complete?
        ;
        this._firstNegotiation = true;
        this._batchedNegotiation = false // batch synchronous negotiations
        ;
        this._queuedNegotiation = false // is there a queued negotiation request?
        ;
        this._sendersAwaitingStable = [];
        this._senderMap = new Map();
        this._closingInterval = null;
        this._remoteTracks = [];
        this._remoteStreams = [];
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        try {
            this._pc = new this._wrtc.RTCPeerConnection(this.config);
        } catch (err) {
            this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
            return;
        }
        // We prefer feature detection whenever possible, but sometimes that's not
        // possible for certain implementations.
        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
        this._pc.oniceconnectionstatechange = ()=>{
            this._onIceStateChange();
        };
        this._pc.onicegatheringstatechange = ()=>{
            this._onIceStateChange();
        };
        this._pc.onconnectionstatechange = ()=>{
            this._onConnectionStateChange();
        };
        this._pc.onsignalingstatechange = ()=>{
            this._onSignalingStateChange();
        };
        this._pc.onicecandidate = (event)=>{
            this._onIceCandidate(event);
        };
        // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783
        if (typeof this._pc.peerIdentity === "object") this._pc.peerIdentity.catch((err)=>{
            this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
        });
        // Other spec events, unused by this implementation:
        // - onconnectionstatechange
        // - onicecandidateerror
        // - onfingerprintfailure
        // - onnegotiationneeded
        if (this.initiator || this.channelNegotiated) this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
        });
        else this._pc.ondatachannel = (event)=>{
            this._setupData(event);
        };
        if (this.streams) this.streams.forEach((stream)=>{
            this.addStream(stream);
        });
        this._pc.ontrack = (event)=>{
            this._onTrack(event);
        };
        this._debug("initial negotiation");
        this._needsNegotiation();
        this._onFinishBound = ()=>{
            this._onFinish();
        };
        this.once("finish", this._onFinishBound);
    }
    get bufferSize() {
        return this._channel && this._channel.bufferedAmount || 0;
    }
    // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    get connected() {
        return this._connected && this._channel.readyState === "open";
    }
    address() {
        return {
            port: this.localPort,
            family: this.localFamily,
            address: this.localAddress
        };
    }
    signal(data) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
        if (typeof data === "string") try {
            data = JSON.parse(data);
        } catch (err) {
            data = {};
        }
        this._debug("signal()");
        if (data.renegotiate && this.initiator) {
            this._debug("got request to renegotiate");
            this._needsNegotiation();
        }
        if (data.transceiverRequest && this.initiator) {
            this._debug("got request for transceiver");
            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
        }
        if (data.candidate) {
            if (this._pc.remoteDescription && this._pc.remoteDescription.type) this._addIceCandidate(data.candidate);
            else this._pendingCandidates.push(data.candidate);
        }
        if (data.sdp) this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(()=>{
            if (this.destroyed) return;
            this._pendingCandidates.forEach((candidate)=>{
                this._addIceCandidate(candidate);
            });
            this._pendingCandidates = [];
            if (this._pc.remoteDescription.type === "offer") this._createAnswer();
        }).catch((err)=>{
            this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
        });
        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
    _addIceCandidate(candidate) {
        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
        this._pc.addIceCandidate(iceCandidateObj).catch((err)=>{
            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) warn("Ignoring unsupported ICE candidate.");
            else this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
        });
    }
    /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */ send(chunk) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
        this._channel.send(chunk);
    }
    /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */ addTransceiver(kind, init) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTransceiver()");
        if (this.initiator) try {
            this._pc.addTransceiver(kind, init);
            this._needsNegotiation();
        } catch (err) {
            this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
        }
        else this.emit("signal", {
            type: "transceiverRequest",
            transceiverRequest: {
                kind,
                init
            }
        });
    }
    /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */ addStream(stream) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addStream()");
        stream.getTracks().forEach((track)=>{
            this.addTrack(track, stream);
        });
    }
    /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */ addTrack(track, stream) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("addTrack()");
        const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
        ;
        let sender = submap.get(stream);
        if (!sender) {
            sender = this._pc.addTrack(track, stream);
            submap.set(stream, sender);
            this._senderMap.set(track, submap);
            this._needsNegotiation();
        } else if (sender.removed) throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
        else throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
    /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */ replaceTrack(oldTrack, newTrack, stream) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("replaceTrack()");
        const submap = this._senderMap.get(oldTrack);
        const sender = submap ? submap.get(stream) : null;
        if (!sender) throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
        if (newTrack) this._senderMap.set(newTrack, submap);
        if (sender.replaceTrack != null) sender.replaceTrack(newTrack);
        else this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
    /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */ removeTrack(track, stream) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSender()");
        const submap = this._senderMap.get(track);
        const sender = submap ? submap.get(stream) : null;
        if (!sender) throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
        try {
            sender.removed = true;
            this._pc.removeTrack(sender);
        } catch (err) {
            if (err.name === "NS_ERROR_UNEXPECTED") this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
            ;
            else this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
        }
        this._needsNegotiation();
    }
    /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */ removeStream(stream) {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
        this._debug("removeSenders()");
        stream.getTracks().forEach((track)=>{
            this.removeTrack(track, stream);
        });
    }
    _needsNegotiation() {
        this._debug("_needsNegotiation");
        if (this._batchedNegotiation) return; // batch synchronous renegotiations
        this._batchedNegotiation = true;
        queueMicrotask(()=>{
            this._batchedNegotiation = false;
            if (this.initiator || !this._firstNegotiation) {
                this._debug("starting batched negotiation");
                this.negotiate();
            } else this._debug("non-initiator initial negotiation request discarded");
            this._firstNegotiation = false;
        });
    }
    negotiate() {
        if (this.destroying) return;
        if (this.destroyed) throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
        if (this.initiator) {
            if (this._isNegotiating) {
                this._queuedNegotiation = true;
                this._debug("already negotiating, queueing");
            } else {
                this._debug("start negotiation");
                setTimeout(()=>{
                    this._createOffer();
                }, 0);
            }
        } else if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
        } else {
            this._debug("requesting negotiation from initiator");
            this.emit("signal", {
                type: "renegotiate",
                renegotiate: true
            });
        }
        this._isNegotiating = true;
    }
    // TODO: Delete this method once readable-stream is updated to contain a default
    // implementation of destroy() that automatically calls _destroy()
    // See: https://github.com/nodejs/readable-stream/issues/283
    destroy(err) {
        this._destroy(err, ()=>{});
    }
    _destroy(err, cb) {
        if (this.destroyed || this.destroying) return;
        this.destroying = true;
        this._debug("destroying (error: %s)", err && (err.message || err));
        queueMicrotask(()=>{
            this.destroyed = true;
            this.destroying = false;
            this._debug("destroy (error: %s)", err && (err.message || err));
            this.readable = this.writable = false;
            if (!this._readableState.ended) this.push(null);
            if (!this._writableState.finished) this.end();
            this._connected = false;
            this._pcReady = false;
            this._channelReady = false;
            this._remoteTracks = null;
            this._remoteStreams = null;
            this._senderMap = null;
            clearInterval(this._closingInterval);
            this._closingInterval = null;
            clearInterval(this._interval);
            this._interval = null;
            this._chunk = null;
            this._cb = null;
            if (this._onFinishBound) this.removeListener("finish", this._onFinishBound);
            this._onFinishBound = null;
            if (this._channel) {
                try {
                    this._channel.close();
                } catch (err) {}
                // allow events concurrent with destruction to be handled
                this._channel.onmessage = null;
                this._channel.onopen = null;
                this._channel.onclose = null;
                this._channel.onerror = null;
            }
            if (this._pc) {
                try {
                    this._pc.close();
                } catch (err) {}
                // allow events concurrent with destruction to be handled
                this._pc.oniceconnectionstatechange = null;
                this._pc.onicegatheringstatechange = null;
                this._pc.onsignalingstatechange = null;
                this._pc.onicecandidate = null;
                this._pc.ontrack = null;
                this._pc.ondatachannel = null;
            }
            this._pc = null;
            this._channel = null;
            if (err) this.emit("error", err);
            this.emit("close");
            cb();
        });
    }
    _setupData(event) {
        if (!event.channel) // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
        // which is invalid behavior. Handle it gracefully.
        // See: https://github.com/feross/simple-peer/issues/163
        return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
        this._channel = event.channel;
        this._channel.binaryType = "arraybuffer";
        if (typeof this._channel.bufferedAmountLowThreshold === "number") this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
        this.channelName = this._channel.label;
        this._channel.onmessage = (event)=>{
            this._onChannelMessage(event);
        };
        this._channel.onbufferedamountlow = ()=>{
            this._onChannelBufferedAmountLow();
        };
        this._channel.onopen = ()=>{
            this._onChannelOpen();
        };
        this._channel.onclose = ()=>{
            this._onChannelClose();
        };
        this._channel.onerror = (event)=>{
            const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);
            this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
        };
        // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
        let isClosing = false;
        this._closingInterval = setInterval(()=>{
            if (this._channel && this._channel.readyState === "closing") {
                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
                ;
                isClosing = true;
            } else isClosing = false;
        }, CHANNEL_CLOSING_TIMEOUT);
    }
    _read() {}
    _write(chunk, encoding, cb) {
        if (this.destroyed) return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
        if (this._connected) {
            try {
                this.send(chunk);
            } catch (err) {
                return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
            }
            if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
                this._cb = cb;
            } else cb(null);
        } else {
            this._debug("write before connect");
            this._chunk = chunk;
            this._cb = cb;
        }
    }
    // When stream finishes writing, close socket. Half open connections are not
    // supported.
    _onFinish() {
        if (this.destroyed) return;
        // Wait a bit before destroying so the socket flushes.
        // TODO: is there a more reliable way to accomplish this?
        const destroySoon = ()=>{
            setTimeout(()=>this.destroy(), 1000);
        };
        if (this._connected) destroySoon();
        else this.once("connect", destroySoon);
    }
    _startIceCompleteTimeout() {
        if (this.destroyed) return;
        if (this._iceCompleteTimer) return;
        this._debug("started iceComplete timeout");
        this._iceCompleteTimer = setTimeout(()=>{
            if (!this._iceComplete) {
                this._iceComplete = true;
                this._debug("iceComplete timeout completed");
                this.emit("iceTimeout");
                this.emit("_iceComplete");
            }
        }, this.iceCompleteTimeout);
    }
    _createOffer() {
        if (this.destroyed) return;
        this._pc.createOffer(this.offerOptions).then((offer)=>{
            if (this.destroyed) return;
            if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);
            offer.sdp = this.sdpTransform(offer.sdp);
            const sendOffer = ()=>{
                if (this.destroyed) return;
                const signal = this._pc.localDescription || offer;
                this._debug("signal");
                this.emit("signal", {
                    type: signal.type,
                    sdp: signal.sdp
                });
            };
            const onSuccess = ()=>{
                this._debug("createOffer success");
                if (this.destroyed) return;
                if (this.trickle || this._iceComplete) sendOffer();
                else this.once("_iceComplete", sendOffer) // wait for candidates
                ;
            };
            const onError = (err)=>{
                this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
        }).catch((err)=>{
            this.destroy(errCode(err, "ERR_CREATE_OFFER"));
        });
    }
    _requestMissingTransceivers() {
        if (this._pc.getTransceivers) this._pc.getTransceivers().forEach((transceiver)=>{
            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
                transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
                ;
                this.addTransceiver(transceiver.sender.track.kind);
            }
        });
    }
    _createAnswer() {
        if (this.destroyed) return;
        this._pc.createAnswer(this.answerOptions).then((answer)=>{
            if (this.destroyed) return;
            if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);
            answer.sdp = this.sdpTransform(answer.sdp);
            const sendAnswer = ()=>{
                if (this.destroyed) return;
                const signal = this._pc.localDescription || answer;
                this._debug("signal");
                this.emit("signal", {
                    type: signal.type,
                    sdp: signal.sdp
                });
                if (!this.initiator) this._requestMissingTransceivers();
            };
            const onSuccess = ()=>{
                if (this.destroyed) return;
                if (this.trickle || this._iceComplete) sendAnswer();
                else this.once("_iceComplete", sendAnswer);
            };
            const onError = (err)=>{
                this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
        }).catch((err)=>{
            this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
        });
    }
    _onConnectionStateChange() {
        if (this.destroyed) return;
        if (this._pc.connectionState === "failed") this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
    _onIceStateChange() {
        if (this.destroyed) return;
        const iceConnectionState = this._pc.iceConnectionState;
        const iceGatheringState = this._pc.iceGatheringState;
        this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
        this.emit("iceStateChange", iceConnectionState, iceGatheringState);
        if (iceConnectionState === "connected" || iceConnectionState === "completed") {
            this._pcReady = true;
            this._maybeReady();
        }
        if (iceConnectionState === "failed") this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
        if (iceConnectionState === "closed") this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
    getStats(cb) {
        // statreports can come with a value array instead of properties
        const flattenValues = (report)=>{
            if (Object.prototype.toString.call(report.values) === "[object Array]") report.values.forEach((value)=>{
                Object.assign(report, value);
            });
            return report;
        };
        // Promise-based getStats() (standard)
        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) this._pc.getStats().then((res)=>{
            const reports = [];
            res.forEach((report)=>{
                reports.push(flattenValues(report));
            });
            cb(null, reports);
        }, (err)=>cb(err));
        else if (this._pc.getStats.length > 0) this._pc.getStats((res)=>{
            // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
            if (this.destroyed) return;
            const reports = [];
            res.result().forEach((result)=>{
                const report = {};
                result.names().forEach((name)=>{
                    report[name] = result.stat(name);
                });
                report.id = result.id;
                report.type = result.type;
                report.timestamp = result.timestamp;
                reports.push(flattenValues(report));
            });
            cb(null, reports);
        }, (err)=>cb(err));
        else cb(null, []);
    }
    _maybeReady() {
        this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
        this._connecting = true;
        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
        const findCandidatePair = ()=>{
            if (this.destroyed) return;
            this.getStats((err, items)=>{
                if (this.destroyed) return;
                // Treat getStats error as non-fatal. It's not essential.
                if (err) items = [];
                const remoteCandidates = {};
                const localCandidates = {};
                const candidatePairs = {};
                let foundSelectedCandidatePair = false;
                items.forEach((item)=>{
                    // TODO: Once all browsers support the hyphenated stats report types, remove
                    // the non-hypenated ones
                    if (item.type === "remotecandidate" || item.type === "remote-candidate") remoteCandidates[item.id] = item;
                    if (item.type === "localcandidate" || item.type === "local-candidate") localCandidates[item.id] = item;
                    if (item.type === "candidatepair" || item.type === "candidate-pair") candidatePairs[item.id] = item;
                });
                const setSelectedCandidatePair = (selectedCandidatePair)=>{
                    foundSelectedCandidatePair = true;
                    let local = localCandidates[selectedCandidatePair.localCandidateId];
                    if (local && (local.ip || local.address)) {
                        // Spec
                        this.localAddress = local.ip || local.address;
                        this.localPort = Number(local.port);
                    } else if (local && local.ipAddress) {
                        // Firefox
                        this.localAddress = local.ipAddress;
                        this.localPort = Number(local.portNumber);
                    } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                        // TODO: remove this once Chrome 58 is released
                        local = selectedCandidatePair.googLocalAddress.split(":");
                        this.localAddress = local[0];
                        this.localPort = Number(local[1]);
                    }
                    if (this.localAddress) this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
                    if (remote && (remote.ip || remote.address)) {
                        // Spec
                        this.remoteAddress = remote.ip || remote.address;
                        this.remotePort = Number(remote.port);
                    } else if (remote && remote.ipAddress) {
                        // Firefox
                        this.remoteAddress = remote.ipAddress;
                        this.remotePort = Number(remote.portNumber);
                    } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                        // TODO: remove this once Chrome 58 is released
                        remote = selectedCandidatePair.googRemoteAddress.split(":");
                        this.remoteAddress = remote[0];
                        this.remotePort = Number(remote[1]);
                    }
                    if (this.remoteAddress) this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
                    this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                };
                items.forEach((item)=>{
                    // Spec-compliant
                    if (item.type === "transport" && item.selectedCandidatePairId) setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
                    // Old implementations
                    if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) setSelectedCandidatePair(item);
                });
                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
                // But wait until at least 1 candidate pair is available
                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
                    setTimeout(findCandidatePair, 100);
                    return;
                } else {
                    this._connecting = false;
                    this._connected = true;
                }
                if (this._chunk) {
                    try {
                        this.send(this._chunk);
                    } catch (err) {
                        return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
                    }
                    this._chunk = null;
                    this._debug('sent chunk from "write before connect"');
                    const cb = this._cb;
                    this._cb = null;
                    cb(null);
                }
                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
                // fallback to using setInterval to implement backpressure.
                if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
                    this._interval = setInterval(()=>this._onInterval(), 150);
                    if (this._interval.unref) this._interval.unref();
                }
                this._debug("connect");
                this.emit("connect");
            });
        };
        findCandidatePair();
    }
    _onInterval() {
        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) return;
        this._onChannelBufferedAmountLow();
    }
    _onSignalingStateChange() {
        if (this.destroyed) return;
        if (this._pc.signalingState === "stable") {
            this._isNegotiating = false;
            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
            this._debug("flushing sender queue", this._sendersAwaitingStable);
            this._sendersAwaitingStable.forEach((sender)=>{
                this._pc.removeTrack(sender);
                this._queuedNegotiation = true;
            });
            this._sendersAwaitingStable = [];
            if (this._queuedNegotiation) {
                this._debug("flushing negotiation queue");
                this._queuedNegotiation = false;
                this._needsNegotiation() // negotiate again
                ;
            } else {
                this._debug("negotiated");
                this.emit("negotiated");
            }
        }
        this._debug("signalingStateChange %s", this._pc.signalingState);
        this.emit("signalingStateChange", this._pc.signalingState);
    }
    _onIceCandidate(event) {
        if (this.destroyed) return;
        if (event.candidate && this.trickle) this.emit("signal", {
            type: "candidate",
            candidate: {
                candidate: event.candidate.candidate,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
                sdpMid: event.candidate.sdpMid
            }
        });
        else if (!event.candidate && !this._iceComplete) {
            this._iceComplete = true;
            this.emit("_iceComplete");
        }
        // as soon as we've received one valid candidate start timeout
        if (event.candidate) this._startIceCompleteTimeout();
    }
    _onChannelMessage(event) {
        if (this.destroyed) return;
        let data = event.data;
        if (data instanceof ArrayBuffer) data = Buffer.from(data);
        this.push(data);
    }
    _onChannelBufferedAmountLow() {
        if (this.destroyed || !this._cb) return;
        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        const cb = this._cb;
        this._cb = null;
        cb(null);
    }
    _onChannelOpen() {
        if (this._connected || this.destroyed) return;
        this._debug("on channel open");
        this._channelReady = true;
        this._maybeReady();
    }
    _onChannelClose() {
        if (this.destroyed) return;
        this._debug("on channel close");
        this.destroy();
    }
    _onTrack(event) {
        if (this.destroyed) return;
        event.streams.forEach((eventStream)=>{
            this._debug("on track");
            this.emit("track", event.track, eventStream);
            this._remoteTracks.push({
                track: event.track,
                stream: eventStream
            });
            if (this._remoteStreams.some((remoteStream)=>{
                return remoteStream.id === eventStream.id;
            })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream
            this._remoteStreams.push(eventStream);
            queueMicrotask(()=>{
                this._debug("on stream");
                this.emit("stream", eventStream) // ensure all tracks have been added
                ;
            });
        });
    }
    _debug() {
        const args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug.apply(null, args);
    }
}
Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */ Peer.config = {
    iceServers: [
        {
            urls: [
                "stun:stun.l.google.com:19302",
                "stun:global.stun.twilio.com:3478"
            ]
        }
    ],
    sdpSemantics: "unified-plan"
};
Peer.channelConfig = {};
module.exports = Peer;

},{"f0160713a299a119":"3xVVi","e41b3bc12f231e8e":"gR93L","bd37747be1aa82e5":"5dXXm","264a1bd6e518dc9f":"hLd4M","73a4545b1d5e9fc1":"7CbvQ","e8fa0db4a87ac551":"9yxn0","daeb0a871ed118f0":"6tQNr"}],"gR93L":[function(require,module,exports) {
// originally pulled out of simple-peer
module.exports = function getBrowserRTC() {
    if (typeof globalThis === "undefined") return null;
    var wrtc = {
        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
    };
    if (!wrtc.RTCPeerConnection) return null;
    return wrtc;
};

},{}],"5dXXm":[function(require,module,exports) {
var global = arguments[3];
var process = require("9f5c61be6bd9c67a");
"use strict";
// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536;
// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295;
function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer = require("caff9346743c214e").Buffer;
var crypto = global.crypto || global.msCrypto;
if (crypto && crypto.getRandomValues) module.exports = randomBytes;
else module.exports = oldBrowser;
function randomBytes(size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer.allocUnsafe(size);
    if (size > 0) {
        if (size > MAX_BYTES) // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for(var generated = 0; generated < size; generated += MAX_BYTES)// buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        else crypto.getRandomValues(bytes);
    }
    if (typeof cb === "function") return process.nextTick(function() {
        cb(null, bytes);
    });
    return bytes;
}

},{"9f5c61be6bd9c67a":"gq3cc","caff9346743c214e":"4WLFd"}],"4WLFd":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"6tQNr"}],"hLd4M":[function(require,module,exports) {
exports = module.exports = require("68bb3bdae87803ec");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require("74167f79b688eaf7");
exports.Duplex = require("84600f6783428a47");
exports.Transform = require("23bee5f697448a0");
exports.PassThrough = require("e0ec4b8e438dbbd");
exports.finished = require("6cc0f9af7147cdbc");
exports.pipeline = require("f90db22d01d3c3d1");

},{"68bb3bdae87803ec":"fdlsB","74167f79b688eaf7":"dvVZS","84600f6783428a47":"e7R9x","23bee5f697448a0":"lXi5u","e0ec4b8e438dbbd":"9wa6Y","6cc0f9af7147cdbc":"4KjsE","f90db22d01d3c3d1":"9oBZJ"}],"fdlsB":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var global = arguments[3];
var process = require("896ff8d56553f7a");
"use strict";
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require("16782d660ac22e0c").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("9a34f23fa53f83f7");
/*</replacement>*/ var Buffer = require("fb95ecaa88342eae").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require("a4a723b7297c7152");
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
else debug = function debug() {};
/*</replacement>*/ var BufferList = require("7a14cc1689b8c63e");
var destroyImpl = require("efa8155386cc4283");
var _require = require("994c984d08c7bbf2"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("8de60461b822641b").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require("19affa8ce41f090d")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++)stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require("830c56f840811f05");
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
    if (from === undefined) from = require("7451b8c4bf72370");
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"896ff8d56553f7a":"gq3cc","16782d660ac22e0c":"32fHr","9a34f23fa53f83f7":"9z3W4","fb95ecaa88342eae":"6tQNr","a4a723b7297c7152":"9C0N7","7a14cc1689b8c63e":"7Gh2M","efa8155386cc4283":"9XP5E","994c984d08c7bbf2":"ks1Kj","8de60461b822641b":"5EQW4","19affa8ce41f090d":"l3bOz","f1c95f846e94e4eb":"e7R9x","6392acd10886f115":"9gZvY","830c56f840811f05":"jMXvV","7451b8c4bf72370":"l88sT"}],"32fHr":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"9z3W4":[function(require,module,exports) {
module.exports = require("ed88fc9aa73f911").EventEmitter;

},{"ed88fc9aa73f911":"32fHr"}],"9C0N7":[function(require,module,exports) {
"use strict";

},{}],"7Gh2M":[function(require,module,exports) {
"use strict";
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = require("59f5d0111b7fa075"), Buffer = _require.Buffer;
var _require2 = require("eef6a677577349b8"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

},{"59f5d0111b7fa075":"6tQNr","eef6a677577349b8":"9C0N7"}],"9XP5E":[function(require,module,exports) {
var process = require("4284522496af5dfb");
"use strict";
// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"4284522496af5dfb":"gq3cc"}],"ks1Kj":[function(require,module,exports) {
"use strict";
var ERR_INVALID_OPT_VALUE = require("4e508d569e2117ef").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"4e508d569e2117ef":"5EQW4"}],"5EQW4":[function(require,module,exports) {
"use strict";
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.codes = codes;

},{}],"l3bOz":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"e7R9x":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
var process = require("2ab1115635c50a9f");
"use strict";
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require("68a7582259cd5865");
var Writable = require("93d042f8bb80078e");
require("aa7b11ba5bf4defc")(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys = objectKeys(Writable.prototype);
for(var v = 0; v < keys.length; v++){
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"2ab1115635c50a9f":"gq3cc","68a7582259cd5865":"fdlsB","93d042f8bb80078e":"dvVZS","aa7b11ba5bf4defc":"l3bOz"}],"dvVZS":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
var global = arguments[3];
var process = require("f05a2a5a09d4d8b0");
"use strict";
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require("dc51171b07b54af1")
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("44a3cc22ec64fcd3");
/*</replacement>*/ var Buffer = require("de8f7fb7ccda8086").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require("acf48fb5d9dc6204");
var _require = require("9d146cd974da0f53"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("3c574b8881abcf86").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require("10dad555ffe77dde")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"f05a2a5a09d4d8b0":"gq3cc","dc51171b07b54af1":"aS0tA","44a3cc22ec64fcd3":"9z3W4","de8f7fb7ccda8086":"6tQNr","acf48fb5d9dc6204":"9XP5E","9d146cd974da0f53":"ks1Kj","3c574b8881abcf86":"5EQW4","10dad555ffe77dde":"l3bOz","c5e7171d6f58d3c0":"e7R9x"}],"aS0tA":[function(require,module,exports) {
/**
 * Module exports.
 */ var global = arguments[3];
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config("noDeprecation")) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config("throwDeprecation")) throw new Error(msg);
            else if (config("traceDeprecation")) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
}

},{}],"9gZvY":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
/*<replacement>*/ var Buffer = require("2a29807c689a070a").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "ÔøΩ";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "ÔøΩ";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "ÔøΩ";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "ÔøΩ";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

},{"2a29807c689a070a":"4WLFd"}],"jMXvV":[function(require,module,exports) {
var process = require("96b869862a96261a");
"use strict";
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = require("745a3cd8f6469ed5");
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"96b869862a96261a":"gq3cc","745a3cd8f6469ed5":"4KjsE"}],"4KjsE":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var ERR_STREAM_PREMATURE_CLOSE = require("d35458f585bdd360").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;

},{"d35458f585bdd360":"5EQW4"}],"l88sT":[function(require,module,exports) {
module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
};

},{}],"lXi5u":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = Transform;
var _require$codes = require("baab47252aa06434").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require("db11ebf938e536ed");
require("82049677fa603d40")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"baab47252aa06434":"5EQW4","db11ebf938e536ed":"e7R9x","82049677fa603d40":"l3bOz"}],"9wa6Y":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = PassThrough;
var Transform = require("7ab21291895ec3d2");
require("f24ec1883eef5e9b")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"7ab21291895ec3d2":"lXi5u","f24ec1883eef5e9b":"l3bOz"}],"9oBZJ":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require("6ba21bd580ac7d57").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = require("dd7fd89dd81b8674");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"6ba21bd580ac7d57":"5EQW4","dd7fd89dd81b8674":"4KjsE"}],"7CbvQ":[function(require,module,exports) {
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var global = arguments[3];
let promise;
module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb)=>(promise || (promise = Promise.resolve())).then(cb).catch((err)=>setTimeout(()=>{
            throw err;
        }, 0));

},{}],"9yxn0":[function(require,module,exports) {
"use strict";
/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */ /**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */ function assign(obj, props) {
    for(const key in props)Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true
    });
    return obj;
}
/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */ function createError(err, code, props) {
    if (!err || typeof err === "string") throw new TypeError("Please pass an Error to err-code");
    if (!props) props = {};
    if (typeof code === "object") {
        props = code;
        code = "";
    }
    if (code) props.code = code;
    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {};
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        // @ts-ignore
        const output = assign(new ErrClass(), props);
        return output;
    }
}
module.exports = createError;

},{}],"LEdQt":[function(require,module,exports) {
/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* global WebSocket */ var Buffer = require("59acb6bfdce87be6").Buffer;
const debug = require("bf7771ecfd590404")("simple-websocket");
const randombytes = require("7b005516076fbacc");
const stream = require("b014530c5edcc345");
const queueMicrotask = require("c35955bc3408b936") // TODO: remove when Node 10 is not supported
;
const ws = require("efbf97603a8da604") // websockets in node - will be empty object in browser
;
const _WebSocket = typeof ws !== "function" ? WebSocket : ws;
const MAX_BUFFERED_AMOUNT = 65536;
/**
 * WebSocket. Same API as node core `net.Socket`. Duplex stream.
 * @param {Object} opts
 * @param {string=} opts.url websocket server url
 * @param {string=} opts.socket raw websocket instance to wrap
 */ class Socket extends stream.Duplex {
    constructor(opts = {}){
        // Support simple usage: `new Socket(url)`
        if (typeof opts === "string") opts = {
            url: opts
        };
        opts = Object.assign({
            allowHalfOpen: false
        }, opts);
        super(opts);
        if (opts.url == null && opts.socket == null) throw new Error("Missing required `url` or `socket` option");
        if (opts.url != null && opts.socket != null) throw new Error("Must specify either `url` or `socket` option, not both");
        this._id = randombytes(4).toString("hex").slice(0, 7);
        this._debug("new websocket: %o", opts);
        this.connected = false;
        this.destroyed = false;
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        if (opts.socket) {
            this.url = opts.socket.url;
            this._ws = opts.socket;
            this.connected = opts.socket.readyState === _WebSocket.OPEN;
        } else {
            this.url = opts.url;
            try {
                if (typeof ws === "function") // `ws` package accepts options
                this._ws = new _WebSocket(opts.url, null, {
                    ...opts,
                    encoding: undefined // encoding option breaks ws internals
                });
                else this._ws = new _WebSocket(opts.url);
            } catch (err) {
                queueMicrotask(()=>this.destroy(err));
                return;
            }
        }
        this._ws.binaryType = "arraybuffer";
        if (opts.socket && this.connected) queueMicrotask(()=>this._handleOpen());
        else this._ws.onopen = ()=>this._handleOpen();
        this._ws.onmessage = (event)=>this._handleMessage(event);
        this._ws.onclose = ()=>this._handleClose();
        this._ws.onerror = (err)=>this._handleError(err);
        this._handleFinishBound = ()=>this._handleFinish();
        this.once("finish", this._handleFinishBound);
    }
    /**
   * Send text/binary data to the WebSocket server.
   * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
   */ send(chunk) {
        this._ws.send(chunk);
    }
    // TODO: Delete this method once readable-stream is updated to contain a default
    // implementation of destroy() that automatically calls _destroy()
    // See: https://github.com/nodejs/readable-stream/issues/283
    destroy(err) {
        this._destroy(err, ()=>{});
    }
    _destroy(err, cb) {
        if (this.destroyed) return;
        this._debug("destroy (error: %s)", err && (err.message || err));
        this.readable = this.writable = false;
        if (!this._readableState.ended) this.push(null);
        if (!this._writableState.finished) this.end();
        this.connected = false;
        this.destroyed = true;
        clearInterval(this._interval);
        this._interval = null;
        this._chunk = null;
        this._cb = null;
        if (this._handleFinishBound) this.removeListener("finish", this._handleFinishBound);
        this._handleFinishBound = null;
        if (this._ws) {
            const ws = this._ws;
            const onClose = ()=>{
                ws.onclose = null;
            };
            if (ws.readyState === _WebSocket.CLOSED) onClose();
            else try {
                ws.onclose = onClose;
                ws.close();
            } catch (err) {
                onClose();
            }
            ws.onopen = null;
            ws.onmessage = null;
            ws.onerror = ()=>{};
        }
        this._ws = null;
        if (err) this.emit("error", err);
        this.emit("close");
        cb();
    }
    _read() {}
    _write(chunk, encoding, cb) {
        if (this.destroyed) return cb(new Error("cannot write after socket is destroyed"));
        if (this.connected) {
            try {
                this.send(chunk);
            } catch (err) {
                return this.destroy(err);
            }
            if (typeof ws !== "function" && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount);
                this._cb = cb;
            } else cb(null);
        } else {
            this._debug("write before connect");
            this._chunk = chunk;
            this._cb = cb;
        }
    }
    _handleOpen() {
        if (this.connected || this.destroyed) return;
        this.connected = true;
        if (this._chunk) {
            try {
                this.send(this._chunk);
            } catch (err) {
                return this.destroy(err);
            }
            this._chunk = null;
            this._debug('sent chunk from "write before connect"');
            const cb = this._cb;
            this._cb = null;
            cb(null);
        }
        // Backpressure is not implemented in Node.js. The `ws` module has a buggy
        // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492
        if (typeof ws !== "function") {
            this._interval = setInterval(()=>this._onInterval(), 150);
            if (this._interval.unref) this._interval.unref();
        }
        this._debug("connect");
        this.emit("connect");
    }
    _handleMessage(event) {
        if (this.destroyed) return;
        let data = event.data;
        if (data instanceof ArrayBuffer) data = Buffer.from(data);
        this.push(data);
    }
    _handleClose() {
        if (this.destroyed) return;
        this._debug("on close");
        this.destroy();
    }
    _handleError(_) {
        this.destroy(new Error(`Error connecting to ${this.url}`));
    }
    // When stream finishes writing, close socket. Half open connections are not
    // supported.
    _handleFinish() {
        if (this.destroyed) return;
        // Wait a bit before destroying so the socket flushes.
        // TODO: is there a more reliable way to accomplish this?
        const destroySoon = ()=>{
            setTimeout(()=>this.destroy(), 1000);
        };
        if (this.connected) destroySoon();
        else this.once("connect", destroySoon);
    }
    _onInterval() {
        if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) return;
        this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
        const cb = this._cb;
        this._cb = null;
        cb(null);
    }
    _debug() {
        const args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug.apply(null, args);
    }
}
Socket.WEBSOCKET_SUPPORT = !!_WebSocket;
module.exports = Socket;

},{"59acb6bfdce87be6":"6tQNr","bf7771ecfd590404":"3xVVi","7b005516076fbacc":"5dXXm","b014530c5edcc345":"hLd4M","c35955bc3408b936":"7CbvQ","efbf97603a8da604":"9C0N7"}],"46hr0":[function(require,module,exports) {
/**
 * Functions/constants needed by both the client and server.
 */ var Buffer = require("1dffecaa9178639f").Buffer;
exports.DEFAULT_ANNOUNCE_PEERS = 50;
exports.MAX_ANNOUNCE_PEERS = 82;
exports.binaryToHex = (str)=>{
    if (typeof str !== "string") str = String(str);
    return Buffer.from(str, "binary").toString("hex");
};
exports.hexToBinary = (str)=>{
    if (typeof str !== "string") str = String(str);
    return Buffer.from(str, "hex").toString("binary");
};
// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like
// 'udp:'. Just replace it with 'http:' since we only need a few properties.
//
// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and
// Edge.
//
// Note: UDP trackers aren't used in the normal browser build, but they are
// used in a Chrome App build (i.e. by Brave Browser).
//
// Bug reports:
// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880
// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505
exports.parseUrl = (str)=>{
    const url = new URL(str.replace(/^udp:/, "http:"));
    if (str.match(/^udp:/)) Object.defineProperties(url, {
        href: {
            value: url.href.replace(/^http/, "udp")
        },
        protocol: {
            value: url.protocol.replace(/^http/, "udp")
        },
        origin: {
            value: url.origin.replace(/^http/, "udp")
        }
    });
    return url;
};
const config = require("b4664badfc93825b");
Object.assign(exports, config);

},{"1dffecaa9178639f":"6tQNr","b4664badfc93825b":"9C0N7"}],"lt7VG":[function(require,module,exports) {
const EventEmitter = require("79a6faa4be832642");
class Tracker extends EventEmitter {
    constructor(client, announceUrl){
        super();
        this.client = client;
        this.announceUrl = announceUrl;
        this.interval = null;
        this.destroyed = false;
    }
    setInterval(intervalMs) {
        if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL;
        clearInterval(this.interval);
        if (intervalMs) {
            this.interval = setInterval(()=>{
                this.announce(this.client._defaultAnnounceOpts());
            }, intervalMs);
            if (this.interval.unref) this.interval.unref();
        }
    }
}
module.exports = Tracker;

},{"79a6faa4be832642":"32fHr"}],"gVh2f":[function(require,module,exports) {
/* global self */ const Rusha = require("fcac2b40bb7a02a");
const rushaWorkerSha1 = require("161dc0b76e03d985");
const rusha = new Rusha();
const scope = typeof window !== "undefined" ? window : self;
const crypto = scope.crypto || scope.msCrypto || {};
let subtle = crypto.subtle || crypto.webkitSubtle;
function sha1sync(buf) {
    return rusha.digest(buf);
}
// Browsers throw if they lack support for an algorithm.
// Promise will be rejected on non-secure origins. (http://goo.gl/lq4gCo)
try {
    subtle.digest({
        name: "sha-1"
    }, new Uint8Array()).catch(function() {
        subtle = false;
    });
} catch (err) {
    subtle = false;
}
function sha1(buf, cb) {
    if (!subtle) {
        if (typeof window !== "undefined") rushaWorkerSha1(buf, function onRushaWorkerSha1(err, hash) {
            if (err) {
                // On error, fallback to synchronous method which cannot fail
                cb(sha1sync(buf));
                return;
            }
            cb(hash);
        });
        else queueMicrotask(()=>cb(sha1sync(buf)));
        return;
    }
    if (typeof buf === "string") buf = uint8array(buf);
    subtle.digest({
        name: "sha-1"
    }, buf).then(function succeed(result) {
        cb(hex(new Uint8Array(result)));
    }, function fail() {
        // On error, fallback to synchronous method which cannot fail
        cb(sha1sync(buf));
    });
}
function uint8array(s) {
    const l = s.length;
    const array = new Uint8Array(l);
    for(let i = 0; i < l; i++)array[i] = s.charCodeAt(i);
    return array;
}
function hex(buf) {
    const l = buf.length;
    const chars = [];
    for(let i = 0; i < l; i++){
        const bite = buf[i];
        chars.push((bite >>> 4).toString(16));
        chars.push((bite & 0x0f).toString(16));
    }
    return chars.join("");
}
module.exports = sha1;
module.exports.sync = sha1sync;

},{"fcac2b40bb7a02a":"kkBj7","161dc0b76e03d985":"gOeiw"}],"kkBj7":[function(require,module,exports) {
(function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
})(typeof self !== "undefined" ? self : this, function() {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
            /******/ /******/ // Flag the module as loaded
            /******/ module1.l = true;
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)
        /******/ __webpack_require__.m = modules;
        /******/ /******/ // expose the module cache
        /******/ __webpack_require__.c = installedModules;
        /******/ /******/ // define getter function for harmony exports
        /******/ __webpack_require__.d = function(exports, name, getter) {
            /******/ if (!__webpack_require__.o(exports, name)) /******/ Object.defineProperty(exports, name, {
                /******/ configurable: false,
                /******/ enumerable: true,
                /******/ get: getter
            });
        /******/ };
        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/ __webpack_require__.n = function(module1) {
            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {
                return module1["default"];
            } : /******/ function getModuleExports() {
                return module1;
            };
            /******/ __webpack_require__.d(getter, "a", getter);
            /******/ return getter;
        /******/ };
        /******/ /******/ // Object.prototype.hasOwnProperty.call
        /******/ __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/ /******/ // __webpack_public_path__
        /******/ __webpack_require__.p = "";
        /******/ /******/ // Load entry module and return exports
        /******/ return __webpack_require__(__webpack_require__.s = 3);
    /******/ }([
        /* 0 */ /***/ function(module1, exports, __webpack_require__) {
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            /* eslint-env commonjs, browser */ var RushaCore = __webpack_require__(5);
            var _require = __webpack_require__(1), toHex = _require.toHex, ceilHeapSize = _require.ceilHeapSize;
            var conv = __webpack_require__(6);
            // Calculate the length of buffer that the sha1 routine uses
            // including the padding.
            var padlen = function(len) {
                for(len += 9; len % 64 > 0; len += 1);
                return len;
            };
            var padZeroes = function(bin, len) {
                var h8 = new Uint8Array(bin.buffer);
                var om = len % 4, align = len - om;
                switch(om){
                    case 0:
                        h8[align + 3] = 0;
                    case 1:
                        h8[align + 2] = 0;
                    case 2:
                        h8[align + 1] = 0;
                    case 3:
                        h8[align + 0] = 0;
                }
                for(var i = (len >> 2) + 1; i < bin.length; i++)bin[i] = 0;
            };
            var padData = function(bin, chunkLen, msgLen) {
                bin[chunkLen >> 2] |= 0x80 << 24 - (chunkLen % 4 << 3);
                // To support msgLen >= 2 GiB, use a float division when computing the
                // high 32-bits of the big-endian message length in bits.
                bin[((chunkLen >> 2) + 2 & -16) + 14] = msgLen / 536870912 | 0;
                bin[((chunkLen >> 2) + 2 & -16) + 15] = msgLen << 3;
            };
            var getRawDigest = function(heap, padMaxChunkLen) {
                var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
                var out = new Int32Array(5);
                var arr = new DataView(out.buffer);
                arr.setInt32(0, io[0], false);
                arr.setInt32(4, io[1], false);
                arr.setInt32(8, io[2], false);
                arr.setInt32(12, io[3], false);
                arr.setInt32(16, io[4], false);
                return out;
            };
            var Rusha = function() {
                function Rusha(chunkSize) {
                    _classCallCheck(this, Rusha);
                    chunkSize = chunkSize || 65536;
                    if (chunkSize % 64 > 0) throw new Error("Chunk size must be a multiple of 128 bit");
                    this._offset = 0;
                    this._maxChunkLen = chunkSize;
                    this._padMaxChunkLen = padlen(chunkSize);
                    // The size of the heap is the sum of:
                    // 1. The padded input message size
                    // 2. The extended space the algorithm needs (320 byte)
                    // 3. The 160 bit state the algoritm uses
                    this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
                    this._h32 = new Int32Array(this._heap);
                    this._h8 = new Int8Array(this._heap);
                    this._core = new RushaCore({
                        Int32Array: Int32Array
                    }, {}, this._heap);
                }
                Rusha.prototype._initState = function _initState(heap, padMsgLen) {
                    this._offset = 0;
                    var io = new Int32Array(heap, padMsgLen + 320, 5);
                    io[0] = 1732584193;
                    io[1] = -271733879;
                    io[2] = -1732584194;
                    io[3] = 271733878;
                    io[4] = -1009589776;
                };
                Rusha.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
                    var padChunkLen = padlen(chunkLen);
                    var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
                    padZeroes(view, chunkLen);
                    padData(view, chunkLen, msgLen);
                    return padChunkLen;
                };
                Rusha.prototype._write = function _write(data, chunkOffset, chunkLen, off) {
                    conv(data, this._h8, this._h32, chunkOffset, chunkLen, off || 0);
                };
                Rusha.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
                    var padChunkLen = chunkLen;
                    this._write(data, chunkOffset, chunkLen);
                    if (finalize) padChunkLen = this._padChunk(chunkLen, msgLen);
                    this._core.hash(padChunkLen, this._padMaxChunkLen);
                };
                Rusha.prototype.rawDigest = function rawDigest(str) {
                    var msgLen = str.byteLength || str.length || str.size || 0;
                    this._initState(this._heap, this._padMaxChunkLen);
                    var chunkOffset = 0, chunkLen = this._maxChunkLen;
                    for(chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen)this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
                    this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                    return getRawDigest(this._heap, this._padMaxChunkLen);
                };
                Rusha.prototype.digest = function digest(str) {
                    return toHex(this.rawDigest(str).buffer);
                };
                Rusha.prototype.digestFromString = function digestFromString(str) {
                    return this.digest(str);
                };
                Rusha.prototype.digestFromBuffer = function digestFromBuffer(str) {
                    return this.digest(str);
                };
                Rusha.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
                    return this.digest(str);
                };
                Rusha.prototype.resetState = function resetState() {
                    this._initState(this._heap, this._padMaxChunkLen);
                    return this;
                };
                Rusha.prototype.append = function append(chunk) {
                    var chunkOffset = 0;
                    var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
                    var turnOffset = this._offset % this._maxChunkLen;
                    var inputLen = void 0;
                    this._offset += chunkLen;
                    while(chunkOffset < chunkLen){
                        inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);
                        this._write(chunk, chunkOffset, inputLen, turnOffset);
                        turnOffset += inputLen;
                        chunkOffset += inputLen;
                        if (turnOffset === this._maxChunkLen) {
                            this._core.hash(this._maxChunkLen, this._padMaxChunkLen);
                            turnOffset = 0;
                        }
                    }
                    return this;
                };
                Rusha.prototype.getState = function getState() {
                    var turnOffset = this._offset % this._maxChunkLen;
                    var heap = void 0;
                    if (!turnOffset) {
                        var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                        heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
                    } else heap = this._heap.slice(0);
                    return {
                        offset: this._offset,
                        heap: heap
                    };
                };
                Rusha.prototype.setState = function setState(state) {
                    this._offset = state.offset;
                    if (state.heap.byteLength === 20) {
                        var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                        io.set(new Int32Array(state.heap));
                    } else this._h32.set(new Int32Array(state.heap));
                    return this;
                };
                Rusha.prototype.rawEnd = function rawEnd() {
                    var msgLen = this._offset;
                    var chunkLen = msgLen % this._maxChunkLen;
                    var padChunkLen = this._padChunk(chunkLen, msgLen);
                    this._core.hash(padChunkLen, this._padMaxChunkLen);
                    var result = getRawDigest(this._heap, this._padMaxChunkLen);
                    this._initState(this._heap, this._padMaxChunkLen);
                    return result;
                };
                Rusha.prototype.end = function end() {
                    return toHex(this.rawEnd().buffer);
                };
                return Rusha;
            }();
            module1.exports = Rusha;
            module1.exports._core = RushaCore;
        /***/ },
        /* 1 */ /***/ function(module1, exports) {
            /* eslint-env commonjs, browser */ //
            // toHex
            //
            var precomputedHex = new Array(256);
            for(var i = 0; i < 256; i++)precomputedHex[i] = (i < 0x10 ? "0" : "") + i.toString(16);
            module1.exports.toHex = function(arrayBuffer) {
                var binarray = new Uint8Array(arrayBuffer);
                var res = new Array(arrayBuffer.byteLength);
                for(var _i = 0; _i < res.length; _i++)res[_i] = precomputedHex[binarray[_i]];
                return res.join("");
            };
            //
            // ceilHeapSize
            //
            module1.exports.ceilHeapSize = function(v) {
                // The asm.js spec says:
                // The heap object's byteLength must be either
                // 2^n for n in [12, 24) or 2^24 * n for n ‚â• 1.
                // Also, byteLengths smaller than 2^16 are deprecated.
                var p = 0;
                // If v is smaller than 2^16, the smallest possible solution
                // is 2^16.
                if (v <= 65536) return 65536;
                // If v < 2^24, we round up to 2^n,
                // otherwise we round up to 2^24 * n.
                if (v < 16777216) {
                    for(p = 1; p < v; p = p << 1);
                } else {
                    for(p = 16777216; p < v; p += 16777216);
                }
                return p;
            };
            //
            // isDedicatedWorkerScope
            //
            module1.exports.isDedicatedWorkerScope = function(self1) {
                var isRunningInWorker = "WorkerGlobalScope" in self1 && self1 instanceof self1.WorkerGlobalScope;
                var isRunningInSharedWorker = "SharedWorkerGlobalScope" in self1 && self1 instanceof self1.SharedWorkerGlobalScope;
                var isRunningInServiceWorker = "ServiceWorkerGlobalScope" in self1 && self1 instanceof self1.ServiceWorkerGlobalScope;
                // Detects whether we run inside a dedicated worker or not.
                //
                // We can't just check for `DedicatedWorkerGlobalScope`, since IE11
                // has a bug where it only supports `WorkerGlobalScope`.
                //
                // Therefore, we consider us as running inside a dedicated worker
                // when we are running inside a worker, but not in a shared or service worker.
                //
                // When new types of workers are introduced, we will need to adjust this code.
                return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
            };
        /***/ },
        /* 2 */ /***/ function(module1, exports, __webpack_require__) {
            /* eslint-env commonjs, worker */ module1.exports = function() {
                var Rusha = __webpack_require__(0);
                var hashData = function(hasher, data, cb) {
                    try {
                        return cb(null, hasher.digest(data));
                    } catch (e) {
                        return cb(e);
                    }
                };
                var hashFile = function(hasher, readTotal, blockSize, file, cb) {
                    var reader = new self.FileReader();
                    reader.onloadend = function onloadend() {
                        if (reader.error) return cb(reader.error);
                        var buffer = reader.result;
                        readTotal += reader.result.byteLength;
                        try {
                            hasher.append(buffer);
                        } catch (e) {
                            cb(e);
                            return;
                        }
                        if (readTotal < file.size) hashFile(hasher, readTotal, blockSize, file, cb);
                        else cb(null, hasher.end());
                    };
                    reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
                };
                var workerBehaviourEnabled = true;
                self.onmessage = function(event) {
                    if (!workerBehaviourEnabled) return;
                    var data = event.data.data, file = event.data.file, id = event.data.id;
                    if (typeof id === "undefined") return;
                    if (!file && !data) return;
                    var blockSize = event.data.blockSize || 4194304;
                    var hasher = new Rusha(blockSize);
                    hasher.resetState();
                    var done = function(err, hash) {
                        if (!err) self.postMessage({
                            id: id,
                            hash: hash
                        });
                        else self.postMessage({
                            id: id,
                            error: err.name
                        });
                    };
                    if (data) hashData(hasher, data, done);
                    if (file) hashFile(hasher, 0, blockSize, file, done);
                };
                return function() {
                    workerBehaviourEnabled = false;
                };
            };
        /***/ },
        /* 3 */ /***/ function(module1, exports, __webpack_require__) {
            /* eslint-env commonjs, browser */ var work = __webpack_require__(4);
            var Rusha = __webpack_require__(0);
            var createHash = __webpack_require__(7);
            var runWorker = __webpack_require__(2);
            var _require = __webpack_require__(1), isDedicatedWorkerScope = _require.isDedicatedWorkerScope;
            var isRunningInDedicatedWorker = typeof self !== "undefined" && isDedicatedWorkerScope(self);
            Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function() {};
            Rusha.createWorker = function() {
                var worker = work(/*require.resolve*/ 2);
                var terminate = worker.terminate;
                worker.terminate = function() {
                    URL.revokeObjectURL(worker.objectURL);
                    terminate.call(worker);
                };
                return worker;
            };
            Rusha.createHash = createHash;
            module1.exports = Rusha;
        /***/ },
        /* 4 */ /***/ function(module1, exports, __webpack_require__) {
            function webpackBootstrapFunc(modules) {
                /******/ // The module cache
                /******/ var installedModules = {};
                /******/ // The require function
                /******/ function __webpack_require__(moduleId) {
                    /******/ // Check if module is in cache
                    /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
                    /******/ // Create a new module (and put it into the cache)
                    /******/ var module1 = installedModules[moduleId] = {
                        /******/ i: moduleId,
                        /******/ l: false,
                        /******/ exports: {}
                    };
                    /******/ // Execute the module function
                    /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __webpack_require__);
                    /******/ // Flag the module as loaded
                    /******/ module1.l = true;
                    /******/ // Return the exports of the module
                    /******/ return module1.exports;
                /******/ }
                /******/ // expose the modules object (__webpack_modules__)
                /******/ __webpack_require__.m = modules;
                /******/ // expose the module cache
                /******/ __webpack_require__.c = installedModules;
                /******/ // identity function for calling harmony imports with the correct context
                /******/ __webpack_require__.i = function(value) {
                    return value;
                };
                /******/ // define getter function for harmony exports
                /******/ __webpack_require__.d = function(exports, name, getter) {
                    /******/ if (!__webpack_require__.o(exports, name)) /******/ Object.defineProperty(exports, name, {
                        /******/ configurable: false,
                        /******/ enumerable: true,
                        /******/ get: getter
                    });
                /******/ };
                /******/ // define __esModule on exports
                /******/ __webpack_require__.r = function(exports) {
                    /******/ Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                /******/ };
                /******/ // getDefaultExport function for compatibility with non-harmony modules
                /******/ __webpack_require__.n = function(module1) {
                    /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {
                        return module1["default"];
                    } : /******/ function getModuleExports() {
                        return module1;
                    };
                    /******/ __webpack_require__.d(getter, "a", getter);
                    /******/ return getter;
                /******/ };
                /******/ // Object.prototype.hasOwnProperty.call
                /******/ __webpack_require__.o = function(object, property) {
                    return Object.prototype.hasOwnProperty.call(object, property);
                };
                /******/ // __webpack_public_path__
                /******/ __webpack_require__.p = "/";
                /******/ // on error function for async loading
                /******/ __webpack_require__.oe = function(err) {
                    console.error(err);
                    throw err;
                };
                var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);
                return f.default || f // try to call default if defined to also support babel esmodule exports
                ;
            }
            var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
            var dependencyRegExp = "\\((/\\*.*?\\*/)?s?.*?(" + moduleNameReqExp + ").*?\\)" // additional chars when output.pathinfo is true
            ;
            // http://stackoverflow.com/a/2593661/130442
            function quoteRegExp(str) {
                return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
            }
            function getModuleDependencies(sources, module1, queueName) {
                var retval = {};
                retval[queueName] = [];
                var fnString = module1.toString();
                var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
                if (!wrapperSignature) return retval;
                var webpackRequireName = wrapperSignature[1];
                // main bundle deps
                var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
                var match;
                while(match = re.exec(fnString)){
                    if (match[3] === "dll-reference") continue;
                    retval[queueName].push(match[3]);
                }
                // dll deps
                re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
                while(match = re.exec(fnString)){
                    if (!sources[match[2]]) {
                        retval[queueName].push(match[1]);
                        sources[match[2]] = __webpack_require__(match[1]).m;
                    }
                    retval[match[2]] = retval[match[2]] || [];
                    retval[match[2]].push(match[4]);
                }
                return retval;
            }
            function hasValuesInQueues(queues) {
                var keys = Object.keys(queues);
                return keys.reduce(function(hasValues, key) {
                    return hasValues || queues[key].length > 0;
                }, false);
            }
            function getRequiredModules(sources, moduleId) {
                var modulesQueue = {
                    main: [
                        moduleId
                    ]
                };
                var requiredModules = {
                    main: []
                };
                var seenModules = {
                    main: {}
                };
                while(hasValuesInQueues(modulesQueue)){
                    var queues = Object.keys(modulesQueue);
                    for(var i = 0; i < queues.length; i++){
                        var queueName = queues[i];
                        var queue = modulesQueue[queueName];
                        var moduleToCheck = queue.pop();
                        seenModules[queueName] = seenModules[queueName] || {};
                        if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;
                        seenModules[queueName][moduleToCheck] = true;
                        requiredModules[queueName] = requiredModules[queueName] || [];
                        requiredModules[queueName].push(moduleToCheck);
                        var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                        var newModulesKeys = Object.keys(newModules);
                        for(var j = 0; j < newModulesKeys.length; j++){
                            modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                            modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                        }
                    }
                }
                return requiredModules;
            }
            module1.exports = function(moduleId, options) {
                options = options || {};
                var sources = {
                    main: __webpack_require__.m
                };
                var requiredModules = options.all ? {
                    main: Object.keys(sources)
                } : getRequiredModules(sources, moduleId);
                var src = "";
                Object.keys(requiredModules).filter(function(m) {
                    return m !== "main";
                }).forEach(function(module1) {
                    var entryModule = 0;
                    while(requiredModules[module1][entryModule])entryModule++;
                    requiredModules[module1].push(entryModule);
                    sources[module1][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                    src = src + "var " + module1 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module1].map(function(id) {
                        return "" + JSON.stringify(id) + ": " + sources[module1][id].toString();
                    }).join(",") + "});\n";
                });
                src = src + "(" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id) {
                    return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
                }).join(",") + "})(self);";
                var blob = new window.Blob([
                    src
                ], {
                    type: "text/javascript"
                });
                if (options.bare) return blob;
                var URL1 = window.URL || window.webkitURL || window.mozURL || window.msURL;
                var workerUrl = URL1.createObjectURL(blob);
                var worker = new window.Worker(workerUrl);
                worker.objectURL = workerUrl;
                return worker;
            };
        /***/ },
        /* 5 */ /***/ function(module1, exports) {
            // The low-level RushCore module provides the heart of Rusha,
            // a high-speed sha1 implementation working on an Int32Array heap.
            // At first glance, the implementation seems complicated, however
            // with the SHA1 spec at hand, it is obvious this almost a textbook
            // implementation that has a few functions hand-inlined and a few loops
            // hand-unrolled.
            module1.exports = function RushaCore(stdlib$840, foreign$841, heap$842) {
                "use asm";
                var H$843 = new stdlib$840.Int32Array(heap$842);
                function hash$844(k$845, x$846) {
                    // k in bytes
                    k$845 = k$845 | 0;
                    x$846 = x$846 | 0;
                    var i$847 = 0, j$848 = 0, y0$849 = 0, z0$850 = 0, y1$851 = 0, z1$852 = 0, y2$853 = 0, z2$854 = 0, y3$855 = 0, z3$856 = 0, y4$857 = 0, z4$858 = 0, t0$859 = 0, t1$860 = 0;
                    y0$849 = H$843[x$846 + 320 >> 2] | 0;
                    y1$851 = H$843[x$846 + 324 >> 2] | 0;
                    y2$853 = H$843[x$846 + 328 >> 2] | 0;
                    y3$855 = H$843[x$846 + 332 >> 2] | 0;
                    y4$857 = H$843[x$846 + 336 >> 2] | 0;
                    for(i$847 = 0; (i$847 | 0) < (k$845 | 0); i$847 = i$847 + 64 | 0){
                        z0$850 = y0$849;
                        z1$852 = y1$851;
                        z2$854 = y2$853;
                        z3$856 = y3$855;
                        z4$858 = y4$857;
                        for(j$848 = 0; (j$848 | 0) < 64; j$848 = j$848 + 4 | 0){
                            t1$860 = H$843[i$847 + j$848 >> 2] | 0;
                            t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                            y4$857 = y3$855;
                            y3$855 = y2$853;
                            y2$853 = y1$851 << 30 | y1$851 >>> 2;
                            y1$851 = y0$849;
                            y0$849 = t0$859;
                            H$843[k$845 + j$848 >> 2] = t1$860;
                        }
                        for(j$848 = k$845 + 64 | 0; (j$848 | 0) < (k$845 + 80 | 0); j$848 = j$848 + 4 | 0){
                            t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                            t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                            y4$857 = y3$855;
                            y3$855 = y2$853;
                            y2$853 = y1$851 << 30 | y1$851 >>> 2;
                            y1$851 = y0$849;
                            y0$849 = t0$859;
                            H$843[j$848 >> 2] = t1$860;
                        }
                        for(j$848 = k$845 + 80 | 0; (j$848 | 0) < (k$845 + 160 | 0); j$848 = j$848 + 4 | 0){
                            t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                            t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1859775393 | 0) | 0;
                            y4$857 = y3$855;
                            y3$855 = y2$853;
                            y2$853 = y1$851 << 30 | y1$851 >>> 2;
                            y1$851 = y0$849;
                            y0$849 = t0$859;
                            H$843[j$848 >> 2] = t1$860;
                        }
                        for(j$848 = k$845 + 160 | 0; (j$848 | 0) < (k$845 + 240 | 0); j$848 = j$848 + 4 | 0){
                            t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                            t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | y1$851 & y3$855 | y2$853 & y3$855) | 0) + ((t1$860 + y4$857 | 0) - 1894007588 | 0) | 0;
                            y4$857 = y3$855;
                            y3$855 = y2$853;
                            y2$853 = y1$851 << 30 | y1$851 >>> 2;
                            y1$851 = y0$849;
                            y0$849 = t0$859;
                            H$843[j$848 >> 2] = t1$860;
                        }
                        for(j$848 = k$845 + 240 | 0; (j$848 | 0) < (k$845 + 320 | 0); j$848 = j$848 + 4 | 0){
                            t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                            t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) - 899497514 | 0) | 0;
                            y4$857 = y3$855;
                            y3$855 = y2$853;
                            y2$853 = y1$851 << 30 | y1$851 >>> 2;
                            y1$851 = y0$849;
                            y0$849 = t0$859;
                            H$843[j$848 >> 2] = t1$860;
                        }
                        y0$849 = y0$849 + z0$850 | 0;
                        y1$851 = y1$851 + z1$852 | 0;
                        y2$853 = y2$853 + z2$854 | 0;
                        y3$855 = y3$855 + z3$856 | 0;
                        y4$857 = y4$857 + z4$858 | 0;
                    }
                    H$843[x$846 + 320 >> 2] = y0$849;
                    H$843[x$846 + 324 >> 2] = y1$851;
                    H$843[x$846 + 328 >> 2] = y2$853;
                    H$843[x$846 + 332 >> 2] = y3$855;
                    H$843[x$846 + 336 >> 2] = y4$857;
                }
                return {
                    hash: hash$844
                };
            };
        /***/ },
        /* 6 */ /***/ function(module1, exports) {
            var _this = this;
            /* eslint-env commonjs, browser */ var reader = void 0;
            if (typeof self !== "undefined" && typeof self.FileReaderSync !== "undefined") reader = new self.FileReaderSync();
            // Convert a binary string and write it to the heap.
            // A binary string is expected to only contain char codes < 256.
            var convStr = function(str, H8, H32, start, len, off) {
                var i = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
                switch(om){
                    case 0:
                        H8[off] = str.charCodeAt(start + 3);
                    case 1:
                        H8[off + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
                    case 2:
                        H8[off + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
                    case 3:
                        H8[off + 3 - (om << 1) | 0] = str.charCodeAt(start);
                }
                if (len < lm + (4 - om)) return;
                for(i = 4 - om; i < j; i = i + 4 | 0)H32[off + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
                switch(lm){
                    case 3:
                        H8[off + j + 1 | 0] = str.charCodeAt(start + j + 2);
                    case 2:
                        H8[off + j + 2 | 0] = str.charCodeAt(start + j + 1);
                    case 1:
                        H8[off + j + 3 | 0] = str.charCodeAt(start + j);
                }
            };
            // Convert a buffer or array and write it to the heap.
            // The buffer or array is expected to only contain elements < 256.
            var convBuf = function(buf, H8, H32, start, len, off) {
                var i = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
                switch(om){
                    case 0:
                        H8[off] = buf[start + 3];
                    case 1:
                        H8[off + 1 - (om << 1) | 0] = buf[start + 2];
                    case 2:
                        H8[off + 2 - (om << 1) | 0] = buf[start + 1];
                    case 3:
                        H8[off + 3 - (om << 1) | 0] = buf[start];
                }
                if (len < lm + (4 - om)) return;
                for(i = 4 - om; i < j; i = i + 4 | 0)H32[off + i >> 2 | 0] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
                switch(lm){
                    case 3:
                        H8[off + j + 1 | 0] = buf[start + j + 2];
                    case 2:
                        H8[off + j + 2 | 0] = buf[start + j + 1];
                    case 1:
                        H8[off + j + 3 | 0] = buf[start + j];
                }
            };
            var convBlob = function(blob, H8, H32, start, len, off) {
                var i = void 0, om = off % 4, lm = (len + om) % 4, j = len - lm;
                var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
                switch(om){
                    case 0:
                        H8[off] = buf[3];
                    case 1:
                        H8[off + 1 - (om << 1) | 0] = buf[2];
                    case 2:
                        H8[off + 2 - (om << 1) | 0] = buf[1];
                    case 3:
                        H8[off + 3 - (om << 1) | 0] = buf[0];
                }
                if (len < lm + (4 - om)) return;
                for(i = 4 - om; i < j; i = i + 4 | 0)H32[off + i >> 2 | 0] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
                switch(lm){
                    case 3:
                        H8[off + j + 1 | 0] = buf[j + 2];
                    case 2:
                        H8[off + j + 2 | 0] = buf[j + 1];
                    case 1:
                        H8[off + j + 3 | 0] = buf[j];
                }
            };
            module1.exports = function(data, H8, H32, start, len, off) {
                if (typeof data === "string") return convStr(data, H8, H32, start, len, off);
                if (data instanceof Array) return convBuf(data, H8, H32, start, len, off);
                // Safely doing a Buffer check using "this" to avoid Buffer polyfill to be included in the dist
                if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) return convBuf(data, H8, H32, start, len, off);
                if (data instanceof ArrayBuffer) return convBuf(new Uint8Array(data), H8, H32, start, len, off);
                if (data.buffer instanceof ArrayBuffer) return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off);
                if (data instanceof Blob) return convBlob(data, H8, H32, start, len, off);
                throw new Error("Unsupported data type.");
            };
        /***/ },
        /* 7 */ /***/ function(module1, exports, __webpack_require__) {
            var _createClass = function() {
                function defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            /* eslint-env commonjs, browser */ var Rusha = __webpack_require__(0);
            var _require = __webpack_require__(1), toHex = _require.toHex;
            var Hash = function() {
                function Hash() {
                    _classCallCheck(this, Hash);
                    this._rusha = new Rusha();
                    this._rusha.resetState();
                }
                Hash.prototype.update = function update(data) {
                    this._rusha.append(data);
                    return this;
                };
                Hash.prototype.digest = function digest(encoding) {
                    var digest = this._rusha.rawEnd().buffer;
                    if (!encoding) return digest;
                    if (encoding === "hex") return toHex(digest);
                    throw new Error("unsupported digest encoding");
                };
                _createClass(Hash, [
                    {
                        key: "state",
                        get: function() {
                            return this._rusha.getState();
                        },
                        set: function(state) {
                            this._rusha.setState(state);
                        }
                    }
                ]);
                return Hash;
            }();
            module1.exports = function() {
                return new Hash();
            };
        /***/ }
    ]);
});

},{}],"gOeiw":[function(require,module,exports) {
const Rusha = require("12b2a3bd1620deac");
let worker;
let nextTaskId;
let cbs;
function init() {
    worker = Rusha.createWorker();
    nextTaskId = 1;
    cbs = {} // taskId -> cb
    ;
    worker.onmessage = function onRushaMessage(e) {
        const taskId = e.data.id;
        const cb = cbs[taskId];
        delete cbs[taskId];
        if (e.data.error != null) cb(new Error("Rusha worker error: " + e.data.error));
        else cb(null, e.data.hash);
    };
}
function sha1(buf, cb) {
    if (!worker) init();
    cbs[nextTaskId] = cb;
    worker.postMessage({
        id: nextTaskId,
        data: buf
    });
    nextTaskId += 1;
}
module.exports = sha1;

},{"12b2a3bd1620deac":"kkBj7"}],"ltUfB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _p2Pt = require("p2pt");
var _p2PtDefault = parcelHelpers.interopDefault(_p2Pt);
var _utils = require("./Utils");
var _yjs = require("yjs");
var _uint8ToBase64 = require("uint8-to-base64");
var trackersAnnounceURLs = [
    "wss://tracker.openwebtorrent.com",
    "wss://tracker.webtorrent.dev",
    "wss://tracker.files.fm:7073/announce",
    "wss://tracker.openwebtorrent.com:443/announce",
    "wss://tracker.files.fm:7073/announce"
];
function dynamicGossip(self) {
    let timerID = null;
    function publish() {
        if (!self.p2pt) return;
        try {
            self.join("update");
            timerID = window.setTimeout(publish, 10000);
        } catch (e) {
            timerID = null;
        }
    }
    return ()=>{
        if (timerID) window.clearTimeout(timerID);
        timerID = window.setTimeout(publish, 10000);
    };
}
const ROOM = {
    studentPublicState: "",
    teacherPublicState: "",
    teacherPrivateState: ""
};
class Comm2 {
    constructor(id, defaultRooms = 0, stationID){
        this.doc = new _yjs.Doc();
        this.timestamp = 0;
        this.peers = {};
        this.stationID = "";
        this.userSettings = {
            displayName: "",
            room: "Lobby",
            role: "student",
            dateJoined: Date.now(),
            handRaised: false,
            connections: [
                {
                    id: "",
                    target: {}
                }
            ]
        };
        let peerID = (0, _utils.getPeerID)();
        if (stationID) {
            this.stationID = "Station " + stationID;
            peerID = this.stationID;
        }
        this.peerID = peerID;
        this.userSettings.displayName = peerID;
        this.initDoc(true, defaultRooms);
        this.initP2PT("classrooms" + id);
        this.timestamp = Date.now();
    }
    initDoc(full = true, defaultRooms = 0) {
        const clientID = this.doc.clientID;
        this.doc.clientID = 0;
        const rooms = this.doc.getMap("rooms");
        const users = this.doc.getMap("users");
        if (full) {
            rooms.set("Lobby", ROOM);
            if (defaultRooms > 0) for(let i = 0; i < defaultRooms; i++)rooms.set("Room " + i, ROOM);
        }
        if (this.stationID) {
            rooms.set(this.stationID, ROOM);
            this.userSettings.room = this.stationID;
        }
        users.set(this.peerID, this.userSettings);
        this.doc.clientID = clientID;
        const self = this;
        this.observer = (event)=>{
            if (self.stationID) {
                if (users.has(self.peerID) && rooms.has(self.stationID)) {
                    self.onUpdate();
                    self.join("join");
                } else self.doc.transact(()=>{
                    rooms.set(self.stationID, ROOM);
                    users.set(self.peerID, self.userSettings);
                });
            } else {
                console.log("Room configuration has changed ... updating");
                if (users.has(self.peerID)) {
                    self.onUpdate();
                    self.join("update");
                } else users.set(self.peerID, self.userSettings);
            }
        };
        rooms.observe(this.observer);
        users.observe(this.observer);
    }
    initP2PT(id) {
        this.p2pt = new (0, _p2PtDefault.default)(trackersAnnounceURLs, id);
        // @ts-ignore
        this.p2pt._maxListeners = 1000000;
        const self = this;
        this.p2pt.on("trackerconnect", (tracker, stats)=>{
            console.log("Connected to tracker : " + tracker.announceUrl);
            console.log("Tracker stats : " + JSON.stringify(stats));
        });
        this.p2pt.on("peerconnect", (peer)=>{
            console.log("Peer connected : " + peer.id, peer);
            self.peers[peer.id] = {
                peer,
                id: null
            };
            setTimeout(()=>{
                self.join();
            }, Math.random() * 2000);
        });
        this.p2pt.on("peerclose", (peer)=>{
            const peerID = this.peers[peer.id]?.id;
            console.log("Peer disconnected : ", peer.id, peerID);
            if (peerID) {
                this.doc.getMap("users").delete(peerID);
                if (peerID.length < 12) this.doc.getMap("rooms").delete(peerID);
            }
            delete self.peers[peer.id];
        });
        this.p2pt.on("msg", (peer, msg)=>{
            console.warn(`Got message from ${peer.id}`, JSON.stringify(msg, null, 2));
            switch(msg.cmd){
                case "join":
                    {
                        this.peers[peer.id].id = msg.id;
                        const data = (0, _uint8ToBase64.decode)(msg.data);
                        if (msg.timestamp < self.timestamp) {
                            self.timestamp = msg.timestamp;
                            self.doc.getMap("users").unobserve(this.observer);
                            self.doc.getMap("rooms").unobserve(this.observer);
                            self.doc = new _yjs.Doc();
                            _yjs.applyUpdate(this.doc, data);
                            self.initDoc(false);
                            self.join("update");
                            self.onUpdate();
                        } else _yjs.applyUpdate(this.doc, data);
                        break;
                    }
                case "update":
                    this.peers[peer.id].id = msg.id;
                    const data = (0, _uint8ToBase64.decode)(msg.data);
                    _yjs.applyUpdate(this.doc, data);
                    break;
                default:
                    this.onMessage(msg.message);
            }
        });
        this.p2pt.start();
    //const gossip = dynamicGossip(this)
    //gossip()
    }
    gotoRoom(room) {
        this.userSettings.room = room;
        this.doc.getMap("users").set(this.peerID, this.userSettings);
    }
    getDoc() {
        return this.doc.toJSON();
    }
    getId() {
        return this.peerID;
    }
    addRoom() {
        const rooms = this.doc.getMap("rooms");
        const room = "Room " + rooms.size;
        rooms.set(room, {
            studentPublicState: "",
            teacherPublicState: "",
            teacherPrivateState: ""
        });
    }
    on(event, callback) {
        switch(event){
            case "update":
                this.update_ = callback;
                break;
            case "message":
                this.update_message = callback;
                break;
        }
    }
    onUpdate() {
        if (this.update_) //console.warn('onUpdate', JSON.stringify(this.doc.toJSON(), null, 2))
        this.update_({
            id: this.peerID,
            data: this.doc.toJSON(),
            timestamp: this.timestamp
        });
    }
    onMessage(message) {
        if (this.update_message) this.update_message(message);
    }
    broadcast(message, room = "") {
        if (!this.p2pt) return;
        // if a room has been defined, then broadcast only to users within that room
        if (room) {
            const users = this.doc.getMap("users").toJSON();
            message.date = Date.now();
            for(const id in this.peers)if (this.peers[id].id) {
                if (users[this.peers[id].id]?.room === room) try {
                    this.p2pt.send(this.peers[id].peer, {
                        id: this.peerID,
                        room,
                        message
                    });
                } catch (e) {
                //console.warn(e.message)
                //delete this.peers[id]
                }
            }
            // as in the original Edrys ... messages are send back to the sender
            this.onMessage(message);
        } else {
            for(const id in this.peers)try {
                this.p2pt.send(this.peers[id].peer, {
                    id: this.peerID,
                    room,
                    ...message
                });
            } catch (e) {
            //console.warn(e.message)
            //delete this.peers[id]
            }
        }
    }
    join(cmd = "join") {
        this.broadcast({
            cmd,
            data: (0, _uint8ToBase64.encode)(_yjs.encodeStateAsUpdate(this.doc)),
            timestamp: this.timestamp
        });
    }
    stop() {
        this.p2pt?.destroy();
    }
}
exports.default = Comm2;

},{"p2pt":"FIXDk","./Utils":"j822r","yjs":"8jx2u","uint8-to-base64":"bxGRZ","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8jx2u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbsolutePosition", ()=>AbsolutePosition);
parcelHelpers.export(exports, "AbstractConnector", ()=>AbstractConnector);
parcelHelpers.export(exports, "AbstractStruct", ()=>AbstractStruct);
parcelHelpers.export(exports, "AbstractType", ()=>AbstractType);
parcelHelpers.export(exports, "Array", ()=>YArray);
parcelHelpers.export(exports, "ContentAny", ()=>ContentAny);
parcelHelpers.export(exports, "ContentBinary", ()=>ContentBinary);
parcelHelpers.export(exports, "ContentDeleted", ()=>ContentDeleted);
parcelHelpers.export(exports, "ContentEmbed", ()=>ContentEmbed);
parcelHelpers.export(exports, "ContentFormat", ()=>ContentFormat);
parcelHelpers.export(exports, "ContentJSON", ()=>ContentJSON);
parcelHelpers.export(exports, "ContentString", ()=>ContentString);
parcelHelpers.export(exports, "ContentType", ()=>ContentType);
parcelHelpers.export(exports, "Doc", ()=>Doc);
parcelHelpers.export(exports, "GC", ()=>GC);
parcelHelpers.export(exports, "ID", ()=>ID);
parcelHelpers.export(exports, "Item", ()=>Item);
parcelHelpers.export(exports, "Map", ()=>YMap);
parcelHelpers.export(exports, "PermanentUserData", ()=>PermanentUserData);
parcelHelpers.export(exports, "RelativePosition", ()=>RelativePosition);
parcelHelpers.export(exports, "Snapshot", ()=>Snapshot);
parcelHelpers.export(exports, "Text", ()=>YText);
parcelHelpers.export(exports, "Transaction", ()=>Transaction);
parcelHelpers.export(exports, "UndoManager", ()=>UndoManager);
parcelHelpers.export(exports, "UpdateEncoderV1", ()=>UpdateEncoderV1);
parcelHelpers.export(exports, "XmlElement", ()=>YXmlElement);
parcelHelpers.export(exports, "XmlFragment", ()=>YXmlFragment);
parcelHelpers.export(exports, "XmlHook", ()=>YXmlHook);
parcelHelpers.export(exports, "XmlText", ()=>YXmlText);
parcelHelpers.export(exports, "YArrayEvent", ()=>YArrayEvent);
parcelHelpers.export(exports, "YEvent", ()=>YEvent);
parcelHelpers.export(exports, "YMapEvent", ()=>YMapEvent);
parcelHelpers.export(exports, "YTextEvent", ()=>YTextEvent);
parcelHelpers.export(exports, "YXmlEvent", ()=>YXmlEvent);
parcelHelpers.export(exports, "applyUpdate", ()=>applyUpdate);
parcelHelpers.export(exports, "applyUpdateV2", ()=>applyUpdateV2);
parcelHelpers.export(exports, "cleanupYTextFormatting", ()=>cleanupYTextFormatting);
parcelHelpers.export(exports, "compareIDs", ()=>compareIDs);
parcelHelpers.export(exports, "compareRelativePositions", ()=>compareRelativePositions);
parcelHelpers.export(exports, "convertUpdateFormatV1ToV2", ()=>convertUpdateFormatV1ToV2);
parcelHelpers.export(exports, "convertUpdateFormatV2ToV1", ()=>convertUpdateFormatV2ToV1);
parcelHelpers.export(exports, "createAbsolutePositionFromRelativePosition", ()=>createAbsolutePositionFromRelativePosition);
parcelHelpers.export(exports, "createDeleteSet", ()=>createDeleteSet);
parcelHelpers.export(exports, "createDeleteSetFromStructStore", ()=>createDeleteSetFromStructStore);
parcelHelpers.export(exports, "createDocFromSnapshot", ()=>createDocFromSnapshot);
parcelHelpers.export(exports, "createID", ()=>createID);
parcelHelpers.export(exports, "createRelativePositionFromJSON", ()=>createRelativePositionFromJSON);
parcelHelpers.export(exports, "createRelativePositionFromTypeIndex", ()=>createRelativePositionFromTypeIndex);
parcelHelpers.export(exports, "createSnapshot", ()=>createSnapshot);
parcelHelpers.export(exports, "decodeRelativePosition", ()=>decodeRelativePosition);
parcelHelpers.export(exports, "decodeSnapshot", ()=>decodeSnapshot);
parcelHelpers.export(exports, "decodeSnapshotV2", ()=>decodeSnapshotV2);
parcelHelpers.export(exports, "decodeStateVector", ()=>decodeStateVector);
parcelHelpers.export(exports, "decodeUpdate", ()=>decodeUpdate);
parcelHelpers.export(exports, "decodeUpdateV2", ()=>decodeUpdateV2);
parcelHelpers.export(exports, "diffUpdate", ()=>diffUpdate);
parcelHelpers.export(exports, "diffUpdateV2", ()=>diffUpdateV2);
parcelHelpers.export(exports, "emptySnapshot", ()=>emptySnapshot);
parcelHelpers.export(exports, "encodeRelativePosition", ()=>encodeRelativePosition);
parcelHelpers.export(exports, "encodeSnapshot", ()=>encodeSnapshot);
parcelHelpers.export(exports, "encodeSnapshotV2", ()=>encodeSnapshotV2);
parcelHelpers.export(exports, "encodeStateAsUpdate", ()=>encodeStateAsUpdate);
parcelHelpers.export(exports, "encodeStateAsUpdateV2", ()=>encodeStateAsUpdateV2);
parcelHelpers.export(exports, "encodeStateVector", ()=>encodeStateVector);
parcelHelpers.export(exports, "encodeStateVectorFromUpdate", ()=>encodeStateVectorFromUpdate);
parcelHelpers.export(exports, "encodeStateVectorFromUpdateV2", ()=>encodeStateVectorFromUpdateV2);
parcelHelpers.export(exports, "equalDeleteSets", ()=>equalDeleteSets);
parcelHelpers.export(exports, "equalSnapshots", ()=>equalSnapshots);
parcelHelpers.export(exports, "findIndexSS", ()=>findIndexSS);
parcelHelpers.export(exports, "findRootTypeKey", ()=>findRootTypeKey);
parcelHelpers.export(exports, "getItem", ()=>getItem);
parcelHelpers.export(exports, "getState", ()=>getState);
parcelHelpers.export(exports, "getTypeChildren", ()=>getTypeChildren);
parcelHelpers.export(exports, "isDeleted", ()=>isDeleted);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
parcelHelpers.export(exports, "iterateDeletedStructs", ()=>iterateDeletedStructs);
parcelHelpers.export(exports, "logType", ()=>logType);
parcelHelpers.export(exports, "logUpdate", ()=>logUpdate);
parcelHelpers.export(exports, "logUpdateV2", ()=>logUpdateV2);
parcelHelpers.export(exports, "mergeUpdates", ()=>mergeUpdates);
parcelHelpers.export(exports, "mergeUpdatesV2", ()=>mergeUpdatesV2);
parcelHelpers.export(exports, "obfuscateUpdate", ()=>obfuscateUpdate);
parcelHelpers.export(exports, "obfuscateUpdateV2", ()=>obfuscateUpdateV2);
parcelHelpers.export(exports, "parseUpdateMeta", ()=>parseUpdateMeta);
parcelHelpers.export(exports, "parseUpdateMetaV2", ()=>parseUpdateMetaV2);
parcelHelpers.export(exports, "readUpdate", ()=>readUpdate);
parcelHelpers.export(exports, "readUpdateV2", ()=>readUpdateV2);
parcelHelpers.export(exports, "relativePositionToJSON", ()=>relativePositionToJSON);
parcelHelpers.export(exports, "snapshot", ()=>snapshot);
parcelHelpers.export(exports, "snapshotContainsUpdate", ()=>snapshotContainsUpdate);
parcelHelpers.export(exports, "transact", ()=>transact);
parcelHelpers.export(exports, "tryGc", ()=>tryGc);
parcelHelpers.export(exports, "typeListToArraySnapshot", ()=>typeListToArraySnapshot);
parcelHelpers.export(exports, "typeMapGetSnapshot", ()=>typeMapGetSnapshot);
var _observable = require("lib0/observable");
var _array = require("lib0/array");
var _math = require("lib0/math");
var _map = require("lib0/map");
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _random = require("lib0/random");
var _promise = require("lib0/promise");
var _buffer = require("lib0/buffer");
var _error = require("lib0/error");
var _binary = require("lib0/binary");
var _function = require("lib0/function");
var _set = require("lib0/set");
var _logging = require("lib0/logging");
var _time = require("lib0/time");
var _string = require("lib0/string");
var _iterator = require("lib0/iterator");
var _object = require("lib0/object");
var global = arguments[3];
/**
 * This is an abstract interface that all Connectors should implement to keep them interchangeable.
 *
 * @note This interface is experimental and it is not advised to actually inherit this class.
 *       It just serves as typing information.
 *
 * @extends {Observable<any>}
 */ class AbstractConnector extends (0, _observable.Observable) {
    /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */ constructor(ydoc, awareness){
        super();
        this.doc = ydoc;
        this.awareness = awareness;
    }
}
class DeleteItem {
    /**
   * @param {number} clock
   * @param {number} len
   */ constructor(clock, len){
        /**
     * @type {number}
     */ this.clock = clock;
        /**
     * @type {number}
     */ this.len = len;
    }
}
/**
 * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
 * - When created in a transaction, it must only be accessed after sorting, and merging
 *   - This DeleteSet is send to other clients
 * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
 * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
 */ class DeleteSet {
    constructor(){
        /**
     * @type {Map<number,Array<DeleteItem>>}
     */ this.clients = new Map();
    }
}
/**
 * Iterate over all structs that the DeleteSet gc's.
 *
 * @param {Transaction} transaction
 * @param {DeleteSet} ds
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{
        const structs = /** @type {Array<GC|Item>} */ transaction.doc.store.clients.get(clientid);
        for(let i = 0; i < deletes.length; i++){
            const del = deletes[i];
            iterateStructs(transaction, structs, del.clock, del.len, f);
        }
    });
/**
 * @param {Array<DeleteItem>} dis
 * @param {number} clock
 * @return {number|null}
 *
 * @private
 * @function
 */ const findIndexDS = (dis, clock)=>{
    let left = 0;
    let right = dis.length - 1;
    while(left <= right){
        const midindex = _math.floor((left + right) / 2);
        const mid = dis[midindex];
        const midclock = mid.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.len) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
    }
    return null;
};
/**
 * @param {DeleteSet} ds
 * @param {ID} id
 * @return {boolean}
 *
 * @private
 * @function
 */ const isDeleted = (ds, id)=>{
    const dis = ds.clients.get(id.client);
    return dis !== undefined && findIndexDS(dis, id.clock) !== null;
};
/**
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const sortAndMergeDeleteSet = (ds)=>{
    ds.clients.forEach((dels)=>{
        dels.sort((a, b)=>a.clock - b.clock);
        // merge items without filtering or splicing the array
        // i is the current pointer
        // j refers to the current insert position for the pointed item
        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
        let i, j;
        for(i = 1, j = 1; i < dels.length; i++){
            const left = dels[j - 1];
            const right = dels[i];
            if (left.clock + left.len >= right.clock) left.len = _math.max(left.len, right.clock + right.len - left.clock);
            else {
                if (j < i) dels[j] = right;
                j++;
            }
        }
        dels.length = j;
    });
};
/**
 * @param {Array<DeleteSet>} dss
 * @return {DeleteSet} A fresh DeleteSet
 */ const mergeDeleteSets = (dss)=>{
    const merged = new DeleteSet();
    for(let dssI = 0; dssI < dss.length; dssI++)dss[dssI].clients.forEach((delsLeft, client)=>{
        if (!merged.clients.has(client)) {
            // Write all missing keys from current ds and all following.
            // If merged already contains `client` current ds has already been added.
            /**
         * @type {Array<DeleteItem>}
         */ const dels = delsLeft.slice();
            for(let i = dssI + 1; i < dss.length; i++)_array.appendTo(dels, dss[i].clients.get(client) || []);
            merged.clients.set(client, dels);
        }
    });
    sortAndMergeDeleteSet(merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {number} client
 * @param {number} clock
 * @param {number} length
 *
 * @private
 * @function
 */ const addToDeleteSet = (ds, client, clock, length)=>{
    _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []).push(new DeleteItem(clock, length));
};
const createDeleteSet = ()=>new DeleteSet();
/**
 * @param {StructStore} ss
 * @return {DeleteSet} Merged and sorted DeleteSet
 *
 * @private
 * @function
 */ const createDeleteSetFromStructStore = (ss)=>{
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client)=>{
        /**
     * @type {Array<DeleteItem>}
     */ const dsitems = [];
        for(let i = 0; i < structs.length; i++){
            const struct = structs[i];
            if (struct.deleted) {
                const clock = struct.id.clock;
                let len = struct.length;
                if (i + 1 < structs.length) for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1])len += next.length;
                dsitems.push(new DeleteItem(clock, len));
            }
        }
        if (dsitems.length > 0) ds.clients.set(client, dsitems);
    });
    return ds;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const writeDeleteSet = (encoder, ds)=>{
    _encoding.writeVarUint(encoder.restEncoder, ds.clients.size);
    // Ensure that the delete set is written in a deterministic order
    _array.from(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{
        encoder.resetDsCurVal();
        _encoding.writeVarUint(encoder.restEncoder, client);
        const len = dsitems.length;
        _encoding.writeVarUint(encoder.restEncoder, len);
        for(let i = 0; i < len; i++){
            const item = dsitems[i];
            encoder.writeDsClock(item.clock);
            encoder.writeDsLen(item.len);
        }
    });
};
/**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {DeleteSet}
 *
 * @private
 * @function
 */ const readDeleteSet = (decoder)=>{
    const ds = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        if (numberOfDeletes > 0) {
            const dsField = _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []);
            for(let i = 0; i < numberOfDeletes; i++)dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
        }
    }
    return ds;
};
/**
 * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
 */ /**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
 *
 * @private
 * @function
 */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{
    const unappliedDS = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        const structs = store.clients.get(client) || [];
        const state = getState(store, client);
        for(let i = 0; i < numberOfDeletes; i++){
            const clock = decoder.readDsClock();
            const clockEnd = clock + decoder.readDsLen();
            if (clock < state) {
                if (state < clockEnd) addToDeleteSet(unappliedDS, client, state, clockEnd - state);
                let index = findIndexSS(structs, clock);
                /**
         * We can ignore the case of GC and Delete structs, because we are going to skip them
         * @type {Item}
         */ // @ts-ignore
                let struct = structs[index];
                // split the first item if necessary
                if (!struct.deleted && struct.id.clock < clock) {
                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
                    index++; // increase we now want to use the next struct
                }
                while(index < structs.length){
                    // @ts-ignore
                    struct = structs[index++];
                    if (struct.id.clock < clockEnd) {
                        if (!struct.deleted) {
                            if (clockEnd < struct.id.clock + struct.length) structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                            struct.delete(transaction);
                        }
                    } else break;
                }
            } else addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
        }
    }
    if (unappliedDS.clients.size > 0) {
        const ds = new UpdateEncoderV2();
        _encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs
        writeDeleteSet(ds, unappliedDS);
        return ds.toUint8Array();
    }
    return null;
};
/**
 * @param {DeleteSet} ds1
 * @param {DeleteSet} ds2
 */ const equalDeleteSets = (ds1, ds2)=>{
    if (ds1.clients.size !== ds2.clients.size) return false;
    for (const [client, deleteItems1] of ds1.clients.entries()){
        const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ ds2.clients.get(client);
        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;
        for(let i = 0; i < deleteItems1.length; i++){
            const di1 = deleteItems1[i];
            const di2 = deleteItems2[i];
            if (di1.clock !== di2.clock || di1.len !== di2.len) return false;
        }
    }
    return true;
};
/**
 * @module Y
 */ const generateNewClientId = _random.uint32;
/**
 * @typedef {Object} DocOpts
 * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
 * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
 * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
 * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
 * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
 * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
 * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
 */ /**
 * A Yjs instance handles the state of shared data.
 * @extends Observable<string>
 */ class Doc extends (0, _observable.Observable) {
    /**
   * @param {DocOpts} opts configuration
   */ constructor({ guid = _random.uuidv4(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){
        super();
        this.gc = gc;
        this.gcFilter = gcFilter;
        this.clientID = generateNewClientId();
        this.guid = guid;
        this.collectionid = collectionid;
        /**
     * @type {Map<string, AbstractType<YEvent<any>>>}
     */ this.share = new Map();
        this.store = new StructStore();
        /**
     * @type {Transaction | null}
     */ this._transaction = null;
        /**
     * @type {Array<Transaction>}
     */ this._transactionCleanups = [];
        /**
     * @type {Set<Doc>}
     */ this.subdocs = new Set();
        /**
     * If this document is a subdocument - a document integrated into another document - then _item is defined.
     * @type {Item?}
     */ this._item = null;
        this.shouldLoad = shouldLoad;
        this.autoLoad = autoLoad;
        this.meta = meta;
        /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     *
     * @type {boolean}
     */ this.isLoaded = false;
        /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */ this.isSynced = false;
        /**
     * Promise that resolves once the document has been loaded from a presistence provider.
     */ this.whenLoaded = _promise.create((resolve)=>{
            this.on("load", ()=>{
                this.isLoaded = true;
                resolve(this);
            });
        });
        const provideSyncedPromise = ()=>_promise.create((resolve)=>{
                /**
       * @param {boolean} isSynced
       */ const eventHandler = (isSynced)=>{
                    if (isSynced === undefined || isSynced === true) {
                        this.off("sync", eventHandler);
                        resolve();
                    }
                };
                this.on("sync", eventHandler);
            });
        this.on("sync", (isSynced)=>{
            if (isSynced === false && this.isSynced) this.whenSynced = provideSyncedPromise();
            this.isSynced = isSynced === undefined || isSynced === true;
            if (!this.isLoaded) this.emit("load", []);
        });
        /**
     * Promise that resolves once the document has been synced with a backend.
     * This promise is recreated when the connection is lost.
     * Note the documentation about the `isSynced` property.
     */ this.whenSynced = provideSyncedPromise();
    }
    /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */ load() {
        const item = this._item;
        if (item !== null && !this.shouldLoad) transact(/** @type {any} */ item.parent.doc, (transaction)=>{
            transaction.subdocsLoaded.add(this);
        }, null, true);
        this.shouldLoad = true;
    }
    getSubdocs() {
        return this.subdocs;
    }
    getSubdocGuids() {
        return new Set(_array.from(this.subdocs).map((doc)=>doc.guid));
    }
    /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */ transact(f, origin = null) {
        return transact(this, f, origin);
    }
    /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
   *
   * @public
   */ get(name, TypeConstructor = AbstractType) {
        const type = _map.setIfUndefined(this.share, name, ()=>{
            // @ts-ignore
            const t = new TypeConstructor();
            t._integrate(this, null);
            return t;
        });
        const Constr = type.constructor;
        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
            if (Constr === AbstractType) {
                // @ts-ignore
                const t = new TypeConstructor();
                t._map = type._map;
                type._map.forEach(/** @param {Item?} n */ (n)=>{
                    for(; n !== null; n = n.left)// @ts-ignore
                    n.parent = t;
                });
                t._start = type._start;
                for(let n = t._start; n !== null; n = n.right)n.parent = t;
                t._length = type._length;
                this.share.set(name, t);
                t._integrate(this, null);
                return t;
            } else throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
        }
        return type;
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */ getArray(name = "") {
        // @ts-ignore
        return this.get(name, YArray);
    }
    /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */ getText(name = "") {
        // @ts-ignore
        return this.get(name, YText);
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */ getMap(name = "") {
        // @ts-ignore
        return this.get(name, YMap);
    }
    /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */ getXmlFragment(name = "") {
        // @ts-ignore
        return this.get(name, YXmlFragment);
    }
    /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */ toJSON() {
        /**
     * @type {Object<string, any>}
     */ const doc = {};
        this.share.forEach((value, key)=>{
            doc[key] = value.toJSON();
        });
        return doc;
    }
    /**
   * Emit `destroy` event and unregister all event handlers.
   */ destroy() {
        _array.from(this.subdocs).forEach((subdoc)=>subdoc.destroy());
        const item = this._item;
        if (item !== null) {
            this._item = null;
            const content = /** @type {ContentDoc} */ item.content;
            content.doc = new Doc({
                guid: this.guid,
                ...content.opts,
                shouldLoad: false
            });
            content.doc._item = item;
            transact(/** @type {any} */ item.parent.doc, (transaction)=>{
                const doc = content.doc;
                if (!item.deleted) transaction.subdocsAdded.add(doc);
                transaction.subdocsRemoved.add(this);
            }, null, true);
        }
        this.emit("destroyed", [
            true
        ]);
        this.emit("destroy", [
            this
        ]);
        super.destroy();
    }
    /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */ on(eventName, f) {
        super.on(eventName, f);
    }
    /**
   * @param {string} eventName
   * @param {function} f
   */ off(eventName, f) {
        super.off(eventName, f);
    }
}
class DSDecoderV1 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @return {number}
   */ readDsClock() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number}
   */ readDsLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
}
class UpdateDecoderV1 extends DSDecoderV1 {
    /**
   * @return {ID}
   */ readLeftID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * @return {ID}
   */ readRightID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return _decoding.readUint8(this.restDecoder);
    }
    /**
   * @return {string}
   */ readString() {
        return _decoding.readVarString(this.restDecoder);
    }
    /**
   * @return {boolean} isKey
   */ readParentInfo() {
        return _decoding.readVarUint(this.restDecoder) === 1;
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readTypeRef() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */ readLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _buffer.copyUint8Array(_decoding.readVarUint8Array(this.restDecoder));
    }
    /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */ readJSON() {
        return JSON.parse(_decoding.readVarString(this.restDecoder));
    }
    /**
   * @return {string}
   */ readKey() {
        return _decoding.readVarString(this.restDecoder);
    }
}
class DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        /**
     * @private
     */ this.dsCurrVal = 0;
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @return {number}
   */ readDsClock() {
        this.dsCurrVal += _decoding.readVarUint(this.restDecoder);
        return this.dsCurrVal;
    }
    /**
   * @return {number}
   */ readDsLen() {
        const diff = _decoding.readVarUint(this.restDecoder) + 1;
        this.dsCurrVal += diff;
        return diff;
    }
}
class UpdateDecoderV2 extends DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        super(decoder);
        /**
     * List of cached keys. If the keys[id] does not exist, we read a new key
     * from stringEncoder and push it to keys.
     *
     * @type {Array<string>}
     */ this.keys = [];
        _decoding.readVarUint(decoder); // read feature flag - currently unused
        this.keyClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.clientDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.leftClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.rightClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.infoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.stringDecoder = new _decoding.StringDecoder(_decoding.readVarUint8Array(decoder));
        this.parentInfoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.typeRefDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.lenDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
    }
    /**
   * @return {ID}
   */ readLeftID() {
        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    /**
   * @return {ID}
   */ readRightID() {
        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return this.clientDecoder.read();
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return /** @type {number} */ this.infoDecoder.read();
    }
    /**
   * @return {string}
   */ readString() {
        return this.stringDecoder.read();
    }
    /**
   * @return {boolean}
   */ readParentInfo() {
        return this.parentInfoDecoder.read() === 1;
    }
    /**
   * @return {number} An unsigned 8-bit integer
   */ readTypeRef() {
        return this.typeRefDecoder.read();
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */ readLen() {
        return this.lenDecoder.read();
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _decoding.readVarUint8Array(this.restDecoder);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */ readJSON() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {string}
   */ readKey() {
        const keyClock = this.keyClockDecoder.read();
        if (keyClock < this.keys.length) return this.keys[keyClock];
        else {
            const key = this.stringDecoder.read();
            this.keys.push(key);
            return key;
        }
    }
}
class DSEncoderV1 {
    constructor(){
        this.restEncoder = _encoding.createEncoder();
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        _encoding.writeVarUint(this.restEncoder, clock);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
}
class UpdateEncoderV1 extends DSEncoderV1 {
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */ writeClient(client) {
        _encoding.writeVarUint(this.restEncoder, client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        _encoding.writeUint8(this.restEncoder, info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        _encoding.writeVarString(this.restEncoder, s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        _encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        _encoding.writeVarUint(this.restEncoder, info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    /**
   * @param {string} key
   */ writeKey(key) {
        _encoding.writeVarString(this.restEncoder, key);
    }
}
class DSEncoderV2 {
    constructor(){
        this.restEncoder = _encoding.createEncoder(); // encodes all the rest / non-optimized
        this.dsCurrVal = 0;
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        const diff = clock - this.dsCurrVal;
        this.dsCurrVal = clock;
        _encoding.writeVarUint(this.restEncoder, diff);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        if (len === 0) _error.unexpectedCase();
        _encoding.writeVarUint(this.restEncoder, len - 1);
        this.dsCurrVal += len;
    }
}
class UpdateEncoderV2 extends DSEncoderV2 {
    constructor(){
        super();
        /**
     * @type {Map<string,number>}
     */ this.keyMap = new Map();
        /**
     * Refers to the next uniqe key-identifier to me used.
     * See writeKey method for more information.
     *
     * @type {number}
     */ this.keyClock = 0;
        this.keyClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.clientEncoder = new _encoding.UintOptRleEncoder();
        this.leftClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.rightClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.infoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.stringEncoder = new _encoding.StringEncoder();
        this.parentInfoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.typeRefEncoder = new _encoding.UintOptRleEncoder();
        this.lenEncoder = new _encoding.UintOptRleEncoder();
    }
    toUint8Array() {
        const encoder = _encoding.createEncoder();
        _encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future
        _encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.infoEncoder));
        _encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.parentInfoEncoder));
        _encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
        // @note The rest encoder is appended! (note the missing var)
        _encoding.writeUint8Array(encoder, _encoding.toUint8Array(this.restEncoder));
        return _encoding.toUint8Array(encoder);
    }
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        this.clientEncoder.write(id.client);
        this.leftClockEncoder.write(id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        this.clientEncoder.write(id.client);
        this.rightClockEncoder.write(id.clock);
    }
    /**
   * @param {number} client
   */ writeClient(client) {
        this.clientEncoder.write(client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        this.infoEncoder.write(info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        this.stringEncoder.write(s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        this.typeRefEncoder.write(info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        this.lenEncoder.write(len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeAny(this.restEncoder, embed);
    }
    /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */ writeKey(key) {
        const clock = this.keyMap.get(key);
        if (clock === undefined) {
            /**
       * @todo uncomment to introduce this feature finally
       *
       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
       * Furthermore, I forgot to set the keyclock. So everything was working fine.
       *
       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
       *
       * I don't know yet how to reintroduce this feature..
       *
       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
       *
       */ // this.keyMap.set(key, this.keyClock)
            this.keyClockEncoder.write(this.keyClock++);
            this.stringEncoder.write(key);
        } else this.keyClockEncoder.write(clock);
    }
}
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Array<GC|Item>} structs All structs by `client`
 * @param {number} client
 * @param {number} clock write structs starting with `ID(client,clock)`
 *
 * @function
 */ const writeStructs = (encoder, structs, client, clock)=>{
    // write first id
    clock = _math.max(clock, structs[0].id.clock); // make sure the first id exists
    const startNewStructs = findIndexSS(structs, clock);
    // write # encoded structs
    _encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    _encoding.writeVarUint(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    // write first struct with an offset
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for(let i = startNewStructs + 1; i < structs.length; i++)structs[i].write(encoder, 0);
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {StructStore} store
 * @param {Map<number,number>} _sm
 *
 * @private
 * @function
 */ const writeClientsStructs = (encoder, store, _sm)=>{
    // we filter all valid _sm entries into sm
    const sm = new Map();
    _sm.forEach((clock, client)=>{
        // only write if new structs are available
        if (getState(store, client) > clock) sm.set(client, clock);
    });
    getStateVector(store).forEach((_clock, client)=>{
        if (!_sm.has(client)) sm.set(client, 0);
    });
    // write # states that were updated
    _encoding.writeVarUint(encoder.restEncoder, sm.size);
    // Write items with higher client ids first
    // This heavily improves the conflict algorithm.
    _array.from(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        writeStructs(encoder, /** @type {Array<GC|Item>} */ store.clients.get(client), client, clock);
    });
};
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
 * @param {Doc} doc
 * @return {Map<number, { i: number, refs: Array<Item | GC> }>}
 *
 * @private
 * @function
 */ const readClientsStructRefs = (decoder, doc)=>{
    /**
   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}
   */ const clientRefs = _map.create();
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        /**
     * @type {Array<GC|Item>}
     */ const refs = new Array(numberOfStructs);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        // const start = performance.now()
        clientRefs.set(client, {
            i: 0,
            refs
        });
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            switch(_binary.BITS5 & info){
                case 0:
                    {
                        const len = decoder.readLen();
                        refs[i] = new GC(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                case 10:
                    {
                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
                        const len = _decoding.readVarUint(decoder.restDecoder);
                        refs[i] = new Skip(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                default:
                    {
                        /**
           * The optimized implementation doesn't use any variables because inlining variables is faster.
           * Below a non-optimized version is shown that implements the basic algorithm with
           * a few comments
           */ const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                        // and we read the next string as parentYKey.
                        // It indicates how we store/retrieve parent from `y.share`
                        // @type {string|null}
                        const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                        );
                        /* A non-optimized implementation of the above algorithm:

          // The item that was originally to the left of this item.
          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null
          // The item that was originally to the right of this item.
          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null
          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0
          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false
          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
          // and we read the next string as parentYKey.
          // It indicates how we store/retrieve parent from `y.share`
          // @type {string|null}
          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null

          const struct = new Item(
            createID(client, clock),
            null, // leftd
            origin, // origin
            null, // right
            rightOrigin, // right origin
            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent
            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
            readItemContent(decoder, info) // item content
          )
          */ refs[i] = struct;
                        clock += struct.length;
                    }
            }
        }
    // console.log('time to read: ', performance.now() - start) // @todo remove
    }
    return clientRefs;
};
/**
 * Resume computing structs generated by struct readers.
 *
 * While there is something to do, we integrate structs in this order
 * 1. top element on stack, if stack is not empty
 * 2. next element from current struct reader (if empty, use next struct reader)
 *
 * If struct causally depends on another struct (ref.missing), we put next reader of
 * `ref.id.client` on top of stack.
 *
 * At some point we find a struct that has no causal dependencies,
 * then we start emptying the stack.
 *
 * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
 * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.
 *
 * This method is implemented in a way so that we can resume computation if this update
 * causally depends on another update.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs
 * @return { null | { update: Uint8Array, missing: Map<number,number> } }
 *
 * @private
 * @function
 */ const integrateStructs = (transaction, store, clientsStructRefs)=>{
    /**
   * @type {Array<Item | GC>}
   */ const stack = [];
    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
    let clientsStructRefsIds = _array.from(clientsStructRefs.keys()).sort((a, b)=>a - b);
    if (clientsStructRefsIds.length === 0) return null;
    const getNextStructTarget = ()=>{
        if (clientsStructRefsIds.length === 0) return null;
        let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        while(nextStructsTarget.refs.length === nextStructsTarget.i){
            clientsStructRefsIds.pop();
            if (clientsStructRefsIds.length > 0) nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
            else return null;
        }
        return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null && stack.length === 0) return null;
    /**
   * @type {StructStore}
   */ const restStructs = new StructStore();
    const missingSV = new Map();
    /**
   * @param {number} client
   * @param {number} clock
   */ const updateMissingSv = (client, clock)=>{
        const mclock = missingSV.get(client);
        if (mclock == null || mclock > clock) missingSV.set(client, clock);
    };
    /**
   * @type {GC|Item}
   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];
    // caching the state because it is used very often
    const state = new Map();
    const addStackToRestSS = ()=>{
        for (const item of stack){
            const client = item.id.client;
            const unapplicableItems = clientsStructRefs.get(client);
            if (unapplicableItems) {
                // decrement because we weren't able to apply previous operation
                unapplicableItems.i--;
                restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
                clientsStructRefs.delete(client);
                unapplicableItems.i = 0;
                unapplicableItems.refs = [];
            } else // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
            restStructs.clients.set(client, [
                item
            ]);
            // remove client from clientsStructRefsIds to prevent users from applying the same update again
            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);
        }
        stack.length = 0;
    };
    // iterate over all struct readers until we are done
    while(true){
        if (stackHead.constructor !== Skip) {
            const localClock = _map.setIfUndefined(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));
            const offset = localClock - stackHead.id.clock;
            if (offset < 0) {
                // update from the same client is missing
                stack.push(stackHead);
                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
                // hid a dead wall, add all items from stack to restSS
                addStackToRestSS();
            } else {
                const missing = stackHead.getMissing(transaction, store);
                if (missing !== null) {
                    stack.push(stackHead);
                    // get the struct reader that has the missing struct
                    /**
           * @type {{ refs: Array<GC|Item>, i: number }}
           */ const structRefs = clientsStructRefs.get(/** @type {number} */ missing) || {
                        refs: [],
                        i: 0
                    };
                    if (structRefs.refs.length === structRefs.i) {
                        // This update message causally depends on another update message that doesn't exist yet
                        updateMissingSv(/** @type {number} */ missing, getState(store, missing));
                        addStackToRestSS();
                    } else {
                        stackHead = structRefs.refs[structRefs.i++];
                        continue;
                    }
                } else if (offset === 0 || offset < stackHead.length) {
                    // all fine, apply the stackhead
                    stackHead.integrate(transaction, offset);
                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
                }
            }
        }
        // iterate to next stackHead
        if (stack.length > 0) stackHead = /** @type {GC|Item} */ stack.pop();
        else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        else {
            curStructsTarget = getNextStructTarget();
            if (curStructsTarget === null) break;
            else stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        }
    }
    if (restStructs.clients.size > 0) {
        const encoder = new UpdateEncoderV2();
        writeClientsStructs(encoder, restStructs, new Map());
        // write empty deleteset
        // writeDeleteSet(encoder, new DeleteSet())
        _encoding.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
        return {
            missing: missingSV,
            update: encoder.toUint8Array()
        };
    }
    return null;
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 *
 * @private
 * @function
 */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts an decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
 *
 * @function
 */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{
        // force that transaction.local is set to non-local
        transaction.local = false;
        let retry = false;
        const doc = transaction.doc;
        const store = doc.store;
        // let start = performance.now()
        const ss = readClientsStructRefs(structDecoder, doc);
        // console.log('time to read structs: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to merge: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const restStructs = integrateStructs(transaction, store, ss);
        const pending = store.pendingStructs;
        if (pending) {
            // check if we can apply something
            for (const [client, clock] of pending.missing)if (clock < getState(store, client)) {
                retry = true;
                break;
            }
            if (restStructs) {
                // merge restStructs into store.pending
                for (const [client, clock] of restStructs.missing){
                    const mclock = pending.missing.get(client);
                    if (mclock == null || mclock > clock) pending.missing.set(client, clock);
                }
                pending.update = mergeUpdatesV2([
                    pending.update,
                    restStructs.update
                ]);
            }
        } else store.pendingStructs = restStructs;
        // console.log('time to integrate: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
        if (store.pendingDs) {
            // @todo we could make a lower-bound state-vector check as we do above
            const pendingDSUpdate = new UpdateDecoderV2(_decoding.createDecoder(store.pendingDs));
            _decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
            if (dsRest && dsRest2) // case 1: ds1 != null && ds2 != null
            store.pendingDs = mergeUpdatesV2([
                dsRest,
                dsRest2
            ]);
            else // case 2: ds1 != null
            // case 3: ds2 != null
            // case 4: ds1 == null && ds2 == null
            store.pendingDs = dsRest || dsRest2;
        } else // Either dsRest == null && pendingDs == null OR dsRest != null
        store.pendingDs = dsRest;
        // console.log('time to cleanup: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
        // start = performance.now()
        if (retry) {
            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;
            store.pendingStructs = null;
            applyUpdateV2(transaction.doc, update);
        }
    }, transactionOrigin, false);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts an decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 *
 * @function
 */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{
    const decoder = _decoding.createDecoder(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
/**
 * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
 * only write the operations that are missing.
 *
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Doc} doc
 * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 *
 * @function
 */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{
    writeClientsStructs(encoder, doc.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([
    0
]), encoder = new UpdateEncoderV2())=>{
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc, targetStateVector);
    const updates = [
        encoder.toUint8Array()
    ];
    // also add the pending updates (if there are any)
    if (doc.store.pendingDs) updates.push(doc.store.pendingDs);
    if (doc.store.pendingStructs) updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
    if (updates.length > 1) {
        if (encoder.constructor === UpdateEncoderV1) return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));
        else if (encoder.constructor === UpdateEncoderV2) return mergeUpdatesV2(updates);
    }
    return updates[0];
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());
/**
 * Read state vector from Decoder and return as Map
 *
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const readStateVector = (decoder)=>{
    const ss = new Map();
    const ssLength = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < ssLength; i++){
        const client = _decoding.readVarUint(decoder.restDecoder);
        const clock = _decoding.readVarUint(decoder.restDecoder);
        ss.set(client, clock);
    }
    return ss;
};
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1(_decoding.createDecoder(decodedState)));
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Map<number,number>} sv
 * @function
 */ const writeStateVector = (encoder, sv)=>{
    _encoding.writeVarUint(encoder.restEncoder, sv.size);
    _array.from(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        _encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
        _encoding.writeVarUint(encoder.restEncoder, clock);
    });
    return encoder;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Doc} doc
 *
 * @function
 */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{
    if (doc instanceof Map) writeStateVector(encoder, doc);
    else writeDocumentStateVector(encoder, doc);
    return encoder.toUint8Array();
};
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());
/**
 * General event handler implementation.
 *
 * @template ARG0, ARG1
 *
 * @private
 */ class EventHandler {
    constructor(){
        /**
     * @type {Array<function(ARG0, ARG1):void>}
     */ this.l = [];
    }
}
/**
 * @template ARG0,ARG1
 * @returns {EventHandler<ARG0,ARG1>}
 *
 * @private
 * @function
 */ const createEventHandler = ()=>new EventHandler();
/**
 * Adds an event listener that is called when
 * {@link EventHandler#callEventListeners} is called.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler.
 *
 * @private
 * @function
 */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);
/**
 * Removes an event listener.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler that was added with
 *                     {@link EventHandler#addEventListener}
 *
 * @private
 * @function
 */ const removeEventHandlerListener = (eventHandler, f)=>{
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g)=>f !== g);
    if (len === eventHandler.l.length) console.error("[yjs] Tried to remove event handler that doesn't exist.");
};
/**
 * Call all event listeners that were added via
 * {@link EventHandler#addEventListener}.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {ARG0} arg0
 * @param {ARG1} arg1
 *
 * @private
 * @function
 */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>_function.callAll(eventHandler.l, [
        arg0,
        arg1
    ]);
class ID {
    /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */ constructor(client, clock){
        /**
     * Client id
     * @type {number}
     */ this.client = client;
        /**
     * unique per client id, continuous number
     * @type {number}
     */ this.clock = clock;
    }
}
/**
 * @param {ID | null} a
 * @param {ID | null} b
 * @return {boolean}
 *
 * @function
 */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
/**
 * @param {number} client
 * @param {number} clock
 *
 * @private
 * @function
 */ const createID = (client, clock)=>new ID(client, clock);
/**
 * @param {encoding.Encoder} encoder
 * @param {ID} id
 *
 * @private
 * @function
 */ const writeID = (encoder, id)=>{
    _encoding.writeVarUint(encoder, id.client);
    _encoding.writeVarUint(encoder, id.clock);
};
/**
 * Read ID.
 * * If first varUint read is 0xFFFFFF a RootID is returned.
 * * Otherwise an ID is returned
 *
 * @param {decoding.Decoder} decoder
 * @return {ID}
 *
 * @private
 * @function
 */ const readID = (decoder)=>createID(_decoding.readVarUint(decoder), _decoding.readVarUint(decoder));
/**
 * The top types are mapped from y.share.get(keyname) => type.
 * `type` does not store any information about the `keyname`.
 * This function finds the correct `keyname` for `type` and throws otherwise.
 *
 * @param {AbstractType<any>} type
 * @return {string}
 *
 * @private
 * @function
 */ const findRootTypeKey = (type)=>{
    // @ts-ignore _y must be defined, otherwise unexpected case
    for (const [key, value] of type.doc.share.entries()){
        if (value === type) return key;
    }
    throw _error.unexpectedCase();
};
/**
 * Check if `parent` is a parent of `child`.
 *
 * @param {AbstractType<any>} parent
 * @param {Item|null} child
 * @return {Boolean} Whether `parent` is a parent of `child`.
 *
 * @private
 * @function
 */ const isParentOf = (parent, child)=>{
    while(child !== null){
        if (child.parent === parent) return true;
        child = /** @type {AbstractType<any>} */ child.parent._item;
    }
    return false;
};
/**
 * Convenient helper to log type information.
 *
 * Do not use in productive systems as the output can be immense!
 *
 * @param {AbstractType<any>} type
 */ const logType = (type)=>{
    const res = [];
    let n = type._start;
    while(n){
        res.push(n);
        n = n.right;
    }
    console.log("Children: ", res);
    console.log("Children content: ", res.filter((m)=>!m.deleted).map((m)=>m.content));
};
class PermanentUserData {
    /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */ constructor(doc, storeType = doc.getMap("users")){
        /**
     * @type {Map<string,DeleteSet>}
     */ const dss = new Map();
        this.yusers = storeType;
        this.doc = doc;
        /**
     * Maps from clientid to userDescription
     *
     * @type {Map<number,string>}
     */ this.clients = new Map();
        this.dss = dss;
        /**
     * @param {YMap<any>} user
     * @param {string} userDescription
     */ const initUser = (user, userDescription)=>{
            /**
       * @type {YArray<Uint8Array>}
       */ const ds = user.get("ds");
            const ids = user.get("ids");
            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);
            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{
                event.changes.added.forEach((item)=>{
                    item.content.getContent().forEach((encodedDs)=>{
                        if (encodedDs instanceof Uint8Array) this.dss.set(userDescription, mergeDeleteSets([
                            this.dss.get(userDescription) || createDeleteSet(),
                            readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs)))
                        ]));
                    });
                });
            });
            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs))))));
            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));
            ids.forEach(addClientId);
        };
        // observe users
        storeType.observe((event)=>{
            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));
        });
        // add intial data
        storeType.forEach(initUser);
    }
    /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {
        const users = this.yusers;
        let user = users.get(userDescription);
        if (!user) {
            user = new YMap();
            user.set("ids", new YArray());
            user.set("ds", new YArray());
            users.set(userDescription, user);
        }
        user.get("ids").push([
            clientid
        ]);
        users.observe((_event)=>{
            setTimeout(()=>{
                const userOverwrite = users.get(userDescription);
                if (userOverwrite !== user) {
                    // user was overwritten, port all data over to the next user object
                    // @todo Experiment with Y.Sets here
                    user = userOverwrite;
                    // @todo iterate over old type
                    this.clients.forEach((_userDescription, clientid)=>{
                        if (userDescription === _userDescription) user.get("ids").push([
                            clientid
                        ]);
                    });
                    const encoder = new DSEncoderV1();
                    const ds = this.dss.get(userDescription);
                    if (ds) {
                        writeDeleteSet(encoder, ds);
                        user.get("ds").push([
                            encoder.toUint8Array()
                        ]);
                    }
                }
            }, 0);
        });
        doc.on("afterTransaction", /** @param {Transaction} transaction */ (transaction)=>{
            setTimeout(()=>{
                const yds = user.get("ds");
                const ds = transaction.deleteSet;
                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
                    const encoder = new DSEncoderV1();
                    writeDeleteSet(encoder, ds);
                    yds.push([
                        encoder.toUint8Array()
                    ]);
                }
            });
        });
    }
    /**
   * @param {number} clientid
   * @return {any}
   */ getUserByClientId(clientid) {
        return this.clients.get(clientid) || null;
    }
    /**
   * @param {ID} id
   * @return {string | null}
   */ getUserByDeletedId(id) {
        for (const [userDescription, ds] of this.dss.entries()){
            if (isDeleted(ds, id)) return userDescription;
        }
        return null;
    }
}
/**
 * A relative position is based on the Yjs model and is not affected by document changes.
 * E.g. If you place a relative position before a certain character, it will always point to this character.
 * If you place a relative position at the end of a type, it will always point to the end of the type.
 *
 * A numeric position is often unsuited for user selections, because it does not change when content is inserted
 * before or after.
 *
 * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
 *
 * One of the properties must be defined.
 *
 * @example
 *   // Current cursor position is at position 10
 *   const relativePosition = createRelativePositionFromIndex(yText, 10)
 *   // modify yText
 *   yText.insert(0, 'abc')
 *   yText.delete(3, 10)
 *   // Compute the cursor position
 *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
 *   absolutePosition.type === yText // => true
 *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
 *
 */ class RelativePosition {
    /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */ constructor(type, tname, item, assoc = 0){
        /**
     * @type {ID|null}
     */ this.type = type;
        /**
     * @type {string|null}
     */ this.tname = tname;
        /**
     * @type {ID | null}
     */ this.item = item;
        /**
     * A relative position is associated to a specific character. By default
     * assoc >= 0, the relative position is associated to the character
     * after the meant position.
     * I.e. position 1 in 'ab' is associated to character 'b'.
     *
     * If assoc < 0, then the relative position is associated to the caharacter
     * before the meant position.
     *
     * @type {number}
     */ this.assoc = assoc;
    }
}
/**
 * @param {RelativePosition} rpos
 * @return {any}
 */ const relativePositionToJSON = (rpos)=>{
    const json = {};
    if (rpos.type) json.type = rpos.type;
    if (rpos.tname) json.tname = rpos.tname;
    if (rpos.item) json.item = rpos.item;
    if (rpos.assoc != null) json.assoc = rpos.assoc;
    return json;
};
/**
 * @param {any} json
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
class AbsolutePosition {
    /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */ constructor(type, index, assoc = 0){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
        /**
     * @type {number}
     */ this.index = index;
        this.assoc = assoc;
    }
}
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @param {number} [assoc]
 *
 * @function
 */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);
/**
 * @param {AbstractType<any>} type
 * @param {ID|null} item
 * @param {number} [assoc]
 *
 * @function
 */ const createRelativePosition = (type, item, assoc)=>{
    let typeid = null;
    let tname = null;
    if (type._item === null) tname = findRootTypeKey(type);
    else typeid = createID(type._item.id.client, type._item.id.clock);
    return new RelativePosition(typeid, tname, item, assoc);
};
/**
 * Create a relativePosition based on a absolute position.
 *
 * @param {AbstractType<any>} type The base type (e.g. YText or YArray).
 * @param {number} index The absolute position.
 * @param {number} [assoc]
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{
    let t = type._start;
    if (assoc < 0) {
        // associated to the left character or the beginning of a type, increment index if possible.
        if (index === 0) return createRelativePosition(type, null, assoc);
        index--;
    }
    while(t !== null){
        if (!t.deleted && t.countable) {
            if (t.length > index) // case 1: found position somewhere in the linked list
            return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
            index -= t.length;
        }
        if (t.right === null && assoc < 0) // left-associated position, return last available id
        return createRelativePosition(type, t.lastId, assoc);
        t = t.right;
    }
    return createRelativePosition(type, null, assoc);
};
/**
 * @param {encoding.Encoder} encoder
 * @param {RelativePosition} rpos
 *
 * @function
 */ const writeRelativePosition = (encoder, rpos)=>{
    const { type, tname, item, assoc } = rpos;
    if (item !== null) {
        _encoding.writeVarUint(encoder, 0);
        writeID(encoder, item);
    } else if (tname !== null) {
        // case 2: found position at the end of the list and type is stored in y.share
        _encoding.writeUint8(encoder, 1);
        _encoding.writeVarString(encoder, tname);
    } else if (type !== null) {
        // case 3: found position at the end of the list and type is attached to an item
        _encoding.writeUint8(encoder, 2);
        writeID(encoder, type);
    } else throw _error.unexpectedCase();
    _encoding.writeVarInt(encoder, assoc);
    return encoder;
};
/**
 * @param {RelativePosition} rpos
 * @return {Uint8Array}
 */ const encodeRelativePosition = (rpos)=>{
    const encoder = _encoding.createEncoder();
    writeRelativePosition(encoder, rpos);
    return _encoding.toUint8Array(encoder);
};
/**
 * @param {decoding.Decoder} decoder
 * @return {RelativePosition}
 *
 * @function
 */ const readRelativePosition = (decoder)=>{
    let type = null;
    let tname = null;
    let itemID = null;
    switch(_decoding.readVarUint(decoder)){
        case 0:
            // case 1: found position somewhere in the linked list
            itemID = readID(decoder);
            break;
        case 1:
            // case 2: found position at the end of the list and type is stored in y.share
            tname = _decoding.readVarString(decoder);
            break;
        case 2:
            // case 3: found position at the end of the list and type is attached to an item
            type = readID(decoder);
    }
    const assoc = _decoding.hasContent(decoder) ? _decoding.readVarInt(decoder) : 0;
    return new RelativePosition(type, tname, itemID, assoc);
};
/**
 * @param {Uint8Array} uint8Array
 * @return {RelativePosition}
 */ const decodeRelativePosition = (uint8Array)=>readRelativePosition(_decoding.createDecoder(uint8Array));
/**
 * @param {RelativePosition} rpos
 * @param {Doc} doc
 * @return {AbsolutePosition|null}
 *
 * @function
 */ const createAbsolutePositionFromRelativePosition = (rpos, doc)=>{
    const store = doc.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index = 0;
    if (rightID !== null) {
        if (getState(store, rightID.client) <= rightID.clock) return null;
        const res = followRedone(store, rightID);
        const right = res.item;
        if (!(right instanceof Item)) return null;
        type = /** @type {AbstractType<any>} */ right.parent;
        if (type._item === null || !type._item.deleted) {
            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary
            let n = right.left;
            while(n !== null){
                if (!n.deleted && n.countable) index += n.length;
                n = n.left;
            }
        }
    } else {
        if (tname !== null) type = doc.get(tname);
        else if (typeID !== null) {
            if (getState(store, typeID.client) <= typeID.clock) // type does not exist yet
            return null;
            const { item } = followRedone(store, typeID);
            if (item instanceof Item && item.content instanceof ContentType) type = item.content.type;
            else // struct is garbage collected
            return null;
        } else throw _error.unexpectedCase();
        if (assoc >= 0) index = type._length;
        else index = 0;
    }
    return createAbsolutePosition(type, index, rpos.assoc);
};
/**
 * @param {RelativePosition|null} a
 * @param {RelativePosition|null} b
 * @return {boolean}
 *
 * @function
 */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
class Snapshot {
    /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */ constructor(ds, sv){
        /**
     * @type {DeleteSet}
     */ this.ds = ds;
        /**
     * State Map
     * @type {Map<number,number>}
     */ this.sv = sv;
    }
}
/**
 * @param {Snapshot} snap1
 * @param {Snapshot} snap2
 * @return {boolean}
 */ const equalSnapshots = (snap1, snap2)=>{
    const ds1 = snap1.ds.clients;
    const ds2 = snap2.ds.clients;
    const sv1 = snap1.sv;
    const sv2 = snap2.sv;
    if (sv1.size !== sv2.size || ds1.size !== ds2.size) return false;
    for (const [key, value] of sv1.entries()){
        if (sv2.get(key) !== value) return false;
    }
    for (const [client, dsitems1] of ds1.entries()){
        const dsitems2 = ds2.get(client) || [];
        if (dsitems1.length !== dsitems2.length) return false;
        for(let i = 0; i < dsitems1.length; i++){
            const dsitem1 = dsitems1[i];
            const dsitem2 = dsitems2[i];
            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) return false;
        }
    }
    return true;
};
/**
 * @param {Snapshot} snapshot
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{
    writeDeleteSet(encoder, snapshot.ds);
    writeStateVector(encoder, snapshot.sv);
    return encoder.toUint8Array();
};
/**
 * @param {Snapshot} snapshot
 * @return {Uint8Array}
 */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());
/**
 * @param {Uint8Array} buf
 * @param {DSDecoderV1 | DSDecoderV2} [decoder]
 * @return {Snapshot}
 */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(_decoding.createDecoder(buf)))=>{
    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
/**
 * @param {Uint8Array} buf
 * @return {Snapshot}
 */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1(_decoding.createDecoder(buf)));
/**
 * @param {DeleteSet} ds
 * @param {Map<number,number>} sm
 * @return {Snapshot}
 */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);
const emptySnapshot = createSnapshot(createDeleteSet(), new Map());
/**
 * @param {Doc} doc
 * @return {Snapshot}
 */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
/**
 * @param {Item} item
 * @param {Snapshot|undefined} snapshot
 *
 * @protected
 * @function
 */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
/**
 * @param {Transaction} transaction
 * @param {Snapshot} snapshot
 */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{
    const meta = _map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, _set.create);
    const store = transaction.doc.store;
    // check if we already split for this snapshot
    if (!meta.has(snapshot)) {
        snapshot.sv.forEach((clock, client)=>{
            if (clock < getState(store, client)) getItemCleanStart(transaction, createID(client, clock));
        });
        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});
        meta.add(snapshot);
    }
};
/**
 * @example
 *  const ydoc = new Y.Doc({ gc: false })
 *  ydoc.getText().insert(0, 'world!')
 *  const snapshot = Y.snapshot(ydoc)
 *  ydoc.getText().insert(0, 'hello ')
 *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
 *  assert(restored.getText().toString() === 'world!')
 *
 * @param {Doc} originDoc
 * @param {Snapshot} snapshot
 * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
 * @return {Doc}
 */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{
    if (originDoc.gc) // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
    throw new Error("Garbage-collection must be disabled in `originDoc`!");
    const { sv, ds } = snapshot;
    const encoder = new UpdateEncoderV2();
    originDoc.transact((transaction)=>{
        let size = 0;
        sv.forEach((clock)=>{
            if (clock > 0) size++;
        });
        _encoding.writeVarUint(encoder.restEncoder, size);
        // splitting the structs before writing them to the encoder
        for (const [client, clock] of sv){
            if (clock === 0) continue;
            if (clock < getState(originDoc.store, client)) getItemCleanStart(transaction, createID(client, clock));
            const structs = originDoc.store.clients.get(client) || [];
            const lastStructIndex = findIndexSS(structs, clock - 1);
            // write # encoded structs
            _encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);
            encoder.writeClient(client);
            // first clock written is 0
            _encoding.writeVarUint(encoder.restEncoder, 0);
            for(let i = 0; i <= lastStructIndex; i++)structs[i].write(encoder, 0);
        }
        writeDeleteSet(encoder, ds);
    });
    applyUpdateV2(newDoc, encoder.toUint8Array(), "snapshot");
    return newDoc;
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) return false;
    }
    const mergedDS = mergeDeleteSets([
        snapshot.ds,
        readDeleteSet(updateDecoder)
    ]);
    return equalDeleteSets(snapshot.ds, mergedDS);
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
class StructStore {
    constructor(){
        /**
     * @type {Map<number,Array<GC|Item>>}
     */ this.clients = new Map();
        /**
     * @type {null | { missing: Map<number, number>, update: Uint8Array }}
     */ this.pendingStructs = null;
        /**
     * @type {null | Uint8Array}
     */ this.pendingDs = null;
    }
}
/**
 * Return the states as a Map<client,clock>.
 * Note that clock refers to the next expected clock id.
 *
 * @param {StructStore} store
 * @return {Map<number,number>}
 *
 * @public
 * @function
 */ const getStateVector = (store)=>{
    const sm = new Map();
    store.clients.forEach((structs, client)=>{
        const struct = structs[structs.length - 1];
        sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
};
/**
 * @param {StructStore} store
 * @param {number} client
 * @return {number}
 *
 * @public
 * @function
 */ const getState = (store, client)=>{
    const structs = store.clients.get(client);
    if (structs === undefined) return 0;
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
};
/**
 * @param {StructStore} store
 * @param {GC|Item} struct
 *
 * @private
 * @function
 */ const addStruct = (store, struct)=>{
    let structs = store.clients.get(struct.id.client);
    if (structs === undefined) {
        structs = [];
        store.clients.set(struct.id.client, structs);
    } else {
        const lastStruct = structs[structs.length - 1];
        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) throw _error.unexpectedCase();
    }
    structs.push(struct);
};
/**
 * Perform a binary search on a sorted array
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 * @return {number}
 *
 * @private
 * @function
 */ const findIndexSS = (structs, clock)=>{
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) return right;
    // @todo does it even make sense to pivot the search?
    // If a good split misses, it might actually increase the time to find the correct item.
    // Currently, the only advantage is that search with pivoting might find the item on the first try.
    let midindex = _math.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search
    while(left <= right){
        mid = structs[midindex];
        midclock = mid.id.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.length) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
        midindex = _math.floor((left + right) / 2);
    }
    // Always check state before looking for a struct in StructStore
    // Therefore the case of not finding a struct is unexpected
    throw _error.unexpectedCase();
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {GC|Item}
 *
 * @private
 * @function
 */ const find = (store, id)=>{
    /**
   * @type {Array<GC|Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    return structs[findIndexSS(structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 * @private
 * @function
 */ const getItem = /** @type {function(StructStore,ID):Item} */ find;
/**
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 */ const findIndexCleanStart = (transaction, structs, clock)=>{
    const index = findIndexSS(structs, clock);
    const struct = structs[index];
    if (struct.id.clock < clock && struct instanceof Item) {
        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
        return index + 1;
    }
    return index;
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanStart = (transaction, id)=>{
    const structs = /** @type {Array<Item>} */ transaction.doc.store.clients.get(id.client);
    return structs[findIndexCleanStart(transaction, structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanEnd = (transaction, store, id)=>{
    /**
   * @type {Array<Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    const index = findIndexSS(structs, id.clock);
    const struct = structs[index];
    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
    return struct;
};
/**
 * Replace `item` with `newitem` in store
 * @param {StructStore} store
 * @param {GC|Item} struct
 * @param {GC|Item} newStruct
 *
 * @private
 * @function
 */ const replaceStruct = (store, struct, newStruct)=>{
    const structs = /** @type {Array<GC|Item>} */ store.clients.get(struct.id.client);
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
/**
 * Iterate over a range of structs
 *
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clockStart Inclusive start
 * @param {number} len
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{
    if (len === 0) return;
    const clockEnd = clockStart + len;
    let index = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
        struct = structs[index++];
        if (clockEnd < struct.id.clock + struct.length) findIndexCleanStart(transaction, structs, clockEnd);
        f(struct);
    }while (index < structs.length && structs[index].id.clock < clockEnd);
};
/**
 * A transaction is created for every change on the Yjs model. It is possible
 * to bundle changes on the Yjs model in a single transaction to
 * minimize the number on messages sent and the number of observer calls.
 * If possible the user of this library should bundle as many changes as
 * possible. Here is an example to illustrate the advantages of bundling:
 *
 * @example
 * const map = y.define('map', YMap)
 * // Log content when change is triggered
 * map.observe(() => {
 *   console.log('change triggered')
 * })
 * // Each change on the map type triggers a log message:
 * map.set('a', 0) // => "change triggered"
 * map.set('b', 0) // => "change triggered"
 * // When put in a transaction, it will trigger the log after the transaction:
 * y.transact(() => {
 *   map.set('a', 1)
 *   map.set('b', 1)
 * }) // => "change triggered"
 *
 * @public
 */ class Transaction {
    /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */ constructor(doc, origin, local){
        /**
     * The Yjs instance.
     * @type {Doc}
     */ this.doc = doc;
        /**
     * Describes the set of deleted items by ids
     * @type {DeleteSet}
     */ this.deleteSet = new DeleteSet();
        /**
     * Holds the state before the transaction started.
     * @type {Map<Number,Number>}
     */ this.beforeState = getStateVector(doc.store);
        /**
     * Holds the state after the transaction.
     * @type {Map<Number,Number>}
     */ this.afterState = new Map();
        /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
     */ this.changed = new Map();
        /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
     */ this.changedParentTypes = new Map();
        /**
     * @type {Array<AbstractStruct>}
     */ this._mergeStructs = [];
        /**
     * @type {any}
     */ this.origin = origin;
        /**
     * Stores meta information on the transaction
     * @type {Map<any,any>}
     */ this.meta = new Map();
        /**
     * Whether this change originates from this doc.
     * @type {boolean}
     */ this.local = local;
        /**
     * @type {Set<Doc>}
     */ this.subdocsAdded = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsRemoved = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsLoaded = new Set();
        /**
     * @type {boolean}
     */ this._needFormattingCleanup = false;
    }
}
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 * @return {boolean} Whether data was written.
 */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{
    if (transaction.deleteSet.clients.size === 0 && !_map.any(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) return false;
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
};
/**
 * If `type.parent` was added in current transaction, `type` technically
 * did not change, it was just added and we should not fire events for `type`.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<YEvent<any>>} type
 * @param {string|null} parentSub
 */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) _map.setIfUndefined(transaction.changed, type, _set.create).add(parentSub);
};
/**
 * @param {Array<AbstractStruct>} structs
 * @param {number} pos
 * @return {number} # of merged structs
 */ const tryToMergeWithLefts = (structs, pos)=>{
    let right = structs[pos];
    let left = structs[pos - 1];
    let i = pos;
    for(; i > 0; right = left, left = structs[--i - 1]){
        if (left.deleted === right.deleted && left.constructor === right.constructor) {
            if (left.mergeWith(right)) {
                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, /** @type {Item} */ left);
                continue;
            }
        }
        break;
    }
    const merged = pos - i;
    if (merged) // remove all merged structs from the array
    structs.splice(pos + 1 - merged, merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGcDeleteSet = (ds, store, gcFilter)=>{
    for (const [client, deleteItems] of ds.clients.entries()){
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            const endDeleteItemClock = deleteItem.clock + deleteItem.len;
            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){
                const struct = structs[si];
                if (deleteItem.clock + deleteItem.len <= struct.id.clock) break;
                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) struct.gc(store, false);
            }
        }
    }
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 */ const tryMergeDeleteSet = (ds, store)=>{
    // try to merge deleted / gc'd items
    // merge from right to left for better efficiecy and so we don't miss any merge targets
    ds.clients.forEach((deleteItems, client)=>{
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            // start with merging the item next to the last deleted item
            const mostRightIndexToCheck = _math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si])si -= 1 + tryToMergeWithLefts(structs, si);
        }
    });
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGc = (ds, store, gcFilter)=>{
    tryGcDeleteSet(ds, store, gcFilter);
    tryMergeDeleteSet(ds, store);
};
/**
 * @param {Array<Transaction>} transactionCleanups
 * @param {number} i
 */ const cleanupTransactions = (transactionCleanups, i)=>{
    if (i < transactionCleanups.length) {
        const transaction = transactionCleanups[i];
        const doc = transaction.doc;
        const store = doc.store;
        const ds = transaction.deleteSet;
        const mergeStructs = transaction._mergeStructs;
        try {
            sortAndMergeDeleteSet(ds);
            transaction.afterState = getStateVector(transaction.doc.store);
            doc.emit("beforeObserverCalls", [
                transaction,
                doc
            ]);
            /**
       * An array of event callbacks.
       *
       * Each callback is called even if the other ones throw errors.
       *
       * @type {Array<function():void>}
       */ const fs = [];
            // observe events on changed types
            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{
                    if (itemtype._item === null || !itemtype._item.deleted) itemtype._callObserver(transaction, subs);
                }));
            fs.push(()=>{
                // deep observe events
                transaction.changedParentTypes.forEach((events, type)=>{
                    // We need to think about the possibility that the user transforms the
                    // Y.Doc in the event.
                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);
                        events.forEach((event)=>{
                            event.currentTarget = type;
                            // path is relative to the current target
                            event._path = null;
                        });
                        // sort events by path length so that top-level events are fired first.
                        events.sort((event1, event2)=>event1.path.length - event2.path.length);
                        // We don't need to check for events.length
                        // because we know it has at least one element
                        callEventHandlerListeners(type._dEH, events, transaction);
                    }
                });
            });
            fs.push(()=>doc.emit("afterTransaction", [
                    transaction,
                    doc
                ]));
            (0, _function.callAll)(fs, []);
            if (transaction._needFormattingCleanup) cleanupYTextAfterTransaction(transaction);
        } finally{
            // Replace deleted items with ItemDeleted / GC.
            // This is where content is actually remove from the Yjs Doc.
            if (doc.gc) tryGcDeleteSet(ds, store, doc.gcFilter);
            tryMergeDeleteSet(ds, store);
            // on all affected store.clients props, try to merge
            transaction.afterState.forEach((clock, client)=>{
                const beforeClock = transaction.beforeState.get(client) || 0;
                if (beforeClock !== clock) {
                    const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                    // we iterate from right to left so we can safely remove entries
                    const firstChangePos = _math.max(findIndexSS(structs, beforeClock), 1);
                    for(let i = structs.length - 1; i >= firstChangePos;)i -= 1 + tryToMergeWithLefts(structs, i);
                }
            });
            // try to merge mergeStructs
            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
            //        but at the moment DS does not handle duplicates
            for(let i = mergeStructs.length - 1; i >= 0; i--){
                const { client, clock } = mergeStructs[i].id;
                const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                const replacedStructPos = findIndexSS(structs, clock);
                if (replacedStructPos + 1 < structs.length) {
                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) continue; // no need to perform next check, both are already merged
                }
                if (replacedStructPos > 0) tryToMergeWithLefts(structs, replacedStructPos);
            }
            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {
                _logging.print(_logging.ORANGE, _logging.BOLD, "[yjs] ", _logging.UNBOLD, _logging.RED, "Changed the client-id because another client seems to be using it.");
                doc.clientID = generateNewClientId();
            }
            // @todo Merge all the transactions into one and provide send the data as a single update message
            doc.emit("afterTransactionCleanup", [
                transaction,
                doc
            ]);
            if (doc._observers.has("update")) {
                const encoder = new UpdateEncoderV1();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit("update", [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            if (doc._observers.has("updateV2")) {
                const encoder = new UpdateEncoderV2();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit("updateV2", [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
                subdocsAdded.forEach((subdoc)=>{
                    subdoc.clientID = doc.clientID;
                    if (subdoc.collectionid == null) subdoc.collectionid = doc.collectionid;
                    doc.subdocs.add(subdoc);
                });
                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));
                doc.emit("subdocs", [
                    {
                        loaded: subdocsLoaded,
                        added: subdocsAdded,
                        removed: subdocsRemoved
                    },
                    doc,
                    transaction
                ]);
                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());
            }
            if (transactionCleanups.length <= i + 1) {
                doc._transactionCleanups = [];
                doc.emit("afterAllTransactions", [
                    doc,
                    transactionCleanups
                ]);
            } else cleanupTransactions(transactionCleanups, i + 1);
        }
    }
};
/**
 * Implements the functionality of `y.transact(()=>{..})`
 *
 * @template T
 * @param {Doc} doc
 * @param {function(Transaction):T} f
 * @param {any} [origin=true]
 * @return {T}
 *
 * @function
 */ const transact = (doc, f, origin = null, local = true)=>{
    const transactionCleanups = doc._transactionCleanups;
    let initialCall = false;
    /**
   * @type {any}
   */ let result = null;
    if (doc._transaction === null) {
        initialCall = true;
        doc._transaction = new Transaction(doc, origin, local);
        transactionCleanups.push(doc._transaction);
        if (transactionCleanups.length === 1) doc.emit("beforeAllTransactions", [
            doc
        ]);
        doc.emit("beforeTransaction", [
            doc._transaction,
            doc
        ]);
    }
    try {
        result = f(doc._transaction);
    } finally{
        if (initialCall) {
            const finishCleanup = doc._transaction === transactionCleanups[0];
            doc._transaction = null;
            if (finishCleanup) // The first transaction ended, now process observer calls.
            // Observer call may create new transactions for which we need to call the observers and do cleanup.
            // We don't want to nest these calls, so we execute these calls one after
            // another.
            // Also we need to ensure that all cleanups are called, even if the
            // observes throw errors.
            // This file is full of hacky try {} finally {} blocks to ensure that an
            // event can throw errors and also that the cleanup is called.
            cleanupTransactions(transactionCleanups, 0);
        }
    }
    return result;
};
class StackItem {
    /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */ constructor(deletions, insertions){
        this.insertions = insertions;
        this.deletions = deletions;
        /**
     * Use this to save and restore metadata like selection range
     */ this.meta = new Map();
    }
}
/**
 * @param {Transaction} tr
 * @param {UndoManager} um
 * @param {StackItem} stackItem
 */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{
    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{
        if (item instanceof Item && um.scope.some((type)=>isParentOf(type, item))) keepItem(item, false);
    });
};
/**
 * @param {UndoManager} undoManager
 * @param {Array<StackItem>} stack
 * @param {string} eventType
 * @return {StackItem?}
 */ const popStackItem = (undoManager, stack, eventType)=>{
    /**
   * Whether a change happened
   * @type {StackItem?}
   */ let result = null;
    /**
   * Keep a reference to the transaction so we can fire the event with the changedParentTypes
   * @type {any}
   */ let _tr = null;
    const doc = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc, (transaction)=>{
        while(stack.length > 0 && result === null){
            const store = doc.store;
            const stackItem = /** @type {StackItem} */ stack.pop();
            /**
       * @type {Set<Item>}
       */ const itemsToRedo = new Set();
            /**
       * @type {Array<Item>}
       */ const itemsToDelete = [];
            let performedChange = false;
            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{
                if (struct instanceof Item) {
                    if (struct.redone !== null) {
                        let { item, diff } = followRedone(store, struct.id);
                        if (diff > 0) item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
                        struct = item;
                    }
                    if (!struct.deleted && scope.some((type)=>isParentOf(type, /** @type {Item} */ struct))) itemsToDelete.push(struct);
                }
            });
            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{
                if (struct instanceof Item && scope.some((type)=>isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
                !isDeleted(stackItem.insertions, struct.id)) itemsToRedo.add(struct);
            });
            itemsToRedo.forEach((struct)=>{
                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
            });
            // We want to delete in reverse order so that children are deleted before
            // parents, so we have more information available when items are filtered.
            for(let i = itemsToDelete.length - 1; i >= 0; i--){
                const item = itemsToDelete[i];
                if (undoManager.deleteFilter(item)) {
                    item.delete(transaction);
                    performedChange = true;
                }
            }
            result = performedChange ? stackItem : null;
        }
        transaction.changed.forEach((subProps, type)=>{
            // destroy search marker if necessary
            if (subProps.has(null) && type._searchMarker) type._searchMarker.length = 0;
        });
        _tr = transaction;
    }, undoManager);
    if (result != null) {
        const changedParentTypes = _tr.changedParentTypes;
        undoManager.emit("stack-item-popped", [
            {
                stackItem: result,
                type: eventType,
                changedParentTypes
            },
            undoManager
        ]);
    }
    return result;
};
/**
 * @typedef {Object} UndoManagerOptions
 * @property {number} [UndoManagerOptions.captureTimeout=500]
 * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
 * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
 * it is necessary to filter what an Undo/Redo operation can delete. If this
 * filter returns false, the type/item won't be deleted even it is in the
 * undo/redo scope.
 * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
 * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
 * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
 */ /**
 * Fires 'stack-item-added' event when a stack item was added to either the undo- or
 * the redo-stack. You may store additional stack information via the
 * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
 * Fires 'stack-item-popped' event when a stack item was popped from either the
 * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
 *
 * @extends {Observable<'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'>}
 */ class UndoManager extends (0, _observable.Observable) {
    /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([
        null
    ]), ignoreRemoteMapChanges = false, doc = /** @type {Doc} */ _array.isArray(typeScope) ? typeScope[0].doc : typeScope.doc } = {}){
        super();
        /**
     * @type {Array<AbstractType<any>>}
     */ this.scope = [];
        this.doc = doc;
        this.addToScope(typeScope);
        this.deleteFilter = deleteFilter;
        trackedOrigins.add(this);
        this.trackedOrigins = trackedOrigins;
        this.captureTransaction = captureTransaction;
        /**
     * @type {Array<StackItem>}
     */ this.undoStack = [];
        /**
     * @type {Array<StackItem>}
     */ this.redoStack = [];
        /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     *
     * @type {boolean}
     */ this.undoing = false;
        this.redoing = false;
        this.lastChange = 0;
        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
        this.captureTimeout = captureTimeout;
        /**
     * @param {Transaction} transaction
     */ this.afterTransactionHandler = (transaction)=>{
            // Only track certain transactions
            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) return;
            const undoing = this.undoing;
            const redoing = this.redoing;
            const stack = undoing ? this.redoStack : this.undoStack;
            if (undoing) this.stopCapturing(); // next undo should not be appended to last stack item
            else if (!redoing) // neither undoing nor redoing: delete redoStack
            this.clear(false, true);
            const insertions = new DeleteSet();
            transaction.afterState.forEach((endClock, client)=>{
                const startClock = transaction.beforeState.get(client) || 0;
                const len = endClock - startClock;
                if (len > 0) addToDeleteSet(insertions, client, startClock, len);
            });
            const now = _time.getUnixTime();
            let didAdd = false;
            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
                // append change to last stack op
                const lastOp = stack[stack.length - 1];
                lastOp.deletions = mergeDeleteSets([
                    lastOp.deletions,
                    transaction.deleteSet
                ]);
                lastOp.insertions = mergeDeleteSets([
                    lastOp.insertions,
                    insertions
                ]);
            } else {
                // create a new stack op
                stack.push(new StackItem(transaction.deleteSet, insertions));
                didAdd = true;
            }
            if (!undoing && !redoing) this.lastChange = now;
            // make sure that deleted structs are not gc'd
            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{
                if (item instanceof Item && this.scope.some((type)=>isParentOf(type, item))) keepItem(item, true);
            });
            const changeEvent = [
                {
                    stackItem: stack[stack.length - 1],
                    origin: transaction.origin,
                    type: undoing ? "redo" : "undo",
                    changedParentTypes: transaction.changedParentTypes
                },
                this
            ];
            if (didAdd) this.emit("stack-item-added", changeEvent);
            else this.emit("stack-item-updated", changeEvent);
        };
        this.doc.on("afterTransaction", this.afterTransactionHandler);
        this.doc.on("destroy", ()=>{
            this.destroy();
        });
    }
    /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */ addToScope(ytypes) {
        ytypes = _array.isArray(ytypes) ? ytypes : [
            ytypes
        ];
        ytypes.forEach((ytype)=>{
            if (this.scope.every((yt)=>yt !== ytype)) {
                if (ytype.doc !== this.doc) _logging.warn("[yjs#509] Not same Y.Doc"); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
                this.scope.push(ytype);
            }
        });
    }
    /**
   * @param {any} origin
   */ addTrackedOrigin(origin) {
        this.trackedOrigins.add(origin);
    }
    /**
   * @param {any} origin
   */ removeTrackedOrigin(origin) {
        this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) this.doc.transact((tr)=>{
            if (clearUndoStack) {
                this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.undoStack = [];
            }
            if (clearRedoStack) {
                this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.redoStack = [];
            }
            this.emit("stack-cleared", [
                {
                    undoStackCleared: clearUndoStack,
                    redoStackCleared: clearRedoStack
                }
            ]);
        });
    }
    /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */ stopCapturing() {
        this.lastChange = 0;
    }
    /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ undo() {
        this.undoing = true;
        let res;
        try {
            res = popStackItem(this, this.undoStack, "undo");
        } finally{
            this.undoing = false;
        }
        return res;
    }
    /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ redo() {
        this.redoing = true;
        let res;
        try {
            res = popStackItem(this, this.redoStack, "redo");
        } finally{
            this.redoing = false;
        }
        return res;
    }
    /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */ canUndo() {
        return this.undoStack.length > 0;
    }
    /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */ canRedo() {
        return this.redoStack.length > 0;
    }
    destroy() {
        this.trackedOrigins.delete(this);
        this.doc.off("afterTransaction", this.afterTransactionHandler);
        super.destroy();
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 */ function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            // @todo use switch instead of ifs
            if (info === 10) {
                const len = _decoding.readVarUint(decoder.restDecoder);
                yield new Skip(createID(client, clock), len);
                clock += len;
            } else if ((_binary.BITS5 & info) !== 0) {
                const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                // and we read the next string as parentYKey.
                // It indicates how we store/retrieve parent from `y.share`
                // @type {string|null}
                const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.
                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                );
                yield struct;
                clock += struct.length;
            } else {
                const len = decoder.readLen();
                yield new GC(createID(client, clock), len);
                clock += len;
            }
        }
    }
}
class LazyStructReader {
    /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */ constructor(decoder, filterSkips){
        this.gen = lazyStructReaderGenerator(decoder);
        /**
     * @type {null | Item | Skip | GC}
     */ this.curr = null;
        this.done = false;
        this.filterSkips = filterSkips;
        this.next();
    }
    /**
   * @return {Item | GC | Skip |null}
   */ next() {
        // ignore "Skip" structs
        do this.curr = this.gen.next().value || null;
        while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
        return this.curr;
    }
}
/**
 * @param {Uint8Array} update
 *
 */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    _logging.print("Structs: ", structs);
    const ds = readDeleteSet(updateDecoder);
    _logging.print("DeleteSet: ", ds);
};
/**
 * @param {Uint8Array} update
 *
 */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    return {
        structs,
        ds: readDeleteSet(updateDecoder)
    };
};
class LazyStructWriter {
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ constructor(encoder){
        this.currClient = 0;
        this.startClock = 0;
        this.written = 0;
        this.encoder = encoder;
        /**
     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
     *
     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
     *
     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
     *
     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
     */ this.clientStructs = [];
    }
}
/**
 * @param {Array<Uint8Array>} updates
 * @return {Uint8Array}
 */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{
    const encoder = new YEncoder();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let size = 0;
        let currClient = curr.id.client;
        let stopCounting = curr.id.clock !== 0; // must start at 0
        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                if (currClock !== 0) {
                    size++;
                    // We found a new client
                    // write what we have to the encoder
                    _encoding.writeVarUint(encoder.restEncoder, currClient);
                    _encoding.writeVarUint(encoder.restEncoder, currClock);
                }
                currClient = curr.id.client;
                currClock = 0;
                stopCounting = curr.id.clock !== 0;
            }
            // we ignore skips
            if (curr.constructor === Skip) stopCounting = true;
            if (!stopCounting) currClock = curr.id.clock + curr.length;
        }
        // write what we have
        if (currClock !== 0) {
            size++;
            _encoding.writeVarUint(encoder.restEncoder, currClient);
            _encoding.writeVarUint(encoder.restEncoder, currClock);
        }
        // prepend the size of the state vector
        const enc = _encoding.createEncoder();
        _encoding.writeVarUint(enc, size);
        _encoding.writeBinaryEncoder(enc, encoder.restEncoder);
        encoder.restEncoder = enc;
        return encoder.toUint8Array();
    } else {
        _encoding.writeVarUint(encoder.restEncoder, 0);
        return encoder.toUint8Array();
    }
};
/**
 * @param {Uint8Array} update
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{
    /**
   * @type {Map<number, number>}
   */ const from = new Map();
    /**
   * @type {Map<number, number>}
   */ const to = new Map();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let currClient = curr.id.client;
        let currClock = curr.id.clock;
        // write the beginning to `from`
        from.set(currClient, currClock);
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                // We found a new client
                // write the end to `to`
                to.set(currClient, currClock);
                // write the beginning to `from`
                from.set(curr.id.client, curr.id.clock);
                // update currClient
                currClient = curr.id.client;
            }
            currClock = curr.id.clock + curr.length;
        }
        // write the end to `to`
        to.set(currClient, currClock);
    }
    return {
        from,
        to
    };
};
/**
 * @param {Uint8Array} update
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);
/**
 * This method is intended to slice any kind of struct and retrieve the right part.
 * It does not handle side-effects, so it should only be used by the lazy-encoder.
 *
 * @param {Item | GC | Skip} left
 * @param {number} diff
 * @return {Item | GC}
 */ const sliceStruct = (left, diff)=>{
    if (left.constructor === GC) {
        const { client, clock } = left.id;
        return new GC(createID(client, clock + diff), left.length - diff);
    } else if (left.constructor === Skip) {
        const { client, clock } = left.id;
        return new Skip(createID(client, clock + diff), left.length - diff);
    } else {
        const leftItem = /** @type {Item} */ left;
        const { client, clock } = leftItem.id;
        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    }
};
/**
 *
 * This function works similarly to `readUpdateV2`.
 *
 * @param {Array<Uint8Array>} updates
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 * @return {Uint8Array}
 */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    if (updates.length === 1) return updates[0];
    const updateDecoders = updates.map((update)=>new YDecoder(_decoding.createDecoder(update)));
    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));
    /**
   * @todo we don't need offset because we always slice before
   * @type {null | { struct: Item | GC | Skip, offset: number }}
   */ let currWrite = null;
    const updateEncoder = new YEncoder();
    // write structs lazily
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    // Note: We need to ensure that all lazyStructDecoders are fully consumed
    // Note: Should merge document updates whenever possible - even from different updates
    // Note: Should handle that some operations cannot be applied yet ()
    while(true){
        // Write higher clients first ‚áí sort by clientID & clock and remove decoders without content
        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);
        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{
            if (dec1.curr.id.client === dec2.curr.id.client) {
                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
                if (clockDiff === 0) // @todo remove references to skip since the structDecoders must filter Skips.
                return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.
                ;
                else return clockDiff;
            } else return dec2.curr.id.client - dec1.curr.id.client;
        });
        if (lazyStructDecoders.length === 0) break;
        const currDecoder = lazyStructDecoders[0];
        // write from currDecoder until the next operation is from another client or if filler-struct
        // then we need to reorder the decoders and find the next operation to write
        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;
        if (currWrite !== null) {
            let curr = /** @type {Item | GC | null} */ currDecoder.curr;
            let iterated = false;
            // iterate until we find something that we haven't written already
            // remember: first the high client-ids are written
            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){
                curr = currDecoder.next();
                iterated = true;
            }
            if (curr === null || // current decoder is empty
            curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates
            ) continue;
            if (firstClient !== currWrite.struct.id.client) {
                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                currWrite = {
                    struct: curr,
                    offset: 0
                };
                currDecoder.next();
            } else if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
                // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
                if (currWrite.struct.constructor === Skip) // extend existing skip
                currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
                else {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
                    /**
             * @type {Skip}
             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
                    currWrite = {
                        struct,
                        offset: 0
                    };
                }
            } else {
                const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
                if (diff > 0) {
                    if (currWrite.struct.constructor === Skip) // prefer to slice Skip because the other struct might contain more information
                    currWrite.struct.length -= diff;
                    else curr = sliceStruct(curr, diff);
                }
                if (!currWrite.struct.mergeWith(/** @type {any} */ curr)) {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    currWrite = {
                        struct: curr,
                        offset: 0
                    };
                    currDecoder.next();
                }
            }
        } else {
            currWrite = {
                struct: /** @type {Item | GC} */ currDecoder.curr,
                offset: 0
            };
            currDecoder.next();
        }
        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = {
                struct: next,
                offset: 0
            };
        }
    }
    if (currWrite !== null) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));
    const ds = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder(_decoding.createDecoder(update));
    const reader = new LazyStructReader(decoder, false);
    while(reader.curr){
        const curr = reader.curr;
        const currClient = curr.id.client;
        const svClock = state.get(currClient) || 0;
        if (reader.curr.constructor === Skip) {
            // the first written struct shouldn't be a skip
            reader.next();
            continue;
        }
        if (curr.id.clock + curr.length > svClock) {
            writeStructToLazyStructWriter(lazyStructWriter, curr, _math.max(svClock - curr.id.clock, 0));
            reader.next();
            while(reader.curr && reader.curr.id.client === currClient){
                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
                reader.next();
            }
        } else // read until something new comes up
        while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock)reader.next();
    }
    finishLazyStructWriting(lazyStructWriter);
    // write ds
    const ds = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds);
    return encoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {LazyStructWriter} lazyWriter
 */ const flushLazyStructWriter = (lazyWriter)=>{
    if (lazyWriter.written > 0) {
        lazyWriter.clientStructs.push({
            written: lazyWriter.written,
            restEncoder: _encoding.toUint8Array(lazyWriter.encoder.restEncoder)
        });
        lazyWriter.encoder.restEncoder = _encoding.createEncoder();
        lazyWriter.written = 0;
    }
};
/**
 * @param {LazyStructWriter} lazyWriter
 * @param {Item | GC} struct
 * @param {number} offset
 */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{
    // flush curr if we start another client
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) flushLazyStructWriter(lazyWriter);
    if (lazyWriter.written === 0) {
        lazyWriter.currClient = struct.id.client;
        // write next client
        lazyWriter.encoder.writeClient(struct.id.client);
        // write startClock
        _encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
};
/**
 * Call this function when we collected all parts and want to
 * put all the parts together. After calling this method,
 * you can continue using the UpdateEncoder.
 *
 * @param {LazyStructWriter} lazyWriter
 */ const finishLazyStructWriting = (lazyWriter)=>{
    flushLazyStructWriter(lazyWriter);
    // this is a fresh encoder because we called flushCurr
    const restEncoder = lazyWriter.encoder.restEncoder;
    /**
   * Now we put all the fragments together.
   * This works similarly to `writeClientsStructs`
   */ // write # states that were updated - i.e. the clients
    _encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);
    for(let i = 0; i < lazyWriter.clientStructs.length; i++){
        const partStructs = lazyWriter.clientStructs[i];
        /**
     * Works similarly to `writeStructs`
     */ // write # encoded structs
        _encoding.writeVarUint(restEncoder, partStructs.written);
        // write the rest of the fragment
        _encoding.writeUint8Array(restEncoder, partStructs.restEncoder);
    }
};
/**
 * @param {Uint8Array} update
 * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
 * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
 */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
    finishLazyStructWriting(lazyWriter);
    const ds = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @typedef {Object} ObfuscatorOptions
 * @property {boolean} [ObfuscatorOptions.formatting=true]
 * @property {boolean} [ObfuscatorOptions.subdocs=true]
 * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
 */ /**
 * @param {ObfuscatorOptions} obfuscator
 */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{
    let i = 0;
    const mapKeyCache = _map.create();
    const nodeNameCache = _map.create();
    const formattingKeyCache = _map.create();
    const formattingValueCache = _map.create();
    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
    /**
   * @param {Item|GC|Skip} block
   * @return {Item|GC|Skip}
   */ return (block)=>{
        switch(block.constructor){
            case GC:
            case Skip:
                return block;
            case Item:
                {
                    const item = /** @type {Item} */ block;
                    const content = item.content;
                    switch(content.constructor){
                        case ContentDeleted:
                            break;
                        case ContentType:
                            if (yxml) {
                                const type = /** @type {ContentType} */ content.type;
                                if (type instanceof YXmlElement) type.nodeName = _map.setIfUndefined(nodeNameCache, type.nodeName, ()=>"node-" + i);
                                if (type instanceof YXmlHook) type.hookName = _map.setIfUndefined(nodeNameCache, type.hookName, ()=>"hook-" + i);
                            }
                            break;
                        case ContentAny:
                            {
                                const c = /** @type {ContentAny} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentBinary:
                            {
                                const c = /** @type {ContentBinary} */ content;
                                c.content = new Uint8Array([
                                    i
                                ]);
                                break;
                            }
                        case ContentDoc:
                            {
                                const c = /** @type {ContentDoc} */ content;
                                if (subdocs) {
                                    c.opts = {};
                                    c.doc.guid = i + "";
                                }
                                break;
                            }
                        case ContentEmbed:
                            {
                                const c = /** @type {ContentEmbed} */ content;
                                c.embed = {};
                                break;
                            }
                        case ContentFormat:
                            {
                                const c = /** @type {ContentFormat} */ content;
                                if (formatting) {
                                    c.key = _map.setIfUndefined(formattingKeyCache, c.key, ()=>i + "");
                                    c.value = _map.setIfUndefined(formattingValueCache, c.value, ()=>({
                                            i
                                        }));
                                }
                                break;
                            }
                        case ContentJSON:
                            {
                                const c = /** @type {ContentJSON} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentString:
                            {
                                const c = /** @type {ContentString} */ content;
                                c.str = _string.repeat(i % 10 + "", c.str.length);
                                break;
                            }
                        default:
                            // unknown content type
                            _error.unexpectedCase();
                    }
                    if (item.parentSub) item.parentSub = _map.setIfUndefined(mapKeyCache, item.parentSub, ()=>i + "");
                    i++;
                    return block;
                }
            default:
                // unknown block-type
                _error.unexpectedCase();
        }
    };
};
/**
 * This function obfuscates the content of a Yjs update. This is useful to share
 * buggy Yjs documents while significantly limiting the possibility that a
 * developer can on the user. Note that it might still be possible to deduce
 * some information by analyzing the "structure" of the document or by analyzing
 * the typing behavior using the CRDT-related metadata that is still kept fully
 * intact.
 *
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV1, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV2, UpdateEncoderV1);
const errorComputeChanges = "You must not compute changes after the event-handler fired.";
/**
 * @template {AbstractType<any>} T
 * YEvent describes the changes on a YType.
 */ class YEvent {
    /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */ constructor(target, transaction){
        /**
     * The type on which this event was created on.
     * @type {T}
     */ this.target = target;
        /**
     * The current target on which the observe callback is called.
     * @type {AbstractType<any>}
     */ this.currentTarget = target;
        /**
     * The transaction that triggered this event.
     * @type {Transaction}
     */ this.transaction = transaction;
        /**
     * @type {Object|null}
     */ this._changes = null;
        /**
     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */ this._keys = null;
        /**
     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}
     */ this._delta = null;
        /**
     * @type {Array<string|number>|null}
     */ this._path = null;
    }
    /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */ get path() {
        return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ deletes(struct) {
        return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */ get keys() {
        if (this._keys === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const keys = new Map();
            const target = this.target;
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            changed.forEach((key)=>{
                if (key !== null) {
                    const item = /** @type {Item} */ target._map.get(key);
                    /**
           * @type {'delete' | 'add' | 'update'}
           */ let action;
                    let oldValue;
                    if (this.adds(item)) {
                        let prev = item.left;
                        while(prev !== null && this.adds(prev))prev = prev.left;
                        if (this.deletes(item)) {
                            if (prev !== null && this.deletes(prev)) {
                                action = "delete";
                                oldValue = _array.last(prev.content.getContent());
                            } else return;
                        } else if (prev !== null && this.deletes(prev)) {
                            action = "update";
                            oldValue = _array.last(prev.content.getContent());
                        } else {
                            action = "add";
                            oldValue = undefined;
                        }
                    } else {
                        if (this.deletes(item)) {
                            action = "delete";
                            oldValue = _array.last(/** @type {Item} */ item.content.getContent());
                        } else return; // nop
                    }
                    keys.set(key, {
                        action,
                        oldValue
                    });
                }
            });
            this._keys = keys;
        }
        return this._keys;
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */ get delta() {
        return this.changes.delta;
    }
    /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ adds(struct) {
        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        let changes = this._changes;
        if (changes === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const target = this.target;
            const added = _set.create();
            const deleted = _set.create();
            /**
       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
       */ const delta = [];
            changes = {
                added,
                deleted,
                delta,
                keys: this.keys
            };
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            if (changed.has(null)) {
                /**
         * @type {any}
         */ let lastOp = null;
                const packOp = ()=>{
                    if (lastOp) delta.push(lastOp);
                };
                for(let item = target._start; item !== null; item = item.right){
                    if (item.deleted) {
                        if (this.deletes(item) && !this.adds(item)) {
                            if (lastOp === null || lastOp.delete === undefined) {
                                packOp();
                                lastOp = {
                                    delete: 0
                                };
                            }
                            lastOp.delete += item.length;
                            deleted.add(item);
                        } // else nop
                    } else if (this.adds(item)) {
                        if (lastOp === null || lastOp.insert === undefined) {
                            packOp();
                            lastOp = {
                                insert: []
                            };
                        }
                        lastOp.insert = lastOp.insert.concat(item.content.getContent());
                        added.add(item);
                    } else {
                        if (lastOp === null || lastOp.retain === undefined) {
                            packOp();
                            lastOp = {
                                retain: 0
                            };
                        }
                        lastOp.retain += item.length;
                    }
                }
                if (lastOp !== null && lastOp.retain === undefined) packOp();
            }
            this._changes = changes;
        }
        return /** @type {any} */ changes;
    }
}
/**
 * Compute the path from this type to the specified target.
 *
 * @example
 *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
 *   const path = type.getPathTo(child)
 *   // assuming `type instanceof YArray`
 *   console.log(path) // might look like => [2, 'key1']
 *   child === type.get(path[0]).get(path[1])
 *
 * @param {AbstractType<any>} parent
 * @param {AbstractType<any>} child target
 * @return {Array<string|number>} Path to the target
 *
 * @private
 * @function
 */ const getPathTo = (parent, child)=>{
    const path = [];
    while(child._item !== null && child !== parent){
        if (child._item.parentSub !== null) // parent is map-ish
        path.unshift(child._item.parentSub);
        else {
            // parent is array-ish
            let i = 0;
            let c = /** @type {AbstractType<any>} */ child._item.parent._start;
            while(c !== child._item && c !== null){
                if (!c.deleted) i++;
                c = c.right;
            }
            path.unshift(i);
        }
        child = /** @type {AbstractType<any>} */ child._item.parent;
    }
    return path;
};
const maxSearchMarker = 80;
/**
 * A unique timestamp that identifies each marker.
 *
 * Time is relative,.. this is more like an ever-increasing clock.
 *
 * @type {number}
 */ let globalSearchMarkerTimestamp = 0;
class ArraySearchMarker {
    /**
   * @param {Item} p
   * @param {number} index
   */ constructor(p, index){
        p.marker = true;
        this.p = p;
        this.index = index;
        this.timestamp = globalSearchMarkerTimestamp++;
    }
}
/**
 * @param {ArraySearchMarker} marker
 */ const refreshMarkerTimestamp = (marker)=>{
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * This is rather complex so this function is the only thing that should overwrite a marker
 *
 * @param {ArraySearchMarker} marker
 * @param {Item} p
 * @param {number} index
 */ const overwriteMarker = (marker, p, index)=>{
    marker.p.marker = false;
    marker.p = p;
    p.marker = true;
    marker.index = index;
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {Item} p
 * @param {number} index
 */ const markPosition = (searchMarker, p, index)=>{
    if (searchMarker.length >= maxSearchMarker) {
        // override oldest marker (we don't want to create more objects)
        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);
        overwriteMarker(marker, p, index);
        return marker;
    } else {
        // create new marker
        const pm = new ArraySearchMarker(p, index);
        searchMarker.push(pm);
        return pm;
    }
};
/**
 * Search marker help us to find positions in the associative array faster.
 *
 * They speed up the process of finding a position without much bookkeeping.
 *
 * A maximum of `maxSearchMarker` objects are created.
 *
 * This function always returns a refreshed marker (updated timestamp)
 *
 * @param {AbstractType<any>} yarray
 * @param {number} index
 */ const findMarker = (yarray, index)=>{
    if (yarray._start === null || index === 0 || yarray._searchMarker === null) return null;
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>_math.abs(index - a.index) < _math.abs(index - b.index) ? a : b);
    let p = yarray._start;
    let pindex = 0;
    if (marker !== null) {
        p = marker.p;
        pindex = marker.index;
        refreshMarkerTimestamp(marker); // we used it, we might need to use it again
    }
    // iterate to right if possible
    while(p.right !== null && pindex < index){
        if (!p.deleted && p.countable) {
            if (index < pindex + p.length) break;
            pindex += p.length;
        }
        p = p.right;
    }
    // iterate to left if necessary (might be that pindex > index)
    while(p.left !== null && pindex > index){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // we want to make sure that p can't be merged with left, because that would screw up everything
    // in that cas just return what we have (it is most likely the best marker anyway)
    // iterate to left until p can't be merged with left
    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // @todo remove!
    // assure position
    // {
    //   let start = yarray._start
    //   let pos = 0
    //   while (start !== p) {
    //     if (!start.deleted && start.countable) {
    //       pos += start.length
    //     }
    //     start = /** @type {Item} */ (start.right)
    //   }
    //   if (pos !== pindex) {
    //     debugger
    //     throw new Error('Gotcha position fail!')
    //   }
    // }
    // if (marker) {
    //   if (window.lengthes == null) {
    //     window.lengthes = []
    //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)
    //   }
    //   window.lengthes.push(marker.index - pindex)
    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
    // }
    if (marker !== null && _math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {
        // adjust existing marker
        overwriteMarker(marker, p, pindex);
        return marker;
    } else // create new marker
    return markPosition(yarray._searchMarker, p, pindex);
};
/**
 * Update markers when a change happened.
 *
 * This should be called before doing a deletion!
 *
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {number} index
 * @param {number} len If insertion, len is positive. If deletion, len is negative.
 */ const updateMarkerChanges = (searchMarker, index, len)=>{
    for(let i = searchMarker.length - 1; i >= 0; i--){
        const m = searchMarker[i];
        if (len > 0) {
            /**
       * @type {Item|null}
       */ let p = m.p;
            p.marker = false;
            // Ideally we just want to do a simple position comparison, but this will only work if
            // search markers don't point to deleted items for formats.
            // Iterate marker to prev undeleted countable position so we know what to do when updating a position
            while(p && (p.deleted || !p.countable)){
                p = p.left;
                if (p && !p.deleted && p.countable) // adjust position. the loop should break now
                m.index -= p.length;
            }
            if (p === null || p.marker === true) {
                // remove search marker if updated position is null or if position is already marked
                searchMarker.splice(i, 1);
                continue;
            }
            m.p = p;
            p.marker = true;
        }
        if (index < m.index || len > 0 && index === m.index) m.index = _math.max(index, m.index + len);
    }
};
/**
 * Accumulate all (list) children of a type and return them as an Array.
 *
 * @param {AbstractType<any>} t
 * @return {Array<Item>}
 */ const getTypeChildren = (t)=>{
    let s = t._start;
    const arr = [];
    while(s){
        arr.push(s);
        s = s.right;
    }
    return arr;
};
/**
 * Call event listeners with an event. This will also add an event to all
 * parents (for `.observeDeep` handlers).
 *
 * @template EventType
 * @param {AbstractType<EventType>} type
 * @param {Transaction} transaction
 * @param {EventType} event
 */ const callTypeObservers = (type, transaction, event)=>{
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while(true){
        // @ts-ignore
        _map.setIfUndefined(changedParentTypes, type, ()=>[]).push(event);
        if (type._item === null) break;
        type = /** @type {AbstractType<any>} */ type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
};
/**
 * @template EventType
 * Abstract Yjs Type class
 */ class AbstractType {
    constructor(){
        /**
     * @type {Item|null}
     */ this._item = null;
        /**
     * @type {Map<string,Item>}
     */ this._map = new Map();
        /**
     * @type {Item|null}
     */ this._start = null;
        /**
     * @type {Doc|null}
     */ this.doc = null;
        this._length = 0;
        /**
     * Event handlers
     * @type {EventHandler<EventType,Transaction>}
     */ this._eH = createEventHandler();
        /**
     * Deep event handlers
     * @type {EventHandler<Array<YEvent<any>>,Transaction>}
     */ this._dEH = createEventHandler();
        /**
     * @type {null | Array<ArraySearchMarker>}
     */ this._searchMarker = null;
    }
    /**
   * @return {AbstractType<any>|null}
   */ get parent() {
        return this._item ? /** @type {AbstractType<any>} */ this._item.parent : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */ _integrate(y, item) {
        this.doc = y;
        this._item = item;
    }
    /**
   * @return {AbstractType<EventType>}
   */ _copy() {
        throw _error.methodUnimplemented();
    }
    /**
   * @return {AbstractType<EventType>}
   */ clone() {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */ _write(_encoder) {}
    /**
   * The first non-deleted item
   */ get _first() {
        let n = this._start;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, _parentSubs) {
        if (!transaction.local && this._searchMarker) this._searchMarker.length = 0;
    }
    /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */ observe(f) {
        addEventHandlerListener(this._eH, f);
    }
    /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ observeDeep(f) {
        addEventHandlerListener(this._dEH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */ unobserve(f) {
        removeEventHandlerListener(this._eH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ unobserveDeep(f) {
        removeEventHandlerListener(this._dEH, f);
    }
    /**
   * @abstract
   * @return {any}
   */ toJSON() {}
}
/**
 * @param {AbstractType<any>} type
 * @param {number} start
 * @param {number} end
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListSlice = (type, start, end)=>{
    if (start < 0) start = type._length + start;
    if (end < 0) end = type._length + end;
    let len = end - start;
    const cs = [];
    let n = type._start;
    while(n !== null && len > 0){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            if (c.length <= start) start -= c.length;
            else {
                for(let i = start; i < c.length && len > 0; i++){
                    cs.push(c[i]);
                    len--;
                }
                start = 0;
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArray = (type)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @param {Snapshot} snapshot
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArraySnapshot = (type, snapshot)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && isVisible(n, snapshot)) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * Executes a provided function on once on overy element of this YArray.
 *
 * @param {AbstractType<any>} type
 * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
 *
 * @private
 * @function
 */ const typeListForEach = (type, f)=>{
    let index = 0;
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)f(c[i], index++, type);
        }
        n = n.right;
    }
};
/**
 * @template C,R
 * @param {AbstractType<any>} type
 * @param {function(C,number,AbstractType<any>):R} f
 * @return {Array<R>}
 *
 * @private
 * @function
 */ const typeListMap = (type, f)=>{
    /**
   * @type {Array<any>}
   */ const result = [];
    typeListForEach(type, (c, i)=>{
        result.push(f(c, i, type));
    });
    return result;
};
/**
 * @param {AbstractType<any>} type
 * @return {IterableIterator<any>}
 *
 * @private
 * @function
 */ const typeListCreateIterator = (type)=>{
    let n = type._start;
    /**
   * @type {Array<any>|null}
   */ let currentContent = null;
    let currentContentIndex = 0;
    return {
        [Symbol.iterator] () {
            return this;
        },
        next: ()=>{
            // find some content
            if (currentContent === null) {
                while(n !== null && n.deleted)n = n.right;
                // check if we reached the end, no need to check currentContent, because it does not exist
                if (n === null) return {
                    done: true,
                    value: undefined
                };
                // we found n, so we can set currentContent
                currentContent = n.content.getContent();
                currentContentIndex = 0;
                n = n.right; // we used the content of n, now iterate to next
            }
            const value = currentContent[currentContentIndex++];
            // check if we need to empty currentContent
            if (currentContent.length <= currentContentIndex) currentContent = null;
            return {
                done: false,
                value
            };
        }
    };
};
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @return {any}
 *
 * @private
 * @function
 */ const typeListGet = (type, index)=>{
    const marker = findMarker(type, index);
    let n = type._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) return n.content.getContent()[index];
        index -= n.length;
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Item?} referenceItem
 * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{
    let left = referenceItem;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const store = doc.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    /**
   * @type {Array<Object|Array<any>|number|null>}
   */ let jsonContent = [];
    const packJsonContent = ()=>{
        if (jsonContent.length > 0) {
            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
            left.integrate(transaction, 0);
            jsonContent = [];
        }
    };
    content.forEach((c)=>{
        if (c === null) jsonContent.push(c);
        else switch(c.constructor){
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
                jsonContent.push(c);
                break;
            default:
                packJsonContent();
                switch(c.constructor){
                    case Uint8Array:
                    case ArrayBuffer:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ c)));
                        left.integrate(transaction, 0);
                        break;
                    case Doc:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ c));
                        left.integrate(transaction, 0);
                        break;
                    default:
                        if (c instanceof AbstractType) {
                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                            left.integrate(transaction, 0);
                        } else throw new Error("Unexpected content type in insert operation");
                }
        }
    });
    packJsonContent();
};
const lengthExceeded = ()=>_error.create("Length exceeded!");
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenerics = (transaction, parent, index, content)=>{
    if (index > parent._length) throw lengthExceeded();
    if (index === 0) {
        if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, index, content.length);
        return typeListInsertGenericsAfter(transaction, parent, null, content);
    }
    const startIndex = index;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
        // we need to iterate one to the left so that the algorithm works
        if (index === 0) {
            // @todo refactor this as it actually doesn't consider formats
            n = n.prev; // important! get the left undeleted item so that we can actually decrease index
            index += n && n.countable && !n.deleted ? n.length : 0;
        }
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index <= n.length) {
            if (index < n.length) // insert in-between
            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
            break;
        }
        index -= n.length;
    }
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, content.length);
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * Pushing content is special as we generally want to push after the last item. So we don't have to update
 * the serach marker.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListPushGenerics = (transaction, parent, content)=>{
    // Use the marker with the highest index and iterate to the right.
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {
        index: 0,
        p: parent._start
    });
    let n = marker.p;
    if (n) while(n.right)n = n.right;
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {number} length
 *
 * @private
 * @function
 */ const typeListDelete = (transaction, parent, index, length)=>{
    if (length === 0) return;
    const startIndex = index;
    const startLength = length;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    // compute the first item to be deleted
    for(; n !== null && index > 0; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        index -= n.length;
    }
    // delete all items until done
    while(length > 0 && n !== null){
        if (!n.deleted) {
            if (length < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));
            n.delete(transaction);
            length -= n.length;
        }
        n = n.right;
    }
    if (length > 0) throw lengthExceeded();
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 *
 * @private
 * @function
 */ const typeMapDelete = (transaction, parent, key)=>{
    const c = parent._map.get(key);
    if (c !== undefined) c.delete(transaction);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value
 *
 * @private
 * @function
 */ const typeMapSet = (transaction, parent, key, value)=>{
    const left = parent._map.get(key) || null;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    let content;
    if (value == null) content = new ContentAny([
        value
    ]);
    else switch(value.constructor){
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
            content = new ContentAny([
                value
            ]);
            break;
        case Uint8Array:
            content = new ContentBinary(/** @type {Uint8Array} */ value);
            break;
        case Doc:
            content = new ContentDoc(/** @type {Doc} */ value);
            break;
        default:
            if (value instanceof AbstractType) content = new ContentType(value);
            else throw new Error("Unexpected content type");
    }
    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGet = (parent, key)=>{
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAll = (parent)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent._map.forEach((value, key)=>{
        if (!value.deleted) res[key] = value.content.getContent()[value.length - 1];
    });
    return res;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {boolean}
 *
 * @private
 * @function
 */ const typeMapHas = (parent, key)=>{
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Snapshot} snapshot
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGetSnapshot = (parent, key, snapshot)=>{
    let v = parent._map.get(key) || null;
    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0)))v = v.left;
    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;
};
/**
 * @param {Map<string,Item>} map
 * @return {IterableIterator<Array<any>>}
 *
 * @private
 * @function
 */ const createMapIterator = (map)=>_iterator.iteratorFilter(map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);
/**
 * @module YArray
 */ /**
 * Event that describes the changes on a YArray
 * @template T
 * @extends YEvent<YArray<T>>
 */ class YArrayEvent extends YEvent {
    /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */ constructor(yarray, transaction){
        super(yarray, transaction);
        this._transaction = transaction;
    }
}
/**
 * A shared Array implementation.
 * @template T
 * @extends AbstractType<YArrayEvent<T>>
 * @implements {Iterable<T>}
 */ class YArray extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>?}
     * @private
     */ this._prelimContent = [];
        /**
     * @type {Array<ArraySearchMarker>}
     */ this._searchMarker = [];
    }
    /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */ static from(items) {
        /**
     * @type {YArray<T>}
     */ const a = new YArray();
        a.push(items);
        return a;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    /**
   * @return {YArray<T>}
   */ _copy() {
        return new YArray();
    }
    /**
   * @return {YArray<T>}
   */ clone() {
        /**
     * @type {YArray<T>}
     */ const arr = new YArray();
        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? /** @type {typeof el} */ el.clone() : el));
        return arr;
    }
    get length() {
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */ push(content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListPushGenerics(transaction, this, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.push(...content);
    }
    /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, length);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */ toJSON() {
        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */ map(f) {
        return typeListMap(this, /** @type {any} */ f);
    }
    /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator]() {
        return typeListCreateIterator(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YArrayRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYArray = (_decoder)=>new YArray();
/**
 * @template T
 * @extends YEvent<YMap<T>>
 * Event that describes the changes on a YMap.
 */ class YMapEvent extends YEvent {
    /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */ constructor(ymap, transaction, subs){
        super(ymap, transaction);
        this.keysChanged = subs;
    }
}
/**
 * @template MapType
 * A shared Map implementation.
 *
 * @extends AbstractType<YMapEvent<MapType>>
 * @implements {Iterable<MapType>}
 */ class YMap extends AbstractType {
    /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */ constructor(entries){
        super();
        /**
     * @type {Map<string,any>?}
     * @private
     */ this._prelimContent = null;
        if (entries === undefined) this._prelimContent = new Map();
        else this._prelimContent = new Map(entries);
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item); /** @type {Map<string, any>} */ 
        this._prelimContent.forEach((value, key)=>{
            this.set(key, value);
        });
        this._prelimContent = null;
    }
    /**
   * @return {YMap<MapType>}
   */ _copy() {
        return new YMap();
    }
    /**
   * @return {YMap<MapType>}
   */ clone() {
        /**
     * @type {YMap<MapType>}
     */ const map = new YMap();
        this.forEach((value, key)=>{
            map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ value.clone() : value);
        });
        return map;
    }
    /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */ toJSON() {
        /**
     * @type {Object<string,MapType>}
     */ const map = {};
        this._map.forEach((item, key)=>{
            if (!item.deleted) {
                const v = item.content.getContent()[item.length - 1];
                map[key] = v instanceof AbstractType ? v.toJSON() : v;
            }
        });
        return map;
    }
    /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */ get size() {
        return [
            ...createMapIterator(this._map)
        ].length;
    }
    /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */ keys() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[0]);
    }
    /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<any>}
   */ values() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */ entries() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>[
                v[0],
                v[1].content.getContent()[v[1].length - 1]
            ]);
    }
    /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        this._map.forEach((item, key)=>{
            if (!item.deleted) f(item.content.getContent()[item.length - 1], key, this);
        });
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<any>}
   */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */ delete(key) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, key);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.delete(key);
    }
    /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */ set(key, value) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, key, /** @type {any} */ value);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.set(key, value);
        return value;
    }
    /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */ get(key) {
        return /** @type {any} */ typeMapGet(this, key);
    }
    /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */ has(key) {
        return typeMapHas(this, key);
    }
    /**
   * Removes all elements from this YMap.
   */ clear() {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            this.forEach(function(_value, key, map) {
                typeMapDelete(transaction, map, key);
            });
        });
        else /** @type {Map<string, any>} */ this._prelimContent.clear();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YMapRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYMap = (_decoder)=>new YMap();
/**
 * @param {any} a
 * @param {any} b
 * @return {boolean}
 */ const equalAttrs = (a, b)=>a === b || typeof a === "object" && typeof b === "object" && a && b && _object.equalFlat(a, b);
class ItemTextListPosition {
    /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */ constructor(left, right, index, currentAttributes){
        this.left = left;
        this.right = right;
        this.index = index;
        this.currentAttributes = currentAttributes;
    }
    /**
   * Only call this if you know that this.right is defined
   */ forward() {
        if (this.right === null) _error.unexpectedCase();
        switch(this.right.content.constructor){
            case ContentFormat:
                if (!this.right.deleted) updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ this.right.content);
                break;
            default:
                if (!this.right.deleted) this.index += this.right.length;
                break;
        }
        this.left = this.right;
        this.right = this.right.right;
    }
}
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} pos
 * @param {number} count steps to move forward
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findNextPosition = (transaction, pos, count)=>{
    while(pos.right !== null && count > 0){
        switch(pos.right.content.constructor){
            case ContentFormat:
                if (!pos.right.deleted) updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ pos.right.content);
                break;
            default:
                if (!pos.right.deleted) {
                    if (count < pos.right.length) // split right
                    getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
                    pos.index += pos.right.length;
                    count -= pos.right.length;
                }
                break;
        }
        pos.left = pos.right;
        pos.right = pos.right.right;
    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
    }
    return pos;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findPosition = (transaction, parent, index)=>{
    const currentAttributes = new Map();
    const marker = findMarker(parent, index);
    if (marker) {
        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
        return findNextPosition(transaction, pos, index - marker.index);
    } else {
        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
        return findNextPosition(transaction, pos, index);
    }
};
/**
 * Negate applied formats
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Map<string,any>} negatedAttributes
 *
 * @private
 * @function
 */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{
    // check if we really need to remove attributes
    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){
        if (!currPos.right.deleted) negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);
        currPos.forward();
    }
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    negatedAttributes.forEach((val, key)=>{
        const left = currPos.left;
        const right = currPos.right;
        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
        nextFormat.integrate(transaction, 0);
        currPos.right = nextFormat;
        currPos.forward();
    });
};
/**
 * @param {Map<string,any>} currentAttributes
 * @param {ContentFormat} format
 *
 * @private
 * @function
 */ const updateCurrentAttributes = (currentAttributes, format)=>{
    const { key, value } = format;
    if (value === null) currentAttributes.delete(key);
    else currentAttributes.set(key, value);
};
/**
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const minimizeAttributeChanges = (currPos, attributes)=>{
    // go right while attributes[right.key] === right.value (or right is deleted)
    while(true){
        if (currPos.right === null) break;
        else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */ currPos.right.content.key] || null, /** @type {ContentFormat} */ currPos.right.content.value)) ;
        else break;
        currPos.forward();
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 * @return {Map<string,any>}
 *
 * @private
 * @function
 **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const negatedAttributes = new Map();
    // insert format-start items
    for(const key in attributes){
        const val = attributes[key];
        const currentVal = currPos.currentAttributes.get(key) || null;
        if (!equalAttrs(currentVal, val)) {
            // save negated attribute (set null if currentVal undefined)
            negatedAttributes.set(key, currentVal);
            const { left, right } = currPos;
            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
            currPos.right.integrate(transaction, 0);
            currPos.forward();
        }
    }
    return negatedAttributes;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {string|object|AbstractType<any>} text
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 **/ const insertText = (transaction, parent, currPos, text, attributes)=>{
    currPos.currentAttributes.forEach((_val, key)=>{
        if (attributes[key] === undefined) attributes[key] = null;
    });
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // insert content
    const content = text.constructor === String ? new ContentString(/** @type {string} */ text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);
    let { left, right, index } = currPos;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const formatText = (transaction, parent, currPos, length, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
    // eslint-disable-next-line no-labels
    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){
        if (!currPos.right.deleted) switch(currPos.right.content.constructor){
            case ContentFormat:
                {
                    const { key, value } = /** @type {ContentFormat} */ currPos.right.content;
                    const attr = attributes[key];
                    if (attr !== undefined) {
                        if (equalAttrs(attr, value)) negatedAttributes.delete(key);
                        else {
                            if (length === 0) break iterationLoop;
                            negatedAttributes.set(key, value);
                        }
                        currPos.right.delete(transaction);
                    } else currPos.currentAttributes.set(key, value);
                    break;
                }
            default:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                break;
        }
        currPos.forward();
    }
    // Quill just assumes that the editor starts with a newline and that it always
    // ends with a newline. We only insert that newline when a new newline is
    // inserted - i.e when length is bigger than type.length
    if (length > 0) {
        let newlines = "";
        for(; length > 0; length--)newlines += "\n";
        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * Call this function after string content has been deleted in order to
 * clean up formatting Items.
 *
 * @param {Transaction} transaction
 * @param {Item} start
 * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
 * @param {Map<string,any>} startAttributes
 * @param {Map<string,any>} currAttributes
 * @return {number} The amount of formatting Items deleted.
 *
 * @function
 */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{
    /**
   * @type {Item|null}
   */ let end = start;
    /**
   * @type {Map<string,ContentFormat>}
   */ const endFormats = _map.create();
    while(end && (!end.countable || end.deleted)){
        if (!end.deleted && end.content.constructor === ContentFormat) {
            const cf = /** @type {ContentFormat} */ end.content;
            endFormats.set(cf.key, cf);
        }
        end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while(start !== end){
        if (curr === start) reachedCurr = true;
        if (!start.deleted) {
            const content = start.content;
            switch(content.constructor){
                case ContentFormat:
                    {
                        const { key, value } = /** @type {ContentFormat} */ content;
                        const startAttrValue = startAttributes.get(key) || null;
                        if (endFormats.get(key) !== content || startAttrValue === value) {
                            // Either this format is overwritten or it is not necessary because the attribute already existed.
                            start.delete(transaction);
                            cleanups++;
                            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
                                if (startAttrValue === null) currAttributes.delete(key);
                                else currAttributes.set(key, startAttrValue);
                            }
                        }
                        if (!reachedCurr && !start.deleted) updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ content);
                        break;
                    }
            }
        }
        start = /** @type {Item} */ start.right;
    }
    return cleanups;
};
/**
 * @param {Transaction} transaction
 * @param {Item | null} item
 */ const cleanupContextlessFormattingGap = (transaction, item)=>{
    // iterate until item.right is null or content
    while(item && item.right && (item.right.deleted || !item.right.countable))item = item.right;
    const attrs = new Set();
    // iterate back until a content item is found
    while(item && (item.deleted || !item.countable)){
        if (!item.deleted && item.content.constructor === ContentFormat) {
            const key = /** @type {ContentFormat} */ item.content.key;
            if (attrs.has(key)) item.delete(transaction);
            else attrs.add(key);
        }
        item = item.left;
    }
};
/**
 * This function is experimental and subject to change / be removed.
 *
 * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
 * automatically after each change. This function iterates twice over the complete YText type
 * and removes unnecessary formatting attributes. This is also helpful for testing.
 *
 * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
 *
 * @param {YText} type
 * @return {number} How many formatting attributes have been cleaned up.
 */ const cleanupYTextFormatting = (type)=>{
    let res = 0;
    transact(/** @type {Doc} */ type.doc, (transaction)=>{
        let start = /** @type {Item} */ type._start;
        let end = type._start;
        let startAttributes = _map.create();
        const currentAttributes = _map.copy(startAttributes);
        while(end){
            if (end.deleted === false) switch(end.content.constructor){
                case ContentFormat:
                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ end.content);
                    break;
                default:
                    res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                    startAttributes = _map.copy(currentAttributes);
                    start = end;
                    break;
            }
            end = end.right;
        }
    });
    return res;
};
/**
 * This will be called by the transction once the event handlers are called to potentially cleanup
 * formatting attributes.
 *
 * @param {Transaction} transaction
 */ const cleanupYTextAfterTransaction = (transaction)=>{
    /**
   * @type {Set<YText>}
   */ const needFullCleanup = new Set();
    // check if another formatting item was inserted
    const doc = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()){
        const clock = transaction.beforeState.get(client) || 0;
        if (afterClock === clock) continue;
        iterateStructs(transaction, /** @type {Array<Item|GC>} */ doc.store.clients.get(client), clock, afterClock, (item)=>{
            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) needFullCleanup.add(/** @type {any} */ item.parent);
        });
    }
    // cleanup in a new transaction
    transact(doc, (t)=>{
        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{
            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(/** @type {YText} */ item.parent)) return;
            const parent = /** @type {YText} */ item.parent;
            if (item.content.constructor === ContentFormat) needFullCleanup.add(parent);
            else // If no formatting attribute was inserted or deleted, we can make due with contextless
            // formatting cleanups.
            // Contextless: it is not necessary to compute currentAttributes for the affected position.
            cleanupContextlessFormattingGap(t, item);
        });
        // If a formatting item was inserted, we simply clean the whole type.
        // We need to compute currentAttributes for the current position anyway.
        for (const yText of needFullCleanup)cleanupYTextFormatting(yText);
    });
};
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const deleteText = (transaction, currPos, length)=>{
    const startLength = length;
    const startAttrs = _map.copy(currPos.currentAttributes);
    const start = currPos.right;
    while(length > 0 && currPos.right !== null){
        if (currPos.right.deleted === false) switch(currPos.right.content.constructor){
            case ContentType:
            case ContentEmbed:
            case ContentString:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                currPos.right.delete(transaction);
                break;
        }
        currPos.forward();
    }
    if (start) cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    const parent = /** @type {AbstractType<any>} */ /** @type {Item} */ (currPos.left || currPos.right).parent;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
    return currPos;
};
/**
 * The Quill Delta format represents changes on a text document with
 * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
 *
 * @example
 *   {
 *     ops: [
 *       { insert: 'Gandalf', attributes: { bold: true } },
 *       { insert: ' the ' },
 *       { insert: 'Grey', attributes: { color: '#cccccc' } }
 *     ]
 *   }
 *
 */ /**
  * Attributes that can be assigned to a selection of text.
  *
  * @example
  *   {
  *     bold: true,
  *     font-size: '40px'
  *   }
  *
  * @typedef {Object} TextAttributes
  */ /**
 * @extends YEvent<YText>
 * Event that describes the changes on a YText type.
 */ class YTextEvent extends YEvent {
    /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */ constructor(ytext, transaction, subs){
        super(ytext, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.keysChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.keysChanged.add(sub);
        });
    }
    /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        if (this._changes === null) {
            /**
       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}
       */ const changes = {
                keys: this.keys,
                delta: this.delta,
                added: new Set(),
                deleted: new Set()
            };
            this._changes = changes;
        }
        return /** @type {any} */ this._changes;
    }
    /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */ get delta() {
        if (this._delta === null) {
            const y = /** @type {Doc} */ this.target.doc;
            /**
       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
       */ const delta = [];
            transact(y, (transaction)=>{
                const currentAttributes = new Map(); // saves all current attributes for insert
                const oldAttributes = new Map();
                let item = this.target._start;
                /**
         * @type {string?}
         */ let action = null;
                /**
         * @type {Object<string,any>}
         */ const attributes = {}; // counts added or removed new attributes for retain
                /**
         * @type {string|object}
         */ let insert = "";
                let retain = 0;
                let deleteLen = 0;
                const addOp = ()=>{
                    if (action !== null) {
                        /**
             * @type {any}
             */ let op = null;
                        switch(action){
                            case "delete":
                                if (deleteLen > 0) op = {
                                    delete: deleteLen
                                };
                                deleteLen = 0;
                                break;
                            case "insert":
                                if (typeof insert === "object" || insert.length > 0) {
                                    op = {
                                        insert
                                    };
                                    if (currentAttributes.size > 0) {
                                        op.attributes = {};
                                        currentAttributes.forEach((value, key)=>{
                                            if (value !== null) op.attributes[key] = value;
                                        });
                                    }
                                }
                                insert = "";
                                break;
                            case "retain":
                                if (retain > 0) {
                                    op = {
                                        retain
                                    };
                                    if (!_object.isEmpty(attributes)) op.attributes = _object.assign({}, attributes);
                                }
                                retain = 0;
                                break;
                        }
                        if (op) delta.push(op);
                        action = null;
                    }
                };
                while(item !== null){
                    switch(item.content.constructor){
                        case ContentType:
                        case ContentEmbed:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    addOp();
                                    action = "insert";
                                    insert = item.content.getContent()[0];
                                    addOp();
                                }
                            } else if (this.deletes(item)) {
                                if (action !== "delete") {
                                    addOp();
                                    action = "delete";
                                }
                                deleteLen += 1;
                            } else if (!item.deleted) {
                                if (action !== "retain") {
                                    addOp();
                                    action = "retain";
                                }
                                retain += 1;
                            }
                            break;
                        case ContentString:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    if (action !== "insert") {
                                        addOp();
                                        action = "insert";
                                    }
                                    insert += /** @type {ContentString} */ item.content.str;
                                }
                            } else if (this.deletes(item)) {
                                if (action !== "delete") {
                                    addOp();
                                    action = "delete";
                                }
                                deleteLen += item.length;
                            } else if (!item.deleted) {
                                if (action !== "retain") {
                                    addOp();
                                    action = "retain";
                                }
                                retain += item.length;
                            }
                            break;
                        case ContentFormat:
                            {
                                const { key, value } = /** @type {ContentFormat} */ item.content;
                                if (this.adds(item)) {
                                    if (!this.deletes(item)) {
                                        const curVal = currentAttributes.get(key) || null;
                                        if (!equalAttrs(curVal, value)) {
                                            if (action === "retain") addOp();
                                            if (equalAttrs(value, oldAttributes.get(key) || null)) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (value !== null) item.delete(transaction);
                                    }
                                } else if (this.deletes(item)) {
                                    oldAttributes.set(key, value);
                                    const curVal = currentAttributes.get(key) || null;
                                    if (!equalAttrs(curVal, value)) {
                                        if (action === "retain") addOp();
                                        attributes[key] = curVal;
                                    }
                                } else if (!item.deleted) {
                                    oldAttributes.set(key, value);
                                    const attr = attributes[key];
                                    if (attr !== undefined) {
                                        if (!equalAttrs(attr, value)) {
                                            if (action === "retain") addOp();
                                            if (value === null) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (attr !== null) item.delete(transaction);
                                    }
                                }
                                if (!item.deleted) {
                                    if (action === "insert") addOp();
                                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ item.content);
                                }
                                break;
                            }
                    }
                    item = item.right;
                }
                addOp();
                while(delta.length > 0){
                    const lastOp = delta[delta.length - 1];
                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) // retain delta's if they don't assign attributes
                    delta.pop();
                    else break;
                }
            });
            this._delta = delta;
        }
        return /** @type {any} */ this._delta;
    }
}
/**
 * Type that represents text with formatting information.
 *
 * This type replaces y-richtext as this implementation is able to handle
 * block formats (format information on a paragraph), embeds (complex elements
 * like pictures and videos), and text formats (**bold**, *italic*).
 *
 * @extends AbstractType<YTextEvent>
 */ class YText extends AbstractType {
    /**
   * @param {String} [string] The initial value of the YText.
   */ constructor(string){
        super();
        /**
     * Array of pending operations on this type
     * @type {Array<function():void>?}
     */ this._pending = string !== undefined ? [
            ()=>this.insert(0, string)
        ] : [];
        /**
     * @type {Array<ArraySearchMarker>|null}
     */ this._searchMarker = [];
        /**
     * Whether this YText contains formatting attributes.
     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
     */ this._hasFormatting = false;
    }
    /**
   * Number of characters of this text type.
   *
   * @type {number}
   */ get length() {
        return this._length;
    }
    /**
   * @param {Doc} y
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        try {
            /** @type {Array<function>} */ this._pending.forEach((f)=>f());
        } catch (e) {
            console.error(e);
        }
        this._pending = null;
    }
    _copy() {
        return new YText();
    }
    /**
   * @return {YText}
   */ clone() {
        const text = new YText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        const event = new YTextEvent(this, transaction, parentSubs);
        callTypeObservers(this, transaction, event);
        // If a remote change happened, we try to cleanup potential formatting duplicates.
        if (!transaction.local && this._hasFormatting) transaction._needFormattingCleanup = true;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */ toString() {
        let str = "";
        /**
     * @type {Item|null}
     */ let n = this._start;
        while(n !== null){
            if (!n.deleted && n.countable && n.content.constructor === ContentString) str += /** @type {ContentString} */ n.content.str;
            n = n.right;
        }
        return str;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */ toJSON() {
        return this.toString();
    }
    /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */ applyDelta(delta, { sanitize = true } = {}) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const currPos = new ItemTextListPosition(null, this._start, 0, new Map());
            for(let i = 0; i < delta.length; i++){
                const op = delta[i];
                if (op.insert !== undefined) {
                    // Quill assumes that the content starts with an empty paragraph.
                    // Yjs/Y.Text assumes that it starts empty. We always hide that
                    // there is a newline at the end of the content.
                    // If we omit this step, clients will see a different number of
                    // paragraphs, but nothing bad will happen.
                    const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
                    if (typeof ins !== "string" || ins.length > 0) insertText(transaction, this, currPos, ins, op.attributes || {});
                } else if (op.retain !== undefined) formatText(transaction, this, currPos, op.retain, op.attributes || {});
                else if (op.delete !== undefined) deleteText(transaction, currPos, op.delete);
            }
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));
    }
    /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */ toDelta(snapshot, prevSnapshot, computeYChange) {
        /**
     * @type{Array<any>}
     */ const ops = [];
        const currentAttributes = new Map();
        const doc = /** @type {Doc} */ this.doc;
        let str = "";
        let n = this._start;
        function packStr() {
            if (str.length > 0) {
                // pack str with attributes to ops
                /**
         * @type {Object<string,any>}
         */ const attributes = {};
                let addAttributes = false;
                currentAttributes.forEach((value, key)=>{
                    addAttributes = true;
                    attributes[key] = value;
                });
                /**
         * @type {Object<string,any>}
         */ const op = {
                    insert: str
                };
                if (addAttributes) op.attributes = attributes;
                ops.push(op);
                str = "";
            }
        }
        const computeDelta = ()=>{
            while(n !== null){
                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) switch(n.content.constructor){
                    case ContentString:
                        {
                            const cur = currentAttributes.get("ychange");
                            if (snapshot !== undefined && !isVisible(n, snapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== "removed") {
                                    packStr();
                                    currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : {
                                        type: "removed"
                                    });
                                }
                            } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== "added") {
                                    packStr();
                                    currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : {
                                        type: "added"
                                    });
                                }
                            } else if (cur !== undefined) {
                                packStr();
                                currentAttributes.delete("ychange");
                            }
                            str += /** @type {ContentString} */ n.content.str;
                            break;
                        }
                    case ContentType:
                    case ContentEmbed:
                        {
                            packStr();
                            /**
               * @type {Object<string,any>}
               */ const op = {
                                insert: n.content.getContent()[0]
                            };
                            if (currentAttributes.size > 0) {
                                const attrs = /** @type {Object<string,any>} */ {};
                                op.attributes = attrs;
                                currentAttributes.forEach((value, key)=>{
                                    attrs[key] = value;
                                });
                            }
                            ops.push(op);
                            break;
                        }
                    case ContentFormat:
                        if (isVisible(n, snapshot)) {
                            packStr();
                            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ n.content);
                        }
                        break;
                }
                n = n.right;
            }
            packStr();
        };
        if (snapshot || prevSnapshot) // snapshots are merged again after the transaction, so we need to keep the
        // transaction alive until we are done
        transact(doc, (transaction)=>{
            if (snapshot) splitSnapshotAffectedStructs(transaction, snapshot);
            if (prevSnapshot) splitSnapshotAffectedStructs(transaction, prevSnapshot);
            computeDelta();
        }, "cleanup");
        else computeDelta();
        return ops;
    }
    /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */ insert(index, text, attributes) {
        if (text.length <= 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index);
            if (!attributes) {
                attributes = {};
                // @ts-ignore
                pos.currentAttributes.forEach((v, k)=>{
                    attributes[k] = v;
                });
            }
            insertText(transaction, this, pos, text, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));
    }
    /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    embed
   *
   * @public
   */ insertEmbed(index, embed, attributes = {}) {
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index);
            insertText(transaction, this, pos, embed, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes));
    }
    /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */ delete(index, length) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            deleteText(transaction, findPosition(transaction, this, index), length);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));
    }
    /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */ format(index, length, attributes) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index);
            if (pos.right === null) return;
            formatText(transaction, this, pos, length, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));
    }
    /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));
    }
    /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes() {
        return typeMapGetAll(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YText}
 *
 * @private
 * @function
 */ const readYText = (_decoder)=>new YText();
/**
 * @module YXml
 */ /**
 * Define the elements to which a set of CSS queries apply.
 * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
 *
 * @example
 *   query = '.classSelector'
 *   query = 'nodeSelector'
 *   query = '#idSelector'
 *
 * @typedef {string} CSS_Selector
 */ /**
 * Dom filter function.
 *
 * @callback domFilter
 * @param {string} nodeName The nodeName of the element
 * @param {Map} attributes The map of attributes.
 * @return {boolean} Whether to include the Dom node in the YXmlElement.
 */ /**
 * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
 * position within them.
 *
 * Can be created with {@link YXmlFragment#createTreeWalker}
 *
 * @public
 * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}
 */ class YXmlTreeWalker {
    /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */ constructor(root, f = ()=>true){
        this._filter = f;
        this._root = root;
        /**
     * @type {Item}
     */ this._currentNode = /** @type {Item} */ root._start;
        this._firstCall = true;
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */ next() {
        /**
     * @type {Item|null}
     */ let n = this._currentNode;
        let type = n && n.content && /** @type {any} */ n.content.type;
        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) do {
            type = /** @type {any} */ n.content.type;
            if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) // walk down in the tree
            n = type._start;
            else // walk right or up in the tree
            while(n !== null){
                if (n.right !== null) {
                    n = n.right;
                    break;
                } else if (n.parent === this._root) n = null;
                else n = /** @type {AbstractType<any>} */ n.parent._item;
            }
        }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)));
        this._firstCall = false;
        if (n === null) // @ts-ignore
        return {
            value: undefined,
            done: true
        };
        this._currentNode = n;
        return {
            value: /** @type {any} */ n.content.type,
            done: false
        };
    }
}
/**
 * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
 * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
 * nodeName and it does not have attributes. Though it can be bound to a DOM
 * element - in this case the attributes and the nodeName are not shared.
 *
 * @public
 * @extends AbstractType<YXmlEvent>
 */ class YXmlFragment extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>|null}
     */ this._prelimContent = [];
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get firstChild() {
        const first = this._first;
        return first ? first.content.getContent()[0] : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    _copy() {
        return new YXmlFragment();
    }
    /**
   * @return {YXmlFragment}
   */ clone() {
        const el = new YXmlFragment();
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    get length() {
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */ createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
    }
    /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */ querySelector(query) {
        query = query.toUpperCase();
        // @ts-ignore
        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);
        const next = iterator.next();
        if (next.done) return null;
        else return next.value;
    }
    /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */ querySelectorAll(query) {
        query = query.toUpperCase();
        // @ts-ignore
        return _array.from(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));
    }
    /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */ toString() {
        return typeListMap(this, (xml)=>xml.toString()).join("");
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const fragment = _document.createDocumentFragment();
        if (binding !== undefined) binding._createAssociation(fragment, this);
        typeListForEach(this, (xmlType)=>{
            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
        });
        return fragment;
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, content);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insertAfter(ref, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
            typeListInsertGenericsAfter(transaction, this, refItem, content);
        });
        else {
            const pc = /** @type {Array<any>} */ this._prelimContent;
            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;
            if (index === 0 && ref !== null) throw _error.create("Reference item not found");
            pc.splice(index, 0, ...content);
        }
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, length);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */ push(content) {
        this.insert(this.length, content);
    }
    /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlFragmentRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YXmlFragment}
 *
 * @private
 * @function
 */ const readYXmlFragment = (_decoder)=>new YXmlFragment();
/**
 * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
 */ /**
 * An YXmlElement imitates the behavior of a
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.
 *
 * * An YXmlElement has attributes (key value pairs)
 * * An YXmlElement has childElements that must inherit from YXmlElement
 *
 * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
 */ class YXmlElement extends YXmlFragment {
    constructor(nodeName = "UNDEFINED"){
        super();
        this.nodeName = nodeName;
        /**
     * @type {Map<string, any>|null}
     */ this._prelimAttrs = new Map();
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        /** @type {Map<string, any>} */ this._prelimAttrs.forEach((value, key)=>{
            this.setAttribute(key, value);
        });
        this._prelimAttrs = null;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */ _copy() {
        return new YXmlElement(this.nodeName);
    }
    /**
   * @return {YXmlElement<KV>}
   */ clone() {
        /**
     * @type {YXmlElement<KV>}
     */ const el = new YXmlElement(this.nodeName);
        const attrs = this.getAttributes();
        _object.forEach(attrs, (value, key)=>{
            if (typeof value === "string") el.setAttribute(key, value);
        });
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */ toString() {
        const attrs = this.getAttributes();
        const stringBuilder = [];
        const keys = [];
        for(const key in attrs)keys.push(key);
        keys.sort();
        const keysLen = keys.length;
        for(let i = 0; i < keysLen; i++){
            const key = keys[i];
            stringBuilder.push(key + '="' + attrs[key] + '"');
        }
        const nodeName = this.nodeName.toLocaleLowerCase();
        const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);
    }
    /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */ hasAttribute(attributeName) {
        return /** @type {any} */ typeMapHas(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes() {
        return /** @type {any} */ typeMapGetAll(this);
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const dom = _document.createElement(this.nodeName);
        const attrs = this.getAttributes();
        for(const key in attrs){
            const value = attrs[key];
            if (typeof value === "string") dom.setAttribute(key, value);
        }
        typeListForEach(this, (yxml)=>{
            dom.appendChild(yxml.toDOM(_document, hooks, binding));
        });
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlElementRefID);
        encoder.writeKey(this.nodeName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlElement}
 *
 * @function
 */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());
/**
 * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>
 * An Event that describes changes on a YXml Element or Yxml Fragment
 */ class YXmlEvent extends YEvent {
    /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */ constructor(target, subs, transaction){
        super(target, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.attributesChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.attributesChanged.add(sub);
        });
    }
}
/**
 * You can manage binding to a custom type with YXmlHook.
 *
 * @extends {YMap<any>}
 */ class YXmlHook extends YMap {
    /**
   * @param {string} hookName nodeName of the Dom Node.
   */ constructor(hookName){
        super();
        /**
     * @type {string}
     */ this.hookName = hookName;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   */ _copy() {
        return new YXmlHook(this.hookName);
    }
    /**
   * @return {YXmlHook}
   */ clone() {
        const el = new YXmlHook(this.hookName);
        this.forEach((value, key)=>{
            el.set(key, value);
        });
        return el;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const hook = hooks[this.hookName];
        let dom;
        if (hook !== undefined) dom = hook.createDom(this);
        else dom = document.createElement(this.hookName);
        dom.setAttribute("data-yjs-hook", this.hookName);
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlHookRefID);
        encoder.writeKey(this.hookName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlHook}
 *
 * @private
 * @function
 */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());
/**
 * Represents text in a Dom Element. In the future this type will also handle
 * simple formatting information like bold and italic.
 */ class YXmlText extends YText {
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    _copy() {
        return new YXmlText();
    }
    /**
   * @return {YXmlText}
   */ clone() {
        const text = new YXmlText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks, binding) {
        const dom = _document.createTextNode(this.toString());
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    toString() {
        // @ts-ignore
        return this.toDelta().map((delta)=>{
            const nestedNodes = [];
            for(const nodeName in delta.attributes){
                const attrs = [];
                for(const key in delta.attributes[nodeName])attrs.push({
                    key,
                    value: delta.attributes[nodeName][key]
                });
                // sort attributes to get a unique order
                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);
                nestedNodes.push({
                    nodeName,
                    attrs
                });
            }
            // sort node order to get a unique order
            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);
            // now convert to dom string
            let str = "";
            for(let i = 0; i < nestedNodes.length; i++){
                const node = nestedNodes[i];
                str += `<${node.nodeName}`;
                for(let j = 0; j < node.attrs.length; j++){
                    const attr = node.attrs[j];
                    str += ` ${attr.key}="${attr.value}"`;
                }
                str += ">";
            }
            str += delta.insert;
            for(let i = nestedNodes.length - 1; i >= 0; i--)str += `</${nestedNodes[i].nodeName}>`;
            return str;
        }).join("");
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlText}
 *
 * @private
 * @function
 */ const readYXmlText = (decoder)=>new YXmlText();
class AbstractStruct {
    /**
   * @param {ID} id
   * @param {number} length
   */ constructor(id, length){
        this.id = id;
        this.length = length;
    }
    /**
   * @type {boolean}
   */ get deleted() {
        throw _error.methodUnimplemented();
    }
    /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */ write(encoder, offset, encodingRef) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        throw _error.methodUnimplemented();
    }
}
const structGCRefNumber = 0;
/**
 * @private
 */ class GC extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {GC} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.length -= offset;
        }
        addStruct(transaction.doc.store, this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structGCRefNumber);
        encoder.writeLen(this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
class ContentBinary {
    /**
   * @param {Uint8Array} content
   */ constructor(content){
        this.content = content;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.content
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentBinary}
   */ copy() {
        return new ContentBinary(this.content);
    }
    /**
   * @param {number} offset
   * @return {ContentBinary}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentBinary} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeBuf(this.content);
    }
    /**
   * @return {number}
   */ getRef() {
        return 3;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentBinary}
 */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());
class ContentDeleted {
    /**
   * @param {number} len
   */ constructor(len){
        this.len = len;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.len;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentDeleted}
   */ copy() {
        return new ContentDeleted(this.len);
    }
    /**
   * @param {number} offset
   * @return {ContentDeleted}
   */ splice(offset) {
        const right = new ContentDeleted(this.len - offset);
        this.len = offset;
        return right;
    }
    /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */ mergeWith(right) {
        this.len += right.len;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
        item.markDeleted();
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeLen(this.len - offset);
    }
    /**
   * @return {number}
   */ getRef() {
        return 1;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentDeleted}
 */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());
/**
 * @param {string} guid
 * @param {Object<string, any>} opts
 */ const createDocFromOpts = (guid, opts)=>new Doc({
        guid,
        ...opts,
        shouldLoad: opts.shouldLoad || opts.autoLoad || false
    });
/**
 * @private
 */ class ContentDoc {
    /**
   * @param {Doc} doc
   */ constructor(doc){
        if (doc._item) console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
        /**
     * @type {Doc}
     */ this.doc = doc;
        /**
     * @type {any}
     */ const opts = {};
        this.opts = opts;
        if (!doc.gc) opts.gc = false;
        if (doc.autoLoad) opts.autoLoad = true;
        if (doc.meta !== null) opts.meta = doc.meta;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.doc
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentDoc}
   */ copy() {
        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
   * @param {number} offset
   * @return {ContentDoc}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentDoc} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        // this needs to be reflected in doc.destroy as well
        this.doc._item = item;
        transaction.subdocsAdded.add(this.doc);
        if (this.doc.shouldLoad) transaction.subdocsLoaded.add(this.doc);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (transaction.subdocsAdded.has(this.doc)) transaction.subdocsAdded.delete(this.doc);
        else transaction.subdocsRemoved.add(this.doc);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(this.doc.guid);
        encoder.writeAny(this.opts);
    }
    /**
   * @return {number}
   */ getRef() {
        return 9;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentDoc}
 */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
/**
 * @private
 */ class ContentEmbed {
    /**
   * @param {Object} embed
   */ constructor(embed){
        this.embed = embed;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.embed
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentEmbed}
   */ copy() {
        return new ContentEmbed(this.embed);
    }
    /**
   * @param {number} offset
   * @return {ContentEmbed}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeJSON(this.embed);
    }
    /**
   * @return {number}
   */ getRef() {
        return 5;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentEmbed}
 */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());
/**
 * @private
 */ class ContentFormat {
    /**
   * @param {string} key
   * @param {Object} value
   */ constructor(key, value){
        this.key = key;
        this.value = value;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentFormat}
   */ copy() {
        return new ContentFormat(this.key, this.value);
    }
    /**
   * @param {number} _offset
   * @return {ContentFormat}
   */ splice(_offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */ mergeWith(_right) {
        return false;
    }
    /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */ integrate(_transaction, item) {
        // @todo searchmarker are currently unsupported for rich text documents
        const p = /** @type {YText} */ item.parent;
        p._searchMarker = null;
        p._hasFormatting = true;
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeKey(this.key);
        encoder.writeJSON(this.value);
    }
    /**
   * @return {number}
   */ getRef() {
        return 6;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentFormat}
 */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());
/**
 * @private
 */ class ContentJSON {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentJSON}
   */ copy() {
        return new ContentJSON(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentJSON}
   */ splice(offset) {
        const right = new ContentJSON(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentJSON} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeString(c === undefined ? "undefined" : JSON.stringify(c));
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 2;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentJSON}
 */ const readContentJSON = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++){
        const c = decoder.readString();
        if (c === "undefined") cs.push(undefined);
        else cs.push(JSON.parse(c));
    }
    return new ContentJSON(cs);
};
class ContentAny {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentAny}
   */ copy() {
        return new ContentAny(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentAny}
   */ splice(offset) {
        const right = new ContentAny(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentAny} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeAny(c);
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 8;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentAny}
 */ const readContentAny = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++)cs.push(decoder.readAny());
    return new ContentAny(cs);
};
/**
 * @private
 */ class ContentString {
    /**
   * @param {string} str
   */ constructor(str){
        /**
     * @type {string}
     */ this.str = str;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.str.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.str.split("");
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentString}
   */ copy() {
        return new ContentString(this.str);
    }
    /**
   * @param {number} offset
   * @return {ContentString}
   */ splice(offset) {
        const right = new ContentString(this.str.slice(offset));
        this.str = this.str.slice(0, offset);
        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
        const firstCharCode = this.str.charCodeAt(offset - 1);
        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
            // We don't support splitting of surrogate pairs because this may lead to invalid documents.
            // Replace the invalid character with a unicode replacement character (ÔøΩ / U+FFFD)
            this.str = this.str.slice(0, offset - 1) + "ÔøΩ";
            // replace right as well
            right.str = "ÔøΩ" + right.str.slice(1);
        }
        return right;
    }
    /**
   * @param {ContentString} right
   * @return {boolean}
   */ mergeWith(right) {
        this.str += right.str;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
   * @return {number}
   */ getRef() {
        return 4;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentString}
 */ const readContentString = (decoder)=>new ContentString(decoder.readString());
/**
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}
 * @private
 */ const typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
];
const YArrayRefID = 0;
const YMapRefID = 1;
const YTextRefID = 2;
const YXmlElementRefID = 3;
const YXmlFragmentRefID = 4;
const YXmlHookRefID = 5;
const YXmlTextRefID = 6;
/**
 * @private
 */ class ContentType {
    /**
   * @param {AbstractType<any>} type
   */ constructor(type){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.type
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentType}
   */ copy() {
        return new ContentType(this.type._copy());
    }
    /**
   * @param {number} offset
   * @return {ContentType}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentType} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        this.type._integrate(transaction.doc, item);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        let item = this.type._start;
        while(item !== null){
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // This will be gc'd later and we want to merge it if possible
            // We try to merge all deleted items after each transaction,
            // but we have no knowledge about that this needs to be merged
            // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
            transaction._mergeStructs.push(item);
            item = item.right;
        }
        this.type._map.forEach((item)=>{
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // same as above
            transaction._mergeStructs.push(item);
        });
        transaction.changed.delete(this.type);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {
        let item = this.type._start;
        while(item !== null){
            item.gc(store, true);
            item = item.right;
        }
        this.type._start = null;
        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{
            while(item !== null){
                item.gc(store, true);
                item = item.left;
            }
        });
        this.type._map = new Map();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        this.type._write(encoder);
    }
    /**
   * @return {number}
   */ getRef() {
        return 7;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentType}
 */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));
/**
 * @todo This should return several items
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {{item:Item, diff:number}}
 */ const followRedone = (store, id)=>{
    /**
   * @type {ID|null}
   */ let nextID = id;
    let diff = 0;
    let item;
    do {
        if (diff > 0) nextID = createID(nextID.client, nextID.clock + diff);
        item = getItem(store, nextID);
        diff = nextID.clock - item.id.clock;
        nextID = item.redone;
    }while (nextID !== null && item instanceof Item);
    return {
        item,
        diff
    };
};
/**
 * Make sure that neither item nor any of its parents is ever deleted.
 *
 * This property does not persist when storing it into a database or when
 * sending it to other peers
 *
 * @param {Item|null} item
 * @param {boolean} keep
 */ const keepItem = (item, keep)=>{
    while(item !== null && item.keep !== keep){
        item.keep = keep;
        item = /** @type {AbstractType<any>} */ item.parent._item;
    }
};
/**
 * Split leftItem into two items
 * @param {Transaction} transaction
 * @param {Item} leftItem
 * @param {number} diff
 * @return {Item}
 *
 * @function
 * @private
 */ const splitItem = (transaction, leftItem, diff)=>{
    // create rightItem
    const { client, clock } = leftItem.id;
    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    if (leftItem.deleted) rightItem.markDeleted();
    if (leftItem.keep) rightItem.keep = true;
    if (leftItem.redone !== null) rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
    leftItem.right = rightItem;
    // update right
    if (rightItem.right !== null) rightItem.right.left = rightItem;
    // right is more specific.
    transaction._mergeStructs.push(rightItem);
    // update parent._map
    if (rightItem.parentSub !== null && rightItem.right === null) /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);
    leftItem.length = diff;
    return rightItem;
};
/**
 * @param {Array<StackItem>} stack
 * @param {ID} id
 */ const isDeletedByUndoStack = (stack, id)=>_array.some(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));
/**
 * Redoes the effect of this operation.
 *
 * @param {Transaction} transaction The Yjs instance.
 * @param {Item} item
 * @param {Set<Item>} redoitems
 * @param {DeleteSet} itemsToDelete
 * @param {boolean} ignoreRemoteMapChanges
 * @param {import('../utils/UndoManager.js').UndoManager} um
 *
 * @return {Item|null}
 *
 * @private
 */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{
    const doc = transaction.doc;
    const store = doc.store;
    const ownClientID = doc.clientID;
    const redone = item.redone;
    if (redone !== null) return getItemCleanStart(transaction, redone);
    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;
    /**
   * @type {Item|null}
   */ let left = null;
    /**
   * @type {Item|null}
   */ let right;
    // make sure that parent is redone
    if (parentItem !== null && parentItem.deleted === true) {
        // try to undo parent if it will be undone anyway
        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) return null;
        while(parentItem.redone !== null)parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
    const parentType = parentItem === null ? /** @type {AbstractType<any>} */ item.parent : /** @type {ContentType} */ parentItem.content.type;
    if (item.parentSub === null) {
        // Is an array item. Insert at the old position
        left = item.left;
        right = item;
        // find next cloned_redo items
        while(left !== null){
            /**
       * @type {Item|null}
       */ let leftTrace = left;
            // trace redone until parent matches
            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem)leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {
                left = leftTrace;
                break;
            }
            left = left.left;
        }
        while(right !== null){
            /**
       * @type {Item|null}
       */ let rightTrace = right;
            // trace redone until parent matches
            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem)rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {
                right = rightTrace;
                break;
            }
            right = right.right;
        }
    } else {
        right = null;
        if (item.right && !ignoreRemoteMapChanges) {
            left = item;
            // Iterate right while right is in itemsToDelete
            // If it is intended to delete right while item is redone, we can expect that item should replace right.
            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){
                left = left.right;
                // follow redone
                while(left.redone)left = getItemCleanStart(transaction, left.redone);
            }
            if (left && left.right !== null) // It is not possible to redo this item because it conflicts with a
            // change from another client
            return null;
        } else left = parentType._map.get(item.parentSub) || null;
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
};
/**
 * Abstract class that represents any content.
 */ class Item extends AbstractStruct {
    /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){
        super(id, content.getLength());
        /**
     * The item that was originally to the left of this item.
     * @type {ID | null}
     */ this.origin = origin;
        /**
     * The item that is currently to the left of this item.
     * @type {Item | null}
     */ this.left = left;
        /**
     * The item that is currently to the right of this item.
     * @type {Item | null}
     */ this.right = right;
        /**
     * The item that was originally to the right of this item.
     * @type {ID | null}
     */ this.rightOrigin = rightOrigin;
        /**
     * @type {AbstractType<any>|ID|null}
     */ this.parent = parent;
        /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     * @type {String | null}
     */ this.parentSub = parentSub;
        /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     * @type {ID | null}
     */ this.redone = null;
        /**
     * @type {AbstractContent}
     */ this.content = content;
        /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     * @type {number} byte
     */ this.info = this.content.isCountable() ? _binary.BIT2 : 0;
    }
    /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */ set marker(isMarked) {
        if ((this.info & _binary.BIT4) > 0 !== isMarked) this.info ^= _binary.BIT4;
    }
    get marker() {
        return (this.info & _binary.BIT4) > 0;
    }
    /**
   * If true, do not garbage collect this Item.
   */ get keep() {
        return (this.info & _binary.BIT1) > 0;
    }
    set keep(doKeep) {
        if (this.keep !== doKeep) this.info ^= _binary.BIT1;
    }
    get countable() {
        return (this.info & _binary.BIT2) > 0;
    }
    /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */ get deleted() {
        return (this.info & _binary.BIT3) > 0;
    }
    set deleted(doDelete) {
        if (this.deleted !== doDelete) this.info ^= _binary.BIT3;
    }
    markDeleted() {
        this.info |= _binary.BIT3;
    }
    /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) return this.origin.client;
        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) return this.rightOrigin.client;
        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) return this.parent.client;
        // We have all missing ids, now find the items
        if (this.origin) {
            this.left = getItemCleanEnd(transaction, store, this.origin);
            this.origin = this.left.lastId;
        }
        if (this.rightOrigin) {
            this.right = getItemCleanStart(transaction, this.rightOrigin);
            this.rightOrigin = this.right.id;
        }
        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) this.parent = null;
        else if (!this.parent) {
            // only set parent if this shouldn't be garbage collected
            if (this.left && this.left.constructor === Item) {
                this.parent = this.left.parent;
                this.parentSub = this.left.parentSub;
            }
            if (this.right && this.right.constructor === Item) {
                this.parent = this.right.parent;
                this.parentSub = this.right.parentSub;
            }
        } else if (this.parent.constructor === ID) {
            const parentItem = getItem(store, this.parent);
            if (parentItem.constructor === GC) this.parent = null;
            else this.parent = /** @type {ContentType} */ parentItem.content.type;
        }
        return null;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
            this.origin = this.left.lastId;
            this.content = this.content.splice(offset);
            this.length -= offset;
        }
        if (this.parent) {
            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
                /**
         * @type {Item|null}
         */ let left = this.left;
                /**
         * @type {Item|null}
         */ let o;
                // set o to the first conflicting item
                if (left !== null) o = left.right;
                else if (this.parentSub !== null) {
                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(o !== null && o.left !== null)o = o.left;
                } else o = /** @type {AbstractType<any>} */ this.parent._start;
                // TODO: use something like DeleteSet here (a tree implementation would be best)
                // @todo use global set definitions
                /**
         * @type {Set<Item>}
         */ const conflictingItems = new Set();
                /**
         * @type {Set<Item>}
         */ const itemsBeforeOrigin = new Set();
                // Let c in conflictingItems, b in itemsBeforeOrigin
                // ***{origin}bbbb{this}{c,b}{c,b}{o}***
                // Note that conflictingItems is a subset of itemsBeforeOrigin
                while(o !== null && o !== this.right){
                    itemsBeforeOrigin.add(o);
                    conflictingItems.add(o);
                    if (compareIDs(this.origin, o.origin)) {
                        // case 1
                        if (o.id.client < this.id.client) {
                            left = o;
                            conflictingItems.clear();
                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) break;
                         // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) // case 2
                    {
                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                            left = o;
                            conflictingItems.clear();
                        }
                    } else break;
                    o = o.right;
                }
                this.left = left;
            }
            // reconnect left/right + update parent map/start if necessary
            if (this.left !== null) {
                const right = this.left.right;
                this.right = right;
                this.left.right = this;
            } else {
                let r;
                if (this.parentSub !== null) {
                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(r !== null && r.left !== null)r = r.left;
                } else {
                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ 
                    this.parent._start = this;
                }
                this.right = r;
            }
            if (this.right !== null) this.right.left = this;
            else if (this.parentSub !== null) {
                // set as current parent value if right === null and this is parentSub
                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);
                if (this.left !== null) // this is the current attribute value of parent. delete right
                this.left.delete(transaction);
            }
            // adjust length of parent
            if (this.parentSub === null && this.countable && !this.deleted) /** @type {AbstractType<any>} */ this.parent._length += this.length;
            addStruct(transaction.doc.store, this);
            this.content.integrate(transaction, this);
            // add parent to transaction.changed
            addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ this.parent, this.parentSub);
            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) // delete if parent is deleted or if this is not the current attribute value of parent
            this.delete(transaction);
        } else // parent is not defined. Integrate GC struct instead
        new GC(this.id, this.length).integrate(transaction, 0);
    }
    /**
   * Returns the next non-deleted item
   */ get next() {
        let n = this.right;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Returns the previous non-deleted item
   */ get prev() {
        let n = this.left;
        while(n !== null && n.deleted)n = n.left;
        return n;
    }
    /**
   * Computes the last content address of this Item.
   */ get lastId() {
        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;
            if (searchMarker) searchMarker.forEach((marker)=>{
                if (marker.p === right) {
                    // right is going to be "forgotten" so we need to update the marker
                    marker.p = this;
                    // adjust marker index
                    if (!this.deleted && this.countable) marker.index -= this.length;
                }
            });
            if (right.keep) this.keep = true;
            this.right = right.right;
            if (this.right !== null) this.right.left = this;
            this.length += right.length;
            return true;
        }
        return false;
    }
    /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (!this.deleted) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            // adjust the length of parent
            if (this.countable && this.parentSub === null) parent._length -= this.length;
            this.markDeleted();
            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
            addChangedTypeToTransaction(transaction, parent, this.parentSub);
            this.content.delete(transaction);
        }
    }
    /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */ gc(store, parentGCd) {
        if (!this.deleted) throw _error.unexpectedCase();
        this.content.gc(store);
        if (parentGCd) replaceStruct(store, this, new GC(this.id, this.length));
        else this.content = new ContentDeleted(this.length);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */ write(encoder, offset) {
        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
        const rightOrigin = this.rightOrigin;
        const parentSub = this.parentSub;
        const info = this.content.getRef() & _binary.BITS5 | (origin === null ? 0 : _binary.BIT8) | // origin is defined
        (rightOrigin === null ? 0 : _binary.BIT7) | // right origin is defined
        (parentSub === null ? 0 : _binary.BIT6); // parentSub is non-null
        encoder.writeInfo(info);
        if (origin !== null) encoder.writeLeftID(origin);
        if (rightOrigin !== null) encoder.writeRightID(rightOrigin);
        if (origin === null && rightOrigin === null) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            if (parent._item !== undefined) {
                const parentItem = parent._item;
                if (parentItem === null) {
                    // parent type on y._map
                    // find the correct key
                    const ykey = findRootTypeKey(parent);
                    encoder.writeParentInfo(true); // write parentYKey
                    encoder.writeString(ykey);
                } else {
                    encoder.writeParentInfo(false); // write parent id
                    encoder.writeLeftID(parentItem.id);
                }
            } else if (parent.constructor === String) {
                encoder.writeParentInfo(true); // write parentYKey
                encoder.writeString(parent);
            } else if (parent.constructor === ID) {
                encoder.writeParentInfo(false); // write parent id
                encoder.writeLeftID(parent);
            } else _error.unexpectedCase();
            if (parentSub !== null) encoder.writeString(parentSub);
        }
        this.content.write(encoder, offset);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @param {number} info
 */ const readItemContent = (decoder, info)=>contentRefs[info & _binary.BITS5](decoder);
/**
 * A lookup map for reading Item content.
 *
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
 */ const contentRefs = [
    ()=>{
        _error.unexpectedCase();
    },
    readContentDeleted,
    readContentJSON,
    readContentBinary,
    readContentString,
    readContentEmbed,
    readContentFormat,
    readContentType,
    readContentAny,
    readContentDoc,
    ()=>{
        _error.unexpectedCase();
    } // 10 - Skip is not ItemContent
];
const structSkipRefNumber = 10;
/**
 * @private
 */ class Skip extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {Skip} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        // skip structs cannot be integrated
        _error.unexpectedCase();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structSkipRefNumber);
        // write as VarUint because Skips can't make use of predictable length-encoding
        _encoding.writeVarUint(encoder.restEncoder, this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
/** eslint-env browser */ const glo = /** @type {any} */ typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
const importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) /**
   * Dear reader of this message. Please take this seriously.
   *
   * If you see this message, make sure that you only import one version of Yjs. In many cases,
   * your package manager installs two versions of Yjs that are used by different packages within your project.
   * Another reason for this message is that some parts of your project use the commonjs version of Yjs
   * and others use the EcmaScript version of Yjs.
   *
   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
   * do the constructor checks anymore - which might break the CRDT algorithm.
   *
   * https://github.com/yjs/yjs/issues/438
   */ console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
glo[importIdentifier] = true;

},{"lib0/observable":"byLQ7","lib0/array":"k9U44","lib0/math":"99M3Z","lib0/map":"b1fdO","lib0/encoding":"h5JHW","lib0/decoding":"1twFz","lib0/random":"bMWgJ","lib0/promise":"4EVk5","lib0/buffer":"3Ygoc","lib0/error":"36p1r","lib0/binary":"l546T","lib0/function":"3Eway","lib0/set":"ilJ09","lib0/logging":"04jLW","lib0/time":"3YA6c","lib0/string":"6sDcK","lib0/iterator":"4bgn6","lib0/object":"Xrj2S","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"byLQ7":[function(require,module,exports) {
/**
 * Observable class prototype.
 *
 * @module observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Handles named events.
 * @experimental
 *
 * This is basically a (better typed) duplicate of Observable, which will replace Observable in the
 * next release.
 *
 * @template {{[key: string]: function(...any):void}} EVENTS
 */ parcelHelpers.export(exports, "ObservableV2", ()=>ObservableV2);
/* c8 ignore start */ /**
 * Handles named events.
 *
 * @deprecated
 * @template N
 */ parcelHelpers.export(exports, "Observable", ()=>Observable) /* c8 ignore end */ ;
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _arrayJs = require("./array.js");
class ObservableV2 {
    constructor(){
        /**
     * Some desc.
     * @type {Map<string, Set<any>>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @template {string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, /** @type {string} */ name, _setJs.create).add(f);
        return f;
    }
    /**
   * @template {string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, /** @type {any} */ _f);
            f(...args);
        };
        this.on(name, /** @type {any} */ _f);
    }
    /**
   * @template {string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}
class Observable {
    constructor(){
        /**
     * Some desc.
     * @type {Map<N, any>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @param {N} name
   * @param {function} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, name, _setJs.create).add(f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, _f);
            f(...args);
        };
        this.on(name, _f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}

},{"./map.js":"b1fdO","./set.js":"ilJ09","./array.js":"k9U44","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"b1fdO":[function(require,module,exports) {
/**
 * Utility module to work with key-value stores.
 *
 * @module map
 */ /**
 * Creates a new Map instance.
 *
 * @function
 * @return {Map<any, any>}
 *
 * @function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "setIfUndefined", ()=>setIfUndefined);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "all", ()=>all);
const create = ()=>new Map();
const copy = (m)=>{
    const r = create();
    m.forEach((v, k)=>{
        r.set(k, v);
    });
    return r;
};
const setIfUndefined = (map, key, createT)=>{
    let set = map.get(key);
    if (set === undefined) map.set(key, set = createT());
    return set;
};
const map = (m, f)=>{
    const res = [];
    for (const [key, value] of m)res.push(f(value, key));
    return res;
};
const any = (m, f)=>{
    for (const [key, value] of m){
        if (f(value, key)) return true;
    }
    return false;
};
const all = (m, f)=>{
    for (const [key, value] of m){
        if (!f(value, key)) return false;
    }
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ilJ09":[function(require,module,exports) {
/**
 * Utility module to work with sets.
 *
 * @module set
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "from", ()=>from);
const create = ()=>new Set();
const toArray = (set)=>Array.from(set);
const first = (set)=>set.values().next().value || undefined;
const from = (entries)=>new Set(entries);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"k9U44":[function(require,module,exports) {
/**
 * Utility module to work with Arrays.
 *
 * @module array
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "appendTo", ()=>appendTo);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "fold", ()=>fold);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "unique", ()=>unique);
parcelHelpers.export(exports, "uniqueBy", ()=>uniqueBy);
parcelHelpers.export(exports, "map", ()=>map);
var _setJs = require("./set.js");
const last = (arr)=>arr[arr.length - 1];
const create = ()=>/** @type {Array<C>} */ [];
const copy = (a)=>/** @type {Array<D>} */ a.slice();
const appendTo = (dest, src)=>{
    for(let i = 0; i < src.length; i++)dest.push(src[i]);
};
const from = Array.from;
const every = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (!f(arr[i], i, arr)) return false;
    }
    return true;
};
const some = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (f(arr[i], i, arr)) return true;
    }
    return false;
};
const equalFlat = (a, b)=>a.length === b.length && every(a, (item, index)=>item === b[index]);
const flatten = (arr)=>fold(arr, /** @type {Array<ELEM>} */ [], (acc, val)=>acc.concat(val));
const unfold = (len, f)=>{
    const array = new Array(len);
    for(let i = 0; i < len; i++)array[i] = f(i, array);
    return array;
};
const fold = (arr, seed, folder)=>arr.reduce(folder, seed);
const isArray = Array.isArray;
const unique = (arr)=>from(_setJs.from(arr));
const uniqueBy = (arr, mapper)=>{
    /**
   * @type {Set<M>}
   */ const happened = _setJs.create();
    /**
   * @type {Array<T>}
   */ const result = [];
    for(let i = 0; i < arr.length; i++){
        const el = arr[i];
        const mapped = mapper(el);
        if (!happened.has(mapped)) {
            happened.add(mapped);
            result.push(el);
        }
    }
    return result;
};
const map = (arr, mapper)=>{
    /**
   * @type {Array<any>}
   */ const res = Array(arr.length);
    for(let i = 0; i < arr.length; i++)res[i] = mapper(/** @type {any} */ arr[i], i, /** @type {any} */ arr);
    return /** @type {any} */ res;
};

},{"./set.js":"ilJ09","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"99M3Z":[function(require,module,exports) {
/**
 * Common Math expressions.
 *
 * @module math
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor);
parcelHelpers.export(exports, "ceil", ()=>ceil);
parcelHelpers.export(exports, "abs", ()=>abs);
parcelHelpers.export(exports, "imul", ()=>imul);
parcelHelpers.export(exports, "round", ()=>round);
parcelHelpers.export(exports, "log10", ()=>log10);
parcelHelpers.export(exports, "log2", ()=>log2);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "sqrt", ()=>sqrt);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "pow", ()=>pow);
parcelHelpers.export(exports, "exp10", ()=>exp10);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "isNegativeZero", ()=>isNegativeZero);
const floor = Math.floor;
const ceil = Math.ceil;
const abs = Math.abs;
const imul = Math.imul;
const round = Math.round;
const log10 = Math.log10;
const log2 = Math.log2;
const log = Math.log;
const sqrt = Math.sqrt;
const add = (a, b)=>a + b;
const min = (a, b)=>a < b ? a : b;
const max = (a, b)=>a > b ? a : b;
const isNaN = Number.isNaN;
const pow = Math.pow;
const exp10 = (exp)=>Math.pow(10, exp);
const sign = Math.sign;
const isNegativeZero = (n)=>n !== 0 ? n < 0 : 1 / n < 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"h5JHW":[function(require,module,exports) {
/**
 * Efficient schema-less binary encoding with support for variable length encoding.
 *
 * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module encoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A BinaryEncoder handles the encoding to an Uint8Array.
 */ parcelHelpers.export(exports, "Encoder", ()=>Encoder);
parcelHelpers.export(exports, "createEncoder", ()=>createEncoder);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "toUint8Array", ()=>toUint8Array);
parcelHelpers.export(exports, "verifyLen", ()=>verifyLen);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "writeUint8", ()=>writeUint8);
parcelHelpers.export(exports, "setUint8", ()=>setUint8);
parcelHelpers.export(exports, "writeUint16", ()=>writeUint16);
parcelHelpers.export(exports, "setUint16", ()=>setUint16);
parcelHelpers.export(exports, "writeUint32", ()=>writeUint32);
parcelHelpers.export(exports, "writeUint32BigEndian", ()=>writeUint32BigEndian);
parcelHelpers.export(exports, "setUint32", ()=>setUint32);
parcelHelpers.export(exports, "writeVarUint", ()=>writeVarUint);
parcelHelpers.export(exports, "writeVarInt", ()=>writeVarInt);
parcelHelpers.export(exports, "_writeVarStringNative", ()=>_writeVarStringNative);
parcelHelpers.export(exports, "_writeVarStringPolyfill", ()=>_writeVarStringPolyfill);
parcelHelpers.export(exports, "writeVarString", ()=>writeVarString);
parcelHelpers.export(exports, "writeTerminatedString", ()=>writeTerminatedString);
parcelHelpers.export(exports, "writeTerminatedUint8Array", ()=>writeTerminatedUint8Array);
parcelHelpers.export(exports, "writeBinaryEncoder", ()=>writeBinaryEncoder);
parcelHelpers.export(exports, "writeUint8Array", ()=>writeUint8Array);
parcelHelpers.export(exports, "writeVarUint8Array", ()=>writeVarUint8Array);
parcelHelpers.export(exports, "writeOnDataView", ()=>writeOnDataView);
parcelHelpers.export(exports, "writeFloat32", ()=>writeFloat32);
parcelHelpers.export(exports, "writeFloat64", ()=>writeFloat64);
parcelHelpers.export(exports, "writeBigInt64", ()=>writeBigInt64);
parcelHelpers.export(exports, "writeBigUint64", ()=>writeBigUint64);
parcelHelpers.export(exports, "writeAny", ()=>writeAny);
/**
 * Now come a few stateful encoder that have their own classes.
 */ /**
 * Basic Run Length Encoder - a basic compression implementation.
 *
 * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.
 *
 * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf
 *
 * @note T must not be null!
 *
 * @template T
 */ parcelHelpers.export(exports, "RleEncoder", ()=>RleEncoder);
/**
 * Basic diff decoder using variable length encoding.
 *
 * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.
 */ parcelHelpers.export(exports, "IntDiffEncoder", ()=>IntDiffEncoder);
/**
 * A combination of IntDiffEncoder and RleEncoder.
 *
 * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.
 *
 * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ‚áí RleIntDiff[1,1,0,2,1,5])
 */ parcelHelpers.export(exports, "RleIntDiffEncoder", ()=>RleIntDiffEncoder);
/**
 * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.
 *
 * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write
 * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.
 *
 * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)
 */ parcelHelpers.export(exports, "UintOptRleEncoder", ()=>UintOptRleEncoder);
/**
 * Increasing Uint Optimized RLE Encoder
 *
 * The RLE encoder counts the number of same occurences of the same value.
 * The IncUintOptRle encoder counts if the value increases.
 * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded
 * as [1, 3, 5].
 */ parcelHelpers.export(exports, "IncUintOptRleEncoder", ()=>IncUintOptRleEncoder);
/**
 * A combination of the IntDiffEncoder and the UintOptRleEncoder.
 *
 * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes
 * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!
 *
 * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])
 *
 * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:
 * * 1 bit that denotes whether the next value is a count (LSB)
 * * 1 bit that denotes whether this value is negative (MSB - 1)
 * * 1 bit that denotes whether to continue reading the variable length integer (MSB)
 *
 * Therefore, only five bits remain to encode diff ranges.
 *
 * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.
 */ parcelHelpers.export(exports, "IntDiffOptRleEncoder", ()=>IntDiffOptRleEncoder);
/**
 * Optimized String Encoder.
 *
 * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.
 * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).
 *
 * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.
 *
 * The lengths are encoded using a UintOptRleEncoder.
 */ parcelHelpers.export(exports, "StringEncoder", ()=>StringEncoder);
var _bufferJs = require("./buffer.js");
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _binaryJs = require("./binary.js");
var _stringJs = require("./string.js");
var _arrayJs = require("./array.js");
class Encoder {
    constructor(){
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        /**
     * @type {Array<Uint8Array>}
     */ this.bufs = [];
    }
}
const createEncoder = ()=>new Encoder();
const encode = (f)=>{
    const encoder = createEncoder();
    f(encoder);
    return toUint8Array(encoder);
};
const length = (encoder)=>{
    let len = encoder.cpos;
    for(let i = 0; i < encoder.bufs.length; i++)len += encoder.bufs[i].length;
    return len;
};
const hasContent = (encoder)=>encoder.cpos > 0 || encoder.bufs.length > 0;
const toUint8Array = (encoder)=>{
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for(let i = 0; i < encoder.bufs.length; i++){
        const d = encoder.bufs[i];
        uint8arr.set(d, curPos);
        curPos += d.length;
    }
    uint8arr.set(_bufferJs.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
};
const verifyLen = (encoder, len)=>{
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
        encoder.bufs.push(_bufferJs.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen, len) * 2);
        encoder.cpos = 0;
    }
};
const write = (encoder, num)=>{
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(bufferLen * 2);
        encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
};
const set = (encoder, pos, num)=>{
    let buffer = null;
    // iterate all buffers and adjust position
    for(let i = 0; i < encoder.bufs.length && buffer === null; i++){
        const b = encoder.bufs[i];
        if (pos < b.length) buffer = b // found buffer
        ;
        else pos -= b.length;
    }
    if (buffer === null) // use current buffer
    buffer = encoder.cbuf;
    buffer[pos] = num;
};
const writeUint8 = write;
const setUint8 = set;
const writeUint16 = (encoder, num)=>{
    write(encoder, num & _binaryJs.BITS8);
    write(encoder, num >>> 8 & _binaryJs.BITS8);
};
const setUint16 = (encoder, pos, num)=>{
    set(encoder, pos, num & _binaryJs.BITS8);
    set(encoder, pos + 1, num >>> 8 & _binaryJs.BITS8);
};
const writeUint32 = (encoder, num)=>{
    for(let i = 0; i < 4; i++){
        write(encoder, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeUint32BigEndian = (encoder, num)=>{
    for(let i = 3; i >= 0; i--)write(encoder, num >>> 8 * i & _binaryJs.BITS8);
};
const setUint32 = (encoder, pos, num)=>{
    for(let i = 0; i < 4; i++){
        set(encoder, pos + i, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeVarUint = (encoder, num)=>{
    while(num > _binaryJs.BITS7){
        write(encoder, _binaryJs.BIT8 | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
    write(encoder, _binaryJs.BITS7 & num);
};
const writeVarInt = (encoder, num)=>{
    const isNegative = _mathJs.isNegativeZero(num);
    if (isNegative) num = -num;
    //             |- whether to continue reading         |- whether is negative     |- number
    write(encoder, (num > _binaryJs.BITS6 ? _binaryJs.BIT8 : 0) | (isNegative ? _binaryJs.BIT7 : 0) | _binaryJs.BITS6 & num);
    num = _mathJs.floor(num / 64) // shift >>> 6
    ;
    // We don't need to consider the case of num === 0 so we can use a different
    // pattern here than above.
    while(num > 0){
        write(encoder, (num > _binaryJs.BITS7 ? _binaryJs.BIT8 : 0) | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
};
/**
 * A cache to store strings temporarily
 */ const _strBuffer = new Uint8Array(30000);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str)=>{
    if (str.length < _maxStrBSize) {
        // We can encode the string into the existing buffer
        /* c8 ignore next */ const written = _stringJs.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
        writeVarUint(encoder, written);
        for(let i = 0; i < written; i++)write(encoder, _strBuffer[i]);
    } else writeVarUint8Array(encoder, _stringJs.encodeUtf8(str));
};
const _writeVarStringPolyfill = (encoder, str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for(let i = 0; i < len; i++)write(encoder, /** @type {number} */ encodedString.codePointAt(i));
};
const writeVarString = _stringJs.utf8TextEncoder && /** @type {any} */ _stringJs.utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeTerminatedString = (encoder, str)=>writeTerminatedUint8Array(encoder, _stringJs.encodeUtf8(str));
const writeTerminatedUint8Array = (encoder, buf)=>{
    for(let i = 0; i < buf.length; i++){
        const b = buf[i];
        if (b === 0 || b === 1) write(encoder, 1);
        write(encoder, buf[i]);
    }
    write(encoder, 0);
};
const writeBinaryEncoder = (encoder, append)=>writeUint8Array(encoder, toUint8Array(append));
const writeUint8Array = (encoder, uint8Array)=>{
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = _mathJs.min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
        // Still something to write, write right half..
        // Append new buffer
        encoder.bufs.push(encoder.cbuf);
        // must have at least size of remaining buffer
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen * 2, rightCopyLen));
        // copy array
        encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
        encoder.cpos = rightCopyLen;
    }
};
const writeVarUint8Array = (encoder, uint8Array)=>{
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len)=>{
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
};
const writeFloat32 = (encoder, num)=>writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num)=>writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigInt64(0, num, false);
const writeBigUint64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigUint64(0, num, false);
const floatTestBed = new DataView(new ArrayBuffer(4));
/**
 * Check if a number can be encoded as a 32 bit float.
 *
 * @param {number} num
 * @return {boolean}
 */ const isFloat32 = (num)=>{
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data)=>{
    switch(typeof data){
        case "string":
            // TYPE 119: STRING
            write(encoder, 119);
            writeVarString(encoder, data);
            break;
        case "number":
            if (_numberJs.isInteger(data) && _mathJs.abs(data) <= _binaryJs.BITS31) {
                // TYPE 125: INTEGER
                write(encoder, 125);
                writeVarInt(encoder, data);
            } else if (isFloat32(data)) {
                // TYPE 124: FLOAT32
                write(encoder, 124);
                writeFloat32(encoder, data);
            } else {
                // TYPE 123: FLOAT64
                write(encoder, 123);
                writeFloat64(encoder, data);
            }
            break;
        case "bigint":
            // TYPE 122: BigInt
            write(encoder, 122);
            writeBigInt64(encoder, data);
            break;
        case "object":
            if (data === null) // TYPE 126: null
            write(encoder, 126);
            else if (_arrayJs.isArray(data)) {
                // TYPE 117: Array
                write(encoder, 117);
                writeVarUint(encoder, data.length);
                for(let i = 0; i < data.length; i++)writeAny(encoder, data[i]);
            } else if (data instanceof Uint8Array) {
                // TYPE 116: ArrayBuffer
                write(encoder, 116);
                writeVarUint8Array(encoder, data);
            } else {
                // TYPE 118: Object
                write(encoder, 118);
                const keys = Object.keys(data);
                writeVarUint(encoder, keys.length);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    writeVarString(encoder, key);
                    writeAny(encoder, data[key]);
                }
            }
            break;
        case "boolean":
            // TYPE 120/121: boolean (true/false)
            write(encoder, data ? 120 : 121);
            break;
        default:
            // TYPE 127: undefined
            write(encoder, 127);
    }
};
class RleEncoder extends Encoder {
    /**
   * @param {function(Encoder, T):void} writer
   */ constructor(writer){
        super();
        /**
     * The writer
     */ this.w = writer;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    /**
   * @param {T} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            this.w(this, v);
            this.s = v;
        }
    }
}
class IntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @param {number} v
   */ write(v) {
        writeVarInt(this, v - this.s);
        this.s = v;
    }
}
class RleIntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v && this.count > 0) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            writeVarInt(this, v - this.s);
            this.s = v;
        }
    }
}
/**
 * @param {UintOptRleEncoder} encoder
 */ const flushUintOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set sign to positive
        // case 2: write several values. set sign to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class UintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class IncUintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s + this.count === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
/**
 * @param {IntDiffOptRleEncoder} encoder
 */ const flushIntDiffOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        //          31 bit making up the diff | wether to write the counter
        // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)
        const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set first bit to positive
        // case 2: write several values. set first bit to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encodedDiff);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class IntDiffOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.diff === v - this.s) {
            this.s = v;
            this.count++;
        } else {
            flushIntDiffOptRleEncoder(this);
            this.count = 1;
            this.diff = v - this.s;
            this.s = v;
        }
    }
    toUint8Array() {
        flushIntDiffOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class StringEncoder {
    constructor(){
        /**
     * @type {Array<string>}
     */ this.sarr = [];
        this.s = "";
        this.lensE = new UintOptRleEncoder();
    }
    /**
   * @param {string} string
   */ write(string) {
        this.s += string;
        if (this.s.length > 19) {
            this.sarr.push(this.s);
            this.s = "";
        }
        this.lensE.write(string.length);
    }
    toUint8Array() {
        const encoder = new Encoder();
        this.sarr.push(this.s);
        this.s = "";
        writeVarString(encoder, this.sarr.join(""));
        writeUint8Array(encoder, this.lensE.toUint8Array());
        return toUint8Array(encoder);
    }
}

},{"./buffer.js":"3Ygoc","./math.js":"99M3Z","./number.js":"j24S2","./binary.js":"l546T","./string.js":"6sDcK","./array.js":"k9U44","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3Ygoc":[function(require,module,exports) {
/**
 * Utility functions to work with buffers (Uint8Array).
 *
 * @module buffer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createUint8ArrayFromLen", ()=>createUint8ArrayFromLen);
parcelHelpers.export(exports, "createUint8ArrayViewFromArrayBuffer", ()=>createUint8ArrayViewFromArrayBuffer);
parcelHelpers.export(exports, "createUint8ArrayFromArrayBuffer", ()=>createUint8ArrayFromArrayBuffer);
parcelHelpers.export(exports, "toBase64", ()=>toBase64);
parcelHelpers.export(exports, "fromBase64", ()=>fromBase64);
parcelHelpers.export(exports, "toBase64UrlEncoded", ()=>toBase64UrlEncoded);
parcelHelpers.export(exports, "fromBase64UrlEncoded", ()=>fromBase64UrlEncoded);
parcelHelpers.export(exports, "toHexString", ()=>toHexString);
parcelHelpers.export(exports, "fromHexString", ()=>fromHexString);
parcelHelpers.export(exports, "copyUint8Array", ()=>copyUint8Array);
parcelHelpers.export(exports, "encodeAny", ()=>encodeAny);
parcelHelpers.export(exports, "decodeAny", ()=>decodeAny);
parcelHelpers.export(exports, "shiftNBitsLeft", ()=>shiftNBitsLeft);
var _stringJs = require("./string.js");
var _environmentJs = require("./environment.js");
var _arrayJs = require("./array.js");
var _mathJs = require("./math.js");
var _encodingJs = require("./encoding.js");
var _decodingJs = require("./decoding.js");
var Buffer = require("6475e0e5014d10a8").Buffer;
const createUint8ArrayFromLen = (len)=>new Uint8Array(len);
const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length)=>new Uint8Array(buffer, byteOffset, length);
const createUint8ArrayFromArrayBuffer = (buffer)=>new Uint8Array(buffer);
/* c8 ignore start */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Browser = (bytes)=>{
    let s = "";
    for(let i = 0; i < bytes.byteLength; i++)s += _stringJs.fromCharCode(bytes[i]);
    // eslint-disable-next-line no-undef
    return btoa(s);
};
/* c8 ignore stop */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Node = (bytes)=>Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
/* c8 ignore start */ /**
 * @param {string} s
 * @return {Uint8Array}
 */ const fromBase64Browser = (s)=>{
    // eslint-disable-next-line no-undef
    const a = atob(s);
    const bytes = createUint8ArrayFromLen(a.length);
    for(let i = 0; i < a.length; i++)bytes[i] = a.charCodeAt(i);
    return bytes;
};
/* c8 ignore stop */ /**
 * @param {string} s
 */ const fromBase64Node = (s)=>{
    const buf = Buffer.from(s, "base64");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
};
const toBase64 = _environmentJs.isBrowser ? toBase64Browser : toBase64Node;
const fromBase64 = _environmentJs.isBrowser ? fromBase64Browser : fromBase64Node;
const toBase64UrlEncoded = (buf)=>toBase64(buf).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
const fromBase64UrlEncoded = (base64)=>fromBase64(base64.replaceAll("-", "+").replaceAll("_", "/"));
const toHexString = (buf)=>_arrayJs.map(buf, (b)=>b.toString(16).padStart(2, "0")).join("");
const fromHexString = (hex)=>{
    const hlen = hex.length;
    const buf = new Uint8Array(_mathJs.ceil(hlen / 2));
    for(let i = 0; i < hlen; i += 2)buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
    return buf;
};
const copyUint8Array = (uint8Array)=>{
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
};
const encodeAny = (data)=>{
    const encoder = _encodingJs.createEncoder();
    _encodingJs.writeAny(encoder, data);
    return _encodingJs.toUint8Array(encoder);
};
const decodeAny = (buf)=>_decodingJs.readAny(_decodingJs.createDecoder(buf));
const shiftNBitsLeft = (bs, N)=>{
    if (N === 0) return bs;
    bs = new Uint8Array(bs);
    bs[0] <<= N;
    for(let i = 1; i < bs.length; i++){
        bs[i - 1] |= bs[i] >>> 8 - N;
        bs[i] <<= N;
    }
    return bs;
};

},{"6475e0e5014d10a8":"6tQNr","./string.js":"6sDcK","./environment.js":"j9Zn1","./array.js":"k9U44","./math.js":"99M3Z","./encoding.js":"h5JHW","./decoding.js":"1twFz","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6sDcK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromCharCode", ()=>fromCharCode);
parcelHelpers.export(exports, "fromCodePoint", ()=>fromCodePoint);
parcelHelpers.export(exports, "MAX_UTF16_CHARACTER", ()=>MAX_UTF16_CHARACTER);
parcelHelpers.export(exports, "trimLeft", ()=>trimLeft);
parcelHelpers.export(exports, "fromCamelCase", ()=>fromCamelCase);
parcelHelpers.export(exports, "utf8ByteLength", ()=>utf8ByteLength);
parcelHelpers.export(exports, "_encodeUtf8Polyfill", ()=>_encodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextEncoder", ()=>utf8TextEncoder);
parcelHelpers.export(exports, "_encodeUtf8Native", ()=>_encodeUtf8Native);
parcelHelpers.export(exports, "encodeUtf8", ()=>encodeUtf8);
parcelHelpers.export(exports, "_decodeUtf8Polyfill", ()=>_decodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextDecoder", ()=>utf8TextDecoder);
parcelHelpers.export(exports, "_decodeUtf8Native", ()=>_decodeUtf8Native);
parcelHelpers.export(exports, "decodeUtf8", ()=>decodeUtf8);
parcelHelpers.export(exports, "splice", ()=>splice);
parcelHelpers.export(exports, "repeat", ()=>repeat);
var _arrayJs = require("./array.js");
const fromCharCode = String.fromCharCode;
const fromCodePoint = String.fromCodePoint;
const MAX_UTF16_CHARACTER = fromCharCode(65535);
/**
 * @param {string} s
 * @return {string}
 */ const toLowerCase = (s)=>s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s)=>s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator)=>trimLeft(s.replace(fromCamelCaseRegex, (match)=>`${separator}${toLowerCase(match)}`));
const utf8ByteLength = (str)=>unescape(encodeURIComponent(str)).length;
const _encodeUtf8Polyfill = (str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for(let i = 0; i < len; i++)buf[i] = /** @type {number} */ encodedString.codePointAt(i);
    return buf;
};
const utf8TextEncoder = /** @type {TextEncoder} */ typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
const _encodeUtf8Native = (str)=>utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
const _decodeUtf8Polyfill = (buf)=>{
    let remainingLen = buf.length;
    let encodedString = "";
    let bufPos = 0;
    while(remainingLen > 0){
        const nextLen = remainingLen < 10000 ? remainingLen : 10000;
        const bytes = buf.subarray(bufPos, bufPos + nextLen);
        bufPos += nextLen;
        // Starting with ES5.1 we can supply a generic array-like object as arguments
        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
        remainingLen -= nextLen;
    }
    return decodeURIComponent(escape(encodedString));
};
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", {
    fatal: true,
    ignoreBOM: true
});
/* c8 ignore start */ if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) // Safari doesn't handle BOM correctly.
// This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call
// Another issue is that from then on no BOM chars are recognized anymore
/* c8 ignore next */ utf8TextDecoder = null;
const _decodeUtf8Native = (buf)=>/** @type {TextDecoder} */ utf8TextDecoder.decode(buf);
const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;
const splice = (str, index, remove, insert = "")=>str.slice(0, index) + insert + str.slice(index + remove);
const repeat = (source, n)=>_arrayJs.unfold(n, ()=>source).join("");

},{"./array.js":"k9U44","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j9Zn1":[function(require,module,exports) {
/**
 * Isomorphic module to work access the environment (query params, env variables).
 *
 * @module map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isMac", ()=>isMac);
parcelHelpers.export(exports, "hasParam", ()=>hasParam);
parcelHelpers.export(exports, "getParam", ()=>getParam);
parcelHelpers.export(exports, "getVariable", ()=>getVariable);
parcelHelpers.export(exports, "getConf", ()=>getConf);
parcelHelpers.export(exports, "hasConf", ()=>hasConf);
parcelHelpers.export(exports, "production", ()=>production);
parcelHelpers.export(exports, "supportsColor", ()=>supportsColor);
var _mapJs = require("./map.js");
var _stringJs = require("./string.js");
var _conditionsJs = require("./conditions.js");
var _storageJs = require("./storage.js");
var _functionJs = require("./function.js");
var process = require("2cfb8bcef1022e2a");
const isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name);
const isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
const isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
/**
 * @type {Map<string,string>}
 */ let params;
const args = [];
/* c8 ignore start */ const computeParams = ()=>{
    if (params === undefined) {
        if (isNode) {
            params = _mapJs.create();
            const pargs = process.argv;
            let currParamName = null;
            for(let i = 0; i < pargs.length; i++){
                const parg = pargs[i];
                if (parg[0] === "-") {
                    if (currParamName !== null) params.set(currParamName, "");
                    currParamName = parg;
                } else if (currParamName !== null) {
                    params.set(currParamName, parg);
                    currParamName = null;
                } else args.push(parg);
            }
            if (currParamName !== null) params.set(currParamName, "");
        // in ReactNative for example this would not be true (unless connected to the Remote Debugger)
        } else if (typeof location === "object") {
            params = _mapJs.create(); // eslint-disable-next-line no-undef
            (location.search || "?").slice(1).split("&").forEach((kv)=>{
                if (kv.length !== 0) {
                    const [key, value] = kv.split("=");
                    params.set(`--${_stringJs.fromCamelCase(key, "-")}`, value);
                    params.set(`-${_stringJs.fromCamelCase(key, "-")}`, value);
                }
            });
        } else params = _mapJs.create();
    }
    return params;
};
const hasParam = (name)=>computeParams().has(name);
const getParam = (name, defaultVal)=>computeParams().get(name) || defaultVal;
const getVariable = (name)=>isNode ? _conditionsJs.undefinedToNull(process.env[name.toUpperCase()]) : _conditionsJs.undefinedToNull(_storageJs.varStorage.getItem(name));
const getConf = (name)=>computeParams().get("--" + name) || getVariable(name);
const hasConf = (name)=>hasParam("--" + name) || getVariable(name) !== null;
const production = hasConf("production");
/* c8 ignore next 2 */ const forceColor = isNode && _functionJs.isOneOf(undefined, [
    "true",
    "1",
    "2"
]);
const supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color") /* c8 ignore stop */ );

},{"2cfb8bcef1022e2a":"gq3cc","./map.js":"b1fdO","./string.js":"6sDcK","./conditions.js":"6ygAM","./storage.js":"hxAy0","./function.js":"3Eway","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6ygAM":[function(require,module,exports) {
/**
 * Often used conditions.
 *
 * @module conditions
 */ /**
 * @template T
 * @param {T|null|undefined} v
 * @return {T|null}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "undefinedToNull", ()=>undefinedToNull);
const undefinedToNull = (v)=>v === undefined ? null : v;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hxAy0":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Isomorphic variable storage.
 *
 * Uses LocalStorage in the browser and falls back to in-memory storage.
 *
 * @module storage
 */ /* c8 ignore start */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "varStorage", ()=>varStorage);
parcelHelpers.export(exports, "onChange", ()=>onChange);
parcelHelpers.export(exports, "offChange", ()=>offChange);
class VarStoragePolyfill {
    constructor(){
        this.map = new Map();
    }
    /**
   * @param {string} key
   * @param {any} newValue
   */ setItem(key, newValue) {
        this.map.set(key, newValue);
    }
    /**
   * @param {string} key
   */ getItem(key) {
        return this.map.get(key);
    }
}
/* c8 ignore stop */ /**
 * @type {any}
 */ let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
/* c8 ignore start */ try {
    // if the same-origin rule is violated, accessing localStorage might thrown an error
    if (typeof localStorage !== "undefined") {
        _localStorage = localStorage;
        usePolyfill = false;
    }
} catch (e) {}
const varStorage = _localStorage;
const onChange = (eventHandler)=>usePolyfill || addEventListener("storage", /** @type {any} */ eventHandler);
const offChange = (eventHandler)=>usePolyfill || removeEventListener("storage", /** @type {any} */ eventHandler);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3Eway":[function(require,module,exports) {
/**
 * Common functions and function call helpers.
 *
 * @module function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "callAll", ()=>callAll);
parcelHelpers.export(exports, "nop", ()=>nop);
parcelHelpers.export(exports, "apply", ()=>apply);
parcelHelpers.export(exports, "id", ()=>id);
parcelHelpers.export(exports, "equalityStrict", ()=>equalityStrict);
parcelHelpers.export(exports, "equalityFlat", ()=>equalityFlat);
parcelHelpers.export(exports, "equalityDeep", ()=>equalityDeep);
parcelHelpers.export(exports, "isOneOf", ()=>isOneOf);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "isTemplate", ()=>isTemplate);
var _arrayJs = require("./array.js");
var _objectJs = require("./object.js");
const callAll = (fs, args, i = 0)=>{
    try {
        for(; i < fs.length; i++)fs[i](...args);
    } finally{
        if (i < fs.length) callAll(fs, args, i + 1);
    }
};
const nop = ()=>{};
const apply = (f)=>f();
const id = (a)=>a;
const equalityStrict = (a, b)=>a === b;
const equalityFlat = (a, b)=>a === b || a != null && b != null && a.constructor === b.constructor && (_arrayJs.isArray(a) && _arrayJs.equalFlat(a, /** @type {Array<T>} */ b) || typeof a === "object" && _objectJs.equalFlat(a, b));
const equalityDeep = (a, b)=>{
    if (a == null || b == null) return equalityStrict(a, b);
    if (a.constructor !== b.constructor) return false;
    if (a === b) return true;
    switch(a.constructor){
        case ArrayBuffer:
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // eslint-disable-next-line no-fallthrough
        case Uint8Array:
            if (a.byteLength !== b.byteLength) return false;
            for(let i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
            break;
        case Set:
            if (a.size !== b.size) return false;
            for (const value of a){
                if (!b.has(value)) return false;
            }
            break;
        case Map:
            if (a.size !== b.size) return false;
            for (const key of a.keys()){
                if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) return false;
            }
            break;
        case Object:
            if (_objectJs.length(a) !== _objectJs.length(b)) return false;
            for(const key in a){
                if (!_objectJs.hasProperty(a, key) || !equalityDeep(a[key], b[key])) return false;
            }
            break;
        case Array:
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; i++){
                if (!equalityDeep(a[i], b[i])) return false;
            }
            break;
        default:
            return false;
    }
    return true;
};
const isOneOf = (value, options)=>options.includes(value);
const isArray = _arrayJs.isArray;
const isString = (s)=>s && s.constructor === String;
const isNumber = (n)=>n != null && n.constructor === Number;
const is = (n, T)=>n && n.constructor === T;
const isTemplate = (T)=>/**
   * @param {any} n
   * @return {n is InstanceType<TYPE>}
   **/ (n)=>n && n.constructor === T;

},{"./array.js":"k9U44","./object.js":"Xrj2S","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"Xrj2S":[function(require,module,exports) {
/**
 * Utility functions for working with EcmaScript objects.
 *
 * @module object
 */ /**
 * @return {Object<string,any>} obj
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "hasProperty", ()=>hasProperty);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
const create = ()=>Object.create(null);
const assign = Object.assign;
const keys = Object.keys;
const forEach = (obj, f)=>{
    for(const key in obj)f(obj[key], key);
};
const map = (obj, f)=>{
    const results = [];
    for(const key in obj)results.push(f(obj[key], key));
    return results;
};
const length = (obj)=>keys(obj).length;
const some = (obj, f)=>{
    for(const key in obj){
        if (f(obj[key], key)) return true;
    }
    return false;
};
const isEmpty = (obj)=>{
    // eslint-disable-next-line
    for(const _k in obj)return false;
    return true;
};
const every = (obj, f)=>{
    for(const key in obj){
        if (!f(obj[key], key)) return false;
    }
    return true;
};
const hasProperty = (obj, key)=>Object.prototype.hasOwnProperty.call(obj, key);
const equalFlat = (a, b)=>a === b || length(a) === length(b) && every(a, (val, key)=>(val !== undefined || hasProperty(b, key)) && b[key] === val);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1twFz":[function(require,module,exports) {
/**
 * Efficient schema-less binary decoding with support for variable length encoding.
 *
 * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module decoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Decoder handles the decoding of an Uint8Array.
 */ parcelHelpers.export(exports, "Decoder", ()=>Decoder);
parcelHelpers.export(exports, "createDecoder", ()=>createDecoder);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "clone", ()=>clone);
parcelHelpers.export(exports, "readUint8Array", ()=>readUint8Array);
parcelHelpers.export(exports, "readVarUint8Array", ()=>readVarUint8Array);
parcelHelpers.export(exports, "readTailAsUint8Array", ()=>readTailAsUint8Array);
parcelHelpers.export(exports, "skip8", ()=>skip8);
parcelHelpers.export(exports, "readUint8", ()=>readUint8);
parcelHelpers.export(exports, "readUint16", ()=>readUint16);
parcelHelpers.export(exports, "readUint32", ()=>readUint32);
parcelHelpers.export(exports, "readUint32BigEndian", ()=>readUint32BigEndian);
parcelHelpers.export(exports, "peekUint8", ()=>peekUint8);
parcelHelpers.export(exports, "peekUint16", ()=>peekUint16);
parcelHelpers.export(exports, "peekUint32", ()=>peekUint32);
parcelHelpers.export(exports, "readVarUint", ()=>readVarUint);
parcelHelpers.export(exports, "readVarInt", ()=>readVarInt);
parcelHelpers.export(exports, "peekVarUint", ()=>peekVarUint);
parcelHelpers.export(exports, "peekVarInt", ()=>peekVarInt);
parcelHelpers.export(exports, "_readVarStringPolyfill", ()=>_readVarStringPolyfill);
parcelHelpers.export(exports, "_readVarStringNative", ()=>_readVarStringNative);
parcelHelpers.export(exports, "readVarString", ()=>readVarString);
parcelHelpers.export(exports, "readTerminatedUint8Array", ()=>readTerminatedUint8Array);
parcelHelpers.export(exports, "readTerminatedString", ()=>readTerminatedString);
parcelHelpers.export(exports, "peekVarString", ()=>peekVarString);
parcelHelpers.export(exports, "readFromDataView", ()=>readFromDataView);
parcelHelpers.export(exports, "readFloat32", ()=>readFloat32);
parcelHelpers.export(exports, "readFloat64", ()=>readFloat64);
parcelHelpers.export(exports, "readBigInt64", ()=>readBigInt64);
parcelHelpers.export(exports, "readBigUint64", ()=>readBigUint64);
parcelHelpers.export(exports, "readAny", ()=>readAny);
/**
 * T must not be null.
 *
 * @template T
 */ parcelHelpers.export(exports, "RleDecoder", ()=>RleDecoder);
parcelHelpers.export(exports, "IntDiffDecoder", ()=>IntDiffDecoder);
parcelHelpers.export(exports, "RleIntDiffDecoder", ()=>RleIntDiffDecoder);
parcelHelpers.export(exports, "UintOptRleDecoder", ()=>UintOptRleDecoder);
parcelHelpers.export(exports, "IncUintOptRleDecoder", ()=>IncUintOptRleDecoder);
parcelHelpers.export(exports, "IntDiffOptRleDecoder", ()=>IntDiffOptRleDecoder);
parcelHelpers.export(exports, "StringDecoder", ()=>StringDecoder);
var _bufferJs = require("./buffer.js");
var _binaryJs = require("./binary.js");
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _stringJs = require("./string.js");
var _errorJs = require("./error.js");
var _encodingJs = require("./encoding.js");
const errorUnexpectedEndOfArray = _errorJs.create("Unexpected end of array");
const errorIntegerOutOfRange = _errorJs.create("Integer out of Range");
class Decoder {
    /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */ constructor(uint8Array){
        /**
     * Decoding target.
     *
     * @type {Uint8Array}
     */ this.arr = uint8Array;
        /**
     * Current decoding position.
     *
     * @type {number}
     */ this.pos = 0;
    }
}
const createDecoder = (uint8Array)=>new Decoder(uint8Array);
const hasContent = (decoder)=>decoder.pos !== decoder.arr.length;
const clone = (decoder, newPos = decoder.pos)=>{
    const _decoder = createDecoder(decoder.arr);
    _decoder.pos = newPos;
    return _decoder;
};
const readUint8Array = (decoder, len)=>{
    const view = _bufferJs.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
};
const readVarUint8Array = (decoder)=>readUint8Array(decoder, readVarUint(decoder));
const readTailAsUint8Array = (decoder)=>readUint8Array(decoder, decoder.arr.length - decoder.pos);
const skip8 = (decoder)=>decoder.pos++;
const readUint8 = (decoder)=>decoder.arr[decoder.pos++];
const readUint16 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
    decoder.pos += 2;
    return uint;
};
const readUint32 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const readUint32BigEndian = (decoder)=>{
    const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const peekUint8 = (decoder)=>decoder.arr[decoder.pos];
const peekUint16 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
const peekUint32 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
const readVarUint = (decoder)=>{
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        const r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult // shift $r << (7*#iterations) and add it to num
        ;
        mult *= 128 // next iteration, shift 7 "more" to the left
        ;
        if (r < _binaryJs.BIT8) return num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const readVarInt = (decoder)=>{
    let r = decoder.arr[decoder.pos++];
    let num = r & _binaryJs.BITS6;
    let mult = 64;
    const sign = (r & _binaryJs.BIT7) > 0 ? -1 : 1;
    if ((r & _binaryJs.BIT8) === 0) // don't continue reading
    return sign * num;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult;
        mult *= 128;
        if (r < _binaryJs.BIT8) return sign * num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const peekVarUint = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarUint(decoder);
    decoder.pos = pos;
    return s;
};
const peekVarInt = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarInt(decoder);
    decoder.pos = pos;
    return s;
};
const _readVarStringPolyfill = (decoder)=>{
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) return "";
    else {
        let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen
        ;
        if (--remainingLen < 100) while(remainingLen--)encodedString += String.fromCodePoint(readUint8(decoder));
        else while(remainingLen > 0){
            const nextLen = remainingLen < 10000 ? remainingLen : 10000;
            // this is dangerous, we create a fresh array view from the existing buffer
            const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
            decoder.pos += nextLen;
            // Starting with ES5.1 we can supply a generic array-like object as arguments
            encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
            remainingLen -= nextLen;
        }
        return decodeURIComponent(escape(encodedString));
    }
};
const _readVarStringNative = (decoder)=>/** @type any */ _stringJs.utf8TextDecoder.decode(readVarUint8Array(decoder));
const readVarString = _stringJs.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
const readTerminatedUint8Array = (decoder)=>{
    const encoder = _encodingJs.createEncoder();
    let b;
    while(true){
        b = readUint8(decoder);
        if (b === 0) return _encodingJs.toUint8Array(encoder);
        if (b === 1) b = readUint8(decoder);
        _encodingJs.write(encoder, b);
    }
};
const readTerminatedString = (decoder)=>_stringJs.decodeUtf8(readTerminatedUint8Array(decoder));
const peekVarString = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarString(decoder);
    decoder.pos = pos;
    return s;
};
const readFromDataView = (decoder, len)=>{
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
};
const readFloat32 = (decoder)=>readFromDataView(decoder, 4).getFloat32(0, false);
const readFloat64 = (decoder)=>readFromDataView(decoder, 8).getFloat64(0, false);
const readBigInt64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigInt64(0, false);
const readBigUint64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigUint64(0, false);
/**
 * @type {Array<function(Decoder):any>}
 */ const readAnyLookupTable = [
    (decoder)=>undefined,
    (decoder)=>null,
    readVarInt,
    readFloat32,
    readFloat64,
    readBigInt64,
    (decoder)=>false,
    (decoder)=>true,
    readVarString,
    (decoder)=>{
        const len = readVarUint(decoder);
        /**
     * @type {Object<string,any>}
     */ const obj = {};
        for(let i = 0; i < len; i++){
            const key = readVarString(decoder);
            obj[key] = readAny(decoder);
        }
        return obj;
    },
    (decoder)=>{
        const len = readVarUint(decoder);
        const arr = [];
        for(let i = 0; i < len; i++)arr.push(readAny(decoder));
        return arr;
    },
    readVarUint8Array // CASE 116: Uint8Array
];
const readAny = (decoder)=>readAnyLookupTable[127 - readUint8(decoder)](decoder);
class RleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */ constructor(uint8Array, reader){
        super(uint8Array);
        /**
     * The reader
     */ this.reader = reader;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = this.reader(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {T} */ this.s;
    }
}
class IntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @return {number}
   */ read() {
        this.s += readVarInt(this);
        return this.s;
    }
}
class RleIntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            this.s += readVarInt(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class UintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class IncUintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s++;
    }
}
class IntDiffOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            const diff = readVarInt(this);
            // if the first bit is set, we read more data
            const hasCount = diff & 1;
            this.diff = _mathJs.floor(diff / 2) // shift >> 1
            ;
            this.count = 1;
            if (hasCount) this.count = readVarUint(this) + 2;
        }
        this.s += this.diff;
        this.count--;
        return this.s;
    }
}
class StringDecoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        this.decoder = new UintOptRleDecoder(uint8Array);
        this.str = readVarString(this.decoder);
        /**
     * @type {number}
     */ this.spos = 0;
    }
    /**
   * @return {string}
   */ read() {
        const end = this.spos + this.decoder.read();
        const res = this.str.slice(this.spos, end);
        this.spos = end;
        return res;
    }
}

},{"./buffer.js":"3Ygoc","./binary.js":"l546T","./math.js":"99M3Z","./number.js":"j24S2","./string.js":"6sDcK","./error.js":"36p1r","./encoding.js":"h5JHW","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"l546T":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Binary data constants.
 *
 * @module binary
 */ /**
 * n-th bit activated.
 *
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BIT1", ()=>BIT1);
parcelHelpers.export(exports, "BIT2", ()=>BIT2);
parcelHelpers.export(exports, "BIT3", ()=>BIT3);
parcelHelpers.export(exports, "BIT4", ()=>BIT4);
parcelHelpers.export(exports, "BIT5", ()=>BIT5);
parcelHelpers.export(exports, "BIT6", ()=>BIT6);
parcelHelpers.export(exports, "BIT7", ()=>BIT7);
parcelHelpers.export(exports, "BIT8", ()=>BIT8);
parcelHelpers.export(exports, "BIT9", ()=>BIT9);
parcelHelpers.export(exports, "BIT10", ()=>BIT10);
parcelHelpers.export(exports, "BIT11", ()=>BIT11);
parcelHelpers.export(exports, "BIT12", ()=>BIT12);
parcelHelpers.export(exports, "BIT13", ()=>BIT13);
parcelHelpers.export(exports, "BIT14", ()=>BIT14);
parcelHelpers.export(exports, "BIT15", ()=>BIT15);
parcelHelpers.export(exports, "BIT16", ()=>BIT16);
parcelHelpers.export(exports, "BIT17", ()=>BIT17);
parcelHelpers.export(exports, "BIT18", ()=>BIT18);
parcelHelpers.export(exports, "BIT19", ()=>BIT19);
parcelHelpers.export(exports, "BIT20", ()=>BIT20);
parcelHelpers.export(exports, "BIT21", ()=>BIT21);
parcelHelpers.export(exports, "BIT22", ()=>BIT22);
parcelHelpers.export(exports, "BIT23", ()=>BIT23);
parcelHelpers.export(exports, "BIT24", ()=>BIT24);
parcelHelpers.export(exports, "BIT25", ()=>BIT25);
parcelHelpers.export(exports, "BIT26", ()=>BIT26);
parcelHelpers.export(exports, "BIT27", ()=>BIT27);
parcelHelpers.export(exports, "BIT28", ()=>BIT28);
parcelHelpers.export(exports, "BIT29", ()=>BIT29);
parcelHelpers.export(exports, "BIT30", ()=>BIT30);
parcelHelpers.export(exports, "BIT31", ()=>BIT31);
parcelHelpers.export(exports, "BIT32", ()=>BIT32);
parcelHelpers.export(exports, "BITS0", ()=>BITS0);
parcelHelpers.export(exports, "BITS1", ()=>BITS1);
parcelHelpers.export(exports, "BITS2", ()=>BITS2);
parcelHelpers.export(exports, "BITS3", ()=>BITS3);
parcelHelpers.export(exports, "BITS4", ()=>BITS4);
parcelHelpers.export(exports, "BITS5", ()=>BITS5);
parcelHelpers.export(exports, "BITS6", ()=>BITS6);
parcelHelpers.export(exports, "BITS7", ()=>BITS7);
parcelHelpers.export(exports, "BITS8", ()=>BITS8);
parcelHelpers.export(exports, "BITS9", ()=>BITS9);
parcelHelpers.export(exports, "BITS10", ()=>BITS10);
parcelHelpers.export(exports, "BITS11", ()=>BITS11);
parcelHelpers.export(exports, "BITS12", ()=>BITS12);
parcelHelpers.export(exports, "BITS13", ()=>BITS13);
parcelHelpers.export(exports, "BITS14", ()=>BITS14);
parcelHelpers.export(exports, "BITS15", ()=>BITS15);
parcelHelpers.export(exports, "BITS16", ()=>BITS16);
parcelHelpers.export(exports, "BITS17", ()=>BITS17);
parcelHelpers.export(exports, "BITS18", ()=>BITS18);
parcelHelpers.export(exports, "BITS19", ()=>BITS19);
parcelHelpers.export(exports, "BITS20", ()=>BITS20);
parcelHelpers.export(exports, "BITS21", ()=>BITS21);
parcelHelpers.export(exports, "BITS22", ()=>BITS22);
parcelHelpers.export(exports, "BITS23", ()=>BITS23);
parcelHelpers.export(exports, "BITS24", ()=>BITS24);
parcelHelpers.export(exports, "BITS25", ()=>BITS25);
parcelHelpers.export(exports, "BITS26", ()=>BITS26);
parcelHelpers.export(exports, "BITS27", ()=>BITS27);
parcelHelpers.export(exports, "BITS28", ()=>BITS28);
parcelHelpers.export(exports, "BITS29", ()=>BITS29);
parcelHelpers.export(exports, "BITS30", ()=>BITS30);
parcelHelpers.export(exports, "BITS31", ()=>BITS31);
parcelHelpers.export(exports, "BITS32", ()=>BITS32);
const BIT1 = 1;
const BIT2 = 2;
const BIT3 = 4;
const BIT4 = 8;
const BIT5 = 16;
const BIT6 = 32;
const BIT7 = 64;
const BIT8 = 128;
const BIT9 = 256;
const BIT10 = 512;
const BIT11 = 1024;
const BIT12 = 2048;
const BIT13 = 4096;
const BIT14 = 8192;
const BIT15 = 16384;
const BIT16 = 32768;
const BIT17 = 65536;
const BIT18 = 131072;
const BIT19 = 262144;
const BIT20 = 524288;
const BIT21 = 1048576;
const BIT22 = 2097152;
const BIT23 = 4194304;
const BIT24 = 8388608;
const BIT25 = 16777216;
const BIT26 = 33554432;
const BIT27 = 67108864;
const BIT28 = 134217728;
const BIT29 = 268435456;
const BIT30 = 536870912;
const BIT31 = 1073741824;
const BIT32 = -2147483648;
const BITS0 = 0;
const BITS1 = 1;
const BITS2 = 3;
const BITS3 = 7;
const BITS4 = 15;
const BITS5 = 31;
const BITS6 = 63;
const BITS7 = 127;
const BITS8 = 255;
const BITS9 = 511;
const BITS10 = 1023;
const BITS11 = 2047;
const BITS12 = 4095;
const BITS13 = 8191;
const BITS14 = 16383;
const BITS15 = 32767;
const BITS16 = 65535;
const BITS17 = BIT18 - 1;
const BITS18 = BIT19 - 1;
const BITS19 = BIT20 - 1;
const BITS20 = BIT21 - 1;
const BITS21 = BIT22 - 1;
const BITS22 = BIT23 - 1;
const BITS23 = BIT24 - 1;
const BITS24 = BIT25 - 1;
const BITS25 = BIT26 - 1;
const BITS26 = BIT27 - 1;
const BITS27 = BIT28 - 1;
const BITS28 = BIT29 - 1;
const BITS29 = BIT30 - 1;
const BITS30 = BIT31 - 1;
const BITS31 = 0x7FFFFFFF;
const BITS32 = 0xFFFFFFFF;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j24S2":[function(require,module,exports) {
/**
 * Utility helpers for working with numbers.
 *
 * @module number
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_SAFE_INTEGER", ()=>MAX_SAFE_INTEGER);
parcelHelpers.export(exports, "MIN_SAFE_INTEGER", ()=>MIN_SAFE_INTEGER);
parcelHelpers.export(exports, "LOWEST_INT32", ()=>LOWEST_INT32);
parcelHelpers.export(exports, "HIGHEST_INT32", ()=>HIGHEST_INT32);
parcelHelpers.export(exports, "HIGHEST_UINT32", ()=>HIGHEST_UINT32);
parcelHelpers.export(exports, "isInteger", ()=>isInteger);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "parseInt", ()=>parseInt);
parcelHelpers.export(exports, "countBits", ()=>countBits);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
const LOWEST_INT32 = -2147483648;
const HIGHEST_INT32 = _binaryJs.BITS31;
const HIGHEST_UINT32 = _binaryJs.BITS32;
const isInteger = Number.isInteger || ((num)=>typeof num === "number" && isFinite(num) && _mathJs.floor(num) === num);
const isNaN = Number.isNaN;
const parseInt = Number.parseInt;
const countBits = (n)=>{
    n &= _binaryJs.BITS32;
    let count = 0;
    while(n){
        n &= n - 1;
        count++;
    }
    return count;
};

},{"./math.js":"99M3Z","./binary.js":"l546T","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"36p1r":[function(require,module,exports) {
/**
 * Error helpers.
 *
 * @module error
 */ /**
 * @param {string} s
 * @return {Error}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "methodUnimplemented", ()=>methodUnimplemented);
parcelHelpers.export(exports, "unexpectedCase", ()=>unexpectedCase);
const create = (s)=>new Error(s);
const methodUnimplemented = ()=>{
    throw create("Method unimplemented");
};
const unexpectedCase = ()=>{
    throw create("Unexpected case");
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bMWgJ":[function(require,module,exports) {
/**
 * Isomorphic module for true random numbers / buffers / uuids.
 *
 * Attention: falls back to Math.random if the browser does not support crypto.
 *
 * @module random
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rand", ()=>rand);
parcelHelpers.export(exports, "uint32", ()=>uint32);
parcelHelpers.export(exports, "uint53", ()=>uint53);
parcelHelpers.export(exports, "oneOf", ()=>oneOf);
parcelHelpers.export(exports, "uuidv4", ()=>uuidv4);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
var _webcrypto = require("lib0/webcrypto");
const rand = Math.random;
const uint32 = ()=>(0, _webcrypto.getRandomValues)(new Uint32Array(1))[0];
const uint53 = ()=>{
    const arr = (0, _webcrypto.getRandomValues)(new Uint32Array(8));
    return (arr[0] & _binaryJs.BITS21) * (_binaryJs.BITS32 + 1) + (arr[1] >>> 0);
};
const oneOf = (arr)=>arr[_mathJs.floor(rand() * arr.length)];
// @ts-ignore
const uuidv4Template = "10000000-1000-4000-8000-100000000000";
const uuidv4 = ()=>uuidv4Template.replace(/[018]/g, /** @param {number} c */ (c)=>(c ^ uint32() & 15 >> c / 4).toString(16));

},{"./math.js":"99M3Z","./binary.js":"l546T","lib0/webcrypto":"8IIou","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8IIou":[function(require,module,exports) {
/* eslint-env browser */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subtle", ()=>subtle);
parcelHelpers.export(exports, "getRandomValues", ()=>getRandomValues);
const subtle = crypto.subtle;
const getRandomValues = crypto.getRandomValues.bind(crypto);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4EVk5":[function(require,module,exports) {
/**
 * Utility helpers to work with promises.
 *
 * @module promise
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "reject", ()=>reject);
parcelHelpers.export(exports, "resolve", ()=>resolve);
parcelHelpers.export(exports, "resolveWith", ()=>resolveWith);
parcelHelpers.export(exports, "until", ()=>until);
parcelHelpers.export(exports, "wait", ()=>wait);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _timeJs = require("./time.js");
const create = (f)=>/** @type {Promise<T>} */ new Promise(f);
const createEmpty = (f)=>new Promise(f);
const all = Promise.all.bind(Promise);
const reject = (reason)=>Promise.reject(reason);
const resolve = (res)=>Promise.resolve(res);
const resolveWith = (res)=>Promise.resolve(res);
const until = (timeout, check, intervalResolution = 10)=>create((resolve, reject)=>{
        const startTime = _timeJs.getUnixTime();
        const hasTimeout = timeout > 0;
        const untilInterval = ()=>{
            if (check()) {
                clearInterval(intervalHandle);
                resolve();
            } else if (hasTimeout) /* c8 ignore else */ {
                if (_timeJs.getUnixTime() - startTime > timeout) {
                    clearInterval(intervalHandle);
                    reject(new Error("Timeout"));
                }
            }
        };
        const intervalHandle = setInterval(untilInterval, intervalResolution);
    });
const wait = (timeout)=>create((resolve, reject)=>setTimeout(resolve, timeout));
const isPromise = (p)=>p instanceof Promise || p && p.then && p.catch && p.finally;

},{"./time.js":"3YA6c","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3YA6c":[function(require,module,exports) {
/**
 * Utility module to work with time.
 *
 * @module time
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "getUnixTime", ()=>getUnixTime);
parcelHelpers.export(exports, "humanizeDuration", ()=>humanizeDuration);
var _metricJs = require("./metric.js");
var _mathJs = require("./math.js");
const getDate = ()=>new Date();
const getUnixTime = Date.now;
const humanizeDuration = (d)=>{
    if (d < 60000) {
        const p = _metricJs.prefix(d, -1);
        return _mathJs.round(p.n * 100) / 100 + p.prefix + "s";
    }
    d = _mathJs.floor(d / 1000);
    const seconds = d % 60;
    const minutes = _mathJs.floor(d / 60) % 60;
    const hours = _mathJs.floor(d / 3600) % 24;
    const days = _mathJs.floor(d / 86400);
    if (days > 0) return days + "d" + (hours > 0 || minutes > 30 ? " " + (minutes > 30 ? hours + 1 : hours) + "h" : "");
    if (hours > 0) /* c8 ignore next */ return hours + "h" + (minutes > 0 || seconds > 30 ? " " + (seconds > 30 ? minutes + 1 : minutes) + "min" : "");
    return minutes + "min" + (seconds > 0 ? " " + seconds + "s" : "");
};

},{"./metric.js":"cDLOO","./math.js":"99M3Z","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cDLOO":[function(require,module,exports) {
/**
 * Utility module to convert metric values.
 *
 * @module metric
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "yotta", ()=>yotta);
parcelHelpers.export(exports, "zetta", ()=>zetta);
parcelHelpers.export(exports, "exa", ()=>exa);
parcelHelpers.export(exports, "peta", ()=>peta);
parcelHelpers.export(exports, "tera", ()=>tera);
parcelHelpers.export(exports, "giga", ()=>giga);
parcelHelpers.export(exports, "mega", ()=>mega);
parcelHelpers.export(exports, "kilo", ()=>kilo);
parcelHelpers.export(exports, "hecto", ()=>hecto);
parcelHelpers.export(exports, "deca", ()=>deca);
parcelHelpers.export(exports, "deci", ()=>deci);
parcelHelpers.export(exports, "centi", ()=>centi);
parcelHelpers.export(exports, "milli", ()=>milli);
parcelHelpers.export(exports, "micro", ()=>micro);
parcelHelpers.export(exports, "nano", ()=>nano);
parcelHelpers.export(exports, "pico", ()=>pico);
parcelHelpers.export(exports, "femto", ()=>femto);
parcelHelpers.export(exports, "atto", ()=>atto);
parcelHelpers.export(exports, "zepto", ()=>zepto);
parcelHelpers.export(exports, "yocto", ()=>yocto);
parcelHelpers.export(exports, "prefix", ()=>prefix);
var _mathJs = require("./math.js");
const yotta = 1e24;
const zetta = 1e21;
const exa = 1e18;
const peta = 1e15;
const tera = 1e12;
const giga = 1e9;
const mega = 1e6;
const kilo = 1e3;
const hecto = 1e2;
const deca = 10;
const deci = 0.1;
const centi = 0.01;
const milli = 1e-3;
const micro = 1e-6;
const nano = 1e-9;
const pico = 1e-12;
const femto = 1e-15;
const atto = 1e-18;
const zepto = 1e-21;
const yocto = 1e-24;
const prefixUp = [
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
const prefixDown = [
    "",
    "m",
    "Œº",
    "n",
    "p",
    "f",
    "a",
    "z",
    "y"
];
const prefix = (n, baseMultiplier = 0)=>{
    const nPow = n === 0 ? 0 : _mathJs.log10(n);
    let mult = 0;
    while(nPow < mult * 3 && baseMultiplier > -8){
        baseMultiplier--;
        mult--;
    }
    while(nPow >= 3 + mult * 3 && baseMultiplier < 8){
        baseMultiplier++;
        mult++;
    }
    const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
    return {
        n: _mathJs.round((mult > 0 ? n / _mathJs.exp10(mult * 3) : n * _mathJs.exp10(mult * -3)) * 1e12) / 1e12,
        prefix
    };
};

},{"./math.js":"99M3Z","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"04jLW":[function(require,module,exports) {
/**
 * Isomorphic logging module with support for colors!
 *
 * @module logging
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>(0, _loggingCommonJs.BOLD));
parcelHelpers.export(exports, "UNBOLD", ()=>(0, _loggingCommonJs.UNBOLD));
parcelHelpers.export(exports, "BLUE", ()=>(0, _loggingCommonJs.BLUE));
parcelHelpers.export(exports, "GREY", ()=>(0, _loggingCommonJs.GREY));
parcelHelpers.export(exports, "GREEN", ()=>(0, _loggingCommonJs.GREEN));
parcelHelpers.export(exports, "RED", ()=>(0, _loggingCommonJs.RED));
parcelHelpers.export(exports, "PURPLE", ()=>(0, _loggingCommonJs.PURPLE));
parcelHelpers.export(exports, "ORANGE", ()=>(0, _loggingCommonJs.ORANGE));
parcelHelpers.export(exports, "UNCOLOR", ()=>(0, _loggingCommonJs.UNCOLOR));
parcelHelpers.export(exports, "print", ()=>print);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "printError", ()=>printError);
parcelHelpers.export(exports, "printImg", ()=>printImg);
parcelHelpers.export(exports, "printImgBase64", ()=>printImgBase64);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "groupCollapsed", ()=>groupCollapsed);
parcelHelpers.export(exports, "groupEnd", ()=>groupEnd);
parcelHelpers.export(exports, "printDom", ()=>printDom);
parcelHelpers.export(exports, "printCanvas", ()=>printCanvas);
parcelHelpers.export(exports, "vconsoles", ()=>vconsoles);
/* c8 ignore start */ parcelHelpers.export(exports, "VConsole", ()=>VConsole);
parcelHelpers.export(exports, "createVConsole", ()=>createVConsole);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _environmentJs = require("./environment.js");
var _setJs = require("./set.js");
var _pairJs = require("./pair.js");
var _domJs = require("./dom.js");
var _jsonJs = require("./json.js");
var _mapJs = require("./map.js");
var _eventloopJs = require("./eventloop.js");
var _mathJs = require("./math.js");
var _loggingCommonJs = require("./logging.common.js");
/**
 * @type {Object<Symbol,pair.Pair<string,string>>}
 */ const _browserStyleMap = {
    [_loggingCommonJs.BOLD]: _pairJs.create("font-weight", "bold"),
    [_loggingCommonJs.UNBOLD]: _pairJs.create("font-weight", "normal"),
    [_loggingCommonJs.BLUE]: _pairJs.create("color", "blue"),
    [_loggingCommonJs.GREEN]: _pairJs.create("color", "green"),
    [_loggingCommonJs.GREY]: _pairJs.create("color", "grey"),
    [_loggingCommonJs.RED]: _pairJs.create("color", "red"),
    [_loggingCommonJs.PURPLE]: _pairJs.create("color", "purple"),
    [_loggingCommonJs.ORANGE]: _pairJs.create("color", "orange"),
    [_loggingCommonJs.UNCOLOR]: _pairJs.create("color", "black")
};
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<string|object|number>}
 */ /* c8 ignore start */ const computeBrowserLoggingArgs = (args)=>{
    const strBuilder = [];
    const styles = [];
    const currentStyle = _mapJs.create();
    /**
   * @type {Array<string|Object|number>}
   */ let logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg.constructor === String || arg.constructor === Number) {
                const style = _domJs.mapToStyleString(currentStyle);
                if (i > 0 || style.length > 0) {
                    strBuilder.push("%c" + arg);
                    styles.push(style);
                } else strBuilder.push(arg);
            } else break;
        }
    }
    if (i > 0) {
        // create logArgs with what we have so far
        logArgs = styles;
        logArgs.unshift(strBuilder.join(""));
    }
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) logArgs.push(arg);
    }
    return logArgs;
};
/* c8 ignore stop */ /* c8 ignore start */ const computeLoggingArgs = _environmentJs.supportsColor ? computeBrowserLoggingArgs : _loggingCommonJs.computeNoColorLoggingArgs;
const print = (...args)=>{
    console.log(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.print(args));
};
const warn = (...args)=>{
    console.warn(...computeLoggingArgs(args));
    args.unshift(_loggingCommonJs.ORANGE);
    vconsoles.forEach((vc)=>vc.print(args));
};
const printError = (err)=>{
    console.error(err);
    vconsoles.forEach((vc)=>vc.printError(err));
};
const printImg = (url, height)=>{
    if (_environmentJs.isBrowser) console.log("%c                      ", `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);
    vconsoles.forEach((vc)=>vc.printImg(url, height));
};
const printImgBase64 = (base64, height)=>printImg(`data:image/gif;base64,${base64}`, height);
const group = (...args)=>{
    console.group(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.group(args));
};
const groupCollapsed = (...args)=>{
    console.groupCollapsed(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupCollapsed(args));
};
const groupEnd = ()=>{
    console.groupEnd();
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupEnd());
};
const printDom = (createNode)=>vconsoles.forEach((vc)=>vc.printDom(createNode()));
const printCanvas = (canvas, height)=>printImg(canvas.toDataURL(), height);
const vconsoles = _setJs.create();
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<Element>}
 */ /* c8 ignore start */ const _computeLineSpans = (args)=>{
    const spans = [];
    const currentStyle = new Map();
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg.constructor === String || arg.constructor === Number) {
                // @ts-ignore
                const span = _domJs.element("span", [
                    _pairJs.create("style", _domJs.mapToStyleString(currentStyle))
                ], [
                    _domJs.text(arg.toString())
                ]);
                if (span.innerHTML === "") span.innerHTML = "&nbsp;";
                spans.push(span);
            } else break;
        }
    }
    // append the rest
    for(; i < args.length; i++){
        let content = args[i];
        if (!(content instanceof Symbol)) {
            if (content.constructor !== String && content.constructor !== Number) content = " " + _jsonJs.stringify(content) + " ";
            spans.push(_domJs.element("span", [], [
                _domJs.text(/** @type {string} */ content)
            ]));
        }
    }
    return spans;
};
/* c8 ignore stop */ const lineStyle = "font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;";
class VConsole {
    /**
   * @param {Element} dom
   */ constructor(dom){
        this.dom = dom;
        /**
     * @type {Element}
     */ this.ccontainer = this.dom;
        this.depth = 0;
        vconsoles.add(this);
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   * @param {boolean} collapsed
   */ group(args, collapsed = false) {
        _eventloopJs.enqueue(()=>{
            const triangleDown = _domJs.element("span", [
                _pairJs.create("hidden", collapsed),
                _pairJs.create("style", "color:grey;font-size:120%;")
            ], [
                _domJs.text("‚ñº")
            ]);
            const triangleRight = _domJs.element("span", [
                _pairJs.create("hidden", !collapsed),
                _pairJs.create("style", "color:grey;font-size:125%;")
            ], [
                _domJs.text("‚ñ∂")
            ]);
            const content = _domJs.element("div", [
                _pairJs.create("style", `${lineStyle};padding-left:${this.depth * 10}px`)
            ], [
                triangleDown,
                triangleRight,
                _domJs.text(" ")
            ].concat(_computeLineSpans(args)));
            const nextContainer = _domJs.element("div", [
                _pairJs.create("hidden", collapsed)
            ]);
            const nextLine = _domJs.element("div", [], [
                content,
                nextContainer
            ]);
            _domJs.append(this.ccontainer, [
                nextLine
            ]);
            this.ccontainer = nextContainer;
            this.depth++;
            // when header is clicked, collapse/uncollapse container
            _domJs.addEventListener(content, "click", (_event)=>{
                nextContainer.toggleAttribute("hidden");
                triangleDown.toggleAttribute("hidden");
                triangleRight.toggleAttribute("hidden");
            });
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ groupCollapsed(args) {
        this.group(args, true);
    }
    groupEnd() {
        _eventloopJs.enqueue(()=>{
            if (this.depth > 0) {
                this.depth--;
                // @ts-ignore
                this.ccontainer = this.ccontainer.parentElement.parentElement;
            }
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ print(args) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element("div", [
                    _pairJs.create("style", `${lineStyle};padding-left:${this.depth * 10}px`)
                ], _computeLineSpans(args))
            ]);
        });
    }
    /**
   * @param {Error} err
   */ printError(err) {
        this.print([
            _loggingCommonJs.RED,
            _loggingCommonJs.BOLD,
            err.toString()
        ]);
    }
    /**
   * @param {string} url
   * @param {number} height
   */ printImg(url, height) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element("img", [
                    _pairJs.create("src", url),
                    _pairJs.create("height", `${_mathJs.round(height * 1.5)}px`)
                ])
            ]);
        });
    }
    /**
   * @param {Node} node
   */ printDom(node) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                node
            ]);
        });
    }
    destroy() {
        _eventloopJs.enqueue(()=>{
            vconsoles.delete(this);
        });
    }
}
const createVConsole = (dom)=>new VConsole(dom);
const createModuleLogger = (moduleName)=>_loggingCommonJs.createModuleLogger(print, moduleName);

},{"./environment.js":"j9Zn1","./set.js":"ilJ09","./pair.js":"fuge1","./dom.js":"96mGX","./json.js":"6Fr11","./map.js":"b1fdO","./eventloop.js":"d57uH","./math.js":"99M3Z","./logging.common.js":"fgcgY","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fuge1":[function(require,module,exports) {
/**
 * Working with value pairs.
 *
 * @module pair
 */ /**
 * @template L,R
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pair", ()=>Pair);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createReversed", ()=>createReversed);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
class Pair {
    /**
   * @param {L} left
   * @param {R} right
   */ constructor(left, right){
        this.left = left;
        this.right = right;
    }
}
const create = (left, right)=>new Pair(left, right);
const createReversed = (right, left)=>new Pair(left, right);
const forEach = (arr, f)=>arr.forEach((p)=>f(p.left, p.right));
const map = (arr, f)=>arr.map((p)=>f(p.left, p.right));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"96mGX":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Utility module to work with the DOM.
 *
 * @module dom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "doc", ()=>doc);
parcelHelpers.export(exports, "createElement", ()=>createElement);
parcelHelpers.export(exports, "createDocumentFragment", ()=>createDocumentFragment);
parcelHelpers.export(exports, "createTextNode", ()=>createTextNode);
parcelHelpers.export(exports, "domParser", ()=>domParser);
parcelHelpers.export(exports, "emitCustomEvent", ()=>emitCustomEvent);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
parcelHelpers.export(exports, "setAttributesMap", ()=>setAttributesMap);
parcelHelpers.export(exports, "fragment", ()=>fragment);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener);
parcelHelpers.export(exports, "removeEventListener", ()=>removeEventListener);
parcelHelpers.export(exports, "addEventListeners", ()=>addEventListeners);
parcelHelpers.export(exports, "removeEventListeners", ()=>removeEventListeners);
parcelHelpers.export(exports, "element", ()=>element);
parcelHelpers.export(exports, "canvas", ()=>canvas);
parcelHelpers.export(exports, "text", ()=>text);
parcelHelpers.export(exports, "pairToStyleString", ()=>pairToStyleString);
parcelHelpers.export(exports, "pairsToStyleString", ()=>pairsToStyleString);
parcelHelpers.export(exports, "mapToStyleString", ()=>mapToStyleString);
parcelHelpers.export(exports, "querySelector", ()=>querySelector);
parcelHelpers.export(exports, "querySelectorAll", ()=>querySelectorAll);
parcelHelpers.export(exports, "getElementById", ()=>getElementById);
parcelHelpers.export(exports, "parseFragment", ()=>parseFragment);
parcelHelpers.export(exports, "parseElement", ()=>parseElement);
parcelHelpers.export(exports, "replaceWith", ()=>replaceWith);
parcelHelpers.export(exports, "insertBefore", ()=>insertBefore);
parcelHelpers.export(exports, "appendChild", ()=>appendChild);
parcelHelpers.export(exports, "ELEMENT_NODE", ()=>ELEMENT_NODE);
parcelHelpers.export(exports, "TEXT_NODE", ()=>TEXT_NODE);
parcelHelpers.export(exports, "CDATA_SECTION_NODE", ()=>CDATA_SECTION_NODE);
parcelHelpers.export(exports, "COMMENT_NODE", ()=>COMMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_NODE", ()=>DOCUMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_TYPE_NODE", ()=>DOCUMENT_TYPE_NODE);
parcelHelpers.export(exports, "DOCUMENT_FRAGMENT_NODE", ()=>DOCUMENT_FRAGMENT_NODE);
parcelHelpers.export(exports, "checkNodeType", ()=>checkNodeType);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
var _pairJs = require("./pair.js");
var _mapJs = require("./map.js");
const doc = /** @type {Document} */ typeof document !== "undefined" ? document : {};
const createElement = (name)=>doc.createElement(name);
const createDocumentFragment = ()=>doc.createDocumentFragment();
const createTextNode = (text)=>doc.createTextNode(text);
const domParser = /** @type {DOMParser} */ typeof DOMParser !== "undefined" ? new DOMParser() : null;
const emitCustomEvent = (el, name, opts)=>el.dispatchEvent(new CustomEvent(name, opts));
const setAttributes = (el, attrs)=>{
    _pairJs.forEach(attrs, (key, value)=>{
        if (value === false) el.removeAttribute(key);
        else if (value === true) el.setAttribute(key, "");
        else // @ts-ignore
        el.setAttribute(key, value);
    });
    return el;
};
const setAttributesMap = (el, attrs)=>{
    attrs.forEach((value, key)=>{
        el.setAttribute(key, value);
    });
    return el;
};
const fragment = (children)=>{
    const fragment = createDocumentFragment();
    for(let i = 0; i < children.length; i++)appendChild(fragment, children[i]);
    return fragment;
};
const append = (parent, nodes)=>{
    appendChild(parent, fragment(nodes));
    return parent;
};
const remove = (el)=>el.remove();
const addEventListener = (el, name, f)=>el.addEventListener(name, f);
const removeEventListener = (el, name, f)=>el.removeEventListener(name, f);
const addEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>addEventListener(node, name, f));
    return node;
};
const removeEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>removeEventListener(node, name, f));
    return node;
};
const element = (name, attrs = [], children = [])=>append(setAttributes(createElement(name), attrs), children);
const canvas = (width, height)=>{
    const c = /** @type {HTMLCanvasElement} */ createElement("canvas");
    c.height = height;
    c.width = width;
    return c;
};
const text = createTextNode;
const pairToStyleString = (pair)=>`${pair.left}:${pair.right};`;
const pairsToStyleString = (pairs)=>pairs.map(pairToStyleString).join("");
const mapToStyleString = (m)=>_mapJs.map(m, (value, key)=>`${key}:${value};`).join("");
const querySelector = (el, query)=>el.querySelector(query);
const querySelectorAll = (el, query)=>el.querySelectorAll(query);
const getElementById = (id)=>/** @type {HTMLElement} */ doc.getElementById(id);
/**
 * @param {string} html
 * @return {HTMLElement}
 */ const _parse = (html)=>domParser.parseFromString(`<html><body>${html}</body></html>`, "text/html").body;
const parseFragment = (html)=>fragment(/** @type {any} */ _parse(html).childNodes);
const parseElement = (html)=>/** @type HTMLElement */ _parse(html).firstElementChild;
const replaceWith = (oldEl, newEl)=>oldEl.replaceWith(newEl);
const insertBefore = (parent, el, ref)=>parent.insertBefore(el, ref);
const appendChild = (parent, child)=>parent.appendChild(child);
const ELEMENT_NODE = doc.ELEMENT_NODE;
const TEXT_NODE = doc.TEXT_NODE;
const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
const COMMENT_NODE = doc.COMMENT_NODE;
const DOCUMENT_NODE = doc.DOCUMENT_NODE;
const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;
const checkNodeType = (node, type)=>node.nodeType === type;
const isParentOf = (parent, child)=>{
    let p = child.parentNode;
    while(p && p !== parent)p = p.parentNode;
    return p === parent;
} /* c8 ignore stop */ ;

},{"./pair.js":"fuge1","./map.js":"b1fdO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6Fr11":[function(require,module,exports) {
/**
 * JSON utility functions.
 *
 * @module json
 */ /**
 * Transform JavaScript object to JSON.
 *
 * @param {any} object
 * @return {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringify", ()=>stringify);
parcelHelpers.export(exports, "parse", ()=>parse);
const stringify = JSON.stringify;
const parse = JSON.parse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"d57uH":[function(require,module,exports) {
/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */ /**
 * Utility module to work with EcmaScript's event loop.
 *
 * @module eventloop
 */ /**
 * @type {Array<function>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enqueue", ()=>enqueue);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "interval", ()=>interval);
parcelHelpers.export(exports, "Animation", ()=>Animation);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame);
parcelHelpers.export(exports, "idleCallback", ()=>idleCallback);
parcelHelpers.export(exports, "createDebouncer", ()=>createDebouncer);
let queue = [];
const _runQueue = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue = [];
};
const enqueue = (f)=>{
    queue.push(f);
    if (queue.length === 1) setTimeout(_runQueue, 0);
};
/**
 * @typedef {Object} TimeoutObject
 * @property {function} TimeoutObject.destroy
 */ /**
 * @param {function(number):void} clearFunction
 */ const createTimeoutClass = (clearFunction)=>class TT {
        /**
   * @param {number} timeoutId
   */ constructor(timeoutId){
            this._ = timeoutId;
        }
        destroy() {
            clearFunction(this._);
        }
    };
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout, callback)=>new Timeout(setTimeout(callback, timeout));
const Interval = createTimeoutClass(clearInterval);
const interval = (timeout, callback)=>new Interval(setInterval(callback, timeout));
const Animation = createTimeoutClass((arg)=>typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
const animationFrame = (cb)=>typeof requestAnimationFrame === "undefined" ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));
/* c8 ignore next */ // @ts-ignore
const Idle = createTimeoutClass((arg)=>typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));
const idleCallback = (cb)=>typeof requestIdleCallback !== "undefined" ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);
const createDebouncer = (timeout)=>{
    let timer = -1;
    return (f)=>{
        clearTimeout(timer);
        if (f) timer = /** @type {any} */ setTimeout(f, timeout);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fgcgY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>BOLD);
parcelHelpers.export(exports, "UNBOLD", ()=>UNBOLD);
parcelHelpers.export(exports, "BLUE", ()=>BLUE);
parcelHelpers.export(exports, "GREY", ()=>GREY);
parcelHelpers.export(exports, "GREEN", ()=>GREEN);
parcelHelpers.export(exports, "RED", ()=>RED);
parcelHelpers.export(exports, "PURPLE", ()=>PURPLE);
parcelHelpers.export(exports, "ORANGE", ()=>ORANGE);
parcelHelpers.export(exports, "UNCOLOR", ()=>UNCOLOR);
parcelHelpers.export(exports, "computeNoColorLoggingArgs", ()=>computeNoColorLoggingArgs);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _symbolJs = require("./symbol.js");
var _timeJs = require("./time.js");
var _environmentJs = require("./environment.js");
var _functionJs = require("./function.js");
const BOLD = _symbolJs.create();
const UNBOLD = _symbolJs.create();
const BLUE = _symbolJs.create();
const GREY = _symbolJs.create();
const GREEN = _symbolJs.create();
const RED = _symbolJs.create();
const PURPLE = _symbolJs.create();
const ORANGE = _symbolJs.create();
const UNCOLOR = _symbolJs.create();
const computeNoColorLoggingArgs = (args)=>{
    const strBuilder = [];
    const logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        if (arg.constructor === String || arg.constructor === Number) strBuilder.push(arg);
        else if (arg.constructor === Object) logArgs.push(JSON.stringify(arg));
    }
    return logArgs;
};
/* c8 ignore stop */ const loggingColors = [
    GREEN,
    PURPLE,
    ORANGE,
    BLUE
];
let nextColor = 0;
let lastLoggingTime = _timeJs.getUnixTime();
const createModuleLogger = (_print, moduleName)=>{
    const color = loggingColors[nextColor];
    const debugRegexVar = _environmentJs.getVariable("log");
    const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ": ";
    return !doLogging ? _functionJs.nop : (...args)=>{
        const timeNow = _timeJs.getUnixTime();
        const timeDiff = timeNow - lastLoggingTime;
        lastLoggingTime = timeNow;
        _print(color, moduleName, UNCOLOR, ...args.map((arg)=>typeof arg === "string" || typeof arg === "symbol" ? arg : JSON.stringify(arg)), color, " +" + timeDiff + "ms");
    };
} /* c8 ignore stop */ ;

},{"./symbol.js":"izjBD","./time.js":"3YA6c","./environment.js":"j9Zn1","./function.js":"3Eway","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"izjBD":[function(require,module,exports) {
/**
 * Utility module to work with EcmaScript Symbols.
 *
 * @module symbol
 */ /**
 * Return fresh symbol.
 *
 * @return {Symbol}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
const create = Symbol;
const isSymbol = (s)=>typeof s === "symbol";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4bgn6":[function(require,module,exports) {
/**
 * Utility module to create and manipulate Iterators.
 *
 * @module iterator
 */ /**
 * @template T,R
 * @param {Iterator<T>} iterator
 * @param {function(T):R} f
 * @return {IterableIterator<R>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIterator", ()=>mapIterator);
parcelHelpers.export(exports, "createIterator", ()=>createIterator);
parcelHelpers.export(exports, "iteratorFilter", ()=>iteratorFilter);
parcelHelpers.export(exports, "iteratorMap", ()=>iteratorMap);
const mapIterator = (iterator, f)=>({
        [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next () {
            const r = iterator.next();
            return {
                value: r.done ? undefined : f(r.value),
                done: r.done
            };
        }
    });
const createIterator = (next)=>({
        /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next
    });
const iteratorFilter = (iterator, filter)=>createIterator(()=>{
        let res;
        do res = iterator.next();
        while (!res.done && !filter(res.value));
        return res;
    });
const iteratorMap = (iterator, fmap)=>createIterator(()=>{
        const { done, value } = iterator.next();
        return {
            done,
            value: done ? undefined : fmap(value)
        };
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bxGRZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
const { fromCharCode } = String;
const encode = (uint8array)=>{
    const output = [];
    for(let i = 0, { length } = uint8array; i < length; i++)output.push(fromCharCode(uint8array[i]));
    return btoa(output.join(""));
};
const asCharCode = (c)=>c.charCodeAt(0);
const decode = (chars)=>Uint8Array.from(atob(chars), asCharCode);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"r4dLl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "render", ()=>render);
var _vue = require("vue");
const _hoisted_1 = /*#__PURE__*/ (0, _vue.createElementVNode)("a", {
    href: "/",
    "data-link": "true"
}, "edrys-lite", -1 /* HOISTED */ );
const _hoisted_2 = {
    class: "pa-2"
};
function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_v_app_bar_nav_icon = (0, _vue.resolveComponent)("v-app-bar-nav-icon");
    const _component_v_app_bar_title = (0, _vue.resolveComponent)("v-app-bar-title");
    const _component_v_btn = (0, _vue.resolveComponent)("v-btn");
    const _component_v_app_bar = (0, _vue.resolveComponent)("v-app-bar");
    const _component_v_card_text = (0, _vue.resolveComponent)("v-card-text");
    const _component_v_divider = (0, _vue.resolveComponent)("v-divider");
    const _component_v_text_field = (0, _vue.resolveComponent)("v-text-field");
    const _component_v_icon = (0, _vue.resolveComponent)("v-icon");
    const _component_v_card = (0, _vue.resolveComponent)("v-card");
    const _component_v_overlay = (0, _vue.resolveComponent)("v-overlay");
    const _component_v_list_item_title = (0, _vue.resolveComponent)("v-list-item-title");
    const _component_v_list_item_subtitle = (0, _vue.resolveComponent)("v-list-item-subtitle");
    const _component_v_list_item = (0, _vue.resolveComponent)("v-list-item");
    const _component_v_list = (0, _vue.resolveComponent)("v-list");
    const _component_v_navigation_drawer = (0, _vue.resolveComponent)("v-navigation-drawer");
    const _component_Modules = (0, _vue.resolveComponent)("Modules");
    const _component_v_col = (0, _vue.resolveComponent)("v-col");
    const _component_v_main = (0, _vue.resolveComponent)("v-main");
    const _component_v_layout = (0, _vue.resolveComponent)("v-layout");
    const _component_Settings = (0, _vue.resolveComponent)("Settings");
    const _component_v_dialog = (0, _vue.resolveComponent)("v-dialog");
    const _component_v_app = (0, _vue.resolveComponent)("v-app");
    return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_app, null, {
        default: (0, _vue.withCtx)(()=>[
                (0, _vue.createVNode)(_component_v_layout, null, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_v_app_bar, {
                                color: "surface-variant"
                            }, {
                                prepend: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_app_bar_nav_icon, {
                                            onClick: _cache[0] || (_cache[0] = ($event)=>$data.showSideMenu = !$data.showSideMenu)
                                        }),
                                        (0, _vue.createCommentVNode)(" remove underline from link "),
                                        (0, _vue.createVNode)(_component_v_app_bar_title, {
                                            tag: "a",
                                            style: {
                                                "color": "white",
                                                "text-decoration": "none"
                                            },
                                            title: "Back to index-page"
                                        }, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    _hoisted_1
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                append: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_btn, {
                                            icon: "mdi-dots-vertical"
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            }),
                            (0, _vue.createVNode)(_component_v_navigation_drawer, {
                                temporary: "",
                                modelValue: $data.showSideMenu,
                                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event)=>$data.showSideMenu = $event)
                            }, {
                                append: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createElementVNode)("div", _hoisted_2, [
                                            !$data.isStation && $data.room?.data?.createdBy === $data.communication?.getId() ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_btn, {
                                                key: 0,
                                                depressed: "",
                                                block: "",
                                                class: "mb-2",
                                                onClick: $options.addRoom
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createVNode)(_component_v_icon, {
                                                            left: ""
                                                        }, {
                                                            default: (0, _vue.withCtx)(()=>[
                                                                    (0, _vue.createTextVNode)("mdi-forum")
                                                                ]),
                                                            _: 1 /* STABLE */ 
                                                        }),
                                                        (0, _vue.createTextVNode)(" New room ")
                                                    ]),
                                                _: 1 /* STABLE */ 
                                            }, 8 /* PROPS */ , [
                                                "onClick"
                                            ])) : (0, _vue.createCommentVNode)("v-if", true)
                                        ])
                                    ]),
                                default: (0, _vue.withCtx)(()=>[
                                        $data.isStation ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_overlay, {
                                            key: 0,
                                            modelValue: $data.showSideMenu,
                                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event)=>$data.showSideMenu = $event),
                                            style: {
                                                "width": "275px"
                                            }
                                        }, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_card, {
                                                        tile: "",
                                                        width: "100%",
                                                        class: "text-center",
                                                        style: {
                                                            "margin-top": "calc(50vh - 100px)"
                                                        }
                                                    }, {
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createVNode)(_component_v_card_text, {
                                                                    class: "white--text"
                                                                }, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createTextVNode)(" Station Mode Active ")
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                }),
                                                                (0, _vue.createVNode)(_component_v_divider),
                                                                (0, _vue.createVNode)(_component_v_card_text, null, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createVNode)(_component_v_text_field, {
                                                                                outlined: "",
                                                                                modelValue: $data.stationName,
                                                                                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event)=>$data.stationName = $event),
                                                                                active: "false",
                                                                                label: "Station Name",
                                                                                required: "",
                                                                                disabled: "true"
                                                                            }, null, 8 /* PROPS */ , [
                                                                                "modelValue"
                                                                            ]),
                                                                            (0, _vue.createTextVNode)(" This browser is now running as a station and ready to serve students ")
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                }),
                                                                (0, _vue.createVNode)(_component_v_divider),
                                                                (0, _vue.createVNode)(_component_v_card_text, null, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createVNode)(_component_v_btn, {
                                                                                href: "/?/classroom/" + $props.id
                                                                            }, {
                                                                                default: (0, _vue.withCtx)(()=>[
                                                                                        (0, _vue.createVNode)(_component_v_icon, {
                                                                                            left: ""
                                                                                        }, {
                                                                                            default: (0, _vue.withCtx)(()=>[
                                                                                                    (0, _vue.createTextVNode)("mdi-export-variant")
                                                                                                ]),
                                                                                            _: 1 /* STABLE */ 
                                                                                        }),
                                                                                        (0, _vue.createTextVNode)(" Exit Station mode ")
                                                                                    ]),
                                                                                _: 1 /* STABLE */ 
                                                                            }, 8 /* PROPS */ , [
                                                                                "href"
                                                                            ])
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                })
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    })
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }, 8 /* PROPS */ , [
                                            "modelValue"
                                        ])) : (0, _vue.createCommentVNode)("v-if", true),
                                        (0, _vue.createVNode)(_component_v_list, {
                                            density: "compact",
                                            nav: ""
                                        }, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    (0, _vue.createVNode)(_component_v_list_item, null, {
                                                        append: (0, _vue.withCtx)(()=>[
                                                                !$data.isStation && $data.room?.data?.createdBy === $data.communication?.getId() ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_btn, {
                                                                    key: 0,
                                                                    color: "grey",
                                                                    icon: "mdi-cog",
                                                                    onClick: _cache[3] || (_cache[3] = ($event)=>$data.showSettings = !$data.showSettings),
                                                                    variant: "text"
                                                                })) : (0, _vue.createCommentVNode)("v-if", true)
                                                            ]),
                                                        default: (0, _vue.withCtx)(()=>[
                                                                (0, _vue.createVNode)(_component_v_list_item_title, null, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createTextVNode)((0, _vue.toDisplayString)($data.room?.data?.name || ""), 1 /* TEXT */ )
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                }),
                                                                (0, _vue.createVNode)(_component_v_list_item_subtitle, null, {
                                                                    default: (0, _vue.withCtx)(()=>[
                                                                            (0, _vue.createTextVNode)(" online users " + (0, _vue.toDisplayString)(Object.keys($data.liveClassProxy?.users || {}).length), 1 /* TEXT */ )
                                                                        ]),
                                                                    _: 1 /* STABLE */ 
                                                                })
                                                            ]),
                                                        _: 1 /* STABLE */ 
                                                    })
                                                ]),
                                            _: 1 /* STABLE */ 
                                        }),
                                        (0, _vue.createVNode)(_component_v_divider),
                                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($options.getRooms(), (room, name, i)=>{
                                            return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_list, {
                                                nav: "",
                                                key: i,
                                                density: "compact"
                                            }, {
                                                default: (0, _vue.withCtx)(()=>[
                                                        (0, _vue.createVNode)(_component_v_list_item, {
                                                            "prepend-icon": name === "Lobby" ? "mdi-account-group" : "mdi-forum",
                                                            title: name,
                                                            style: {
                                                                "background-color": "lightgray",
                                                                "padding-top": "0px",
                                                                "padding-bottom": "0px",
                                                                "min-height": "2rem"
                                                            }
                                                        }, {
                                                            append: (0, _vue.withCtx)(()=>[
                                                                    (0, _vue.createVNode)(_component_v_btn, {
                                                                        icon: "mdi-arrow-right-circle",
                                                                        variant: "text",
                                                                        onClick: ($event)=>$options.gotoRoom(name)
                                                                    }, null, 8 /* PROPS */ , [
                                                                        "onClick"
                                                                    ])
                                                                ]),
                                                            _: 2 /* DYNAMIC */ 
                                                        }, 1032 /* PROPS, DYNAMIC_SLOTS */ , [
                                                            "prepend-icon",
                                                            "title"
                                                        ]),
                                                        ((0, _vue.openBlock)(true), (0, _vue.createElementBlock)((0, _vue.Fragment), null, (0, _vue.renderList)($options.usersInRoom(name), (user, j)=>{
                                                            return (0, _vue.openBlock)(), (0, _vue.createBlock)(_component_v_list_item, {
                                                                key: j,
                                                                title: user,
                                                                style: {
                                                                    "min-height": "1.25rem"
                                                                }
                                                            }, null, 8 /* PROPS */ , [
                                                                "title"
                                                            ]);
                                                        }), 128 /* KEYED_FRAGMENT */ ))
                                                    ]),
                                                _: 2 /* DYNAMIC */ 
                                            }, 1024 /* DYNAMIC_SLOTS */ );
                                        }), 128 /* KEYED_FRAGMENT */ ))
                                    ]),
                                _: 1 /* STABLE */ 
                            }, 8 /* PROPS */ , [
                                "modelValue"
                            ]),
                            (0, _vue.createVNode)(_component_v_main, {
                                style: {
                                    "overflow-y": "scroll"
                                }
                            }, {
                                default: (0, _vue.withCtx)(()=>[
                                        (0, _vue.createVNode)(_component_v_col, null, {
                                            default: (0, _vue.withCtx)(()=>[
                                                    $data.liveClassProxy !== null ? ((0, _vue.openBlock)(), (0, _vue.createBlock)(_component_Modules, {
                                                        role: $data.isStation ? "station" : $data.room.data.createdBy === $data.communication?.getId() ? "teacher" : "student",
                                                        username_: $data.communication?.getId(),
                                                        liveClassProxy: $data.liveClassProxy,
                                                        scrapedModules_: $data.scrapedModules,
                                                        communication: $data.communication,
                                                        key: $data.componentKey,
                                                        class_id: $props.id
                                                    }, null, 8 /* PROPS */ , [
                                                        "role",
                                                        "username_",
                                                        "liveClassProxy",
                                                        "scrapedModules_",
                                                        "communication",
                                                        "class_id"
                                                    ])) : (0, _vue.createCommentVNode)("v-if", true)
                                                ]),
                                            _: 1 /* STABLE */ 
                                        })
                                    ]),
                                _: 1 /* STABLE */ 
                            })
                        ]),
                    _: 1 /* STABLE */ 
                }),
                (0, _vue.createVNode)(_component_v_dialog, {
                    modelValue: $data.showSettings,
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event)=>$data.showSettings = $event),
                    "max-width": "1200px",
                    width: "90%",
                    scrollable: "",
                    persistent: "",
                    id: "settings" + $data.componentKey
                }, {
                    default: (0, _vue.withCtx)(()=>[
                            (0, _vue.createVNode)(_component_Settings, {
                                ref: "Settings",
                                onClose: _cache[5] || (_cache[5] = ($event)=>$data.showSettings = false),
                                config: $data.data,
                                scrapedModules: $data.scrapedModules,
                                onSaveClass: $options.saveClass,
                                onDeleteClass: $options.deleteClass,
                                onUpdateClass: $options.updateClass
                            }, null, 8 /* PROPS */ , [
                                "config",
                                "scrapedModules",
                                "onSaveClass",
                                "onDeleteClass",
                                "onUpdateClass"
                            ])
                        ]),
                    _: 1 /* STABLE */ 
                }, 8 /* PROPS */ , [
                    "modelValue",
                    "id"
                ])
            ]),
        _: 1 /* STABLE */ 
    });
}
if (module.hot) module.hot.accept(()=>{
    __VUE_HMR_RUNTIME__.rerender("19d649-hmr", render);
});

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dZNk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let NOOP = ()=>{};
exports.default = (script)=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"451o5":[function() {},{}],"fBTzQ":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createVuetify", ()=>createVuetify);
parcelHelpers.export(exports, "version", ()=>version);
var _defaultsMjs = require("./composables/defaults.mjs");
var _displayMjs = require("./composables/display.mjs");
var _iconsMjs = require("./composables/icons.mjs");
var _localeMjs = require("./composables/locale.mjs");
var _themeMjs = require("./composables/theme.mjs");
var _dateMjs = require("./labs/date/date.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("./util/index.mjs"); // Types
var _indexMjs1 = require("./composables/index.mjs");
parcelHelpers.exportAll(_indexMjs1, exports);
function createVuetify() {
    let vuetify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const { blueprint, ...rest } = vuetify;
    const options = (0, _indexMjs.mergeDeep)(blueprint, rest);
    const { aliases = {}, components = {}, directives = {} } = options;
    const defaults = (0, _defaultsMjs.createDefaults)(options.defaults);
    const display = (0, _displayMjs.createDisplay)(options.display, options.ssr);
    const theme = (0, _themeMjs.createTheme)(options.theme);
    const icons = (0, _iconsMjs.createIcons)(options.icons);
    const locale = (0, _localeMjs.createLocale)(options.locale);
    const date = (0, _dateMjs.createDate)(options.date);
    const install = (app)=>{
        for(const key in directives)app.directive(key, directives[key]);
        for(const key in components)app.component(key, components[key]);
        for(const key in aliases)app.component(key, (0, _indexMjs.defineComponent)({
            ...aliases[key],
            name: key,
            aliasName: aliases[key].name
        }));
        theme.install(app);
        app.provide((0, _defaultsMjs.DefaultsSymbol), defaults);
        app.provide((0, _displayMjs.DisplaySymbol), display);
        app.provide((0, _themeMjs.ThemeSymbol), theme);
        app.provide((0, _iconsMjs.IconSymbol), icons);
        app.provide((0, _localeMjs.LocaleSymbol), locale);
        app.provide((0, _dateMjs.DateAdapterSymbol), date);
        if ((0, _indexMjs.IN_BROWSER) && options.ssr) {
            if (app.$nuxt) app.$nuxt.hook("app:suspense:resolve", ()=>{
                display.update();
            });
            else {
                const { mount } = app;
                app.mount = function() {
                    const vm = mount(...arguments);
                    (0, _vue.nextTick)(()=>display.update());
                    app.mount = mount;
                    return vm;
                };
            }
        }
        (0, _indexMjs.getUid).reset();
        if (typeof __VUE_OPTIONS_API__ !== "boolean" || __VUE_OPTIONS_API__) app.mixin({
            computed: {
                $vuetify () {
                    return (0, _vue.reactive)({
                        defaults: inject.call(this, (0, _defaultsMjs.DefaultsSymbol)),
                        display: inject.call(this, (0, _displayMjs.DisplaySymbol)),
                        theme: inject.call(this, (0, _themeMjs.ThemeSymbol)),
                        icons: inject.call(this, (0, _iconsMjs.IconSymbol)),
                        locale: inject.call(this, (0, _localeMjs.LocaleSymbol)),
                        date: inject.call(this, (0, _dateMjs.DateAdapterSymbol))
                    });
                }
            }
        });
    };
    return {
        install,
        defaults,
        display,
        theme,
        icons,
        locale,
        date
    };
}
const version = "3.3.16";
createVuetify.version = version;
// Vue's inject() can only be used in setup
function inject(key) {
    const vm = this.$;
    const provides = vm.parent?.provides ?? vm.vnode.appContext?.provides;
    if (provides && key in provides) return provides[key];
}

},{"./composables/defaults.mjs":"11B6w","./composables/display.mjs":"6nXZK","./composables/icons.mjs":"ezwoc","./composables/locale.mjs":"4MZbL","./composables/theme.mjs":"9LCgN","./labs/date/date.mjs":"kn66v","vue":"ff77s","./util/index.mjs":"6uIWw","./composables/index.mjs":false,"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"11B6w":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultsSymbol", ()=>DefaultsSymbol);
parcelHelpers.export(exports, "createDefaults", ()=>createDefaults);
parcelHelpers.export(exports, "injectDefaults", ()=>injectDefaults);
parcelHelpers.export(exports, "provideDefaults", ()=>provideDefaults);
parcelHelpers.export(exports, "internalUseDefaults", ()=>internalUseDefaults);
parcelHelpers.export(exports, "useDefaults", ()=>useDefaults);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
    return (0, _vue.ref)(options);
}
function injectDefaults() {
    const defaults = (0, _vue.inject)(DefaultsSymbol);
    if (!defaults) throw new Error("[Vuetify] Could not find defaults instance");
    return defaults;
}
function provideDefaults(defaults, options) {
    const injectedDefaults = injectDefaults();
    const providedDefaults = (0, _vue.ref)(defaults);
    const newDefaults = (0, _vue.computed)(()=>{
        const disabled = (0, _vue.unref)(options?.disabled);
        if (disabled) return injectedDefaults.value;
        const scoped = (0, _vue.unref)(options?.scoped);
        const reset = (0, _vue.unref)(options?.reset);
        const root = (0, _vue.unref)(options?.root);
        if (providedDefaults.value == null && !(scoped || reset || root)) return injectedDefaults.value;
        let properties = (0, _indexMjs.mergeDeep)(providedDefaults.value, {
            prev: injectedDefaults.value
        });
        if (scoped) return properties;
        if (reset || root) {
            const len = Number(reset || Infinity);
            for(let i = 0; i <= len; i++){
                if (!properties || !("prev" in properties)) break;
                properties = properties.prev;
            }
            if (properties && typeof root === "string" && root in properties) properties = (0, _indexMjs.mergeDeep)((0, _indexMjs.mergeDeep)(properties, {
                prev: properties
            }), properties[root]);
            return properties;
        }
        return properties.prev ? (0, _indexMjs.mergeDeep)(properties.prev, properties) : properties;
    });
    (0, _vue.provide)(DefaultsSymbol, newDefaults);
    return newDefaults;
}
function propIsDefined(vnode, prop) {
    return typeof vnode.props?.[prop] !== "undefined" || typeof vnode.props?.[(0, _indexMjs.toKebabCase)(prop)] !== "undefined";
}
function internalUseDefaults() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let name = arguments.length > 1 ? arguments[1] : undefined;
    let defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : injectDefaults();
    const vm = (0, _indexMjs.getCurrentInstance)("useDefaults");
    name = name ?? vm.type.name ?? vm.type.__name;
    if (!name) throw new Error("[Vuetify] Could not determine component name");
    const componentDefaults = (0, _vue.computed)(()=>defaults.value?.[props._as ?? name]);
    const _props = new Proxy(props, {
        get (target, prop) {
            const propValue = Reflect.get(target, prop);
            if (prop === "class" || prop === "style") return [
                componentDefaults.value?.[prop],
                propValue
            ].filter((v)=>v != null);
            else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) return componentDefaults.value?.[prop] ?? defaults.value?.global?.[prop] ?? propValue;
            return propValue;
        }
    });
    const _subcomponentDefaults = (0, _vue.shallowRef)();
    (0, _vue.watchEffect)(()=>{
        if (componentDefaults.value) {
            const subComponents = Object.entries(componentDefaults.value).filter((_ref)=>{
                let [key] = _ref;
                return key.startsWith(key[0].toUpperCase());
            });
            _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : undefined;
        } else _subcomponentDefaults.value = undefined;
    });
    function provideSubDefaults() {
        const injected = (0, _indexMjs.injectSelf)(DefaultsSymbol, vm);
        (0, _vue.provide)(DefaultsSymbol, (0, _vue.computed)(()=>{
            return _subcomponentDefaults.value ? (0, _indexMjs.mergeDeep)(injected?.value ?? {}, _subcomponentDefaults.value) : injected?.value;
        }));
    }
    return {
        props: _props,
        provideSubDefaults
    };
}
function useDefaults() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let name = arguments.length > 1 ? arguments[1] : undefined;
    const { props: _props, provideSubDefaults } = internalUseDefaults(props, name);
    provideSubDefaults();
    return _props;
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6uIWw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _anchorMjs = require("./anchor.mjs");
parcelHelpers.exportAll(_anchorMjs, exports);
var _animationMjs = require("./animation.mjs");
parcelHelpers.exportAll(_animationMjs, exports);
var _bindPropsMjs = require("./bindProps.mjs");
parcelHelpers.exportAll(_bindPropsMjs, exports);
var _colorUtilsMjs = require("./colorUtils.mjs");
parcelHelpers.exportAll(_colorUtilsMjs, exports);
var _consoleMjs = require("./console.mjs");
parcelHelpers.exportAll(_consoleMjs, exports);
var _createSimpleFunctionalMjs = require("./createSimpleFunctional.mjs");
parcelHelpers.exportAll(_createSimpleFunctionalMjs, exports);
var _defineComponentMjs = require("./defineComponent.mjs");
parcelHelpers.exportAll(_defineComponentMjs, exports);
var _domMjs = require("./dom.mjs");
parcelHelpers.exportAll(_domMjs, exports);
var _easingMjs = require("./easing.mjs");
parcelHelpers.exportAll(_easingMjs, exports);
var _getCurrentInstanceMjs = require("./getCurrentInstance.mjs");
parcelHelpers.exportAll(_getCurrentInstanceMjs, exports);
var _getScrollParentMjs = require("./getScrollParent.mjs");
parcelHelpers.exportAll(_getScrollParentMjs, exports);
var _globalsMjs = require("./globals.mjs");
parcelHelpers.exportAll(_globalsMjs, exports);
var _helpersMjs = require("./helpers.mjs");
parcelHelpers.exportAll(_helpersMjs, exports);
var _injectSelfMjs = require("./injectSelf.mjs");
parcelHelpers.exportAll(_injectSelfMjs, exports);
var _isFixedPositionMjs = require("./isFixedPosition.mjs");
parcelHelpers.exportAll(_isFixedPositionMjs, exports);
var _propsFactoryMjs = require("./propsFactory.mjs");
parcelHelpers.exportAll(_propsFactoryMjs, exports);
var _useRenderMjs = require("./useRender.mjs");
parcelHelpers.exportAll(_useRenderMjs, exports);

},{"./anchor.mjs":"6PVNe","./animation.mjs":"4XWex","./bindProps.mjs":"39gaC","./colorUtils.mjs":"7U9Hi","./console.mjs":"d3sZr","./createSimpleFunctional.mjs":"50sjd","./defineComponent.mjs":"5tFXo","./dom.mjs":"c4c8X","./easing.mjs":"eJSW7","./getCurrentInstance.mjs":"5Irou","./getScrollParent.mjs":"964BL","./globals.mjs":"8Aq1g","./helpers.mjs":"fcCSo","./injectSelf.mjs":"2Ag2W","./isFixedPosition.mjs":"dzuRI","./propsFactory.mjs":"8JLu1","./useRender.mjs":"1OxHl","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6PVNe":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Parse a raw anchor string into an object */ parcelHelpers.export(exports, "parseAnchor", ()=>parseAnchor);
parcelHelpers.export(exports, "toPhysical", ()=>toPhysical);
parcelHelpers.export(exports, "flipSide", ()=>flipSide);
parcelHelpers.export(exports, "flipAlign", ()=>flipAlign);
parcelHelpers.export(exports, "flipCorner", ()=>flipCorner);
parcelHelpers.export(exports, "getAxis", ()=>getAxis);
var _helpersMjs = require("./helpers.mjs");
const block = [
    "top",
    "bottom"
];
const inline = [
    "start",
    "end",
    "left",
    "right"
];
function parseAnchor(anchor, isRtl) {
    let [side, align] = anchor.split(" ");
    if (!align) align = (0, _helpersMjs.includes)(block, side) ? "start" : (0, _helpersMjs.includes)(inline, side) ? "top" : "center";
    return {
        side: toPhysical(side, isRtl),
        align: toPhysical(align, isRtl)
    };
}
function toPhysical(str, isRtl) {
    if (str === "start") return isRtl ? "right" : "left";
    if (str === "end") return isRtl ? "left" : "right";
    return str;
}
function flipSide(anchor) {
    return {
        side: ({
            center: "center",
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
        })[anchor.side],
        align: anchor.align
    };
}
function flipAlign(anchor) {
    return {
        side: anchor.side,
        align: ({
            center: "center",
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
        })[anchor.align]
    };
}
function flipCorner(anchor) {
    return {
        side: anchor.align,
        align: anchor.side
    };
}
function getAxis(anchor) {
    return (0, _helpersMjs.includes)(block, anchor.side) ? "y" : "x";
}

},{"./helpers.mjs":"fcCSo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fcCSo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getNestedValue", ()=>getNestedValue);
parcelHelpers.export(exports, "deepEqual", ()=>deepEqual);
parcelHelpers.export(exports, "getObjectValueByPath", ()=>getObjectValueByPath);
parcelHelpers.export(exports, "getPropertyFromItem", ()=>getPropertyFromItem);
parcelHelpers.export(exports, "createRange", ()=>createRange);
parcelHelpers.export(exports, "getZIndex", ()=>getZIndex);
parcelHelpers.export(exports, "convertToUnit", ()=>convertToUnit);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "refElement", ()=>refElement);
parcelHelpers.export(exports, "keyCodes", ()=>keyCodes);
parcelHelpers.export(exports, "keyValues", ()=>keyValues);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "has", ()=>has);
parcelHelpers.export(exports, "pick", ()=>pick);
parcelHelpers.export(exports, "omit", ()=>omit);
parcelHelpers.export(exports, "only", ()=>only);
parcelHelpers.export(exports, "isOn", ()=>isOn);
/**
 * Filter attributes that should be applied to
 * the root element of an input component. Remaining
 * attributes should be passed to the <input> element inside.
 */ parcelHelpers.export(exports, "filterInputAttrs", ()=>filterInputAttrs);
/**
 * Returns the set difference of B and A, i.e. the set of elements in B but not in A
 */ parcelHelpers.export(exports, "arrayDiff", ()=>arrayDiff);
parcelHelpers.export(exports, "wrapInArray", ()=>wrapInArray);
parcelHelpers.export(exports, "defaultFilter", ()=>defaultFilter);
parcelHelpers.export(exports, "searchItems", ()=>searchItems);
parcelHelpers.export(exports, "debounce", ()=>debounce);
parcelHelpers.export(exports, "throttle", ()=>throttle);
/**
 * Filters slots to only those starting with `prefix`, removing the prefix
 */ parcelHelpers.export(exports, "getPrefixedSlots", ()=>getPrefixedSlots);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "getDecimals", ()=>getDecimals);
parcelHelpers.export(exports, "padEnd", ()=>padEnd);
parcelHelpers.export(exports, "padStart", ()=>padStart);
parcelHelpers.export(exports, "chunk", ()=>chunk);
parcelHelpers.export(exports, "humanReadableFileSize", ()=>humanReadableFileSize);
parcelHelpers.export(exports, "camelizeObjectKeys", ()=>camelizeObjectKeys);
parcelHelpers.export(exports, "mergeDeep", ()=>mergeDeep);
parcelHelpers.export(exports, "fillArray", ()=>fillArray);
parcelHelpers.export(exports, "flattenFragments", ()=>flattenFragments);
parcelHelpers.export(exports, "randomHexColor", ()=>randomHexColor);
parcelHelpers.export(exports, "toKebabCase", ()=>toKebabCase);
parcelHelpers.export(exports, "findChildren", ()=>findChildren);
parcelHelpers.export(exports, "findChildrenWithProvide", ()=>findChildrenWithProvide);
parcelHelpers.export(exports, "CircularBuffer", ()=>CircularBuffer);
parcelHelpers.export(exports, "getEventCoordinates", ()=>getEventCoordinates);
// Only allow a single return type
parcelHelpers.export(exports, "destructComputed", ()=>destructComputed);
/** Array.includes but value can be any type */ parcelHelpers.export(exports, "includes", ()=>includes);
parcelHelpers.export(exports, "eventName", ()=>eventName);
parcelHelpers.export(exports, "EventProp", ()=>EventProp);
parcelHelpers.export(exports, "hasEvent", ()=>hasEvent);
parcelHelpers.export(exports, "callEvent", ()=>callEvent);
parcelHelpers.export(exports, "focusableChildren", ()=>focusableChildren);
parcelHelpers.export(exports, "getNextElement", ()=>getNextElement);
parcelHelpers.export(exports, "focusChild", ()=>focusChild);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "noop", ()=>noop);
/** Returns null if the selector is not supported or we can't check */ parcelHelpers.export(exports, "matchesSelector", ()=>matchesSelector);
// Utilities
var _vue = require("vue");
var _globalsMjs = require("./globals.mjs"); // Types
function _classPrivateFieldInitSpec(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) descriptor.set.call(receiver, value);
    else {
        if (!descriptor.writable) throw new TypeError("attempted to set read only private field");
        descriptor.value = value;
    }
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
    return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) return descriptor.get.call(receiver);
    return descriptor.value;
}
function getNestedValue(obj, path, fallback) {
    const last = path.length - 1;
    if (last < 0) return obj === undefined ? fallback : obj;
    for(let i = 0; i < last; i++){
        if (obj == null) return fallback;
        obj = obj[path[i]];
    }
    if (obj == null) return fallback;
    return obj[path[last]] === undefined ? fallback : obj[path[last]];
}
function deepEqual(a, b) {
    if (a === b) return true;
    if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) // If the values are Date, compare them as timestamps
    return false;
    if (a !== Object(a) || b !== Object(b)) // If the values aren't objects, they were already checked for equality
    return false;
    const props = Object.keys(a);
    if (props.length !== Object.keys(b).length) // Different number of props, don't bother to check
    return false;
    return props.every((p)=>deepEqual(a[p], b[p]));
}
function getObjectValueByPath(obj, path, fallback) {
    // credit: http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key#comment55278413_6491621
    if (obj == null || !path || typeof path !== "string") return fallback;
    if (obj[path] !== undefined) return obj[path];
    path = path.replace(/\[(\w+)\]/g, ".$1"); // convert indexes to properties
    path = path.replace(/^\./, ""); // strip a leading dot
    return getNestedValue(obj, path.split("."), fallback);
}
function getPropertyFromItem(item, property, fallback) {
    if (property == null) return item === undefined ? fallback : item;
    if (item !== Object(item)) {
        if (typeof property !== "function") return fallback;
        const value = property(item, fallback);
        return typeof value === "undefined" ? fallback : value;
    }
    if (typeof property === "string") return getObjectValueByPath(item, property, fallback);
    if (Array.isArray(property)) return getNestedValue(item, property, fallback);
    if (typeof property !== "function") return fallback;
    const value = property(item, fallback);
    return typeof value === "undefined" ? fallback : value;
}
function createRange(length) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return Array.from({
        length
    }, (v, k)=>start + k);
}
function getZIndex(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return 0;
    const index = +window.getComputedStyle(el).getPropertyValue("z-index");
    if (!index) return getZIndex(el.parentNode);
    return index;
}
function convertToUnit(str) {
    let unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "px";
    if (str == null || str === "") return undefined;
    else if (isNaN(+str)) return String(str);
    else if (!isFinite(+str)) return undefined;
    else return `${Number(str)}${unit}`;
}
function isObject(obj) {
    return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
function refElement(obj) {
    return obj && "$el" in obj ? obj.$el : obj;
}
const keyCodes = Object.freeze({
    enter: 13,
    tab: 9,
    delete: 46,
    esc: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    end: 35,
    home: 36,
    del: 46,
    backspace: 8,
    insert: 45,
    pageup: 33,
    pagedown: 34,
    shift: 16
});
const keyValues = Object.freeze({
    enter: "Enter",
    tab: "Tab",
    delete: "Delete",
    esc: "Escape",
    space: "Space",
    up: "ArrowUp",
    down: "ArrowDown",
    left: "ArrowLeft",
    right: "ArrowRight",
    end: "End",
    home: "Home",
    del: "Delete",
    backspace: "Backspace",
    insert: "Insert",
    pageup: "PageUp",
    pagedown: "PageDown",
    shift: "Shift"
});
function keys(o) {
    return Object.keys(o);
}
function has(obj, key) {
    return key.every((k)=>obj.hasOwnProperty(k));
}
function pick(obj, paths, exclude) {
    const found = Object.create(null);
    const rest = Object.create(null);
    for(const key in obj)if (paths.some((path)=>path instanceof RegExp ? path.test(key) : path === key) && !exclude?.some((path)=>path === key)) found[key] = obj[key];
    else rest[key] = obj[key];
    return [
        found,
        rest
    ];
}
function omit(obj, exclude) {
    const clone = {
        ...obj
    };
    exclude.forEach((prop)=>delete clone[prop]);
    return clone;
}
function only(obj, include) {
    const clone = {};
    include.forEach((prop)=>clone[prop] = obj[prop]);
    return clone;
}
const onRE = /^on[^a-z]/;
const isOn = (key)=>onRE.test(key);
const bubblingEvents = [
    "onAfterscriptexecute",
    "onAnimationcancel",
    "onAnimationend",
    "onAnimationiteration",
    "onAnimationstart",
    "onAuxclick",
    "onBeforeinput",
    "onBeforescriptexecute",
    "onChange",
    "onClick",
    "onCompositionend",
    "onCompositionstart",
    "onCompositionupdate",
    "onContextmenu",
    "onCopy",
    "onCut",
    "onDblclick",
    "onFocusin",
    "onFocusout",
    "onFullscreenchange",
    "onFullscreenerror",
    "onGesturechange",
    "onGestureend",
    "onGesturestart",
    "onGotpointercapture",
    "onInput",
    "onKeydown",
    "onKeypress",
    "onKeyup",
    "onLostpointercapture",
    "onMousedown",
    "onMousemove",
    "onMouseout",
    "onMouseover",
    "onMouseup",
    "onMousewheel",
    "onPaste",
    "onPointercancel",
    "onPointerdown",
    "onPointerenter",
    "onPointerleave",
    "onPointermove",
    "onPointerout",
    "onPointerover",
    "onPointerup",
    "onReset",
    "onSelect",
    "onSubmit",
    "onTouchcancel",
    "onTouchend",
    "onTouchmove",
    "onTouchstart",
    "onTransitioncancel",
    "onTransitionend",
    "onTransitionrun",
    "onTransitionstart",
    "onWheel"
];
function filterInputAttrs(attrs) {
    const [events, props] = pick(attrs, [
        onRE
    ]);
    const inputEvents = omit(events, bubblingEvents);
    const [rootAttrs, inputAttrs] = pick(props, [
        "class",
        "style",
        "id",
        /^data-/
    ]);
    Object.assign(rootAttrs, events);
    Object.assign(inputAttrs, inputEvents);
    return [
        rootAttrs,
        inputAttrs
    ];
}
function arrayDiff(a, b) {
    const diff = [];
    for(let i = 0; i < b.length; i++)if (!a.includes(b[i])) diff.push(b[i]);
    return diff;
}
function wrapInArray(v) {
    return v == null ? [] : Array.isArray(v) ? v : [
        v
    ];
}
function defaultFilter(value, search, item) {
    return value != null && search != null && typeof value !== "boolean" && value.toString().toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) !== -1;
}
function searchItems(items, search) {
    if (!search) return items;
    search = search.toString().toLowerCase();
    if (search.trim() === "") return items;
    return items.filter((item)=>Object.keys(item).some((key)=>defaultFilter(getObjectValueByPath(item, key), search, item)));
}
function debounce(fn, delay) {
    let timeoutId = 0;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        clearTimeout(timeoutId);
        timeoutId = setTimeout(()=>fn(...args), delay);
    };
}
function throttle(fn, limit) {
    let throttling = false;
    return function() {
        if (!throttling) {
            throttling = true;
            setTimeout(()=>throttling = false, limit);
            return fn(...arguments);
        }
    };
}
function getPrefixedSlots(prefix, slots) {
    return Object.keys(slots).filter((k)=>k.startsWith(prefix)).reduce((obj, k)=>{
        obj[k.replace(prefix, "")] = slots[k];
        return obj;
    }, {});
}
function clamp(value) {
    let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Math.max(min, Math.min(max, value));
}
function getDecimals(value) {
    const trimmedStr = value.toString().trim();
    return trimmedStr.includes(".") ? trimmedStr.length - trimmedStr.indexOf(".") - 1 : 0;
}
function padEnd(str, length) {
    let char = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "0";
    return str + char.repeat(Math.max(0, length - str.length));
}
function padStart(str, length) {
    let char = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "0";
    return char.repeat(Math.max(0, length - str.length)) + str;
}
function chunk(str) {
    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const chunked = [];
    let index = 0;
    while(index < str.length){
        chunked.push(str.substr(index, size));
        index += size;
    }
    return chunked;
}
function humanReadableFileSize(bytes) {
    let base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
    if (bytes < base) return `${bytes} B`;
    const prefix = base === 1024 ? [
        "Ki",
        "Mi",
        "Gi"
    ] : [
        "k",
        "M",
        "G"
    ];
    let unit = -1;
    while(Math.abs(bytes) >= base && unit < prefix.length - 1){
        bytes /= base;
        ++unit;
    }
    return `${bytes.toFixed(1)} ${prefix[unit]}B`;
}
function camelizeObjectKeys(obj) {
    if (!obj) return {};
    return Object.keys(obj).reduce((o, key)=>{
        o[(0, _vue.camelize)(key)] = obj[key];
        return o;
    }, {});
}
function mergeDeep() {
    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let arrayFn = arguments.length > 2 ? arguments[2] : undefined;
    const out = {};
    for(const key in source)out[key] = source[key];
    for(const key in target){
        const sourceProperty = source[key];
        const targetProperty = target[key];
        // Only continue deep merging if
        // both properties are objects
        if (isObject(sourceProperty) && isObject(targetProperty)) {
            out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
            continue;
        }
        if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
            out[key] = arrayFn(sourceProperty, targetProperty);
            continue;
        }
        out[key] = targetProperty;
    }
    return out;
}
function fillArray(length, obj) {
    return Array(length).fill(obj);
}
function flattenFragments(nodes) {
    return nodes.map((node)=>{
        if (node.type === (0, _vue.Fragment)) return flattenFragments(node.children);
        else return node;
    }).flat();
}
const randomHexColor = ()=>{
    const n = (Math.random() * 1048575000000).toString(16);
    return "#" + n.slice(0, 6);
};
function toKebabCase() {
    let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    if (toKebabCase.cache.has(str)) return toKebabCase.cache.get(str);
    const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
    toKebabCase.cache.set(str, kebab);
    return kebab;
}
toKebabCase.cache = new Map();
function findChildren(vnode) {
    if (!vnode || typeof vnode !== "object") return [];
    if (Array.isArray(vnode)) return vnode.map((child)=>findChildren(child)).filter((v)=>v).flat(1);
    else if (Array.isArray(vnode.children)) return vnode.children.map((child)=>findChildren(child)).filter((v)=>v).flat(1);
    else if (vnode.component) return [
        vnode.component,
        ...findChildren(vnode.component?.subTree)
    ].filter((v)=>v).flat(1);
    return [];
}
function findChildrenWithProvide(key, vnode) {
    if (!vnode || typeof vnode !== "object") return [];
    if (Array.isArray(vnode)) return vnode.map((child)=>findChildrenWithProvide(key, child)).flat(1);
    else if (Array.isArray(vnode.children)) return vnode.children.map((child)=>findChildrenWithProvide(key, child)).flat(1);
    else if (vnode.component) {
        if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) return [
            vnode.component
        ];
        else if (vnode.component.subTree) return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
    }
    return [];
}
var _arr = /*#__PURE__*/ new WeakMap();
var _pointer = /*#__PURE__*/ new WeakMap();
class CircularBuffer {
    constructor(size){
        _classPrivateFieldInitSpec(this, _arr, {
            writable: true,
            value: []
        });
        _classPrivateFieldInitSpec(this, _pointer, {
            writable: true,
            value: 0
        });
        this.size = size;
    }
    push(val) {
        _classPrivateFieldGet(this, _arr)[_classPrivateFieldGet(this, _pointer)] = val;
        _classPrivateFieldSet(this, _pointer, (_classPrivateFieldGet(this, _pointer) + 1) % this.size);
    }
    values() {
        return _classPrivateFieldGet(this, _arr).slice(_classPrivateFieldGet(this, _pointer)).concat(_classPrivateFieldGet(this, _arr).slice(0, _classPrivateFieldGet(this, _pointer)));
    }
}
function getEventCoordinates(e) {
    if ("touches" in e) return {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
    };
    return {
        clientX: e.clientX,
        clientY: e.clientY
    };
}
function destructComputed(getter) {
    const refs = (0, _vue.reactive)({});
    const base = (0, _vue.computed)(getter);
    (0, _vue.watchEffect)(()=>{
        for(const key in base.value)refs[key] = base.value[key];
    }, {
        flush: "sync"
    });
    return (0, _vue.toRefs)(refs);
}
function includes(arr, val) {
    return arr.includes(val);
}
function eventName(propName) {
    return propName[2].toLowerCase() + propName.slice(3);
}
const EventProp = ()=>[
        Function,
        Array
    ];
function hasEvent(props, name) {
    name = "on" + (0, _vue.capitalize)(name);
    return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
}
function callEvent(handler) {
    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
    if (Array.isArray(handler)) for (const h of handler)h(...args);
    else if (typeof handler === "function") handler(...args);
}
function focusableChildren(el) {
    let filterByTabIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const targets = [
        "button",
        "[href]",
        'input:not([type="hidden"])',
        "select",
        "textarea",
        "[tabindex]"
    ].map((s)=>`${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
    return [
        ...el.querySelectorAll(targets)
    ];
}
function getNextElement(elements, location, condition) {
    let _el;
    let idx = elements.indexOf(document.activeElement);
    const inc = location === "next" ? 1 : -1;
    do {
        idx += inc;
        _el = elements[idx];
    }while ((!_el || _el.offsetParent == null || !(condition?.(_el) ?? true)) && idx < elements.length && idx >= 0);
    return _el;
}
function focusChild(el, location) {
    const focusable = focusableChildren(el);
    if (!location) {
        if (el === document.activeElement || !el.contains(document.activeElement)) focusable[0]?.focus();
    } else if (location === "first") focusable[0]?.focus();
    else if (location === "last") focusable.at(-1)?.focus();
    else if (typeof location === "number") focusable[location]?.focus();
    else {
        const _el = getNextElement(focusable, location);
        if (_el) _el.focus();
        else focusChild(el, location === "next" ? "first" : "last");
    }
}
function isEmpty(val) {
    return val === null || val === undefined || typeof val === "string" && val.trim() === "";
}
function noop() {}
function matchesSelector(el, selector) {
    const supportsSelector = (0, _globalsMjs.IN_BROWSER) && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
    if (!supportsSelector) return null;
    try {
        return !!el && el.matches(selector);
    } catch (err) {
        return null;
    }
}

},{"vue":"ff77s","./globals.mjs":"8Aq1g","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8Aq1g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IN_BROWSER", ()=>IN_BROWSER);
parcelHelpers.export(exports, "SUPPORTS_INTERSECTION", ()=>SUPPORTS_INTERSECTION);
parcelHelpers.export(exports, "SUPPORTS_TOUCH", ()=>SUPPORTS_TOUCH);
const IN_BROWSER = typeof window !== "undefined";
const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4XWex":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @see https://stackoverflow.com/a/57876601/2074736 */ parcelHelpers.export(exports, "nullifyTransforms", ()=>nullifyTransforms);
parcelHelpers.export(exports, "animate", ()=>animate);
var _boxMjs = require("./box.mjs");
function nullifyTransforms(el) {
    const rect = el.getBoundingClientRect();
    const style = getComputedStyle(el);
    const tx = style.transform;
    if (tx) {
        let ta, sx, sy, dx, dy;
        if (tx.startsWith("matrix3d(")) {
            ta = tx.slice(9, -1).split(/, /);
            sx = +ta[0];
            sy = +ta[5];
            dx = +ta[12];
            dy = +ta[13];
        } else if (tx.startsWith("matrix(")) {
            ta = tx.slice(7, -1).split(/, /);
            sx = +ta[0];
            sy = +ta[3];
            dx = +ta[4];
            dy = +ta[5];
        } else return new (0, _boxMjs.Box)(rect);
        const to = style.transformOrigin;
        const x = rect.x - dx - (1 - sx) * parseFloat(to);
        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
        const w = sx ? rect.width / sx : el.offsetWidth + 1;
        const h = sy ? rect.height / sy : el.offsetHeight + 1;
        return new (0, _boxMjs.Box)({
            x,
            y,
            width: w,
            height: h
        });
    } else return new (0, _boxMjs.Box)(rect);
}
function animate(el, keyframes, options) {
    if (typeof el.animate === "undefined") return {
        finished: Promise.resolve()
    };
    let animation;
    try {
        animation = el.animate(keyframes, options);
    } catch (err) {
        return {
            finished: Promise.resolve()
        };
    }
    if (typeof animation.finished === "undefined") animation.finished = new Promise((resolve)=>{
        animation.onfinish = ()=>{
            resolve(animation);
        };
    });
    return animation;
}

},{"./box.mjs":"lKLXL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lKLXL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Box", ()=>Box);
parcelHelpers.export(exports, "getOverflow", ()=>getOverflow);
class Box {
    constructor(_ref){
        let { x, y, width, height } = _ref;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    get top() {
        return this.y;
    }
    get bottom() {
        return this.y + this.height;
    }
    get left() {
        return this.x;
    }
    get right() {
        return this.x + this.width;
    }
}
function getOverflow(a, b) {
    return {
        x: {
            before: Math.max(0, b.left - a.left),
            after: Math.max(0, a.right - b.right)
        },
        y: {
            before: Math.max(0, b.top - a.top),
            after: Math.max(0, a.bottom - b.bottom)
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"39gaC":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindProps", ()=>bindProps);
parcelHelpers.export(exports, "unbindProps", ()=>unbindProps);
var _helpersMjs = require("./helpers.mjs");
const handlers = new WeakMap();
function bindProps(el, props) {
    Object.keys(props).forEach((k)=>{
        if ((0, _helpersMjs.isOn)(k)) {
            const name = (0, _helpersMjs.eventName)(k);
            const handler = handlers.get(el);
            if (props[k] == null) handler?.forEach((v)=>{
                const [n, fn] = v;
                if (n === name) {
                    el.removeEventListener(name, fn);
                    handler.delete(v);
                }
            });
            else if (!handler || ![
                ...handler
            ]?.some((v)=>v[0] === name && v[1] === props[k])) {
                el.addEventListener(name, props[k]);
                const _handler = handler || new Set();
                _handler.add([
                    name,
                    props[k]
                ]);
                if (!handlers.has(el)) handlers.set(el, _handler);
            }
        } else if (props[k] == null) el.removeAttribute(k);
        else el.setAttribute(k, props[k]);
    });
}
function unbindProps(el, props) {
    Object.keys(props).forEach((k)=>{
        if ((0, _helpersMjs.isOn)(k)) {
            const name = (0, _helpersMjs.eventName)(k);
            const handler = handlers.get(el);
            handler?.forEach((v)=>{
                const [n, fn] = v;
                if (n === name) {
                    el.removeEventListener(name, fn);
                    handler.delete(v);
                }
            });
        } else el.removeAttribute(k);
    });
}

},{"./helpers.mjs":"fcCSo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7U9Hi":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCssColor", ()=>isCssColor);
parcelHelpers.export(exports, "parseColor", ()=>parseColor);
parcelHelpers.export(exports, "RGBToInt", ()=>RGBToInt);
parcelHelpers.export(exports, "classToHex", ()=>classToHex);
/** Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV */ parcelHelpers.export(exports, "HSVtoRGB", ()=>HSVtoRGB);
parcelHelpers.export(exports, "HSLtoRGB", ()=>HSLtoRGB);
/** Converts RGBA to HSVA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV */ parcelHelpers.export(exports, "RGBtoHSV", ()=>RGBtoHSV);
parcelHelpers.export(exports, "HSVtoHSL", ()=>HSVtoHSL);
parcelHelpers.export(exports, "HSLtoHSV", ()=>HSLtoHSV);
parcelHelpers.export(exports, "RGBtoCSS", ()=>RGBtoCSS);
parcelHelpers.export(exports, "HSVtoCSS", ()=>HSVtoCSS);
parcelHelpers.export(exports, "RGBtoHex", ()=>RGBtoHex);
parcelHelpers.export(exports, "HexToRGB", ()=>HexToRGB);
parcelHelpers.export(exports, "HexToHSV", ()=>HexToHSV);
parcelHelpers.export(exports, "HSVtoHex", ()=>HSVtoHex);
parcelHelpers.export(exports, "parseHex", ()=>parseHex);
parcelHelpers.export(exports, "parseGradient", ()=>parseGradient);
parcelHelpers.export(exports, "lighten", ()=>lighten);
parcelHelpers.export(exports, "darken", ()=>darken);
/**
 * Calculate the relative luminance of a given color
 * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef
 */ parcelHelpers.export(exports, "getLuma", ()=>getLuma);
/**
 * Returns the contrast ratio (1-21) between two colors.
 * @see https://www.w3.org/TR/WCAG20/#contrast-ratiodef
 */ parcelHelpers.export(exports, "getContrast", ()=>getContrast);
parcelHelpers.export(exports, "getForeground", ()=>getForeground);
var _apcaMjs = require("./color/APCA.mjs");
var _consoleMjs = require("./console.mjs");
var _helpersMjs = require("./helpers.mjs");
var _transformCIELABMjs = require("./color/transformCIELAB.mjs");
var _transformSRGBMjs = require("./color/transformSRGB.mjs"); // Types
function isCssColor(color) {
    return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
const mappers = {
    rgb: (r, g, b, a)=>({
            r,
            g,
            b,
            a
        }),
    rgba: (r, g, b, a)=>({
            r,
            g,
            b,
            a
        }),
    hsl: (h, s, l, a)=>HSLtoRGB({
            h,
            s,
            l,
            a
        }),
    hsla: (h, s, l, a)=>HSLtoRGB({
            h,
            s,
            l,
            a
        }),
    hsv: (h, s, v, a)=>HSVtoRGB({
            h,
            s,
            v,
            a
        }),
    hsva: (h, s, v, a)=>HSVtoRGB({
            h,
            s,
            v,
            a
        })
};
function parseColor(color) {
    if (typeof color === "number") {
        if (isNaN(color) || color < 0 || color > 0xFFFFFF) // int can't have opacity
        (0, _consoleMjs.consoleWarn)(`'${color}' is not a valid hex color`);
        return {
            r: (color & 0xFF0000) >> 16,
            g: (color & 0xFF00) >> 8,
            b: color & 0xFF
        };
    } else if (typeof color === "string" && cssColorRe.test(color)) {
        const { groups } = color.match(cssColorRe);
        const { fn, values } = groups;
        const realValues = values.split(/,\s*/).map((v)=>{
            if (v.endsWith("%") && [
                "hsl",
                "hsla",
                "hsv",
                "hsva"
            ].includes(fn)) return parseFloat(v) / 100;
            else return parseFloat(v);
        });
        return mappers[fn](...realValues);
    } else if (typeof color === "string") {
        let hex = color.startsWith("#") ? color.slice(1) : color;
        if ([
            3,
            4
        ].includes(hex.length)) hex = hex.split("").map((char)=>char + char).join("");
        else if (![
            6,
            8
        ].includes(hex.length)) (0, _consoleMjs.consoleWarn)(`'${color}' is not a valid hex(a) color`);
        const int = parseInt(hex, 16);
        if (isNaN(int) || int < 0 || int > 0xFFFFFFFF) (0, _consoleMjs.consoleWarn)(`'${color}' is not a valid hex(a) color`);
        return HexToRGB(hex);
    } else if (typeof color === "object") {
        if ((0, _helpersMjs.has)(color, [
            "r",
            "g",
            "b"
        ])) return color;
        else if ((0, _helpersMjs.has)(color, [
            "h",
            "s",
            "l"
        ])) return HSVtoRGB(HSLtoHSV(color));
        else if ((0, _helpersMjs.has)(color, [
            "h",
            "s",
            "v"
        ])) return HSVtoRGB(color);
    }
    throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}\nExpected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function RGBToInt(color) {
    return (color.r << 16) + (color.g << 8) + color.b;
}
function classToHex(color, colors, currentTheme) {
    const [colorName, colorModifier] = color.toString().trim().replace("-", "").split(" ", 2);
    let hexColor = "";
    if (colorName && colorName in colors) {
        if (colorModifier && colorModifier in colors[colorName]) hexColor = colors[colorName][colorModifier];
        else if ("base" in colors[colorName]) hexColor = colors[colorName].base;
    } else if (colorName && colorName in currentTheme) hexColor = currentTheme[colorName];
    return hexColor;
}
function HSVtoRGB(hsva) {
    const { h, s, v, a } = hsva;
    const f = (n)=>{
        const k = (n + h / 60) % 6;
        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    };
    const rgb = [
        f(5),
        f(3),
        f(1)
    ].map((v)=>Math.round(v * 255));
    return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2],
        a
    };
}
function HSLtoRGB(hsla) {
    return HSVtoRGB(HSLtoHSV(hsla));
}
function RGBtoHSV(rgba) {
    if (!rgba) return {
        h: 0,
        s: 1,
        v: 1,
        a: 1
    };
    const r = rgba.r / 255;
    const g = rgba.g / 255;
    const b = rgba.b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    if (max !== min) {
        if (max === r) h = 60 * (0 + (g - b) / (max - min));
        else if (max === g) h = 60 * (2 + (b - r) / (max - min));
        else if (max === b) h = 60 * (4 + (r - g) / (max - min));
    }
    if (h < 0) h = h + 360;
    const s = max === 0 ? 0 : (max - min) / max;
    const hsv = [
        h,
        s,
        max
    ];
    return {
        h: hsv[0],
        s: hsv[1],
        v: hsv[2],
        a: rgba.a
    };
}
function HSVtoHSL(hsva) {
    const { h, s, v, a } = hsva;
    const l = v - v * s / 2;
    const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l);
    return {
        h,
        s: sprime,
        l,
        a
    };
}
function HSLtoHSV(hsl) {
    const { h, s, l, a } = hsl;
    const v = l + s * Math.min(l, 1 - l);
    const sprime = v === 0 ? 0 : 2 - 2 * l / v;
    return {
        h,
        s: sprime,
        v,
        a
    };
}
function RGBtoCSS(_ref) {
    let { r, g, b, a } = _ref;
    return a === undefined ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${a})`;
}
function HSVtoCSS(hsva) {
    return RGBtoCSS(HSVtoRGB(hsva));
}
function toHex(v) {
    const h = Math.round(v).toString(16);
    return ("00".substr(0, 2 - h.length) + h).toUpperCase();
}
function RGBtoHex(_ref2) {
    let { r, g, b, a } = _ref2;
    return `#${[
        toHex(r),
        toHex(g),
        toHex(b),
        a !== undefined ? toHex(Math.round(a * 255)) : ""
    ].join("")}`;
}
function HexToRGB(hex) {
    hex = parseHex(hex);
    let [r, g, b, a] = (0, _helpersMjs.chunk)(hex, 2).map((c)=>parseInt(c, 16));
    a = a === undefined ? a : a / 255;
    return {
        r,
        g,
        b,
        a
    };
}
function HexToHSV(hex) {
    const rgb = HexToRGB(hex);
    return RGBtoHSV(rgb);
}
function HSVtoHex(hsva) {
    return RGBtoHex(HSVtoRGB(hsva));
}
function parseHex(hex) {
    if (hex.startsWith("#")) hex = hex.slice(1);
    hex = hex.replace(/([^0-9a-f])/gi, "F");
    if (hex.length === 3 || hex.length === 4) hex = hex.split("").map((x)=>x + x).join("");
    if (hex.length !== 6) hex = (0, _helpersMjs.padEnd)((0, _helpersMjs.padEnd)(hex, 6), 8, "F");
    return hex;
}
function parseGradient(gradient, colors, currentTheme) {
    return gradient.replace(/([a-z]+(\s[a-z]+-[1-5])?)(?=$|,)/gi, (x)=>{
        return classToHex(x, colors, currentTheme) || x;
    }).replace(/(rgba\()#[0-9a-f]+(?=,)/gi, (x)=>{
        return "rgba(" + Object.values(HexToRGB(parseHex(x.replace(/rgba\(/, "")))).slice(0, 3).join(",");
    });
}
function lighten(value, amount) {
    const lab = _transformCIELABMjs.fromXYZ(_transformSRGBMjs.toXYZ(value));
    lab[0] = lab[0] + amount * 10;
    return _transformSRGBMjs.fromXYZ(_transformCIELABMjs.toXYZ(lab));
}
function darken(value, amount) {
    const lab = _transformCIELABMjs.fromXYZ(_transformSRGBMjs.toXYZ(value));
    lab[0] = lab[0] - amount * 10;
    return _transformSRGBMjs.fromXYZ(_transformCIELABMjs.toXYZ(lab));
}
function getLuma(color) {
    const rgb = parseColor(color);
    return _transformSRGBMjs.toXYZ(rgb)[1];
}
function getContrast(first, second) {
    const l1 = getLuma(first);
    const l2 = getLuma(second);
    const light = Math.max(l1, l2);
    const dark = Math.min(l1, l2);
    return (light + 0.05) / (dark + 0.05);
}
function getForeground(color) {
    const blackContrast = Math.abs((0, _apcaMjs.APCAcontrast)(parseColor(0), parseColor(color)));
    const whiteContrast = Math.abs((0, _apcaMjs.APCAcontrast)(parseColor(0xffffff), parseColor(color)));
    return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
}

},{"./color/APCA.mjs":"pfq97","./console.mjs":"d3sZr","./helpers.mjs":"fcCSo","./color/transformCIELAB.mjs":"5dg7w","./color/transformSRGB.mjs":"hLysY","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"pfq97":[function(require,module,exports) {
/**
 * WCAG 3.0 APCA perceptual contrast algorithm from https://github.com/Myndex/SAPC-APCA
 * @licence https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 * @see https://www.w3.org/WAI/GL/task-forces/silver/wiki/Visual_Contrast_of_Text_Subgroup
 */ // Types
// MAGICAL NUMBERS
// sRGB Conversion to Relative Luminance (Y)
// Transfer Curve (aka "Gamma") for sRGB linearization
// Simple power curve vs piecewise described in docs
// Essentially, 2.4 best models actual display
// characteristics in combination with the total method
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "APCAcontrast", ()=>APCAcontrast);
const mainTRC = 2.4;
const Rco = 0.2126729; // sRGB Red Coefficient (from matrix)
const Gco = 0.7151522; // sRGB Green Coefficient (from matrix)
const Bco = 0.0721750; // sRGB Blue Coefficient (from matrix)
// For Finding Raw SAPC Contrast from Relative Luminance (Y)
// Constants for SAPC Power Curve Exponents
// One pair for normal text, and one for reverse
// These are the "beating heart" of SAPC
const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62;
// For Clamping and Scaling Values
const blkThrs = 0.03; // Level that triggers the soft black clamp
const blkClmp = 1.45; // Exponent for the soft black clamp curve
const deltaYmin = 0.0005; // Lint trap
const scaleBoW = 1.25; // Scaling for dark text on light
const scaleWoB = 1.25; // Scaling for light text on dark
const loConThresh = 0.078; // Threshold for new simple offset scale
const loConFactor = 12.82051282051282; // = 1/0.078,
const loConOffset = 0.06; // The simple offset
const loClip = 0.001; // Output clip (lint trap #2)
function APCAcontrast(text, background) {
    // Linearize sRGB
    const Rtxt = (text.r / 255) ** mainTRC;
    const Gtxt = (text.g / 255) ** mainTRC;
    const Btxt = (text.b / 255) ** mainTRC;
    const Rbg = (background.r / 255) ** mainTRC;
    const Gbg = (background.g / 255) ** mainTRC;
    const Bbg = (background.b / 255) ** mainTRC;
    // Apply the standard coefficients and sum to Y
    let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
    let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
    // Soft clamp Y when near black.
    // Now clamping all colors to prevent crossover errors
    if (Ytxt <= blkThrs) Ytxt += (blkThrs - Ytxt) ** blkClmp;
    if (Ybg <= blkThrs) Ybg += (blkThrs - Ybg) ** blkClmp;
    // Return 0 Early for extremely low ‚àÜY (lint trap #1)
    if (Math.abs(Ybg - Ytxt) < deltaYmin) return 0.0;
    // SAPC CONTRAST
    let outputContrast; // For weighted final values
    if (Ybg > Ytxt) {
        // For normal polarity, black text on white
        // Calculate the SAPC contrast value and scale
        const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
        // NEW! SAPC SmoothScale‚Ñ¢
        // Low Contrast Smooth Scale Rollout to prevent polarity reversal
        // and also a low clip for very low contrasts (lint trap #2)
        // much of this is for very low contrasts, less than 10
        // therefore for most reversing needs, only loConOffset is important
        outputContrast = SAPC < loClip ? 0.0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
    } else {
        // For reverse polarity, light text on dark
        // WoB should always return negative value.
        const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
        outputContrast = SAPC > -loClip ? 0.0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
    }
    return outputContrast * 100;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"d3sZr":[function(require,module,exports) {
/* eslint-disable no-console */ // Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "consoleWarn", ()=>consoleWarn);
parcelHelpers.export(exports, "consoleError", ()=>consoleError);
parcelHelpers.export(exports, "deprecate", ()=>deprecate);
parcelHelpers.export(exports, "breaking", ()=>breaking);
parcelHelpers.export(exports, "removed", ()=>removed);
var _vue = require("vue");
function consoleWarn(message) {
    (0, _vue.warn)(`Vuetify: ${message}`);
}
function consoleError(message) {
    (0, _vue.warn)(`Vuetify error: ${message}`);
}
function deprecate(original, replacement) {
    replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s)=>`'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
    (0, _vue.warn)(`[Vuetify UPGRADE] '${original}' is deprecated, use ${replacement} instead.`);
}
function breaking(original, replacement) {
// warn(`[Vuetify BREAKING] '${original}' has been removed, use '${replacement}' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide`)
}
function removed(original) {
// warn(`[Vuetify REMOVED] '${original}' has been removed. You can safely omit it.`)
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5dg7w":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromXYZ", ()=>fromXYZ);
parcelHelpers.export(exports, "toXYZ", ()=>toXYZ);
const delta = 0.20689655172413793; // 6√∑29
const cielabForwardTransform = (t)=>t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t)=>t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ(xyz) {
    const transform = cielabForwardTransform;
    const transformedY = transform(xyz[1]);
    return [
        116 * transformedY - 16,
        500 * (transform(xyz[0] / 0.95047) - transformedY),
        200 * (transformedY - transform(xyz[2] / 1.08883))
    ];
}
function toXYZ(lab) {
    const transform = cielabReverseTransform;
    const Ln = (lab[0] + 16) / 116;
    return [
        transform(Ln + lab[1] / 500) * 0.95047,
        transform(Ln),
        transform(Ln - lab[2] / 200) * 1.08883
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hLysY":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromXYZ", ()=>fromXYZ);
parcelHelpers.export(exports, "toXYZ", ()=>toXYZ);
var _helpersMjs = require("../helpers.mjs"); // Types
// For converting XYZ to sRGB
const srgbForwardMatrix = [
    [
        3.2406,
        -1.5372,
        -0.4986
    ],
    [
        -0.9689,
        1.8758,
        0.0415
    ],
    [
        0.0557,
        -0.204,
        1.0570
    ]
];
// Forward gamma adjust
const srgbForwardTransform = (C)=>C <= 0.0031308 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
// For converting sRGB to XYZ
const srgbReverseMatrix = [
    [
        0.4124,
        0.3576,
        0.1805
    ],
    [
        0.2126,
        0.7152,
        0.0722
    ],
    [
        0.0193,
        0.1192,
        0.9505
    ]
];
// Reverse gamma adjust
const srgbReverseTransform = (C)=>C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
    const rgb = Array(3);
    const transform = srgbForwardTransform;
    const matrix = srgbForwardMatrix;
    // Matrix transform, then gamma adjustment
    for(let i = 0; i < 3; ++i)// Rescale back to [0, 255]
    rgb[i] = Math.round((0, _helpersMjs.clamp)(transform(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
    return {
        r: rgb[0],
        g: rgb[1],
        b: rgb[2]
    };
}
function toXYZ(_ref) {
    let { r, g, b } = _ref;
    const xyz = [
        0,
        0,
        0
    ];
    const transform = srgbReverseTransform;
    const matrix = srgbReverseMatrix;
    // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB
    r = transform(r / 255);
    g = transform(g / 255);
    b = transform(b / 255);
    // Matrix color space transform
    for(let i = 0; i < 3; ++i)xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
    return xyz;
}

},{"../helpers.mjs":"fcCSo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"50sjd":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSimpleFunctional", ()=>createSimpleFunctional);
var _componentMjs = require("../composables/component.mjs"); // Utilities
var _vue = require("vue");
var _defineComponentMjs = require("./defineComponent.mjs");
function createSimpleFunctional(klass) {
    let tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "div";
    let name = arguments.length > 2 ? arguments[2] : undefined;
    return (0, _defineComponentMjs.genericComponent)()({
        name: name ?? (0, _vue.capitalize)((0, _vue.camelize)(klass.replace(/__/g, "-"))),
        props: {
            tag: {
                type: String,
                default: tag
            },
            ...(0, _componentMjs.makeComponentProps)()
        },
        setup (props, _ref) {
            let { slots } = _ref;
            return ()=>{
                return (0, _vue.h)(props.tag, {
                    class: [
                        klass,
                        props.class
                    ],
                    style: props.style
                }, slots.default?.());
            };
        }
    });
}

},{"../composables/component.mjs":"jVHld","vue":"ff77s","./defineComponent.mjs":"5tFXo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jVHld":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeComponentProps", ()=>makeComponentProps);
var _propsFactoryMjs = require("../util/propsFactory.mjs"); // Types
const makeComponentProps = (0, _propsFactoryMjs.propsFactory)({
    class: [
        String,
        Array
    ],
    style: {
        type: [
            String,
            Array,
            Object
        ],
        default: null
    }
}, "component");

},{"../util/propsFactory.mjs":"8JLu1","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8JLu1":[function(require,module,exports) {
// Types
// eslint-disable-line vue/prefer-import-from-vue
/**
 * Creates a factory function for props definitions.
 * This is used to define props in a composable then override
 * default values in an implementing component.
 *
 * @example Simplified signature
 * (props: Props) => (defaults?: Record<keyof props, any>) => Props
 *
 * @example Usage
 * const makeProps = propsFactory({
 *   foo: String,
 * })
 *
 * defineComponent({
 *   props: {
 *     ...makeProps({
 *       foo: 'a',
 *     }),
 *   },
 *   setup (props) {
 *     // would be "string | undefined", now "string" because a default has been provided
 *     props.foo
 *   },
 * }
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "propsFactory", ()=>propsFactory);
function propsFactory(props, source) {
    return (defaults)=>{
        return Object.keys(props).reduce((obj, prop)=>{
            const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
            const definition = isObjectDefinition ? props[prop] : {
                type: props[prop]
            };
            if (defaults && prop in defaults) obj[prop] = {
                ...definition,
                default: defaults[prop]
            };
            else obj[prop] = definition;
            if (source && !obj[prop].source) obj[prop].source = source;
            return obj;
        }, {});
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5tFXo":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Implementation
parcelHelpers.export(exports, "defineComponent", ()=>defineComponent);
// Implementation
parcelHelpers.export(exports, "genericComponent", ()=>genericComponent);
parcelHelpers.export(exports, "defineFunctionalComponent", ()=>defineFunctionalComponent);
var _defaultsMjs = require("../composables/defaults.mjs"); // Utilities
var _vue = require("vue");
var _consoleMjs = require("./console.mjs");
var _helpersMjs = require("./helpers.mjs");
var _propsFactoryMjs = require("./propsFactory.mjs"); // Types
function defineComponent(options) {
    options._setup = options._setup ?? options.setup;
    if (!options.name) {
        (0, _consoleMjs.consoleWarn)("The component is missing an explicit name, unable to generate default prop value");
        return options;
    }
    if (options._setup) {
        options.props = (0, _propsFactoryMjs.propsFactory)(options.props ?? {}, options.name)();
        const propKeys = Object.keys(options.props);
        options.filterProps = function filterProps(props) {
            return (0, _helpersMjs.pick)(props, propKeys, [
                "class",
                "style"
            ]);
        };
        options.props._as = String;
        options.setup = function setup(props, ctx) {
            const defaults = (0, _defaultsMjs.injectDefaults)();
            // Skip props proxy if defaults are not provided
            if (!defaults.value) return options._setup(props, ctx);
            const { props: _props, provideSubDefaults } = (0, _defaultsMjs.internalUseDefaults)(props, props._as ?? options.name, defaults);
            const setupBindings = options._setup(_props, ctx);
            provideSubDefaults();
            return setupBindings;
        };
    }
    return options;
}
function genericComponent() {
    let exposeDefaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    return (options)=>(exposeDefaults ? defineComponent : (0, _vue.defineComponent))(options);
}
function defineFunctionalComponent(props, render) {
    render.props = props;
    return render;
}

},{"../composables/defaults.mjs":"11B6w","vue":"ff77s","./console.mjs":"d3sZr","./helpers.mjs":"fcCSo","./propsFactory.mjs":"8JLu1","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"c4c8X":[function(require,module,exports) {
/**
 * Returns:
 *  - 'null' if the node is not attached to the DOM
 *  - the root node (HTMLDocument | ShadowRoot) otherwise
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attachedRoot", ()=>attachedRoot);
function attachedRoot(node) {
    /* istanbul ignore next */ if (typeof node.getRootNode !== "function") {
        // Shadow DOM not supported (IE11), lets find the root of this node
        while(node.parentNode)node = node.parentNode;
        // The root parent is the document if the node is attached to the DOM
        if (node !== document) return null;
        return document;
    }
    const root = node.getRootNode();
    // The composed root node is the document if the node is attached to the DOM
    if (root !== document && root.getRootNode({
        composed: true
    }) !== document) return null;
    return root;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eJSW7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "standardEasing", ()=>standardEasing);
parcelHelpers.export(exports, "deceleratedEasing", ()=>deceleratedEasing);
parcelHelpers.export(exports, "acceleratedEasing", ()=>acceleratedEasing);
const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)"; // Entering
const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)"; // Leaving

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5Irou":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCurrentInstance", ()=>getCurrentInstance);
parcelHelpers.export(exports, "getCurrentInstanceName", ()=>getCurrentInstanceName);
parcelHelpers.export(exports, "getUid", ()=>getUid);
var _vue = require("vue");
var _helpersMjs = require("./helpers.mjs"); // Types
function getCurrentInstance(name, message) {
    const vm = (0, _vue.getCurrentInstance)();
    if (!vm) throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
    return vm;
}
function getCurrentInstanceName() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "composables";
    const vm = getCurrentInstance(name).type;
    return (0, _helpersMjs.toKebabCase)(vm?.aliasName || vm?.name);
}
let _uid = 0;
let _map = new WeakMap();
function getUid() {
    const vm = getCurrentInstance("getUid");
    if (_map.has(vm)) return _map.get(vm);
    else {
        const uid = _uid++;
        _map.set(vm, uid);
        return uid;
    }
}
getUid.reset = ()=>{
    _uid = 0;
    _map = new WeakMap();
};

},{"vue":"ff77s","./helpers.mjs":"fcCSo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"964BL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getScrollParent", ()=>getScrollParent);
parcelHelpers.export(exports, "getScrollParents", ()=>getScrollParents);
parcelHelpers.export(exports, "hasScrollbar", ()=>hasScrollbar);
function getScrollParent(el) {
    let includeHidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    while(el){
        if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el)) return el;
        el = el.parentElement;
    }
    return document.scrollingElement;
}
function getScrollParents(el, stopAt) {
    const elements = [];
    if (stopAt && el && !stopAt.contains(el)) return elements;
    while(el){
        if (hasScrollbar(el)) elements.push(el);
        if (el === stopAt) break;
        el = el.parentElement;
    }
    return elements;
}
function hasScrollbar(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
    const style = window.getComputedStyle(el);
    return style.overflowY === "scroll" || style.overflowY === "auto" && el.scrollHeight > el.clientHeight;
}
function isPotentiallyScrollable(el) {
    if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
    const style = window.getComputedStyle(el);
    return [
        "scroll",
        "auto"
    ].includes(style.overflowY);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2Ag2W":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "injectSelf", ()=>injectSelf);
var _getCurrentInstanceMjs = require("./getCurrentInstance.mjs"); // Types
function injectSelf(key) {
    let vm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _getCurrentInstanceMjs.getCurrentInstance)("injectSelf");
    const { provides } = vm;
    if (provides && key in provides) // TS doesn't allow symbol as index type
    return provides[key];
    return undefined;
}

},{"./getCurrentInstance.mjs":"5Irou","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dzuRI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFixedPosition", ()=>isFixedPosition);
function isFixedPosition(el) {
    while(el){
        if (window.getComputedStyle(el).position === "fixed") return true;
        el = el.offsetParent;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1OxHl":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useRender", ()=>useRender);
var _getCurrentInstanceMjs = require("./getCurrentInstance.mjs"); // Types
function useRender(render) {
    const vm = (0, _getCurrentInstanceMjs.getCurrentInstance)("useRender");
    vm.render = render;
}

},{"./getCurrentInstance.mjs":"5Irou","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6nXZK":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "breakpoints", ()=>breakpoints);
parcelHelpers.export(exports, "DisplaySymbol", ()=>DisplaySymbol);
parcelHelpers.export(exports, "createDisplay", ()=>createDisplay);
parcelHelpers.export(exports, "useDisplay", ()=>useDisplay);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs");
var _globalsMjs = require("../util/globals.mjs"); // Types
const breakpoints = [
    "sm",
    "md",
    "lg",
    "xl",
    "xxl"
]; // no xs
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
    mobileBreakpoint: "lg",
    thresholds: {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920,
        xxl: 2560
    }
};
const parseDisplayOptions = function() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDisplayOptions;
    return (0, _indexMjs.mergeDeep)(defaultDisplayOptions, options);
};
function getClientWidth(ssr) {
    return (0, _globalsMjs.IN_BROWSER) && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
}
function getClientHeight(ssr) {
    return (0, _globalsMjs.IN_BROWSER) && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
}
function getPlatform(ssr) {
    const userAgent = (0, _globalsMjs.IN_BROWSER) && !ssr ? window.navigator.userAgent : "ssr";
    function match(regexp) {
        return Boolean(userAgent.match(regexp));
    }
    const android = match(/android/i);
    const ios = match(/iphone|ipad|ipod/i);
    const cordova = match(/cordova/i);
    const electron = match(/electron/i);
    const chrome = match(/chrome/i);
    const edge = match(/edge/i);
    const firefox = match(/firefox/i);
    const opera = match(/opera/i);
    const win = match(/win/i);
    const mac = match(/mac/i);
    const linux = match(/linux/i);
    return {
        android,
        ios,
        cordova,
        electron,
        chrome,
        edge,
        firefox,
        opera,
        win,
        mac,
        linux,
        touch: (0, _globalsMjs.SUPPORTS_TOUCH),
        ssr: userAgent === "ssr"
    };
}
function createDisplay(options, ssr) {
    const { thresholds, mobileBreakpoint } = parseDisplayOptions(options);
    const height = (0, _vue.shallowRef)(getClientHeight(ssr));
    const platform = (0, _vue.shallowRef)(getPlatform(ssr));
    const state = (0, _vue.reactive)({});
    const width = (0, _vue.shallowRef)(getClientWidth(ssr));
    function updateSize() {
        height.value = getClientHeight();
        width.value = getClientWidth();
    }
    function update() {
        updateSize();
        platform.value = getPlatform();
    }
    // eslint-disable-next-line max-statements
    (0, _vue.watchEffect)(()=>{
        const xs = width.value < thresholds.sm;
        const sm = width.value < thresholds.md && !xs;
        const md = width.value < thresholds.lg && !(sm || xs);
        const lg = width.value < thresholds.xl && !(md || sm || xs);
        const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
        const xxl = width.value >= thresholds.xxl;
        const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
        const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
        const mobile = width.value < breakpointValue;
        state.xs = xs;
        state.sm = sm;
        state.md = md;
        state.lg = lg;
        state.xl = xl;
        state.xxl = xxl;
        state.smAndUp = !xs;
        state.mdAndUp = !(xs || sm);
        state.lgAndUp = !(xs || sm || md);
        state.xlAndUp = !(xs || sm || md || lg);
        state.smAndDown = !(md || lg || xl || xxl);
        state.mdAndDown = !(lg || xl || xxl);
        state.lgAndDown = !(xl || xxl);
        state.xlAndDown = !xxl;
        state.name = name;
        state.height = height.value;
        state.width = width.value;
        state.mobile = mobile;
        state.mobileBreakpoint = mobileBreakpoint;
        state.platform = platform.value;
        state.thresholds = thresholds;
    });
    if (0, _globalsMjs.IN_BROWSER) window.addEventListener("resize", updateSize, {
        passive: true
    });
    return {
        ...(0, _vue.toRefs)(state),
        update,
        ssr: !!ssr
    };
}
function useDisplay() {
    const display = (0, _vue.inject)(DisplaySymbol);
    if (!display) throw new Error("Could not find Vuetify display injection");
    return display;
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","../util/globals.mjs":"8Aq1g","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ezwoc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IconValue", ()=>IconValue);
parcelHelpers.export(exports, "IconSymbol", ()=>IconSymbol);
parcelHelpers.export(exports, "makeIconProps", ()=>makeIconProps);
parcelHelpers.export(exports, "VComponentIcon", ()=>VComponentIcon);
parcelHelpers.export(exports, "VSvgIcon", ()=>VSvgIcon);
parcelHelpers.export(exports, "VLigatureIcon", ()=>VLigatureIcon);
parcelHelpers.export(exports, "VClassIcon", ()=>VClassIcon);
parcelHelpers.export(exports, "defaultSets", ()=>defaultSets);
// Composables
parcelHelpers.export(exports, "createIcons", ()=>createIcons);
parcelHelpers.export(exports, "useIcon", ()=>useIcon);
var _vue = require("vue");
// Icons
var _mdiMjs = require("../iconsets/mdi.mjs"); // Utilities
var _indexMjs = require("../util/index.mjs"); // Types
const IconValue = [
    String,
    Function,
    Object,
    Array
];
const IconSymbol = Symbol.for("vuetify:icons");
const makeIconProps = (0, _indexMjs.propsFactory)({
    icon: {
        type: IconValue
    },
    // Could not remove this and use makeTagProps, types complained because it is not required
    tag: {
        type: String,
        required: true
    }
}, "icon");
const VComponentIcon = (0, _indexMjs.genericComponent)()({
    name: "VComponentIcon",
    props: makeIconProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        return ()=>{
            const Icon = props.icon;
            return (0, _vue.createVNode)(props.tag, null, {
                default: ()=>[
                        props.icon ? (0, _vue.createVNode)(Icon, null, null) : slots.default?.()
                    ]
            });
        };
    }
});
const VSvgIcon = (0, _indexMjs.defineComponent)({
    name: "VSvgIcon",
    inheritAttrs: false,
    props: makeIconProps(),
    setup (props, _ref2) {
        let { attrs } = _ref2;
        return ()=>{
            return (0, _vue.createVNode)(props.tag, (0, _vue.mergeProps)(attrs, {
                "style": null
            }), {
                default: ()=>[
                        (0, _vue.createVNode)("svg", {
                            "class": "v-icon__svg",
                            "xmlns": "http://www.w3.org/2000/svg",
                            "viewBox": "0 0 24 24",
                            "role": "img",
                            "aria-hidden": "true"
                        }, [
                            Array.isArray(props.icon) ? props.icon.map((path)=>Array.isArray(path) ? (0, _vue.createVNode)("path", {
                                    "d": path[0],
                                    "fill-opacity": path[1]
                                }, null) : (0, _vue.createVNode)("path", {
                                    "d": path
                                }, null)) : (0, _vue.createVNode)("path", {
                                "d": props.icon
                            }, null)
                        ])
                    ]
            });
        };
    }
});
const VLigatureIcon = (0, _indexMjs.defineComponent)({
    name: "VLigatureIcon",
    props: makeIconProps(),
    setup (props) {
        return ()=>{
            return (0, _vue.createVNode)(props.tag, null, {
                default: ()=>[
                        props.icon
                    ]
            });
        };
    }
});
const VClassIcon = (0, _indexMjs.defineComponent)({
    name: "VClassIcon",
    props: makeIconProps(),
    setup (props) {
        return ()=>{
            return (0, _vue.createVNode)(props.tag, {
                "class": props.icon
            }, null);
        };
    }
});
const defaultSets = {
    svg: {
        component: VSvgIcon
    },
    class: {
        component: VClassIcon
    }
};
function createIcons(options) {
    return (0, _indexMjs.mergeDeep)({
        defaultSet: "mdi",
        sets: {
            ...defaultSets,
            mdi: (0, _mdiMjs.mdi)
        },
        aliases: {
            ...(0, _mdiMjs.aliases),
            /* eslint-disable max-len */ vuetify: [
                "M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z",
                [
                    "M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z",
                    0.6
                ]
            ],
            "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
        }
    }, options);
}
const useIcon = (props)=>{
    const icons = (0, _vue.inject)(IconSymbol);
    if (!icons) throw new Error("Missing Vuetify Icons provide!");
    const iconData = (0, _vue.computed)(()=>{
        const iconAlias = (0, _vue.unref)(props);
        if (!iconAlias) return {
            component: VComponentIcon
        };
        let icon = iconAlias;
        if (typeof icon === "string") {
            icon = icon.trim();
            if (icon.startsWith("$")) icon = icons.aliases?.[icon.slice(1)];
        }
        if (!icon) throw new Error(`Could not find aliased icon "${iconAlias}"`);
        if (Array.isArray(icon)) return {
            component: VSvgIcon,
            icon
        };
        else if (typeof icon !== "string") return {
            component: VComponentIcon,
            icon
        };
        const iconSetName = Object.keys(icons.sets).find((setName)=>typeof icon === "string" && icon.startsWith(`${setName}:`));
        const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
        const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
        return {
            component: iconSet.component,
            icon: iconName
        };
    });
    return {
        iconData
    };
};

},{"vue":"ff77s","../iconsets/mdi.mjs":"hVW1u","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hVW1u":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "aliases", ()=>aliases);
parcelHelpers.export(exports, "mdi", ()=>mdi);
var _iconsMjs = require("../composables/icons.mjs"); // Utilities
var _vue = require("vue");
// Types
const aliases = {
    collapse: "mdi-chevron-up",
    complete: "mdi-check",
    cancel: "mdi-close-circle",
    close: "mdi-close",
    delete: "mdi-close-circle",
    // delete (e.g. v-chip close)
    clear: "mdi-close-circle",
    success: "mdi-check-circle",
    info: "mdi-information",
    warning: "mdi-alert-circle",
    error: "mdi-close-circle",
    prev: "mdi-chevron-left",
    next: "mdi-chevron-right",
    checkboxOn: "mdi-checkbox-marked",
    checkboxOff: "mdi-checkbox-blank-outline",
    checkboxIndeterminate: "mdi-minus-box",
    delimiter: "mdi-circle",
    // for carousel
    sortAsc: "mdi-arrow-up",
    sortDesc: "mdi-arrow-down",
    expand: "mdi-chevron-down",
    menu: "mdi-menu",
    subgroup: "mdi-menu-down",
    dropdown: "mdi-menu-down",
    radioOn: "mdi-radiobox-marked",
    radioOff: "mdi-radiobox-blank",
    edit: "mdi-pencil",
    ratingEmpty: "mdi-star-outline",
    ratingFull: "mdi-star",
    ratingHalf: "mdi-star-half-full",
    loading: "mdi-cached",
    first: "mdi-page-first",
    last: "mdi-page-last",
    unfold: "mdi-unfold-more-horizontal",
    file: "mdi-paperclip",
    plus: "mdi-plus",
    minus: "mdi-minus",
    calendar: "mdi-calendar"
};
const mdi = {
    // Not using mergeProps here, functional components merge props by default (?)
    component: (props)=>(0, _vue.h)((0, _iconsMjs.VClassIcon), {
            ...props,
            class: "mdi"
        })
};

},{"../composables/icons.mjs":"ezwoc","vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4MZbL":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocaleSymbol", ()=>LocaleSymbol);
parcelHelpers.export(exports, "createLocale", ()=>createLocale);
parcelHelpers.export(exports, "useLocale", ()=>useLocale);
parcelHelpers.export(exports, "provideLocale", ()=>provideLocale);
parcelHelpers.export(exports, "RtlSymbol", ()=>RtlSymbol);
parcelHelpers.export(exports, "createRtl", ()=>createRtl);
parcelHelpers.export(exports, "provideRtl", ()=>provideRtl);
parcelHelpers.export(exports, "useRtl", ()=>useRtl);
var _vue = require("vue");
var _indexMjs = require("../locale/index.mjs");
var _vuetifyMjs = require("../locale/adapters/vuetify.mjs"); // Types
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
    return obj.name != null;
}
function createLocale(options) {
    const i18n = options?.adapter && isLocaleInstance(options?.adapter) ? options?.adapter : (0, _vuetifyMjs.createVuetifyAdapter)(options);
    const rtl = createRtl(i18n, options);
    return {
        ...i18n,
        ...rtl
    };
}
function useLocale() {
    const locale = (0, _vue.inject)(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
    return locale;
}
function provideLocale(props) {
    const locale = (0, _vue.inject)(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected locale instance");
    const i18n = locale.provide(props);
    const rtl = provideRtl(i18n, locale.rtl, props);
    const data = {
        ...i18n,
        ...rtl
    };
    (0, _vue.provide)(LocaleSymbol, data);
    return data;
}
const RtlSymbol = Symbol.for("vuetify:rtl");
function createRtl(i18n, options) {
    const rtl = (0, _vue.ref)(options?.rtl ?? (0, _indexMjs.defaultRtl));
    const isRtl = (0, _vue.computed)(()=>rtl.value[i18n.current.value] ?? false);
    return {
        isRtl,
        rtl,
        rtlClasses: (0, _vue.computed)(()=>`v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
}
function provideRtl(locale, rtl, props) {
    const isRtl = (0, _vue.computed)(()=>props.rtl ?? rtl.value[locale.current.value] ?? false);
    return {
        isRtl,
        rtl,
        rtlClasses: (0, _vue.computed)(()=>`v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
    };
}
function useRtl() {
    const locale = (0, _vue.inject)(LocaleSymbol);
    if (!locale) throw new Error("[Vuetify] Could not find injected rtl instance");
    return {
        isRtl: locale.isRtl,
        rtlClasses: locale.rtlClasses
    };
}

},{"vue":"ff77s","../locale/index.mjs":"i7XNK","../locale/adapters/vuetify.mjs":"4Vdit","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"i7XNK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "af", ()=>(0, _afMjsDefault.default));
parcelHelpers.export(exports, "ar", ()=>(0, _arMjsDefault.default));
parcelHelpers.export(exports, "bg", ()=>(0, _bgMjsDefault.default));
parcelHelpers.export(exports, "ca", ()=>(0, _caMjsDefault.default));
parcelHelpers.export(exports, "ckb", ()=>(0, _ckbMjsDefault.default));
parcelHelpers.export(exports, "cs", ()=>(0, _csMjsDefault.default));
parcelHelpers.export(exports, "da", ()=>(0, _daMjsDefault.default));
parcelHelpers.export(exports, "de", ()=>(0, _deMjsDefault.default));
parcelHelpers.export(exports, "el", ()=>(0, _elMjsDefault.default));
parcelHelpers.export(exports, "en", ()=>(0, _enMjsDefault.default));
parcelHelpers.export(exports, "es", ()=>(0, _esMjsDefault.default));
parcelHelpers.export(exports, "et", ()=>(0, _etMjsDefault.default));
parcelHelpers.export(exports, "fa", ()=>(0, _faMjsDefault.default));
parcelHelpers.export(exports, "fi", ()=>(0, _fiMjsDefault.default));
parcelHelpers.export(exports, "fr", ()=>(0, _frMjsDefault.default));
parcelHelpers.export(exports, "hr", ()=>(0, _hrMjsDefault.default));
parcelHelpers.export(exports, "hu", ()=>(0, _huMjsDefault.default));
parcelHelpers.export(exports, "he", ()=>(0, _heMjsDefault.default));
parcelHelpers.export(exports, "id", ()=>(0, _idMjsDefault.default));
parcelHelpers.export(exports, "it", ()=>(0, _itMjsDefault.default));
parcelHelpers.export(exports, "ja", ()=>(0, _jaMjsDefault.default));
parcelHelpers.export(exports, "ko", ()=>(0, _koMjsDefault.default));
parcelHelpers.export(exports, "lv", ()=>(0, _lvMjsDefault.default));
parcelHelpers.export(exports, "lt", ()=>(0, _ltMjsDefault.default));
parcelHelpers.export(exports, "nl", ()=>(0, _nlMjsDefault.default));
parcelHelpers.export(exports, "no", ()=>(0, _noMjsDefault.default));
parcelHelpers.export(exports, "pl", ()=>(0, _plMjsDefault.default));
parcelHelpers.export(exports, "pt", ()=>(0, _ptMjsDefault.default));
parcelHelpers.export(exports, "ro", ()=>(0, _roMjsDefault.default));
parcelHelpers.export(exports, "ru", ()=>(0, _ruMjsDefault.default));
parcelHelpers.export(exports, "sk", ()=>(0, _skMjsDefault.default));
parcelHelpers.export(exports, "sl", ()=>(0, _slMjsDefault.default));
parcelHelpers.export(exports, "srCyrl", ()=>(0, _srCyrlMjsDefault.default));
parcelHelpers.export(exports, "srLatn", ()=>(0, _srLatnMjsDefault.default));
parcelHelpers.export(exports, "sv", ()=>(0, _svMjsDefault.default));
parcelHelpers.export(exports, "th", ()=>(0, _thMjsDefault.default));
parcelHelpers.export(exports, "tr", ()=>(0, _trMjsDefault.default));
parcelHelpers.export(exports, "az", ()=>(0, _azMjsDefault.default));
parcelHelpers.export(exports, "uk", ()=>(0, _ukMjsDefault.default));
parcelHelpers.export(exports, "vi", ()=>(0, _viMjsDefault.default));
parcelHelpers.export(exports, "zhHans", ()=>(0, _zhHansMjsDefault.default));
parcelHelpers.export(exports, "zhHant", ()=>(0, _zhHantMjsDefault.default));
parcelHelpers.export(exports, "defaultRtl", ()=>defaultRtl);
var _afMjs = require("./af.mjs");
var _afMjsDefault = parcelHelpers.interopDefault(_afMjs);
var _arMjs = require("./ar.mjs");
var _arMjsDefault = parcelHelpers.interopDefault(_arMjs);
var _bgMjs = require("./bg.mjs");
var _bgMjsDefault = parcelHelpers.interopDefault(_bgMjs);
var _caMjs = require("./ca.mjs");
var _caMjsDefault = parcelHelpers.interopDefault(_caMjs);
var _ckbMjs = require("./ckb.mjs");
var _ckbMjsDefault = parcelHelpers.interopDefault(_ckbMjs);
var _csMjs = require("./cs.mjs");
var _csMjsDefault = parcelHelpers.interopDefault(_csMjs);
var _daMjs = require("./da.mjs");
var _daMjsDefault = parcelHelpers.interopDefault(_daMjs);
var _deMjs = require("./de.mjs");
var _deMjsDefault = parcelHelpers.interopDefault(_deMjs);
var _elMjs = require("./el.mjs");
var _elMjsDefault = parcelHelpers.interopDefault(_elMjs);
var _enMjs = require("./en.mjs");
var _enMjsDefault = parcelHelpers.interopDefault(_enMjs);
var _esMjs = require("./es.mjs");
var _esMjsDefault = parcelHelpers.interopDefault(_esMjs);
var _etMjs = require("./et.mjs");
var _etMjsDefault = parcelHelpers.interopDefault(_etMjs);
var _faMjs = require("./fa.mjs");
var _faMjsDefault = parcelHelpers.interopDefault(_faMjs);
var _fiMjs = require("./fi.mjs");
var _fiMjsDefault = parcelHelpers.interopDefault(_fiMjs);
var _frMjs = require("./fr.mjs");
var _frMjsDefault = parcelHelpers.interopDefault(_frMjs);
var _hrMjs = require("./hr.mjs");
var _hrMjsDefault = parcelHelpers.interopDefault(_hrMjs);
var _huMjs = require("./hu.mjs");
var _huMjsDefault = parcelHelpers.interopDefault(_huMjs);
var _heMjs = require("./he.mjs");
var _heMjsDefault = parcelHelpers.interopDefault(_heMjs);
var _idMjs = require("./id.mjs");
var _idMjsDefault = parcelHelpers.interopDefault(_idMjs);
var _itMjs = require("./it.mjs");
var _itMjsDefault = parcelHelpers.interopDefault(_itMjs);
var _jaMjs = require("./ja.mjs");
var _jaMjsDefault = parcelHelpers.interopDefault(_jaMjs);
var _koMjs = require("./ko.mjs");
var _koMjsDefault = parcelHelpers.interopDefault(_koMjs);
var _lvMjs = require("./lv.mjs");
var _lvMjsDefault = parcelHelpers.interopDefault(_lvMjs);
var _ltMjs = require("./lt.mjs");
var _ltMjsDefault = parcelHelpers.interopDefault(_ltMjs);
var _nlMjs = require("./nl.mjs");
var _nlMjsDefault = parcelHelpers.interopDefault(_nlMjs);
var _noMjs = require("./no.mjs");
var _noMjsDefault = parcelHelpers.interopDefault(_noMjs);
var _plMjs = require("./pl.mjs");
var _plMjsDefault = parcelHelpers.interopDefault(_plMjs);
var _ptMjs = require("./pt.mjs");
var _ptMjsDefault = parcelHelpers.interopDefault(_ptMjs);
var _roMjs = require("./ro.mjs");
var _roMjsDefault = parcelHelpers.interopDefault(_roMjs);
var _ruMjs = require("./ru.mjs");
var _ruMjsDefault = parcelHelpers.interopDefault(_ruMjs);
var _skMjs = require("./sk.mjs");
var _skMjsDefault = parcelHelpers.interopDefault(_skMjs);
var _slMjs = require("./sl.mjs");
var _slMjsDefault = parcelHelpers.interopDefault(_slMjs);
var _srCyrlMjs = require("./sr-Cyrl.mjs");
var _srCyrlMjsDefault = parcelHelpers.interopDefault(_srCyrlMjs);
var _srLatnMjs = require("./sr-Latn.mjs");
var _srLatnMjsDefault = parcelHelpers.interopDefault(_srLatnMjs);
var _svMjs = require("./sv.mjs");
var _svMjsDefault = parcelHelpers.interopDefault(_svMjs);
var _thMjs = require("./th.mjs");
var _thMjsDefault = parcelHelpers.interopDefault(_thMjs);
var _trMjs = require("./tr.mjs");
var _trMjsDefault = parcelHelpers.interopDefault(_trMjs);
var _azMjs = require("./az.mjs");
var _azMjsDefault = parcelHelpers.interopDefault(_azMjs);
var _ukMjs = require("./uk.mjs");
var _ukMjsDefault = parcelHelpers.interopDefault(_ukMjs);
var _viMjs = require("./vi.mjs");
var _viMjsDefault = parcelHelpers.interopDefault(_viMjs);
var _zhHansMjs = require("./zh-Hans.mjs");
var _zhHansMjsDefault = parcelHelpers.interopDefault(_zhHansMjs);
var _zhHantMjs = require("./zh-Hant.mjs");
var _zhHantMjsDefault = parcelHelpers.interopDefault(_zhHantMjs);
const defaultRtl = {
    af: false,
    ar: true,
    bg: false,
    ca: false,
    ckb: false,
    cs: false,
    de: false,
    el: false,
    en: false,
    es: false,
    et: false,
    fa: true,
    fi: false,
    fr: false,
    hr: false,
    hu: false,
    he: true,
    id: false,
    it: false,
    ja: false,
    ko: false,
    lv: false,
    lt: false,
    nl: false,
    no: false,
    pl: false,
    pt: false,
    ro: false,
    ru: false,
    sk: false,
    sl: false,
    srCyrl: false,
    srLatn: false,
    sv: false,
    th: false,
    tr: false,
    az: false,
    uk: false,
    vi: false,
    zhHans: false,
    zhHant: false
};

},{"./af.mjs":false,"./ar.mjs":false,"./bg.mjs":false,"./ca.mjs":false,"./ckb.mjs":false,"./cs.mjs":false,"./da.mjs":false,"./de.mjs":false,"./el.mjs":false,"./en.mjs":false,"./es.mjs":false,"./et.mjs":false,"./fa.mjs":false,"./fi.mjs":false,"./fr.mjs":false,"./hr.mjs":false,"./hu.mjs":false,"./he.mjs":false,"./id.mjs":false,"./it.mjs":false,"./ja.mjs":false,"./ko.mjs":false,"./lv.mjs":false,"./lt.mjs":false,"./nl.mjs":false,"./no.mjs":false,"./pl.mjs":false,"./pt.mjs":false,"./ro.mjs":false,"./ru.mjs":false,"./sk.mjs":false,"./sl.mjs":false,"./sr-Cyrl.mjs":false,"./sr-Latn.mjs":false,"./sv.mjs":false,"./th.mjs":false,"./tr.mjs":false,"./az.mjs":false,"./uk.mjs":false,"./vi.mjs":false,"./zh-Hans.mjs":false,"./zh-Hant.mjs":false,"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ldNWH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    badge: "Badge",
    open: "Open",
    close: "Close",
    dataIterator: {
        noResultsText: "No matching records found",
        loadingText: "Loading items..."
    },
    dataTable: {
        itemsPerPageText: "Rows per page:",
        ariaLabel: {
            sortDescending: "Sorted descending.",
            sortAscending: "Sorted ascending.",
            sortNone: "Not sorted.",
            activateNone: "Activate to remove sorting.",
            activateDescending: "Activate to sort descending.",
            activateAscending: "Activate to sort ascending."
        },
        sortBy: "Sort by"
    },
    dataFooter: {
        itemsPerPageText: "Items per page:",
        itemsPerPageAll: "All",
        nextPage: "Next page",
        prevPage: "Previous page",
        firstPage: "First page",
        lastPage: "Last page",
        pageText: "{0}-{1} of {2}"
    },
    dateRangeInput: {
        divider: "to"
    },
    datePicker: {
        ok: "OK",
        cancel: "Cancel",
        range: {
            title: "Select dates",
            header: "Enter dates"
        },
        title: "Select date",
        header: "Enter date",
        input: {
            placeholder: "Enter date"
        }
    },
    noDataText: "No data available",
    carousel: {
        prev: "Previous visual",
        next: "Next visual",
        ariaLabel: {
            delimiter: "Carousel slide {0} of {1}"
        }
    },
    calendar: {
        moreEvents: "{0} more"
    },
    input: {
        clear: "Clear {0}",
        prependAction: "{0} prepended action",
        appendAction: "{0} appended action",
        otp: "Please enter OTP character {0}"
    },
    fileInput: {
        counter: "{0} files",
        counterSize: "{0} files ({1} in total)"
    },
    timePicker: {
        am: "AM",
        pm: "PM"
    },
    pagination: {
        ariaLabel: {
            root: "Pagination Navigation",
            next: "Next page",
            previous: "Previous page",
            page: "Go to page {0}",
            currentPage: "Page {0}, Current page",
            first: "First page",
            last: "Last page"
        }
    },
    stepper: {
        next: "Next",
        prev: "Previous"
    },
    rating: {
        ariaLabel: {
            item: "Rating {0} of {1}"
        }
    },
    loading: "Loading...",
    infiniteScroll: {
        loadMore: "Load more",
        empty: "No more"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4Vdit":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createVuetifyAdapter", ()=>createVuetifyAdapter);
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Locales
var _enMjs = require("../en.mjs"); // Types
var _enMjsDefault = parcelHelpers.interopDefault(_enMjs);
const LANG_PREFIX = "$vuetify.";
const replace = (str, params)=>{
    return str.replace(/\{(\d+)\}/g, (match, index)=>{
        return String(params[+index]);
    });
};
const createTranslateFunction = (current, fallback, messages)=>{
    return function(key) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)params[_key - 1] = arguments[_key];
        if (!key.startsWith(LANG_PREFIX)) return replace(key, params);
        const shortKey = key.replace(LANG_PREFIX, "");
        const currentLocale = current.value && messages.value[current.value];
        const fallbackLocale = fallback.value && messages.value[fallback.value];
        let str = (0, _indexMjs.getObjectValueByPath)(currentLocale, shortKey, null);
        if (!str) {
            (0, _indexMjs.consoleWarn)(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
            str = (0, _indexMjs.getObjectValueByPath)(fallbackLocale, shortKey, null);
        }
        if (!str) {
            (0, _indexMjs.consoleError)(`Translation key "${key}" not found in fallback`);
            str = key;
        }
        if (typeof str !== "string") {
            (0, _indexMjs.consoleError)(`Translation key "${key}" has a non-string value`);
            str = key;
        }
        return replace(str, params);
    };
};
function createNumberFunction(current, fallback) {
    return (value, options)=>{
        const numberFormat = new Intl.NumberFormat([
            current.value,
            fallback.value
        ], options);
        return numberFormat.format(value);
    };
}
function useProvided(props, prop, provided) {
    const internal = (0, _proxiedModelMjs.useProxiedModel)(props, prop, props[prop] ?? provided.value);
    // TODO: Remove when defaultValue works
    internal.value = props[prop] ?? provided.value;
    (0, _vue.watch)(provided, (v)=>{
        if (props[prop] == null) internal.value = provided.value;
    });
    return internal;
}
function createProvideFunction(state) {
    return (props)=>{
        const current = useProvided(props, "locale", state.current);
        const fallback = useProvided(props, "fallback", state.fallback);
        const messages = useProvided(props, "messages", state.messages);
        return {
            name: "vuetify",
            current,
            fallback,
            messages,
            t: createTranslateFunction(current, fallback, messages),
            n: createNumberFunction(current, fallback),
            provide: createProvideFunction({
                current,
                fallback,
                messages
            })
        };
    };
}
function createVuetifyAdapter(options) {
    const current = (0, _vue.shallowRef)(options?.locale ?? "en");
    const fallback = (0, _vue.shallowRef)(options?.fallback ?? "en");
    const messages = (0, _vue.ref)({
        en: (0, _enMjsDefault.default),
        ...options?.messages
    });
    return {
        name: "vuetify",
        current,
        fallback,
        messages,
        t: createTranslateFunction(current, fallback, messages),
        n: createNumberFunction(current, fallback),
        provide: createProvideFunction({
            current,
            fallback,
            messages
        })
    };
}

},{"../../composables/proxiedModel.mjs":"bUF28","vue":"ff77s","../../util/index.mjs":"6uIWw","../en.mjs":"ldNWH","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bUF28":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Composables
parcelHelpers.export(exports, "useProxiedModel", ()=>useProxiedModel);
var _toggleScopeMjs = require("./toggleScope.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
function useProxiedModel(props, prop, defaultValue) {
    let transformIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : (v)=>v;
    let transformOut = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : (v)=>v;
    const vm = (0, _indexMjs.getCurrentInstance)("useProxiedModel");
    const internal = (0, _vue.ref)(props[prop] !== undefined ? props[prop] : defaultValue);
    const kebabProp = (0, _indexMjs.toKebabCase)(prop);
    const checkKebab = kebabProp !== prop;
    const isControlled = checkKebab ? (0, _vue.computed)(()=>{
        props[prop];
        return !!((vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) && (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`)));
    }) : (0, _vue.computed)(()=>{
        props[prop];
        return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`));
    });
    (0, _toggleScopeMjs.useToggleScope)(()=>!isControlled.value, ()=>{
        (0, _vue.watch)(()=>props[prop], (val)=>{
            internal.value = val;
        });
    });
    const model = (0, _vue.computed)({
        get () {
            const externalValue = props[prop];
            return transformIn(isControlled.value ? externalValue : internal.value);
        },
        set (internalValue) {
            const newValue = transformOut(internalValue);
            const value = (0, _vue.toRaw)(isControlled.value ? props[prop] : internal.value);
            if (value === newValue || transformIn(value) === internalValue) return;
            internal.value = newValue;
            vm?.emit(`update:${prop}`, newValue);
        }
    });
    Object.defineProperty(model, "externalValue", {
        get: ()=>isControlled.value ? props[prop] : internal.value
    });
    return model;
}

},{"./toggleScope.mjs":"cE29O","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cE29O":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Types
parcelHelpers.export(exports, "useToggleScope", ()=>useToggleScope);
var _vue = require("vue");
function useToggleScope(source, fn) {
    let scope;
    function start() {
        scope = (0, _vue.effectScope)();
        scope.run(()=>fn.length ? fn(()=>{
                scope?.stop();
                start();
            }) : fn());
    }
    (0, _vue.watch)(source, (active)=>{
        if (active && !scope) start();
        else if (!active) {
            scope?.stop();
            scope = undefined;
        }
    }, {
        immediate: true
    });
    (0, _vue.onScopeDispose)(()=>{
        scope?.stop();
    });
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9LCgN":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ThemeSymbol", ()=>ThemeSymbol);
parcelHelpers.export(exports, "makeThemeProps", ()=>makeThemeProps);
// Composables
parcelHelpers.export(exports, "createTheme", ()=>createTheme);
parcelHelpers.export(exports, "provideTheme", ()=>provideTheme);
parcelHelpers.export(exports, "useTheme", ()=>useTheme);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = (0, _indexMjs.propsFactory)({
    theme: String
}, "theme");
const defaultThemeOptions = {
    defaultTheme: "light",
    variations: {
        colors: [],
        lighten: 0,
        darken: 0
    },
    themes: {
        light: {
            dark: false,
            colors: {
                background: "#FFFFFF",
                surface: "#FFFFFF",
                "surface-bright": "#FFFFFF",
                "surface-variant": "#424242",
                "on-surface-variant": "#EEEEEE",
                primary: "#6200EE",
                "primary-darken-1": "#3700B3",
                secondary: "#03DAC6",
                "secondary-darken-1": "#018786",
                error: "#B00020",
                info: "#2196F3",
                success: "#4CAF50",
                warning: "#FB8C00"
            },
            variables: {
                "border-color": "#000000",
                "border-opacity": 0.12,
                "high-emphasis-opacity": 0.87,
                "medium-emphasis-opacity": 0.60,
                "disabled-opacity": 0.38,
                "idle-opacity": 0.04,
                "hover-opacity": 0.04,
                "focus-opacity": 0.12,
                "selected-opacity": 0.08,
                "activated-opacity": 0.12,
                "pressed-opacity": 0.12,
                "dragged-opacity": 0.08,
                "theme-kbd": "#212529",
                "theme-on-kbd": "#FFFFFF",
                "theme-code": "#F5F5F5",
                "theme-on-code": "#000000"
            }
        },
        dark: {
            dark: true,
            colors: {
                background: "#121212",
                surface: "#212121",
                "surface-bright": "#ccbfd6",
                "surface-variant": "#a3a3a3",
                "on-surface-variant": "#424242",
                primary: "#BB86FC",
                "primary-darken-1": "#3700B3",
                secondary: "#03DAC5",
                "secondary-darken-1": "#03DAC5",
                error: "#CF6679",
                info: "#2196F3",
                success: "#4CAF50",
                warning: "#FB8C00"
            },
            variables: {
                "border-color": "#FFFFFF",
                "border-opacity": 0.12,
                "high-emphasis-opacity": 1,
                "medium-emphasis-opacity": 0.70,
                "disabled-opacity": 0.50,
                "idle-opacity": 0.10,
                "hover-opacity": 0.04,
                "focus-opacity": 0.12,
                "selected-opacity": 0.08,
                "activated-opacity": 0.12,
                "pressed-opacity": 0.16,
                "dragged-opacity": 0.08,
                "theme-kbd": "#212529",
                "theme-on-kbd": "#FFFFFF",
                "theme-code": "#343434",
                "theme-on-code": "#CCCCCC"
            }
        }
    }
};
function parseThemeOptions() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultThemeOptions;
    if (!options) return {
        ...defaultThemeOptions,
        isDisabled: true
    };
    const themes = {};
    for (const [key, theme] of Object.entries(options.themes ?? {})){
        const defaultTheme = theme.dark || key === "dark" ? defaultThemeOptions.themes?.dark : defaultThemeOptions.themes?.light;
        themes[key] = (0, _indexMjs.mergeDeep)(defaultTheme, theme);
    }
    return (0, _indexMjs.mergeDeep)(defaultThemeOptions, {
        ...options,
        themes
    });
}
function createTheme(options) {
    const parsedOptions = parseThemeOptions(options);
    const name = (0, _vue.ref)(parsedOptions.defaultTheme);
    const themes = (0, _vue.ref)(parsedOptions.themes);
    const computedThemes = (0, _vue.computed)(()=>{
        const acc = {};
        for (const [name, original] of Object.entries(themes.value)){
            const theme = acc[name] = {
                ...original,
                colors: {
                    ...original.colors
                }
            };
            if (parsedOptions.variations) for (const name of parsedOptions.variations.colors){
                const color = theme.colors[name];
                if (!color) continue;
                for (const variation of [
                    "lighten",
                    "darken"
                ]){
                    const fn = variation === "lighten" ? (0, _indexMjs.lighten) : (0, _indexMjs.darken);
                    for (const amount of (0, _indexMjs.createRange)(parsedOptions.variations[variation], 1))theme.colors[`${name}-${variation}-${amount}`] = (0, _indexMjs.RGBtoHex)(fn((0, _indexMjs.parseColor)(color), amount));
                }
            }
            for (const color of Object.keys(theme.colors)){
                if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`]) continue;
                const onColor = `on-${color}`;
                const colorVal = (0, _indexMjs.parseColor)(theme.colors[color]);
                // TODO: warn about poor color selections
                // const contrastAsText = Math.abs(APCAcontrast(colorVal, colorToInt(theme.colors.background)))
                // const minContrast = Math.max(blackContrast, whiteContrast)
                // if (minContrast < 60) {
                //   consoleInfo(`${key} theme color ${color} has poor contrast (${minContrast.toFixed()}%)`)
                // } else if (contrastAsText < 60 && !['background', 'surface'].includes(color)) {
                //   consoleInfo(`${key} theme color ${color} has poor contrast as text (${contrastAsText.toFixed()}%)`)
                // }
                // Prefer white text if both have an acceptable contrast ratio
                theme.colors[onColor] = (0, _indexMjs.getForeground)(colorVal);
            }
        }
        return acc;
    });
    const current = (0, _vue.computed)(()=>computedThemes.value[name.value]);
    const styles = (0, _vue.computed)(()=>{
        const lines = [];
        if (current.value.dark) createCssClass(lines, ":root", [
            "color-scheme: dark"
        ]);
        createCssClass(lines, ":root", genCssVariables(current.value));
        for (const [themeName, theme] of Object.entries(computedThemes.value))createCssClass(lines, `.v-theme--${themeName}`, [
            `color-scheme: ${theme.dark ? "dark" : "normal"}`,
            ...genCssVariables(theme)
        ]);
        const bgLines = [];
        const fgLines = [];
        const colors = new Set(Object.values(computedThemes.value).flatMap((theme)=>Object.keys(theme.colors)));
        for (const key of colors)if (/^on-[a-z]/.test(key)) createCssClass(fgLines, `.${key}`, [
            `color: rgb(var(--v-theme-${key})) !important`
        ]);
        else {
            createCssClass(bgLines, `.bg-${key}`, [
                `--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`,
                `background-color: rgb(var(--v-theme-${key})) !important`,
                `color: rgb(var(--v-theme-on-${key})) !important`
            ]);
            createCssClass(fgLines, `.text-${key}`, [
                `color: rgb(var(--v-theme-${key})) !important`
            ]);
            createCssClass(fgLines, `.border-${key}`, [
                `--v-border-color: var(--v-theme-${key})`
            ]);
        }
        lines.push(...bgLines, ...fgLines);
        return lines.map((str, i)=>i === 0 ? str : `    ${str}`).join("");
    });
    function getHead() {
        return {
            style: [
                {
                    children: styles.value,
                    id: "vuetify-theme-stylesheet",
                    nonce: parsedOptions.cspNonce || false
                }
            ]
        };
    }
    function install(app) {
        if (parsedOptions.isDisabled) return;
        const head = app._context.provides.usehead;
        if (head) {
            if (head.push) {
                const entry = head.push(getHead);
                if (0, _indexMjs.IN_BROWSER) (0, _vue.watch)(styles, ()=>{
                    entry.patch(getHead);
                });
            } else if (0, _indexMjs.IN_BROWSER) {
                head.addHeadObjs((0, _vue.computed)(getHead));
                (0, _vue.watchEffect)(()=>head.updateDOM());
            } else head.addHeadObjs(getHead());
        } else {
            let styleEl = (0, _indexMjs.IN_BROWSER) ? document.getElementById("vuetify-theme-stylesheet") : null;
            if (0, _indexMjs.IN_BROWSER) (0, _vue.watch)(styles, updateStyles, {
                immediate: true
            });
            else updateStyles();
            function updateStyles() {
                if (typeof document !== "undefined" && !styleEl) {
                    const el = document.createElement("style");
                    el.type = "text/css";
                    el.id = "vuetify-theme-stylesheet";
                    if (parsedOptions.cspNonce) el.setAttribute("nonce", parsedOptions.cspNonce);
                    styleEl = el;
                    document.head.appendChild(styleEl);
                }
                if (styleEl) styleEl.innerHTML = styles.value;
            }
        }
    }
    const themeClasses = (0, _vue.computed)(()=>parsedOptions.isDisabled ? undefined : `v-theme--${name.value}`);
    return {
        install,
        isDisabled: parsedOptions.isDisabled,
        name,
        themes,
        current,
        computedThemes,
        themeClasses,
        styles,
        global: {
            name,
            current
        }
    };
}
function provideTheme(props) {
    (0, _indexMjs.getCurrentInstance)("provideTheme");
    const theme = (0, _vue.inject)(ThemeSymbol, null);
    if (!theme) throw new Error("Could not find Vuetify theme injection");
    const name = (0, _vue.computed)(()=>{
        return props.theme ?? theme.name.value;
    });
    const current = (0, _vue.computed)(()=>theme.themes.value[name.value]);
    const themeClasses = (0, _vue.computed)(()=>theme.isDisabled ? undefined : `v-theme--${name.value}`);
    const newTheme = {
        ...theme,
        name,
        current,
        themeClasses
    };
    (0, _vue.provide)(ThemeSymbol, newTheme);
    return newTheme;
}
function useTheme() {
    (0, _indexMjs.getCurrentInstance)("useTheme");
    const theme = (0, _vue.inject)(ThemeSymbol, null);
    if (!theme) throw new Error("Could not find Vuetify theme injection");
    return theme;
}
function createCssClass(lines, selector, content) {
    lines.push(`${selector} {\n`, ...content.map((line)=>`  ${line};\n`), "}\n");
}
function genCssVariables(theme) {
    const lightOverlay = theme.dark ? 2 : 1;
    const darkOverlay = theme.dark ? 1 : 2;
    const variables = [];
    for (const [key, value] of Object.entries(theme.colors)){
        const rgb = (0, _indexMjs.parseColor)(value);
        variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
        if (!key.startsWith("on-")) variables.push(`--v-theme-${key}-overlay-multiplier: ${(0, _indexMjs.getLuma)(value) > 0.18 ? lightOverlay : darkOverlay}`);
    }
    for (const [key, value] of Object.entries(theme.variables)){
        const color = typeof value === "string" && value.startsWith("#") ? (0, _indexMjs.parseColor)(value) : undefined;
        const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : undefined;
        variables.push(`--v-${key}: ${rgb ?? value}`);
    }
    return variables;
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kn66v":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DateAdapterSymbol", ()=>DateAdapterSymbol);
parcelHelpers.export(exports, "createDate", ()=>createDate);
parcelHelpers.export(exports, "makeDateProps", ()=>makeDateProps);
parcelHelpers.export(exports, "useDate", ()=>useDate);
parcelHelpers.export(exports, "toIso", ()=>toIso);
// https://stackoverflow.com/questions/274861/how-do-i-calculate-the-week-number-given-a-date/275024#275024
parcelHelpers.export(exports, "getWeek", ()=>getWeek);
var _localeMjs = require("../../composables/locale.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Adapters
var _vuetifyMjs = require("./adapters/vuetify.mjs"); // Types
const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
function createDate(options) {
    return (0, _indexMjs.mergeDeep)({
        adapter: (0, _vuetifyMjs.VuetifyDateAdapter),
        locale: {
            af: "af-ZA",
            // ar: '', # not the same value for all variants
            bg: "bg-BG",
            ca: "ca-ES",
            ckb: "",
            cs: "",
            de: "de-DE",
            el: "el-GR",
            en: "en-US",
            // es: '', # not the same value for all variants
            et: "et-EE",
            fa: "fa-IR",
            fi: "fi-FI",
            // fr: '', #not the same value for all variants
            hr: "hr-HR",
            hu: "hu-HU",
            he: "he-IL",
            id: "id-ID",
            it: "it-IT",
            ja: "ja-JP",
            ko: "ko-KR",
            lv: "lv-LV",
            lt: "lt-LT",
            nl: "nl-NL",
            no: "nn-NO",
            pl: "pl-PL",
            pt: "pt-PT",
            ro: "ro-RO",
            ru: "ru-RU",
            sk: "sk-SK",
            sl: "sl-SI",
            srCyrl: "sr-SP",
            srLatn: "sr-SP",
            sv: "sv-SE",
            th: "th-TH",
            tr: "tr-TR",
            az: "az-AZ",
            uk: "uk-UA",
            vi: "vi-VN",
            zhHans: "zh-CN",
            zhHant: "zh-TW"
        }
    }, options);
}
const makeDateProps = (0, _indexMjs.propsFactory)({
    displayDate: {
        type: Object,
        default: new Date()
    },
    hideAdjacentMonths: Boolean,
    modelValue: {
        type: null,
        default: ()=>[]
    }
}, "date");
function useDate() {
    const date = (0, _vue.inject)(DateAdapterSymbol);
    const locale = (0, _localeMjs.useLocale)();
    if (!date) throw new Error("[Vuetify] Could not find injected date");
    const instance = (0, _vue.reactive)(typeof date.adapter === "function" ? new date.adapter({
        locale: date.locale?.[locale.current.value] ?? locale.current.value
    }) : date.adapter);
    (0, _vue.watch)(locale.current, (value)=>{
        const newLocale = date.locale ? date.locale[value] : value;
        instance.locale = newLocale ?? instance.locale;
    });
    return instance;
}
function toIso(adapter, value) {
    const date = adapter.toJsDate(value);
    return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
}
function getMondayOfFirstWeekOfYear(year) {
    return new Date(year, 0, 1);
}
function getWeek(adapter, value) {
    const date = adapter.toJsDate(value);
    let year = date.getFullYear();
    let d1w1 = getMondayOfFirstWeekOfYear(year);
    if (date < d1w1) {
        year = year - 1;
        d1w1 = getMondayOfFirstWeekOfYear(year);
    } else {
        const tv = getMondayOfFirstWeekOfYear(year + 1);
        if (date >= tv) {
            year = year + 1;
            d1w1 = tv;
        }
    }
    const diffTime = Math.abs(date.getTime() - d1w1.getTime());
    const diffDays = Math.ceil(diffTime / 86400000);
    return Math.floor(diffDays / 7) + 1;
}

},{"../../composables/locale.mjs":"4MZbL","vue":"ff77s","../../util/index.mjs":"6uIWw","./adapters/vuetify.mjs":"dG2CU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dG2CU":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VuetifyDateAdapter", ()=>VuetifyDateAdapter);
var _indexMjs = require("../../../util/index.mjs"); // Types
const firstDay = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AG: 0,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AS: 0,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BD: 0,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BR: 0,
    BS: 0,
    BT: 0,
    BW: 0,
    BY: 1,
    BZ: 0,
    CA: 0,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CO: 0,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DM: 0,
    DO: 0,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    ET: 0,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    "GB-alt-variant": 0,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    GT: 0,
    GU: 0,
    HK: 0,
    HN: 0,
    HR: 1,
    HU: 1,
    ID: 0,
    IE: 1,
    IL: 0,
    IN: 0,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JM: 0,
    JO: 6,
    JP: 0,
    KE: 0,
    KG: 1,
    KH: 0,
    KR: 0,
    KW: 6,
    KZ: 1,
    LA: 0,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MH: 0,
    MK: 1,
    MM: 0,
    MN: 1,
    MO: 0,
    MQ: 1,
    MT: 0,
    MV: 5,
    MX: 0,
    MY: 1,
    MZ: 0,
    NI: 0,
    NL: 1,
    NO: 1,
    NP: 0,
    NZ: 1,
    OM: 6,
    PA: 0,
    PE: 0,
    PH: 0,
    PK: 0,
    PL: 1,
    PR: 0,
    PT: 0,
    PY: 0,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SA: 0,
    SD: 6,
    SE: 1,
    SG: 0,
    SI: 1,
    SK: 1,
    SM: 1,
    SV: 0,
    SY: 6,
    TH: 0,
    TJ: 1,
    TM: 1,
    TR: 1,
    TT: 0,
    TW: 0,
    UA: 1,
    UM: 0,
    US: 0,
    UY: 1,
    UZ: 1,
    VA: 1,
    VE: 0,
    VI: 0,
    VN: 1,
    WS: 0,
    XK: 1,
    YE: 0,
    ZA: 0,
    ZW: 0
};
function getWeekArray(date, locale) {
    const weeks = [];
    let currentWeek = [];
    const firstDayOfMonth = startOfMonth(date);
    const lastDayOfMonth = endOfMonth(date);
    const firstDayWeekIndex = firstDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()];
    const lastDayWeekIndex = lastDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()];
    for(let i = 0; i < firstDayWeekIndex; i++){
        const adjacentDay = new Date(firstDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
        currentWeek.push(adjacentDay);
    }
    for(let i = 1; i <= lastDayOfMonth.getDate(); i++){
        const day = new Date(date.getFullYear(), date.getMonth(), i);
        // Add the day to the current week
        currentWeek.push(day);
        // If the current week has 7 days, add it to the weeks array and start a new week
        if (currentWeek.length === 7) {
            weeks.push(currentWeek);
            currentWeek = [];
        }
    }
    for(let i = 1; i < 7 - lastDayWeekIndex; i++){
        const adjacentDay = new Date(lastDayOfMonth);
        adjacentDay.setDate(adjacentDay.getDate() + i);
        currentWeek.push(adjacentDay);
    }
    weeks.push(currentWeek);
    return weeks;
}
function startOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
}
function endOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
function parseLocalDate(value) {
    const parts = value.split("-").map(Number);
    // new Date() uses local time zone when passing individual date component values
    return new Date(parts[0], parts[1] - 1, parts[2]);
}
const _YYYMMDD = /([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))/;
function date(value) {
    if (value == null) return new Date();
    if (value instanceof Date) return value;
    if (typeof value === "string") {
        let parsed;
        if (_YYYMMDD.test(value)) return parseLocalDate(value);
        else parsed = Date.parse(value);
        if (!isNaN(parsed)) return new Date(parsed);
    }
    return null;
}
const sundayJanuarySecond2000 = new Date(2000, 0, 2);
function getWeekdays(locale) {
    const daysFromSunday = firstDay[locale.slice(-2).toUpperCase()];
    return (0, _indexMjs.createRange)(7).map((i)=>{
        const weekday = new Date(sundayJanuarySecond2000);
        weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
        return new Intl.DateTimeFormat(locale, {
            weekday: "narrow"
        }).format(weekday);
    });
}
function format(value, formatString, locale) {
    const date = new Date(value);
    let options = {};
    switch(formatString){
        case "fullDateWithWeekday":
            options = {
                weekday: "long",
                day: "numeric",
                month: "long",
                year: "numeric"
            };
            break;
        case "normalDateWithWeekday":
            options = {
                weekday: "short",
                day: "numeric",
                month: "short"
            };
            break;
        case "keyboardDate":
            options = {};
            break;
        case "monthAndDate":
            options = {
                month: "long",
                day: "numeric"
            };
            break;
        case "monthAndYear":
            options = {
                month: "long",
                year: "numeric"
            };
            break;
        case "dayOfMonth":
            options = {
                day: "numeric"
            };
            break;
        default:
            options = {
                timeZone: "UTC",
                timeZoneName: "short"
            };
    }
    return new Intl.DateTimeFormat(locale, options).format(date);
}
function addDays(date, amount) {
    const d = new Date(date);
    d.setDate(d.getDate() + amount);
    return d;
}
function addMonths(date, amount) {
    const d = new Date(date);
    d.setMonth(d.getMonth() + amount);
    return d;
}
function getYear(date) {
    return date.getFullYear();
}
function getMonth(date) {
    return date.getMonth();
}
function startOfYear(date) {
    return new Date(date.getFullYear(), 0, 1);
}
function endOfYear(date) {
    return new Date(date.getFullYear(), 11, 31);
}
function isWithinRange(date, range) {
    return isAfter(date, range[0]) && isBefore(date, range[1]);
}
function isValid(date) {
    if (!date || date == null) return false;
    const d = new Date(date);
    return d instanceof Date && !isNaN(d.getTime());
}
function isAfter(date, comparing) {
    return date.getTime() > comparing.getTime();
}
function isBefore(date, comparing) {
    return date.getTime() < comparing.getTime();
}
function isEqual(date, comparing) {
    return date.getTime() === comparing.getTime();
}
function isSameDay(date, comparing) {
    return date.getDate() === comparing.getDate() && date.getMonth() === comparing.getMonth() && date.getFullYear() === comparing.getFullYear();
}
function isSameMonth(date, comparing) {
    return date.getMonth() === comparing.getMonth() && date.getFullYear() === comparing.getFullYear();
}
function getDiff(date, comparing, unit) {
    const d = new Date(date);
    const c = new Date(comparing);
    if (unit === "month") return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
    return Math.floor((d.getTime() - c.getTime()) / 86400000);
}
function setYear(date, year) {
    const d = new Date(date);
    d.setFullYear(year);
    return d;
}
function startOfDay(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
function endOfDay(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
}
class VuetifyDateAdapter {
    constructor(options){
        this.locale = options.locale;
    }
    date(value) {
        return date(value);
    }
    toJsDate(date) {
        return date;
    }
    addDays(date, amount) {
        return addDays(date, amount);
    }
    addMonths(date, amount) {
        return addMonths(date, amount);
    }
    getWeekArray(date) {
        return getWeekArray(date, this.locale);
    }
    startOfMonth(date) {
        return startOfMonth(date);
    }
    endOfMonth(date) {
        return endOfMonth(date);
    }
    format(date, formatString) {
        return format(date, formatString, this.locale);
    }
    isEqual(date, comparing) {
        return isEqual(date, comparing);
    }
    isValid(date) {
        return isValid(date);
    }
    isWithinRange(date, range) {
        return isWithinRange(date, range);
    }
    isAfter(date, comparing) {
        return isAfter(date, comparing);
    }
    isBefore(date, comparing) {
        return !isAfter(date, comparing) && !isEqual(date, comparing);
    }
    isSameDay(date, comparing) {
        return isSameDay(date, comparing);
    }
    isSameMonth(date, comparing) {
        return isSameMonth(date, comparing);
    }
    setYear(date, year) {
        return setYear(date, year);
    }
    getDiff(date, comparing, unit) {
        return getDiff(date, comparing, unit);
    }
    getWeekdays() {
        return getWeekdays(this.locale);
    }
    getYear(date) {
        return getYear(date);
    }
    getMonth(date) {
        return getMonth(date);
    }
    startOfDay(date) {
        return startOfDay(date);
    }
    endOfDay(date) {
        return endOfDay(date);
    }
    startOfYear(date) {
        return startOfYear(date);
    }
    endOfYear(date) {
        return endOfYear(date);
    }
}

},{"../../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lUqcD":[function(require,module,exports) {
/*
 * PUBLIC INTERFACES ONLY
 * Imports in our code should be to the composable directly, not this file
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDefaults", ()=>(0, _defaultsMjs.useDefaults));
parcelHelpers.export(exports, "useDisplay", ()=>(0, _displayMjs.useDisplay));
parcelHelpers.export(exports, "useLayout", ()=>(0, _layoutMjs.useLayout));
parcelHelpers.export(exports, "useLocale", ()=>(0, _localeMjs.useLocale));
parcelHelpers.export(exports, "useRtl", ()=>(0, _localeMjs.useRtl));
parcelHelpers.export(exports, "useTheme", ()=>(0, _themeMjs.useTheme));
var _defaultsMjs = require("./defaults.mjs");
var _displayMjs = require("./display.mjs");
var _layoutMjs = require("./layout.mjs");
var _localeMjs = require("./locale.mjs");
var _themeMjs = require("./theme.mjs");

},{"./defaults.mjs":false,"./display.mjs":"6nXZK","./layout.mjs":false,"./locale.mjs":"4MZbL","./theme.mjs":false,"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fPMsf":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VuetifyLayoutKey", ()=>VuetifyLayoutKey);
parcelHelpers.export(exports, "VuetifyLayoutItemKey", ()=>VuetifyLayoutItemKey);
parcelHelpers.export(exports, "makeLayoutProps", ()=>makeLayoutProps);
parcelHelpers.export(exports, "makeLayoutItemProps", ()=>makeLayoutItemProps);
parcelHelpers.export(exports, "useLayout", ()=>useLayout);
parcelHelpers.export(exports, "useLayoutItem", ()=>useLayoutItem);
parcelHelpers.export(exports, "createLayout", ()=>createLayout);
var _resizeObserverMjs = require("./resizeObserver.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1000;
const makeLayoutProps = (0, _indexMjs.propsFactory)({
    overlaps: {
        type: Array,
        default: ()=>[]
    },
    fullHeight: Boolean
}, "layout");
const makeLayoutItemProps = (0, _indexMjs.propsFactory)({
    name: {
        type: String
    },
    order: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    absolute: Boolean
}, "layout-item");
function useLayout() {
    const layout = (0, _vue.inject)(VuetifyLayoutKey);
    if (!layout) throw new Error("[Vuetify] Could not find injected layout");
    return {
        getLayoutItem: layout.getLayoutItem,
        mainRect: layout.mainRect,
        mainStyles: layout.mainStyles
    };
}
function useLayoutItem(options) {
    const layout = (0, _vue.inject)(VuetifyLayoutKey);
    if (!layout) throw new Error("[Vuetify] Could not find injected layout");
    const id = options.id ?? `layout-item-${(0, _indexMjs.getUid)()}`;
    const vm = (0, _indexMjs.getCurrentInstance)("useLayoutItem");
    (0, _vue.provide)(VuetifyLayoutItemKey, {
        id
    });
    const isKeptAlive = (0, _vue.shallowRef)(false);
    (0, _vue.onDeactivated)(()=>isKeptAlive.value = true);
    (0, _vue.onActivated)(()=>isKeptAlive.value = false);
    const { layoutItemStyles, layoutItemScrimStyles } = layout.register(vm, {
        ...options,
        active: (0, _vue.computed)(()=>isKeptAlive.value ? false : options.active.value),
        id
    });
    (0, _vue.onBeforeUnmount)(()=>layout.unregister(id));
    return {
        layoutItemStyles,
        layoutRect: layout.layoutRect,
        layoutItemScrimStyles
    };
}
const generateLayers = (layout, positions, layoutSizes, activeItems)=>{
    let previousLayer = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };
    const layers = [
        {
            id: "",
            layer: {
                ...previousLayer
            }
        }
    ];
    for (const id of layout){
        const position = positions.get(id);
        const amount = layoutSizes.get(id);
        const active = activeItems.get(id);
        if (!position || !amount || !active) continue;
        const layer = {
            ...previousLayer,
            [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
        };
        layers.push({
            id,
            layer
        });
        previousLayer = layer;
    }
    return layers;
};
function createLayout(props) {
    const parentLayout = (0, _vue.inject)(VuetifyLayoutKey, null);
    const rootZIndex = (0, _vue.computed)(()=>parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
    const registered = (0, _vue.ref)([]);
    const positions = (0, _vue.reactive)(new Map());
    const layoutSizes = (0, _vue.reactive)(new Map());
    const priorities = (0, _vue.reactive)(new Map());
    const activeItems = (0, _vue.reactive)(new Map());
    const disabledTransitions = (0, _vue.reactive)(new Map());
    const { resizeRef, contentRect: layoutRect } = (0, _resizeObserverMjs.useResizeObserver)();
    const computedOverlaps = (0, _vue.computed)(()=>{
        const map = new Map();
        const overlaps = props.overlaps ?? [];
        for (const overlap of overlaps.filter((item)=>item.includes(":"))){
            const [top, bottom] = overlap.split(":");
            if (!registered.value.includes(top) || !registered.value.includes(bottom)) continue;
            const topPosition = positions.get(top);
            const bottomPosition = positions.get(bottom);
            const topAmount = layoutSizes.get(top);
            const bottomAmount = layoutSizes.get(bottom);
            if (!topPosition || !bottomPosition || !topAmount || !bottomAmount) continue;
            map.set(bottom, {
                position: topPosition.value,
                amount: parseInt(topAmount.value, 10)
            });
            map.set(top, {
                position: bottomPosition.value,
                amount: -parseInt(bottomAmount.value, 10)
            });
        }
        return map;
    });
    const layers = (0, _vue.computed)(()=>{
        const uniquePriorities = [
            ...new Set([
                ...priorities.values()
            ].map((p)=>p.value))
        ].sort((a, b)=>a - b);
        const layout = [];
        for (const p of uniquePriorities){
            const items = registered.value.filter((id)=>priorities.get(id)?.value === p);
            layout.push(...items);
        }
        return generateLayers(layout, positions, layoutSizes, activeItems);
    });
    const transitionsEnabled = (0, _vue.computed)(()=>{
        return !Array.from(disabledTransitions.values()).some((ref)=>ref.value);
    });
    const mainRect = (0, _vue.computed)(()=>{
        return layers.value[layers.value.length - 1].layer;
    });
    const mainStyles = (0, _vue.computed)(()=>{
        return {
            "--v-layout-left": (0, _indexMjs.convertToUnit)(mainRect.value.left),
            "--v-layout-right": (0, _indexMjs.convertToUnit)(mainRect.value.right),
            "--v-layout-top": (0, _indexMjs.convertToUnit)(mainRect.value.top),
            "--v-layout-bottom": (0, _indexMjs.convertToUnit)(mainRect.value.bottom),
            ...transitionsEnabled.value ? undefined : {
                transition: "none"
            }
        };
    });
    const items = (0, _vue.computed)(()=>{
        return layers.value.slice(1).map((_ref, index)=>{
            let { id } = _ref;
            const { layer } = layers.value[index];
            const size = layoutSizes.get(id);
            const position = positions.get(id);
            return {
                id,
                ...layer,
                size: Number(size.value),
                position: position.value
            };
        });
    });
    const getLayoutItem = (id)=>{
        return items.value.find((item)=>item.id === id);
    };
    const rootVm = (0, _indexMjs.getCurrentInstance)("createLayout");
    const isMounted = (0, _vue.shallowRef)(false);
    (0, _vue.onMounted)(()=>{
        isMounted.value = true;
    });
    (0, _vue.provide)(VuetifyLayoutKey, {
        register: (vm, _ref2)=>{
            let { id, order, position, layoutSize, elementSize, active, disableTransitions, absolute } = _ref2;
            priorities.set(id, order);
            positions.set(id, position);
            layoutSizes.set(id, layoutSize);
            activeItems.set(id, active);
            disableTransitions && disabledTransitions.set(id, disableTransitions);
            const instances = (0, _indexMjs.findChildrenWithProvide)(VuetifyLayoutItemKey, rootVm?.vnode);
            const instanceIndex = instances.indexOf(vm);
            if (instanceIndex > -1) registered.value.splice(instanceIndex, 0, id);
            else registered.value.push(id);
            const index = (0, _vue.computed)(()=>items.value.findIndex((i)=>i.id === id));
            const zIndex = (0, _vue.computed)(()=>rootZIndex.value + layers.value.length * 2 - index.value * 2);
            const layoutItemStyles = (0, _vue.computed)(()=>{
                const isHorizontal = position.value === "left" || position.value === "right";
                const isOppositeHorizontal = position.value === "right";
                const isOppositeVertical = position.value === "bottom";
                const styles = {
                    [position.value]: 0,
                    zIndex: zIndex.value,
                    transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
                    position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
                    ...transitionsEnabled.value ? undefined : {
                        transition: "none"
                    }
                };
                if (!isMounted.value) return styles;
                const item = items.value[index.value];
                if (!item) throw new Error(`[Vuetify] Could not find layout item "${id}"`);
                const overlap = computedOverlaps.value.get(id);
                if (overlap) item[overlap.position] += overlap.amount;
                return {
                    ...styles,
                    height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : undefined,
                    left: isOppositeHorizontal ? undefined : `${item.left}px`,
                    right: isOppositeHorizontal ? `${item.right}px` : undefined,
                    top: position.value !== "bottom" ? `${item.top}px` : undefined,
                    bottom: position.value !== "top" ? `${item.bottom}px` : undefined,
                    width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : undefined
                };
            });
            const layoutItemScrimStyles = (0, _vue.computed)(()=>({
                    zIndex: zIndex.value - 1
                }));
            return {
                layoutItemStyles,
                layoutItemScrimStyles,
                zIndex
            };
        },
        unregister: (id)=>{
            priorities.delete(id);
            positions.delete(id);
            layoutSizes.delete(id);
            activeItems.delete(id);
            disabledTransitions.delete(id);
            registered.value = registered.value.filter((v)=>v !== id);
        },
        mainRect,
        mainStyles,
        getLayoutItem,
        items,
        layoutRect,
        rootZIndex
    });
    const layoutClasses = (0, _vue.computed)(()=>[
            "v-layout",
            {
                "v-layout--full-height": props.fullHeight
            }
        ]);
    const layoutStyles = (0, _vue.computed)(()=>({
            zIndex: rootZIndex.value,
            position: parentLayout ? "relative" : undefined,
            overflow: parentLayout ? "hidden" : undefined
        }));
    return {
        layoutClasses,
        layoutStyles,
        getLayoutItem,
        items,
        layoutRect,
        layoutRef: resizeRef
    };
}

},{"./resizeObserver.mjs":"byLTu","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"byLTu":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useResizeObserver", ()=>useResizeObserver);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs");
var _globalsMjs = require("../util/globals.mjs"); // Types
function useResizeObserver(callback) {
    let box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "content";
    const resizeRef = (0, _vue.ref)();
    const contentRect = (0, _vue.ref)();
    if (0, _globalsMjs.IN_BROWSER) {
        const observer = new ResizeObserver((entries)=>{
            callback?.(entries, observer);
            if (!entries.length) return;
            if (box === "content") contentRect.value = entries[0].contentRect;
            else contentRect.value = entries[0].target.getBoundingClientRect();
        });
        (0, _vue.onBeforeUnmount)(()=>{
            observer.disconnect();
        });
        (0, _vue.watch)(resizeRef, (newValue, oldValue)=>{
            if (oldValue) {
                observer.unobserve((0, _indexMjs.refElement)(oldValue));
                contentRect.value = undefined;
            }
            if (newValue) observer.observe((0, _indexMjs.refElement)(newValue));
        }, {
            flush: "post"
        });
    }
    return {
        resizeRef,
        contentRect: (0, _vue.readonly)(contentRect)
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","../util/globals.mjs":"8Aq1g","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4RJCr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexMjs = require("./VApp/index.mjs");
parcelHelpers.exportAll(_indexMjs, exports);
var _indexMjs1 = require("./VAppBar/index.mjs");
parcelHelpers.exportAll(_indexMjs1, exports);
var _indexMjs2 = require("./VAlert/index.mjs");
parcelHelpers.exportAll(_indexMjs2, exports);
var _indexMjs3 = require("./VAutocomplete/index.mjs");
parcelHelpers.exportAll(_indexMjs3, exports);
var _indexMjs4 = require("./VAvatar/index.mjs");
parcelHelpers.exportAll(_indexMjs4, exports);
var _indexMjs5 = require("./VBadge/index.mjs");
parcelHelpers.exportAll(_indexMjs5, exports);
var _indexMjs6 = require("./VBanner/index.mjs");
parcelHelpers.exportAll(_indexMjs6, exports);
var _indexMjs7 = require("./VBottomNavigation/index.mjs");
parcelHelpers.exportAll(_indexMjs7, exports);
var _indexMjs8 = require("./VBreadcrumbs/index.mjs");
parcelHelpers.exportAll(_indexMjs8, exports);
var _indexMjs9 = require("./VBtn/index.mjs");
parcelHelpers.exportAll(_indexMjs9, exports);
var _indexMjs10 = require("./VBtnGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs10, exports);
var _indexMjs11 = require("./VBtnToggle/index.mjs"); // export * from './VCalendar'
parcelHelpers.exportAll(_indexMjs11, exports);
var _indexMjs12 = require("./VCard/index.mjs");
parcelHelpers.exportAll(_indexMjs12, exports);
var _indexMjs13 = require("./VCarousel/index.mjs");
parcelHelpers.exportAll(_indexMjs13, exports);
var _indexMjs14 = require("./VCheckbox/index.mjs");
parcelHelpers.exportAll(_indexMjs14, exports);
var _indexMjs15 = require("./VChip/index.mjs");
parcelHelpers.exportAll(_indexMjs15, exports);
var _indexMjs16 = require("./VChipGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs16, exports);
var _indexMjs17 = require("./VCode/index.mjs");
parcelHelpers.exportAll(_indexMjs17, exports);
var _indexMjs18 = require("./VColorPicker/index.mjs"); // export * from './VContent'
parcelHelpers.exportAll(_indexMjs18, exports);
var _indexMjs19 = require("./VCombobox/index.mjs");
parcelHelpers.exportAll(_indexMjs19, exports);
var _indexMjs20 = require("./VCounter/index.mjs"); // export * from './VDataIterator'
parcelHelpers.exportAll(_indexMjs20, exports);
// export * from './VDataTable'
var _indexMjs21 = require("./VDefaultsProvider/index.mjs");
parcelHelpers.exportAll(_indexMjs21, exports);
var _indexMjs22 = require("./VDialog/index.mjs");
parcelHelpers.exportAll(_indexMjs22, exports);
var _indexMjs23 = require("./VDivider/index.mjs");
parcelHelpers.exportAll(_indexMjs23, exports);
var _indexMjs24 = require("./VExpansionPanel/index.mjs");
parcelHelpers.exportAll(_indexMjs24, exports);
var _indexMjs25 = require("./VField/index.mjs");
parcelHelpers.exportAll(_indexMjs25, exports);
var _indexMjs26 = require("./VFileInput/index.mjs");
parcelHelpers.exportAll(_indexMjs26, exports);
var _indexMjs27 = require("./VFooter/index.mjs");
parcelHelpers.exportAll(_indexMjs27, exports);
var _indexMjs28 = require("./VForm/index.mjs");
parcelHelpers.exportAll(_indexMjs28, exports);
var _indexMjs29 = require("./VGrid/index.mjs");
parcelHelpers.exportAll(_indexMjs29, exports);
var _indexMjs30 = require("./VHover/index.mjs");
parcelHelpers.exportAll(_indexMjs30, exports);
var _indexMjs31 = require("./VIcon/index.mjs");
parcelHelpers.exportAll(_indexMjs31, exports);
var _indexMjs32 = require("./VImg/index.mjs");
parcelHelpers.exportAll(_indexMjs32, exports);
var _indexMjs33 = require("./VInput/index.mjs");
parcelHelpers.exportAll(_indexMjs33, exports);
var _indexMjs34 = require("./VItemGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs34, exports);
var _indexMjs35 = require("./VKbd/index.mjs");
parcelHelpers.exportAll(_indexMjs35, exports);
var _indexMjs36 = require("./VLabel/index.mjs");
parcelHelpers.exportAll(_indexMjs36, exports);
var _indexMjs37 = require("./VLayout/index.mjs");
parcelHelpers.exportAll(_indexMjs37, exports);
var _indexMjs38 = require("./VLazy/index.mjs");
parcelHelpers.exportAll(_indexMjs38, exports);
var _indexMjs39 = require("./VList/index.mjs");
parcelHelpers.exportAll(_indexMjs39, exports);
var _indexMjs40 = require("./VLocaleProvider/index.mjs");
parcelHelpers.exportAll(_indexMjs40, exports);
var _indexMjs41 = require("./VMain/index.mjs");
parcelHelpers.exportAll(_indexMjs41, exports);
var _indexMjs42 = require("./VMenu/index.mjs");
parcelHelpers.exportAll(_indexMjs42, exports);
var _indexMjs43 = require("./VMessages/index.mjs");
parcelHelpers.exportAll(_indexMjs43, exports);
var _indexMjs44 = require("./VNavigationDrawer/index.mjs");
parcelHelpers.exportAll(_indexMjs44, exports);
var _indexMjs45 = require("./VNoSsr/index.mjs"); // export * from './VOtpInput'
parcelHelpers.exportAll(_indexMjs45, exports);
// export * from './VOverflowBtn'
var _indexMjs46 = require("./VOverlay/index.mjs");
parcelHelpers.exportAll(_indexMjs46, exports);
var _indexMjs47 = require("./VPagination/index.mjs");
parcelHelpers.exportAll(_indexMjs47, exports);
var _indexMjs48 = require("./VParallax/index.mjs");
parcelHelpers.exportAll(_indexMjs48, exports);
var _indexMjs49 = require("./VProgressCircular/index.mjs");
parcelHelpers.exportAll(_indexMjs49, exports);
var _indexMjs50 = require("./VProgressLinear/index.mjs");
parcelHelpers.exportAll(_indexMjs50, exports);
var _indexMjs51 = require("./VRadio/index.mjs");
parcelHelpers.exportAll(_indexMjs51, exports);
var _indexMjs52 = require("./VRadioGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs52, exports);
var _indexMjs53 = require("./VRangeSlider/index.mjs");
parcelHelpers.exportAll(_indexMjs53, exports);
var _indexMjs54 = require("./VRating/index.mjs");
parcelHelpers.exportAll(_indexMjs54, exports);
var _indexMjs55 = require("./VResponsive/index.mjs");
parcelHelpers.exportAll(_indexMjs55, exports);
var _indexMjs56 = require("./VSelect/index.mjs");
parcelHelpers.exportAll(_indexMjs56, exports);
var _indexMjs57 = require("./VSelectionControl/index.mjs");
parcelHelpers.exportAll(_indexMjs57, exports);
var _indexMjs58 = require("./VSelectionControlGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs58, exports);
var _indexMjs59 = require("./VSheet/index.mjs"); // export * from './VSkeletonLoader'
parcelHelpers.exportAll(_indexMjs59, exports);
var _indexMjs60 = require("./VSlideGroup/index.mjs");
parcelHelpers.exportAll(_indexMjs60, exports);
var _indexMjs61 = require("./VSlider/index.mjs");
parcelHelpers.exportAll(_indexMjs61, exports);
var _indexMjs62 = require("./VSnackbar/index.mjs"); // export * from './VSparkline'
parcelHelpers.exportAll(_indexMjs62, exports);
// export * from './VSpeedDial'
// export * from './VStepper'
var _indexMjs63 = require("./VSwitch/index.mjs");
parcelHelpers.exportAll(_indexMjs63, exports);
var _indexMjs64 = require("./VSystemBar/index.mjs");
parcelHelpers.exportAll(_indexMjs64, exports);
var _indexMjs65 = require("./VTabs/index.mjs");
parcelHelpers.exportAll(_indexMjs65, exports);
var _indexMjs66 = require("./VTable/index.mjs");
parcelHelpers.exportAll(_indexMjs66, exports);
var _indexMjs67 = require("./VTextarea/index.mjs");
parcelHelpers.exportAll(_indexMjs67, exports);
var _indexMjs68 = require("./VTextField/index.mjs");
parcelHelpers.exportAll(_indexMjs68, exports);
var _indexMjs69 = require("./VThemeProvider/index.mjs");
parcelHelpers.exportAll(_indexMjs69, exports);
var _indexMjs70 = require("./VTimeline/index.mjs"); // export * from './VTimePicker'
parcelHelpers.exportAll(_indexMjs70, exports);
var _indexMjs71 = require("./VToolbar/index.mjs");
parcelHelpers.exportAll(_indexMjs71, exports);
var _indexMjs72 = require("./VTooltip/index.mjs"); // export * from './VTreeview'
parcelHelpers.exportAll(_indexMjs72, exports);
var _indexMjs73 = require("./VValidation/index.mjs");
parcelHelpers.exportAll(_indexMjs73, exports);
var _indexMjs74 = require("./VVirtualScroll/index.mjs");
parcelHelpers.exportAll(_indexMjs74, exports);
var _indexMjs75 = require("./VWindow/index.mjs");
parcelHelpers.exportAll(_indexMjs75, exports);
var _indexMjs76 = require("./transitions/index.mjs");
parcelHelpers.exportAll(_indexMjs76, exports);

},{"./VApp/index.mjs":"iI8Zj","./VAppBar/index.mjs":"dMiSX","./VAlert/index.mjs":"bKic8","./VAutocomplete/index.mjs":"abO3K","./VAvatar/index.mjs":"1cQMc","./VBadge/index.mjs":"j3ZWY","./VBanner/index.mjs":"7MGbd","./VBottomNavigation/index.mjs":"4eVMk","./VBreadcrumbs/index.mjs":"1kxW3","./VBtn/index.mjs":"7xV1x","./VBtnGroup/index.mjs":"hwVCz","./VBtnToggle/index.mjs":"6czdk","./VCard/index.mjs":"jpFL2","./VCarousel/index.mjs":"04oa5","./VCheckbox/index.mjs":"2g3Bq","./VChip/index.mjs":"9w6oh","./VChipGroup/index.mjs":"8Mo8M","./VCode/index.mjs":"8vejh","./VColorPicker/index.mjs":"cxXRF","./VCombobox/index.mjs":"5cy5y","./VCounter/index.mjs":"fn25z","./VDefaultsProvider/index.mjs":"1OIgj","./VDialog/index.mjs":"jqeGZ","./VDivider/index.mjs":"ajcaZ","./VExpansionPanel/index.mjs":"JN3Sr","./VField/index.mjs":"b1DV7","./VFileInput/index.mjs":"cxUZw","./VFooter/index.mjs":"kJKqg","./VForm/index.mjs":"leMHZ","./VGrid/index.mjs":"8lAfd","./VHover/index.mjs":"7iKVm","./VIcon/index.mjs":"2wJue","./VImg/index.mjs":"87IoX","./VInput/index.mjs":"gMYJL","./VItemGroup/index.mjs":"5ohEj","./VKbd/index.mjs":"4tlLn","./VLabel/index.mjs":"cclAn","./VLayout/index.mjs":"dUgae","./VLazy/index.mjs":"caroX","./VList/index.mjs":"1md2l","./VLocaleProvider/index.mjs":"eqswv","./VMain/index.mjs":"fLV4C","./VMenu/index.mjs":"fYY6u","./VMessages/index.mjs":"acqI7","./VNavigationDrawer/index.mjs":"dC6sN","./VNoSsr/index.mjs":"fH3GW","./VOverlay/index.mjs":"28W37","./VPagination/index.mjs":"l82dR","./VParallax/index.mjs":"lFFWx","./VProgressCircular/index.mjs":"2azsA","./VProgressLinear/index.mjs":"g9djC","./VRadio/index.mjs":"eeYly","./VRadioGroup/index.mjs":"cgoyM","./VRangeSlider/index.mjs":"3DspP","./VRating/index.mjs":"aoL48","./VResponsive/index.mjs":"kOixX","./VSelect/index.mjs":"jMuFA","./VSelectionControl/index.mjs":"e5hfd","./VSelectionControlGroup/index.mjs":"aTTRm","./VSheet/index.mjs":"4Lo8P","./VSlideGroup/index.mjs":"5SDTw","./VSlider/index.mjs":"bQcEZ","./VSnackbar/index.mjs":"7rs2U","./VSwitch/index.mjs":"RAHVW","./VSystemBar/index.mjs":"4M9Nq","./VTabs/index.mjs":"jisPV","./VTable/index.mjs":"4v7zA","./VTextarea/index.mjs":"d0Cab","./VTextField/index.mjs":"kjCqu","./VThemeProvider/index.mjs":"5D2nH","./VTimeline/index.mjs":"ywN7N","./VToolbar/index.mjs":"8SqYH","./VTooltip/index.mjs":"2hfM9","./VValidation/index.mjs":"43TMr","./VVirtualScroll/index.mjs":"7IUqN","./VWindow/index.mjs":"5nWwd","./transitions/index.mjs":"oiH7Z","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iI8Zj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VApp", ()=>(0, _vappMjs.VApp));
var _vappMjs = require("./VApp.mjs");

},{"./VApp.mjs":"3nUH8","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3nUH8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAppProps", ()=>makeVAppProps);
parcelHelpers.export(exports, "VApp", ()=>VApp);
var _vue = require("vue");
// Styles
var _vappCss = require("./VApp.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVAppProps = (0, _indexMjs.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _layoutMjs.makeLayoutProps)({
        fullHeight: true
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VApp");
const VApp = (0, _indexMjs.genericComponent)()({
    name: "VApp",
    props: makeVAppProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const theme = (0, _themeMjs.provideTheme)(props);
        const { layoutClasses, layoutStyles, getLayoutItem, items, layoutRef } = (0, _layoutMjs.createLayout)(props);
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "ref": layoutRef,
                "class": [
                    "v-application",
                    theme.themeClasses.value,
                    layoutClasses.value,
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    layoutStyles.value,
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", {
                    "class": "v-application__wrap"
                }, [
                    slots.default?.()
                ])
            ]));
        return {
            getLayoutItem,
            items,
            theme
        };
    }
});

},{"vue":"ff77s","./VApp.css":"3euGS","../../composables/component.mjs":"jVHld","../../composables/layout.mjs":"fPMsf","../../composables/locale.mjs":"4MZbL","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3euGS":[function() {},{}],"dMiSX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAppBar", ()=>(0, _vappBarMjs.VAppBar));
parcelHelpers.export(exports, "VAppBarNavIcon", ()=>(0, _vappBarNavIconMjs.VAppBarNavIcon));
parcelHelpers.export(exports, "VAppBarTitle", ()=>(0, _vappBarTitleMjs.VAppBarTitle));
var _vappBarMjs = require("./VAppBar.mjs");
var _vappBarNavIconMjs = require("./VAppBarNavIcon.mjs");
var _vappBarTitleMjs = require("./VAppBarTitle.mjs");

},{"./VAppBar.mjs":"VNtQQ","./VAppBarNavIcon.mjs":"86tBG","./VAppBarTitle.mjs":"7QLyL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"VNtQQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAppBarProps", ()=>makeVAppBarProps);
parcelHelpers.export(exports, "VAppBar", ()=>VAppBar);
var _vue = require("vue");
// Styles
var _vappBarCss = require("./VAppBar.css");
// Components
var _vtoolbarMjs = require("../VToolbar/VToolbar.mjs"); // Composables
var _layoutMjs = require("../../composables/layout.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _scrollMjs = require("../../composables/scroll.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _toggleScopeMjs = require("../../composables/toggleScope.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVAppBarProps = (0, _indexMjs.propsFactory)({
    scrollBehavior: String,
    modelValue: {
        type: Boolean,
        default: true
    },
    location: {
        type: String,
        default: "top",
        validator: (value)=>[
                "top",
                "bottom"
            ].includes(value)
    },
    ...(0, _vtoolbarMjs.makeVToolbarProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)(),
    ...(0, _scrollMjs.makeScrollProps)(),
    height: {
        type: [
            Number,
            String
        ],
        default: 64
    }
}, "VAppBar");
const VAppBar = (0, _indexMjs.genericComponent)()({
    name: "VAppBar",
    props: makeVAppBarProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const vToolbarRef = (0, _vue.ref)();
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const scrollBehavior = (0, _vue.computed)(()=>{
            const behavior = new Set(props.scrollBehavior?.split(" ") ?? []);
            return {
                hide: behavior.has("hide"),
                // fullyHide: behavior.has('fully-hide'),
                inverted: behavior.has("inverted"),
                collapse: behavior.has("collapse"),
                elevate: behavior.has("elevate"),
                fadeImage: behavior.has("fade-image")
            };
        });
        const canScroll = (0, _vue.computed)(()=>{
            const behavior = scrollBehavior.value;
            return behavior.hide || // behavior.fullyHide ||
            behavior.inverted || behavior.collapse || behavior.elevate || behavior.fadeImage || // behavior.shrink ||
            !isActive.value;
        });
        const { currentScroll, scrollThreshold, isScrollingUp, scrollRatio } = (0, _scrollMjs.useScroll)(props, {
            canScroll
        });
        const isCollapsed = (0, _vue.computed)(()=>props.collapse || scrollBehavior.value.collapse && (scrollBehavior.value.inverted ? scrollRatio.value > 0 : scrollRatio.value === 0));
        const isFlat = (0, _vue.computed)(()=>props.flat || scrollBehavior.value.elevate && (scrollBehavior.value.inverted ? currentScroll.value > 0 : currentScroll.value === 0));
        const opacity = (0, _vue.computed)(()=>scrollBehavior.value.fadeImage ? scrollBehavior.value.inverted ? 1 - scrollRatio.value : scrollRatio.value : undefined);
        const height = (0, _vue.computed)(()=>{
            if (scrollBehavior.value.hide && scrollBehavior.value.inverted) return 0;
            const height = vToolbarRef.value?.contentHeight ?? 0;
            const extensionHeight = vToolbarRef.value?.extensionHeight ?? 0;
            return height + extensionHeight;
        });
        (0, _toggleScopeMjs.useToggleScope)((0, _vue.computed)(()=>!!props.scrollBehavior), ()=>{
            (0, _vue.watchEffect)(()=>{
                if (scrollBehavior.value.hide) {
                    if (scrollBehavior.value.inverted) isActive.value = currentScroll.value > scrollThreshold.value;
                    else isActive.value = isScrollingUp.value || currentScroll.value < scrollThreshold.value;
                } else isActive.value = true;
            });
        });
        const { ssrBootStyles } = (0, _ssrBootMjs.useSsrBoot)();
        const { layoutItemStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: (0, _vue.toRef)(props, "location"),
            layoutSize: height,
            elementSize: (0, _vue.shallowRef)(undefined),
            active: isActive,
            absolute: (0, _vue.toRef)(props, "absolute")
        });
        (0, _indexMjs.useRender)(()=>{
            const [toolbarProps] = (0, _vtoolbarMjs.VToolbar).filterProps(props);
            return (0, _vue.createVNode)((0, _vtoolbarMjs.VToolbar), (0, _vue.mergeProps)({
                "ref": vToolbarRef,
                "class": [
                    "v-app-bar",
                    {
                        "v-app-bar--bottom": props.location === "bottom"
                    },
                    props.class
                ],
                "style": [
                    {
                        ...layoutItemStyles.value,
                        "--v-toolbar-image-opacity": opacity.value,
                        height: undefined,
                        ...ssrBootStyles.value
                    },
                    props.style
                ]
            }, toolbarProps, {
                "collapse": isCollapsed.value,
                "flat": isFlat.value
            }), slots);
        });
        return {};
    }
});

},{"vue":"ff77s","./VAppBar.css":"2MDbH","../VToolbar/VToolbar.mjs":"wCdRX","../../composables/layout.mjs":"fPMsf","../../composables/proxiedModel.mjs":"bUF28","../../composables/scroll.mjs":"8ynzG","../../composables/ssrBoot.mjs":"b8ivf","../../composables/toggleScope.mjs":"cE29O","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2MDbH":[function() {},{}],"wCdRX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVToolbarProps", ()=>makeVToolbarProps);
parcelHelpers.export(exports, "VToolbar", ()=>VToolbar);
var _vue = require("vue");
// Styles
var _vtoolbarCss = require("./VToolbar.css");
// Components
var _vtoolbarTitleMjs = require("./VToolbarTitle.mjs");
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VImg/index.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const allowedDensities = [
    null,
    "prominent",
    "default",
    "comfortable",
    "compact"
];
const makeVToolbarProps = (0, _indexMjs3.propsFactory)({
    absolute: Boolean,
    collapse: Boolean,
    color: String,
    density: {
        type: String,
        default: "default",
        validator: (v)=>allowedDensities.includes(v)
    },
    extended: Boolean,
    extensionHeight: {
        type: [
            Number,
            String
        ],
        default: 48
    },
    flat: Boolean,
    floating: Boolean,
    height: {
        type: [
            Number,
            String
        ],
        default: 64
    },
    image: String,
    title: String,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "header"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VToolbar");
const VToolbar = (0, _indexMjs3.genericComponent)()({
    name: "VToolbar",
    props: makeVToolbarProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        const isExtended = (0, _vue.shallowRef)(!!(props.extended || slots.extension?.()));
        const contentHeight = (0, _vue.computed)(()=>parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
        const extensionHeight = (0, _vue.computed)(()=>isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                variant: "text"
            }
        });
        (0, _indexMjs3.useRender)(()=>{
            const hasTitle = !!(props.title || slots.title);
            const hasImage = !!(slots.image || props.image);
            const extension = slots.extension?.();
            isExtended.value = !!(props.extended || extension);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-toolbar",
                    {
                        "v-toolbar--absolute": props.absolute,
                        "v-toolbar--collapse": props.collapse,
                        "v-toolbar--flat": props.flat,
                        "v-toolbar--floating": props.floating,
                        [`v-toolbar--density-${props.density}`]: true
                    },
                    backgroundColorClasses.value,
                    borderClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    themeClasses.value,
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        hasImage && (0, _vue.createVNode)("div", {
                            "key": "image",
                            "class": "v-toolbar__image"
                        }, [
                            !slots.image ? (0, _vue.createVNode)((0, _indexMjs2.VImg), {
                                "key": "image-img",
                                "cover": true,
                                "src": props.image
                            }, null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "image-defaults",
                                "disabled": !props.image,
                                "defaults": {
                                    VImg: {
                                        cover: true,
                                        src: props.image
                                    }
                                }
                            }, slots.image)
                        ]),
                        (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                            "defaults": {
                                VTabs: {
                                    height: (0, _indexMjs3.convertToUnit)(contentHeight.value)
                                }
                            }
                        }, {
                            default: ()=>[
                                    (0, _vue.createVNode)("div", {
                                        "class": "v-toolbar__content",
                                        "style": {
                                            height: (0, _indexMjs3.convertToUnit)(contentHeight.value)
                                        }
                                    }, [
                                        slots.prepend && (0, _vue.createVNode)("div", {
                                            "class": "v-toolbar__prepend"
                                        }, [
                                            slots.prepend?.()
                                        ]),
                                        hasTitle && (0, _vue.createVNode)((0, _vtoolbarTitleMjs.VToolbarTitle), {
                                            "key": "title",
                                            "text": props.title
                                        }, {
                                            text: slots.title
                                        }),
                                        slots.default?.(),
                                        slots.append && (0, _vue.createVNode)("div", {
                                            "class": "v-toolbar__append"
                                        }, [
                                            slots.append?.()
                                        ])
                                    ])
                                ]
                        }),
                        (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                            "defaults": {
                                VTabs: {
                                    height: (0, _indexMjs3.convertToUnit)(extensionHeight.value)
                                }
                            }
                        }, {
                            default: ()=>[
                                    (0, _vue.createVNode)((0, _indexMjs.VExpandTransition), null, {
                                        default: ()=>[
                                                isExtended.value && (0, _vue.createVNode)("div", {
                                                    "class": "v-toolbar__extension",
                                                    "style": {
                                                        height: (0, _indexMjs3.convertToUnit)(extensionHeight.value)
                                                    }
                                                }, [
                                                    extension
                                                ])
                                            ]
                                    })
                                ]
                        })
                    ]
            });
        });
        return {
            contentHeight,
            extensionHeight
        };
    }
});

},{"vue":"ff77s","./VToolbar.css":"bB8eH","./VToolbarTitle.mjs":"i8vFv","../transitions/index.mjs":"oiH7Z","../VDefaultsProvider/index.mjs":"1OIgj","../VImg/index.mjs":"87IoX","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/elevation.mjs":"3BDEa","../../composables/locale.mjs":"4MZbL","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bB8eH":[function() {},{}],"i8vFv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVToolbarTitleProps", ()=>makeVToolbarTitleProps);
parcelHelpers.export(exports, "VToolbarTitle", ()=>VToolbarTitle);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVToolbarTitleProps = (0, _indexMjs.propsFactory)({
    text: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VToolbarTitle");
const VToolbarTitle = (0, _indexMjs.genericComponent)()({
    name: "VToolbarTitle",
    props: makeVToolbarTitleProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>{
            const hasText = !!(slots.default || slots.text || props.text);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-toolbar-title",
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        hasText && (0, _vue.createVNode)("div", {
                            "class": "v-toolbar-title__placeholder"
                        }, [
                            slots.text ? slots.text() : props.text,
                            slots.default?.()
                        ])
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3KkML":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeTagProps", ()=>makeTagProps);
var _indexMjs = require("../util/index.mjs"); // Types
const makeTagProps = (0, _indexMjs.propsFactory)({
    tag: {
        type: String,
        default: "div"
    }
}, "tag");

},{"../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"oiH7Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VDialogTransition", ()=>(0, _dialogTransitionMjs.VDialogTransition));
parcelHelpers.export(exports, "VFabTransition", ()=>VFabTransition);
parcelHelpers.export(exports, "VDialogBottomTransition", ()=>VDialogBottomTransition);
parcelHelpers.export(exports, "VDialogTopTransition", ()=>VDialogTopTransition);
parcelHelpers.export(exports, "VFadeTransition", ()=>VFadeTransition);
parcelHelpers.export(exports, "VScaleTransition", ()=>VScaleTransition);
parcelHelpers.export(exports, "VScrollXTransition", ()=>VScrollXTransition);
parcelHelpers.export(exports, "VScrollXReverseTransition", ()=>VScrollXReverseTransition);
parcelHelpers.export(exports, "VScrollYTransition", ()=>VScrollYTransition);
parcelHelpers.export(exports, "VScrollYReverseTransition", ()=>VScrollYReverseTransition);
parcelHelpers.export(exports, "VSlideXTransition", ()=>VSlideXTransition);
parcelHelpers.export(exports, "VSlideXReverseTransition", ()=>VSlideXReverseTransition);
parcelHelpers.export(exports, "VSlideYTransition", ()=>VSlideYTransition);
parcelHelpers.export(exports, "VSlideYReverseTransition", ()=>VSlideYReverseTransition);
parcelHelpers.export(exports, "VExpandTransition", ()=>VExpandTransition);
parcelHelpers.export(exports, "VExpandXTransition", ()=>VExpandXTransition);
var _createTransitionMjs = require("./createTransition.mjs");
var _expandTransitionMjs = require("./expand-transition.mjs"); // Component specific transitions
var _expandTransitionMjsDefault = parcelHelpers.interopDefault(_expandTransitionMjs);
var _dialogTransitionMjs = require("./dialog-transition.mjs");
const VFabTransition = (0, _createTransitionMjs.createCssTransition)("fab-transition", "center center", "out-in");
const VDialogBottomTransition = (0, _createTransitionMjs.createCssTransition)("dialog-bottom-transition");
const VDialogTopTransition = (0, _createTransitionMjs.createCssTransition)("dialog-top-transition");
const VFadeTransition = (0, _createTransitionMjs.createCssTransition)("fade-transition");
const VScaleTransition = (0, _createTransitionMjs.createCssTransition)("scale-transition");
const VScrollXTransition = (0, _createTransitionMjs.createCssTransition)("scroll-x-transition");
const VScrollXReverseTransition = (0, _createTransitionMjs.createCssTransition)("scroll-x-reverse-transition");
const VScrollYTransition = (0, _createTransitionMjs.createCssTransition)("scroll-y-transition");
const VScrollYReverseTransition = (0, _createTransitionMjs.createCssTransition)("scroll-y-reverse-transition");
const VSlideXTransition = (0, _createTransitionMjs.createCssTransition)("slide-x-transition");
const VSlideXReverseTransition = (0, _createTransitionMjs.createCssTransition)("slide-x-reverse-transition");
const VSlideYTransition = (0, _createTransitionMjs.createCssTransition)("slide-y-transition");
const VSlideYReverseTransition = (0, _createTransitionMjs.createCssTransition)("slide-y-reverse-transition");
const VExpandTransition = (0, _createTransitionMjs.createJavascriptTransition)("expand-transition", (0, _expandTransitionMjsDefault.default)());
const VExpandXTransition = (0, _createTransitionMjs.createJavascriptTransition)("expand-x-transition", (0, _expandTransitionMjsDefault.default)("", true));

},{"./createTransition.mjs":"14VxC","./expand-transition.mjs":"3MXs5","./dialog-transition.mjs":"eorv2","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"14VxC":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeTransitionProps", ()=>makeTransitionProps);
parcelHelpers.export(exports, "createCssTransition", ()=>createCssTransition);
parcelHelpers.export(exports, "createJavascriptTransition", ()=>createJavascriptTransition);
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const makeTransitionProps = (0, _indexMjs.propsFactory)({
    disabled: Boolean,
    group: Boolean,
    hideOnLeave: Boolean,
    leaveAbsolute: Boolean,
    mode: String,
    origin: String
}, "transition");
function createCssTransition(name, origin, mode) {
    return (0, _indexMjs.genericComponent)()({
        name,
        props: makeTransitionProps({
            mode,
            origin
        }),
        setup (props, _ref) {
            let { slots } = _ref;
            const functions = {
                onBeforeEnter (el) {
                    if (props.origin) el.style.transformOrigin = props.origin;
                },
                onLeave (el) {
                    if (props.leaveAbsolute) {
                        const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = el;
                        el._transitionInitialStyles = {
                            position: el.style.position,
                            top: el.style.top,
                            left: el.style.left,
                            width: el.style.width,
                            height: el.style.height
                        };
                        el.style.position = "absolute";
                        el.style.top = `${offsetTop}px`;
                        el.style.left = `${offsetLeft}px`;
                        el.style.width = `${offsetWidth}px`;
                        el.style.height = `${offsetHeight}px`;
                    }
                    if (props.hideOnLeave) el.style.setProperty("display", "none", "important");
                },
                onAfterLeave (el) {
                    if (props.leaveAbsolute && el?._transitionInitialStyles) {
                        const { position, top, left, width, height } = el._transitionInitialStyles;
                        delete el._transitionInitialStyles;
                        el.style.position = position || "";
                        el.style.top = top || "";
                        el.style.left = left || "";
                        el.style.width = width || "";
                        el.style.height = height || "";
                    }
                }
            };
            return ()=>{
                const tag = props.group ? (0, _vue.TransitionGroup) : (0, _vue.Transition);
                return (0, _vue.h)(tag, {
                    name: props.disabled ? "" : name,
                    css: !props.disabled,
                    ...props.group ? undefined : {
                        mode: props.mode
                    },
                    ...props.disabled ? {} : functions
                }, slots.default);
            };
        }
    });
}
function createJavascriptTransition(name, functions) {
    let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "in-out";
    return (0, _indexMjs.genericComponent)()({
        name,
        props: {
            mode: {
                type: String,
                default: mode
            },
            disabled: Boolean
        },
        setup (props, _ref2) {
            let { slots } = _ref2;
            return ()=>{
                return (0, _vue.h)((0, _vue.Transition), {
                    name: props.disabled ? "" : name,
                    css: !props.disabled,
                    // mode: props.mode, // TODO: vuejs/vue-next#3104
                    ...props.disabled ? {} : functions
                }, slots.default);
            };
        }
    });
}

},{"vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3MXs5":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function() {
        let expandedParentClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        const sizeProperty = x ? "width" : "height";
        const offsetProperty = (0, _vue.camelize)(`offset-${sizeProperty}`);
        return {
            onBeforeEnter (el) {
                el._parent = el.parentNode;
                el._initialStyle = {
                    transition: el.style.transition,
                    overflow: el.style.overflow,
                    [sizeProperty]: el.style[sizeProperty]
                };
            },
            onEnter (el) {
                const initialStyle = el._initialStyle;
                el.style.setProperty("transition", "none", "important");
                // Hide overflow to account for collapsed margins in the calculated height
                el.style.overflow = "hidden";
                const offset = `${el[offsetProperty]}px`;
                el.style[sizeProperty] = "0";
                el.offsetHeight; // force reflow
                el.style.transition = initialStyle.transition;
                if (expandedParentClass && el._parent) el._parent.classList.add(expandedParentClass);
                requestAnimationFrame(()=>{
                    el.style[sizeProperty] = offset;
                });
            },
            onAfterEnter: resetStyles,
            onEnterCancelled: resetStyles,
            onLeave (el) {
                el._initialStyle = {
                    transition: "",
                    overflow: el.style.overflow,
                    [sizeProperty]: el.style[sizeProperty]
                };
                el.style.overflow = "hidden";
                el.style[sizeProperty] = `${el[offsetProperty]}px`;
                el.offsetHeight; // force reflow
                requestAnimationFrame(()=>el.style[sizeProperty] = "0");
            },
            onAfterLeave,
            onLeaveCancelled: onAfterLeave
        };
        function onAfterLeave(el) {
            if (expandedParentClass && el._parent) el._parent.classList.remove(expandedParentClass);
            resetStyles(el);
        }
        function resetStyles(el) {
            const size = el._initialStyle[sizeProperty];
            el.style.overflow = el._initialStyle.overflow;
            if (size != null) el.style[sizeProperty] = size;
            delete el._initialStyle;
        }
    });
var _vue = require("vue");

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eorv2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVDialogTransitionProps", ()=>makeVDialogTransitionProps);
parcelHelpers.export(exports, "VDialogTransition", ()=>VDialogTransition);
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVDialogTransitionProps = (0, _indexMjs.propsFactory)({
    target: Object
}, "v-dialog-transition");
const VDialogTransition = (0, _indexMjs.genericComponent)()({
    name: "VDialogTransition",
    props: makeVDialogTransitionProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const functions = {
            onBeforeEnter (el) {
                el.style.pointerEvents = "none";
                el.style.visibility = "hidden";
            },
            async onEnter (el, done) {
                await new Promise((resolve)=>requestAnimationFrame(resolve));
                await new Promise((resolve)=>requestAnimationFrame(resolve));
                el.style.visibility = "";
                const { x, y, sx, sy, speed } = getDimensions(props.target, el);
                const animation = (0, _indexMjs.animate)(el, [
                    {
                        transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
                        opacity: 0
                    },
                    {}
                ], {
                    duration: 225 * speed,
                    easing: (0, _indexMjs.deceleratedEasing)
                });
                getChildren(el)?.forEach((el)=>{
                    (0, _indexMjs.animate)(el, [
                        {
                            opacity: 0
                        },
                        {
                            opacity: 0,
                            offset: 0.33
                        },
                        {}
                    ], {
                        duration: 450 * speed,
                        easing: (0, _indexMjs.standardEasing)
                    });
                });
                animation.finished.then(()=>done());
            },
            onAfterEnter (el) {
                el.style.removeProperty("pointer-events");
            },
            onBeforeLeave (el) {
                el.style.pointerEvents = "none";
            },
            async onLeave (el, done) {
                await new Promise((resolve)=>requestAnimationFrame(resolve));
                const { x, y, sx, sy, speed } = getDimensions(props.target, el);
                const animation = (0, _indexMjs.animate)(el, [
                    {},
                    {
                        transform: `translate(${x}px, ${y}px) scale(${sx}, ${sy})`,
                        opacity: 0
                    }
                ], {
                    duration: 125 * speed,
                    easing: (0, _indexMjs.acceleratedEasing)
                });
                animation.finished.then(()=>done());
                getChildren(el)?.forEach((el)=>{
                    (0, _indexMjs.animate)(el, [
                        {},
                        {
                            opacity: 0,
                            offset: 0.2
                        },
                        {
                            opacity: 0
                        }
                    ], {
                        duration: 250 * speed,
                        easing: (0, _indexMjs.standardEasing)
                    });
                });
            },
            onAfterLeave (el) {
                el.style.removeProperty("pointer-events");
            }
        };
        return ()=>{
            return props.target ? (0, _vue.createVNode)((0, _vue.Transition), (0, _vue.mergeProps)({
                "name": "dialog-transition"
            }, functions, {
                "css": false
            }), slots) : (0, _vue.createVNode)((0, _vue.Transition), {
                "name": "dialog-transition"
            }, slots);
        };
    }
});
/** Animatable children (card, sheet, list) */ function getChildren(el) {
    const els = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")?.children;
    return els && [
        ...els
    ];
}
function getDimensions(target, el) {
    const targetBox = target.getBoundingClientRect();
    const elBox = (0, _indexMjs.nullifyTransforms)(el);
    const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v)=>parseFloat(v));
    const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
    let offsetX = targetBox.left + targetBox.width / 2;
    if (anchorSide === "left" || anchorOffset === "left") offsetX -= targetBox.width / 2;
    else if (anchorSide === "right" || anchorOffset === "right") offsetX += targetBox.width / 2;
    let offsetY = targetBox.top + targetBox.height / 2;
    if (anchorSide === "top" || anchorOffset === "top") offsetY -= targetBox.height / 2;
    else if (anchorSide === "bottom" || anchorOffset === "bottom") offsetY += targetBox.height / 2;
    const tsx = targetBox.width / elBox.width;
    const tsy = targetBox.height / elBox.height;
    const maxs = Math.max(1, tsx, tsy);
    const sx = tsx / maxs || 0;
    const sy = tsy / maxs || 0;
    // Animate elements larger than 12% of the screen area up to 1.5x slower
    const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
    const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
    return {
        x: offsetX - (originX + elBox.left),
        y: offsetY - (originY + elBox.top),
        sx,
        sy,
        speed
    };
}

},{"vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1OIgj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VDefaultsProvider", ()=>(0, _vdefaultsProviderMjs.VDefaultsProvider));
var _vdefaultsProviderMjs = require("./VDefaultsProvider.mjs");

},{"./VDefaultsProvider.mjs":"7jbqA","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7jbqA":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVDefaultsProviderProps", ()=>makeVDefaultsProviderProps);
parcelHelpers.export(exports, "VDefaultsProvider", ()=>VDefaultsProvider);
var _defaultsMjs = require("../../composables/defaults.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVDefaultsProviderProps = (0, _indexMjs.propsFactory)({
    defaults: Object,
    disabled: Boolean,
    reset: [
        Number,
        String
    ],
    root: [
        Boolean,
        String
    ],
    scoped: Boolean
}, "VDefaultsProvider");
const VDefaultsProvider = (0, _indexMjs.genericComponent)(false)({
    name: "VDefaultsProvider",
    props: makeVDefaultsProviderProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { defaults, disabled, reset, root, scoped } = (0, _vue.toRefs)(props);
        (0, _defaultsMjs.provideDefaults)(defaults, {
            reset,
            root,
            scoped,
            disabled
        });
        return ()=>slots.default?.();
    }
});

},{"../../composables/defaults.mjs":"11B6w","vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"87IoX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VImg", ()=>(0, _vimgMjs.VImg));
var _vimgMjs = require("./VImg.mjs");

},{"./VImg.mjs":"hdpTE","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hdpTE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVImgProps", ()=>makeVImgProps);
parcelHelpers.export(exports, "VImg", ()=>VImg);
var _vue = require("vue");
// Styles
var _vimgCss = require("./VImg.css");
// Components
var _vresponsiveMjs = require("../VResponsive/VResponsive.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Directives
var _indexMjs = require("../../directives/intersect/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVImgProps = (0, _indexMjs1.propsFactory)({
    alt: String,
    cover: Boolean,
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
        type: Object,
        // For more information on types, navigate to:
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        default: ()=>({
                root: undefined,
                rootMargin: undefined,
                threshold: undefined
            })
    },
    sizes: String,
    src: {
        type: [
            String,
            Object
        ],
        default: ""
    },
    srcset: String,
    ...(0, _vresponsiveMjs.makeVResponsiveProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _transitionMjs.makeTransitionProps)()
}, "VImg");
const VImg = (0, _indexMjs1.genericComponent)()({
    name: "VImg",
    directives: {
        intersect: (0, _indexMjsDefault.default)
    },
    props: makeVImgProps(),
    emits: {
        loadstart: (value)=>true,
        load: (value)=>true,
        error: (value)=>true
    },
    setup (props, _ref) {
        let { emit, slots } = _ref;
        const currentSrc = (0, _vue.shallowRef)(""); // Set from srcset
        const image = (0, _vue.ref)();
        const state = (0, _vue.shallowRef)(props.eager ? "loading" : "idle");
        const naturalWidth = (0, _vue.shallowRef)();
        const naturalHeight = (0, _vue.shallowRef)();
        const normalisedSrc = (0, _vue.computed)(()=>{
            return props.src && typeof props.src === "object" ? {
                src: props.src.src,
                srcset: props.srcset || props.src.srcset,
                lazySrc: props.lazySrc || props.src.lazySrc,
                aspect: Number(props.aspectRatio || props.src.aspect || 0)
            } : {
                src: props.src,
                srcset: props.srcset,
                lazySrc: props.lazySrc,
                aspect: Number(props.aspectRatio || 0)
            };
        });
        const aspectRatio = (0, _vue.computed)(()=>{
            return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
        });
        (0, _vue.watch)(()=>props.src, ()=>{
            init(state.value !== "idle");
        });
        (0, _vue.watch)(aspectRatio, (val, oldVal)=>{
            if (!val && oldVal && image.value) pollForSize(image.value);
        });
        // TODO: getSrc when window width changes
        (0, _vue.onBeforeMount)(()=>init());
        function init(isIntersecting) {
            if (props.eager && isIntersecting) return;
            if ((0, _indexMjs1.SUPPORTS_INTERSECTION) && !isIntersecting && !props.eager) return;
            state.value = "loading";
            if (normalisedSrc.value.lazySrc) {
                const lazyImg = new Image();
                lazyImg.src = normalisedSrc.value.lazySrc;
                pollForSize(lazyImg, null);
            }
            if (!normalisedSrc.value.src) return;
            (0, _vue.nextTick)(()=>{
                emit("loadstart", image.value?.currentSrc || normalisedSrc.value.src);
                if (image.value?.complete) {
                    if (!image.value.naturalWidth) onError();
                    if (state.value === "error") return;
                    if (!aspectRatio.value) pollForSize(image.value, null);
                    onLoad();
                } else {
                    if (!aspectRatio.value) pollForSize(image.value);
                    getSrc();
                }
            });
        }
        function onLoad() {
            getSrc();
            state.value = "loaded";
            emit("load", image.value?.currentSrc || normalisedSrc.value.src);
        }
        function onError() {
            state.value = "error";
            emit("error", image.value?.currentSrc || normalisedSrc.value.src);
        }
        function getSrc() {
            const img = image.value;
            if (img) currentSrc.value = img.currentSrc || img.src;
        }
        let timer = -1;
        function pollForSize(img) {
            let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
            const poll = ()=>{
                clearTimeout(timer);
                const { naturalHeight: imgHeight, naturalWidth: imgWidth } = img;
                if (imgHeight || imgWidth) {
                    naturalWidth.value = imgWidth;
                    naturalHeight.value = imgHeight;
                } else if (!img.complete && state.value === "loading" && timeout != null) timer = window.setTimeout(poll, timeout);
                else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
                    naturalWidth.value = 1;
                    naturalHeight.value = 1;
                }
            };
            poll();
        }
        const containClasses = (0, _vue.computed)(()=>({
                "v-img__img--cover": props.cover,
                "v-img__img--contain": !props.cover
            }));
        const __image = ()=>{
            if (!normalisedSrc.value.src || state.value === "idle") return null;
            const img = (0, _vue.createVNode)("img", {
                "class": [
                    "v-img__img",
                    containClasses.value
                ],
                "src": normalisedSrc.value.src,
                "srcset": normalisedSrc.value.srcset,
                "alt": props.alt,
                "sizes": props.sizes,
                "ref": image,
                "onLoad": onLoad,
                "onError": onError
            }, null);
            const sources = slots.sources?.();
            return (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition,
                "appear": true
            }, {
                default: ()=>[
                        (0, _vue.withDirectives)(sources ? (0, _vue.createVNode)("picture", {
                            "class": "v-img__picture"
                        }, [
                            sources,
                            img
                        ]) : img, [
                            [
                                (0, _vue.vShow),
                                state.value === "loaded"
                            ]
                        ])
                    ]
            });
        };
        const __preloadImage = ()=>(0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition
            }, {
                default: ()=>[
                        normalisedSrc.value.lazySrc && state.value !== "loaded" && (0, _vue.createVNode)("img", {
                            "class": [
                                "v-img__img",
                                "v-img__img--preload",
                                containClasses.value
                            ],
                            "src": normalisedSrc.value.lazySrc,
                            "alt": props.alt
                        }, null)
                    ]
            });
        const __placeholder = ()=>{
            if (!slots.placeholder) return null;
            return (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition,
                "appear": true
            }, {
                default: ()=>[
                        (state.value === "loading" || state.value === "error" && !slots.error) && (0, _vue.createVNode)("div", {
                            "class": "v-img__placeholder"
                        }, [
                            slots.placeholder()
                        ])
                    ]
            });
        };
        const __error = ()=>{
            if (!slots.error) return null;
            return (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition,
                "appear": true
            }, {
                default: ()=>[
                        state.value === "error" && (0, _vue.createVNode)("div", {
                            "class": "v-img__error"
                        }, [
                            slots.error()
                        ])
                    ]
            });
        };
        const __gradient = ()=>{
            if (!props.gradient) return null;
            return (0, _vue.createVNode)("div", {
                "class": "v-img__gradient",
                "style": {
                    backgroundImage: `linear-gradient(${props.gradient})`
                }
            }, null);
        };
        const isBooted = (0, _vue.shallowRef)(false);
        {
            const stop = (0, _vue.watch)(aspectRatio, (val)=>{
                if (val) {
                    // Doesn't work with nextTick, idk why
                    requestAnimationFrame(()=>{
                        requestAnimationFrame(()=>{
                            isBooted.value = true;
                        });
                    });
                    stop();
                }
            });
        }
        (0, _indexMjs1.useRender)(()=>{
            const [responsiveProps] = (0, _vresponsiveMjs.VResponsive).filterProps(props);
            return (0, _vue.withDirectives)((0, _vue.createVNode)((0, _vresponsiveMjs.VResponsive), (0, _vue.mergeProps)({
                "class": [
                    "v-img",
                    {
                        "v-img--booting": !isBooted.value
                    },
                    props.class
                ],
                "style": [
                    {
                        width: (0, _indexMjs1.convertToUnit)(props.width === "auto" ? naturalWidth.value : props.width)
                    },
                    props.style
                ]
            }, responsiveProps, {
                "aspectRatio": aspectRatio.value,
                "aria-label": props.alt,
                "role": props.alt ? "img" : undefined
            }), {
                additional: ()=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        (0, _vue.createVNode)(__image, null, null),
                        (0, _vue.createVNode)(__preloadImage, null, null),
                        (0, _vue.createVNode)(__gradient, null, null),
                        (0, _vue.createVNode)(__placeholder, null, null),
                        (0, _vue.createVNode)(__error, null, null)
                    ]),
                default: slots.default
            }), [
                [
                    (0, _vue.resolveDirective)("intersect"),
                    {
                        handler: init,
                        options: props.options
                    },
                    null,
                    {
                        once: true
                    }
                ]
            ]);
        });
        return {
            currentSrc,
            image,
            state,
            naturalWidth,
            naturalHeight
        };
    }
});

},{"vue":"ff77s","./VImg.css":"14KPm","../VResponsive/VResponsive.mjs":"jzmwG","../../composables/component.mjs":"jVHld","../../composables/transition.mjs":"gFVfN","../../directives/intersect/index.mjs":"jD88I","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"14KPm":[function() {},{}],"jzmwG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useAspectStyles", ()=>useAspectStyles);
parcelHelpers.export(exports, "makeVResponsiveProps", ()=>makeVResponsiveProps);
parcelHelpers.export(exports, "VResponsive", ()=>VResponsive);
var _vue = require("vue");
// Styles
var _vresponsiveCss = require("./VResponsive.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
function useAspectStyles(props) {
    return {
        aspectStyles: (0, _vue.computed)(()=>{
            const ratio = Number(props.aspectRatio);
            return ratio ? {
                paddingBottom: String(1 / ratio * 100) + "%"
            } : undefined;
        })
    };
}
const makeVResponsiveProps = (0, _indexMjs.propsFactory)({
    aspectRatio: [
        String,
        Number
    ],
    contentClass: String,
    inline: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)()
}, "VResponsive");
const VResponsive = (0, _indexMjs.genericComponent)()({
    name: "VResponsive",
    props: makeVResponsiveProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { aspectStyles } = useAspectStyles(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-responsive",
                    {
                        "v-responsive--inline": props.inline
                    },
                    props.class
                ],
                "style": [
                    dimensionStyles.value,
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", {
                    "class": "v-responsive__sizer",
                    "style": aspectStyles.value
                }, null),
                slots.additional?.(),
                slots.default && (0, _vue.createVNode)("div", {
                    "class": [
                        "v-responsive__content",
                        props.contentClass
                    ]
                }, [
                    slots.default()
                ])
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VResponsive.css":"kF86D","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kF86D":[function() {},{}],"nAc7s":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeDimensionProps", ()=>makeDimensionProps);
parcelHelpers.export(exports, "useDimension", ()=>useDimension);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeDimensionProps = (0, _indexMjs.propsFactory)({
    height: [
        Number,
        String
    ],
    maxHeight: [
        Number,
        String
    ],
    maxWidth: [
        Number,
        String
    ],
    minHeight: [
        Number,
        String
    ],
    minWidth: [
        Number,
        String
    ],
    width: [
        Number,
        String
    ]
}, "dimension");
function useDimension(props) {
    const dimensionStyles = (0, _vue.computed)(()=>({
            height: (0, _indexMjs.convertToUnit)(props.height),
            maxHeight: (0, _indexMjs.convertToUnit)(props.maxHeight),
            maxWidth: (0, _indexMjs.convertToUnit)(props.maxWidth),
            minHeight: (0, _indexMjs.convertToUnit)(props.minHeight),
            minWidth: (0, _indexMjs.convertToUnit)(props.minWidth),
            width: (0, _indexMjs.convertToUnit)(props.width)
        }));
    return {
        dimensionStyles
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gFVfN":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeTransitionProps", ()=>makeTransitionProps);
parcelHelpers.export(exports, "MaybeTransition", ()=>MaybeTransition);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeTransitionProps = (0, _indexMjs.propsFactory)({
    transition: {
        type: [
            Boolean,
            String,
            Object
        ],
        default: "fade-transition",
        validator: (val)=>val !== true
    }
}, "transition");
const MaybeTransition = (props, _ref)=>{
    let { slots } = _ref;
    const { transition, disabled, ...rest } = props;
    const { component = (0, _vue.Transition), ...customProps } = typeof transition === "object" ? transition : {};
    return (0, _vue.h)(component, (0, _vue.mergeProps)(typeof transition === "string" ? {
        name: disabled ? "" : transition
    } : customProps, rest, {
        disabled
    }), slots);
};

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jD88I":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Intersect", ()=>Intersect);
var _indexMjs = require("../../util/index.mjs"); // Types
function mounted(el, binding) {
    if (!(0, _indexMjs.SUPPORTS_INTERSECTION)) return;
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const { handler, options } = typeof value === "object" ? value : {
        handler: value,
        options: {}
    };
    const observer = new IntersectionObserver(function() {
        let entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        let observer = arguments.length > 1 ? arguments[1] : undefined;
        const _observe = el._observe?.[binding.instance.$.uid];
        if (!_observe) return; // Just in case, should never fire
        const isIntersecting = entries.some((entry)=>entry.isIntersecting);
        // If is not quiet or has already been
        // initted, invoke the user callback
        if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) handler(isIntersecting, entries, observer);
        if (isIntersecting && modifiers.once) unmounted(el, binding);
        else _observe.init = true;
    }, options);
    el._observe = Object(el._observe);
    el._observe[binding.instance.$.uid] = {
        init: false,
        observer
    };
    observer.observe(el);
}
function unmounted(el, binding) {
    const observe = el._observe?.[binding.instance.$.uid];
    if (!observe) return;
    observe.observer.unobserve(el);
    delete el._observe[binding.instance.$.uid];
}
const Intersect = {
    mounted,
    unmounted
};
exports.default = Intersect;

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3nPTz":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeBorderProps", ()=>makeBorderProps);
parcelHelpers.export(exports, "useBorder", ()=>useBorder);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeBorderProps = (0, _indexMjs.propsFactory)({
    border: [
        Boolean,
        Number,
        String
    ]
}, "border");
function useBorder(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const borderClasses = (0, _vue.computed)(()=>{
        const border = (0, _vue.isRef)(props) ? props.value : props.border;
        const classes = [];
        if (border === true || border === "") classes.push(`${name}--border`);
        else if (typeof border === "string" || border === 0) for (const value of String(border).split(" "))classes.push(`border-${value}`);
        return classes;
    });
    return {
        borderClasses
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4pLYX":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Composables
parcelHelpers.export(exports, "useColor", ()=>useColor);
parcelHelpers.export(exports, "useTextColor", ()=>useTextColor);
parcelHelpers.export(exports, "useBackgroundColor", ()=>useBackgroundColor);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
function useColor(colors) {
    return (0, _indexMjs.destructComputed)(()=>{
        const classes = [];
        const styles = {};
        if (colors.value.background) {
            if ((0, _indexMjs.isCssColor)(colors.value.background)) {
                styles.backgroundColor = colors.value.background;
                if (!colors.value.text) {
                    const textColor = (0, _indexMjs.getForeground)(styles.backgroundColor);
                    styles.color = textColor;
                    styles.caretColor = textColor;
                }
            } else classes.push(`bg-${colors.value.background}`);
        }
        if (colors.value.text) {
            if ((0, _indexMjs.isCssColor)(colors.value.text)) {
                styles.color = colors.value.text;
                styles.caretColor = colors.value.text;
            } else classes.push(`text-${colors.value.text}`);
        }
        return {
            colorClasses: classes,
            colorStyles: styles
        };
    });
}
function useTextColor(props, name) {
    const colors = (0, _vue.computed)(()=>({
            text: (0, _vue.isRef)(props) ? props.value : name ? props[name] : null
        }));
    const { colorClasses: textColorClasses, colorStyles: textColorStyles } = useColor(colors);
    return {
        textColorClasses,
        textColorStyles
    };
}
function useBackgroundColor(props, name) {
    const colors = (0, _vue.computed)(()=>({
            background: (0, _vue.isRef)(props) ? props.value : name ? props[name] : null
        }));
    const { colorClasses: backgroundColorClasses, colorStyles: backgroundColorStyles } = useColor(colors);
    return {
        backgroundColorClasses,
        backgroundColorStyles
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3BDEa":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeElevationProps", ()=>makeElevationProps);
parcelHelpers.export(exports, "useElevation", ()=>useElevation);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeElevationProps = (0, _indexMjs.propsFactory)({
    elevation: {
        type: [
            Number,
            String
        ],
        validator (v) {
            const value = parseInt(v);
            return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
            // https://material.io/design/environment/elevation.html#default-elevations
            value <= 24;
        }
    }
}, "elevation");
function useElevation(props) {
    const elevationClasses = (0, _vue.computed)(()=>{
        const elevation = (0, _vue.isRef)(props) ? props.value : props.elevation;
        const classes = [];
        if (elevation == null) return classes;
        classes.push(`elevation-${elevation}`);
        return classes;
    });
    return {
        elevationClasses
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ldhZ9":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeRoundedProps", ()=>makeRoundedProps);
parcelHelpers.export(exports, "useRounded", ()=>useRounded);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeRoundedProps = (0, _indexMjs.propsFactory)({
    rounded: {
        type: [
            Boolean,
            Number,
            String
        ],
        default: undefined
    }
}, "rounded");
function useRounded(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const roundedClasses = (0, _vue.computed)(()=>{
        const rounded = (0, _vue.isRef)(props) ? props.value : props.rounded;
        const classes = [];
        if (rounded === true || rounded === "") classes.push(`${name}--rounded`);
        else if (typeof rounded === "string" || rounded === 0) for (const value of String(rounded).split(" "))classes.push(`rounded-${value}`);
        return classes;
    });
    return {
        roundedClasses
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8ynzG":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeScrollProps", ()=>makeScrollProps);
parcelHelpers.export(exports, "useScroll", ()=>useScroll);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeScrollProps = (0, _indexMjs.propsFactory)({
    scrollTarget: {
        type: String
    },
    scrollThreshold: {
        type: [
            String,
            Number
        ],
        default: 300
    }
}, "scroll");
function useScroll(props) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { canScroll } = args;
    let previousScroll = 0;
    const target = (0, _vue.ref)(null);
    const currentScroll = (0, _vue.shallowRef)(0);
    const savedScroll = (0, _vue.shallowRef)(0);
    const currentThreshold = (0, _vue.shallowRef)(0);
    const isScrollActive = (0, _vue.shallowRef)(false);
    const isScrollingUp = (0, _vue.shallowRef)(false);
    const scrollThreshold = (0, _vue.computed)(()=>{
        return Number(props.scrollThreshold);
    });
    /**
   * 1: at top
   * 0: at threshold
   */ const scrollRatio = (0, _vue.computed)(()=>{
        return (0, _indexMjs.clamp)((scrollThreshold.value - currentScroll.value) / scrollThreshold.value || 0);
    });
    const onScroll = ()=>{
        const targetEl = target.value;
        if (!targetEl || canScroll && !canScroll.value) return;
        previousScroll = currentScroll.value;
        currentScroll.value = "window" in targetEl ? targetEl.pageYOffset : targetEl.scrollTop;
        isScrollingUp.value = currentScroll.value < previousScroll;
        currentThreshold.value = Math.abs(currentScroll.value - scrollThreshold.value);
    };
    (0, _vue.watch)(isScrollingUp, ()=>{
        savedScroll.value = savedScroll.value || currentScroll.value;
    });
    (0, _vue.watch)(isScrollActive, ()=>{
        savedScroll.value = 0;
    });
    (0, _vue.onMounted)(()=>{
        (0, _vue.watch)(()=>props.scrollTarget, (scrollTarget)=>{
            const newTarget = scrollTarget ? document.querySelector(scrollTarget) : window;
            if (!newTarget) {
                (0, _indexMjs.consoleWarn)(`Unable to locate element with identifier ${scrollTarget}`);
                return;
            }
            if (newTarget === target.value) return;
            target.value?.removeEventListener("scroll", onScroll);
            target.value = newTarget;
            target.value.addEventListener("scroll", onScroll, {
                passive: true
            });
        }, {
            immediate: true
        });
    });
    (0, _vue.onBeforeUnmount)(()=>{
        target.value?.removeEventListener("scroll", onScroll);
    });
    // Do we need this? If yes - seems that
    // there's no need to expose onScroll
    canScroll && (0, _vue.watch)(canScroll, onScroll, {
        immediate: true
    });
    return {
        scrollThreshold,
        currentScroll,
        currentThreshold,
        isScrollActive,
        scrollRatio,
        // required only for testing
        // probably can be removed
        // later (2 chars chlng)
        isScrollingUp,
        savedScroll
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"b8ivf":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Composables
parcelHelpers.export(exports, "useSsrBoot", ()=>useSsrBoot);
var _vue = require("vue");
function useSsrBoot() {
    const isBooted = (0, _vue.shallowRef)(false);
    (0, _vue.onMounted)(()=>{
        window.requestAnimationFrame(()=>{
            isBooted.value = true;
        });
    });
    const ssrBootStyles = (0, _vue.computed)(()=>!isBooted.value ? {
            transition: "none !important"
        } : undefined);
    return {
        ssrBootStyles,
        isBooted: (0, _vue.readonly)(isBooted)
    };
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"86tBG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAppBarNavIconProps", ()=>makeVAppBarNavIconProps);
parcelHelpers.export(exports, "VAppBarNavIcon", ()=>VAppBarNavIcon);
var _vue = require("vue");
// Components
var _vbtnMjs = require("../VBtn/VBtn.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVAppBarNavIconProps = (0, _indexMjs.propsFactory)({
    ...(0, _vbtnMjs.makeVBtnProps)({
        icon: "$menu",
        variant: "text"
    })
}, "VAppBarNavIcon");
const VAppBarNavIcon = (0, _indexMjs.genericComponent)()({
    name: "VAppBarNavIcon",
    props: makeVAppBarNavIconProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)((0, _vbtnMjs.VBtn), (0, _vue.mergeProps)(props, {
                "class": [
                    "v-app-bar-nav-icon"
                ]
            }), slots));
        return {};
    }
});

},{"vue":"ff77s","../VBtn/VBtn.mjs":"ewnpF","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ewnpF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBtnProps", ()=>makeVBtnProps);
parcelHelpers.export(exports, "VBtn", ()=>VBtn);
var _vue = require("vue");
// Styles
var _vbtnCss = require("./VBtn.css");
// Components
var _vbtnToggleMjs = require("../VBtnToggle/VBtnToggle.mjs");
var _indexMjs = require("../VDefaultsProvider/index.mjs");
var _indexMjs1 = require("../VIcon/index.mjs");
var _indexMjs2 = require("../VProgressCircular/index.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _loaderMjs = require("../../composables/loader.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _selectLinkMjs = require("../../composables/selectLink.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Directives
var _indexMjs3 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs4 = require("../../util/index.mjs"); // Types
const makeVBtnProps = (0, _indexMjs4.propsFactory)({
    active: {
        type: Boolean,
        default: undefined
    },
    symbol: {
        type: null,
        default: (0, _vbtnToggleMjs.VBtnToggleSymbol)
    },
    flat: Boolean,
    icon: [
        Boolean,
        String,
        Function,
        Object
    ],
    prependIcon: (0, _iconsMjs.IconValue),
    appendIcon: (0, _iconsMjs.IconValue),
    block: Boolean,
    stacked: Boolean,
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: true
    },
    text: String,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _groupMjs.makeGroupItemProps)(),
    ...(0, _loaderMjs.makeLoaderProps)(),
    ...(0, _locationMjs.makeLocationProps)(),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _routerMjs.makeRouterProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "button"
    }),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "elevated"
    })
}, "VBtn");
const VBtn = (0, _indexMjs4.genericComponent)()({
    name: "VBtn",
    directives: {
        Ripple: (0, _indexMjs3.Ripple)
    },
    props: makeVBtnProps(),
    emits: {
        "group:selected": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { loaderClasses } = (0, _loaderMjs.useLoader)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { sizeClasses, sizeStyles } = (0, _sizeMjs.useSize)(props);
        const group = (0, _groupMjs.useGroupItem)(props, props.symbol, false);
        const link = (0, _routerMjs.useLink)(props, attrs);
        const isActive = (0, _vue.computed)(()=>{
            if (props.active !== undefined) return props.active;
            if (link.isLink.value) return link.isActive?.value;
            return group?.isSelected.value;
        });
        const isDisabled = (0, _vue.computed)(()=>group?.disabled.value || props.disabled);
        const isElevated = (0, _vue.computed)(()=>{
            return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
        });
        const valueAttr = (0, _vue.computed)(()=>{
            if (props.value === undefined) return undefined;
            return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
        });
        function onClick(e) {
            if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank")) return;
            link.navigate?.(e);
            group?.toggle();
        }
        (0, _selectLinkMjs.useSelectLink)(link, group?.select);
        (0, _indexMjs4.useRender)(()=>{
            const Tag = link.isLink.value ? "a" : props.tag;
            const hasPrepend = !!(props.prependIcon || slots.prepend);
            const hasAppend = !!(props.appendIcon || slots.append);
            const hasIcon = !!(props.icon && props.icon !== true);
            const hasColor = group?.isSelected.value && (!link.isLink.value || link.isActive?.value) || !group || link.isActive?.value;
            return (0, _vue.withDirectives)((0, _vue.createVNode)(Tag, {
                "type": Tag === "a" ? undefined : "button",
                "class": [
                    "v-btn",
                    group?.selectedClass.value,
                    {
                        "v-btn--active": isActive.value,
                        "v-btn--block": props.block,
                        "v-btn--disabled": isDisabled.value,
                        "v-btn--elevated": isElevated.value,
                        "v-btn--flat": props.flat,
                        "v-btn--icon": !!props.icon,
                        "v-btn--loading": props.loading,
                        "v-btn--stacked": props.stacked
                    },
                    themeClasses.value,
                    borderClasses.value,
                    hasColor ? colorClasses.value : undefined,
                    densityClasses.value,
                    elevationClasses.value,
                    loaderClasses.value,
                    positionClasses.value,
                    roundedClasses.value,
                    sizeClasses.value,
                    variantClasses.value,
                    props.class
                ],
                "style": [
                    hasColor ? colorStyles.value : undefined,
                    dimensionStyles.value,
                    locationStyles.value,
                    sizeStyles.value,
                    props.style
                ],
                "disabled": isDisabled.value || undefined,
                "href": link.href.value,
                "onClick": onClick,
                "value": valueAttr.value
            }, {
                default: ()=>[
                        (0, _variantMjs.genOverlays)(true, "v-btn"),
                        !props.icon && hasPrepend && (0, _vue.createVNode)("span", {
                            "key": "prepend",
                            "class": "v-btn__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                "key": "prepend-icon",
                                "icon": props.prependIcon
                            }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !props.prependIcon,
                                "defaults": {
                                    VIcon: {
                                        icon: props.prependIcon
                                    }
                                }
                            }, slots.prepend)
                        ]),
                        (0, _vue.createVNode)("span", {
                            "class": "v-btn__content",
                            "data-no-activator": ""
                        }, [
                            !slots.default && hasIcon ? (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                "key": "content-icon",
                                "icon": props.icon
                            }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                                "key": "content-defaults",
                                "disabled": !hasIcon,
                                "defaults": {
                                    VIcon: {
                                        icon: props.icon
                                    }
                                }
                            }, {
                                default: ()=>[
                                        slots.default?.() ?? props.text
                                    ]
                            })
                        ]),
                        !props.icon && hasAppend && (0, _vue.createVNode)("span", {
                            "key": "append",
                            "class": "v-btn__append"
                        }, [
                            !slots.append ? (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                "key": "append-icon",
                                "icon": props.appendIcon
                            }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                                "key": "append-defaults",
                                "disabled": !props.appendIcon,
                                "defaults": {
                                    VIcon: {
                                        icon: props.appendIcon
                                    }
                                }
                            }, slots.append)
                        ]),
                        !!props.loading && (0, _vue.createVNode)("span", {
                            "key": "loader",
                            "class": "v-btn__loader"
                        }, [
                            slots.loader?.() ?? (0, _vue.createVNode)((0, _indexMjs2.VProgressCircular), {
                                "color": typeof props.loading === "boolean" ? undefined : props.loading,
                                "indeterminate": true,
                                "size": "23",
                                "width": "2"
                            }, null)
                        ])
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("ripple"),
                    !isDisabled.value && props.ripple,
                    null
                ]
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VBtn.css":"1vJmj","../VBtnToggle/VBtnToggle.mjs":"hjTiQ","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../VProgressCircular/index.mjs":"2azsA","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/group.mjs":"7LC6J","../../composables/icons.mjs":"ezwoc","../../composables/loader.mjs":"dJ5WR","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/rounded.mjs":"ldhZ9","../../composables/router.mjs":"bEBrG","../../composables/selectLink.mjs":"ivqnJ","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1vJmj":[function() {},{}],"hjTiQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBtnToggleSymbol", ()=>VBtnToggleSymbol);
parcelHelpers.export(exports, "makeVBtnToggleProps", ()=>makeVBtnToggleProps);
parcelHelpers.export(exports, "VBtnToggle", ()=>VBtnToggle);
var _vue = require("vue");
// Styles
var _vbtnToggleCss = require("./VBtnToggle.css");
// Components
var _vbtnGroupMjs = require("../VBtnGroup/VBtnGroup.mjs"); // Composables
var _groupMjs = require("../../composables/group.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
const makeVBtnToggleProps = (0, _indexMjs.propsFactory)({
    ...(0, _vbtnGroupMjs.makeVBtnGroupProps)(),
    ...(0, _groupMjs.makeGroupProps)()
}, "VBtnToggle");
const VBtnToggle = (0, _indexMjs.genericComponent)()({
    name: "VBtnToggle",
    props: makeVBtnToggleProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { isSelected, next, prev, select, selected } = (0, _groupMjs.useGroup)(props, VBtnToggleSymbol);
        (0, _indexMjs.useRender)(()=>{
            const [btnGroupProps] = (0, _vbtnGroupMjs.VBtnGroup).filterProps(props);
            return (0, _vue.createVNode)((0, _vbtnGroupMjs.VBtnGroup), (0, _vue.mergeProps)({
                "class": [
                    "v-btn-toggle",
                    props.class
                ]
            }, btnGroupProps, {
                "style": props.style
            }), {
                default: ()=>[
                        slots.default?.({
                            isSelected,
                            next,
                            prev,
                            select,
                            selected
                        })
                    ]
            });
        });
        return {
            next,
            prev,
            select
        };
    }
});

},{"vue":"ff77s","./VBtnToggle.css":"8qVm3","../VBtnGroup/VBtnGroup.mjs":"hGrJO","../../composables/group.mjs":"7LC6J","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8qVm3":[function() {},{}],"hGrJO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBtnGroupProps", ()=>makeVBtnGroupProps);
parcelHelpers.export(exports, "VBtnGroup", ()=>VBtnGroup);
var _vue = require("vue");
// Styles
var _vbtnGroupCss = require("./VBtnGroup.css");
// Composables
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVBtnGroupProps = (0, _indexMjs.propsFactory)({
    divided: Boolean,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)()
}, "VBtnGroup");
const VBtnGroup = (0, _indexMjs.genericComponent)()({
    name: "VBtnGroup",
    props: makeVBtnGroupProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                height: "auto",
                color: (0, _vue.toRef)(props, "color"),
                density: (0, _vue.toRef)(props, "density"),
                flat: true,
                variant: (0, _vue.toRef)(props, "variant")
            }
        });
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-btn-group",
                    {
                        "v-btn-group--divided": props.divided
                    },
                    themeClasses.value,
                    borderClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": props.style
            }, slots);
        });
    }
});

},{"vue":"ff77s","./VBtnGroup.css":"g3oyH","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/elevation.mjs":"3BDEa","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"g3oyH":[function() {},{}],"7cRh5":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeDensityProps", ()=>makeDensityProps);
parcelHelpers.export(exports, "useDensity", ()=>useDensity);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const allowedDensities = [
    null,
    "default",
    "comfortable",
    "compact"
];
const makeDensityProps = (0, _indexMjs.propsFactory)({
    density: {
        type: String,
        default: "default",
        validator: (v)=>allowedDensities.includes(v)
    }
}, "density");
function useDensity(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const densityClasses = (0, _vue.computed)(()=>{
        return `${name}--density-${props.density}`;
    });
    return {
        densityClasses
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8A0hd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allowedVariants", ()=>allowedVariants);
parcelHelpers.export(exports, "genOverlays", ()=>genOverlays);
parcelHelpers.export(exports, "makeVariantProps", ()=>makeVariantProps);
parcelHelpers.export(exports, "useVariant", ()=>useVariant);
var _vue = require("vue");
// Composables
var _colorMjs = require("./color.mjs"); // Utilities
var _indexMjs = require("../util/index.mjs"); // Types
const allowedVariants = [
    "elevated",
    "flat",
    "tonal",
    "outlined",
    "text",
    "plain"
];
function genOverlays(isClickable, name) {
    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
        isClickable && (0, _vue.createVNode)("span", {
            "key": "overlay",
            "class": `${name}__overlay`
        }, null),
        (0, _vue.createVNode)("span", {
            "key": "underlay",
            "class": `${name}__underlay`
        }, null)
    ]);
}
const makeVariantProps = (0, _indexMjs.propsFactory)({
    color: String,
    variant: {
        type: String,
        default: "elevated",
        validator: (v)=>allowedVariants.includes(v)
    }
}, "variant");
function useVariant(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const variantClasses = (0, _vue.computed)(()=>{
        const { variant } = (0, _vue.unref)(props);
        return `${name}--variant-${variant}`;
    });
    const { colorClasses, colorStyles } = (0, _colorMjs.useColor)((0, _vue.computed)(()=>{
        const { variant, color } = (0, _vue.unref)(props);
        return {
            [[
                "elevated",
                "flat"
            ].includes(variant) ? "background" : "text"]: color
        };
    }));
    return {
        colorClasses,
        colorStyles,
        variantClasses
    };
}

},{"vue":"ff77s","./color.mjs":"4pLYX","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7LC6J":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeGroupProps", ()=>makeGroupProps);
parcelHelpers.export(exports, "makeGroupItemProps", ()=>makeGroupItemProps);
parcelHelpers.export(exports, "useGroupItem", ()=>useGroupItem);
parcelHelpers.export(exports, "useGroup", ()=>useGroup);
var _proxiedModelMjs = require("./proxiedModel.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeGroupProps = (0, _indexMjs.propsFactory)({
    modelValue: {
        type: null,
        default: undefined
    },
    multiple: Boolean,
    mandatory: [
        Boolean,
        String
    ],
    max: Number,
    selectedClass: String,
    disabled: Boolean
}, "group");
const makeGroupItemProps = (0, _indexMjs.propsFactory)({
    value: null,
    disabled: Boolean,
    selectedClass: String
}, "group-item");
function useGroupItem(props, injectKey) {
    let required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    const vm = (0, _indexMjs.getCurrentInstance)("useGroupItem");
    if (!vm) throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    const id = (0, _indexMjs.getUid)();
    (0, _vue.provide)(Symbol.for(`${injectKey.description}:id`), id);
    const group = (0, _vue.inject)(injectKey, null);
    if (!group) {
        if (!required) return group;
        throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
    }
    const value = (0, _vue.toRef)(props, "value");
    const disabled = (0, _vue.computed)(()=>!!(group.disabled.value || props.disabled));
    group.register({
        id,
        value,
        disabled
    }, vm);
    (0, _vue.onBeforeUnmount)(()=>{
        group.unregister(id);
    });
    const isSelected = (0, _vue.computed)(()=>{
        return group.isSelected(id);
    });
    const selectedClass = (0, _vue.computed)(()=>isSelected.value && [
            group.selectedClass.value,
            props.selectedClass
        ]);
    (0, _vue.watch)(isSelected, (value)=>{
        vm.emit("group:selected", {
            value
        });
    });
    return {
        id,
        isSelected,
        toggle: ()=>group.select(id, !isSelected.value),
        select: (value)=>group.select(id, value),
        selectedClass,
        value,
        disabled,
        group
    };
}
function useGroup(props, injectKey) {
    let isUnmounted = false;
    const items = (0, _vue.reactive)([]);
    const selected = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", [], (v)=>{
        if (v == null) return [];
        return getIds(items, (0, _indexMjs.wrapInArray)(v));
    }, (v)=>{
        const arr = getValues(items, v);
        return props.multiple ? arr : arr[0];
    });
    const groupVm = (0, _indexMjs.getCurrentInstance)("useGroup");
    function register(item, vm) {
        // Is there a better way to fix this typing?
        const unwrapped = item;
        const key = Symbol.for(`${injectKey.description}:id`);
        const children = (0, _indexMjs.findChildrenWithProvide)(key, groupVm?.vnode);
        const index = children.indexOf(vm);
        if (index > -1) items.splice(index, 0, unwrapped);
        else items.push(unwrapped);
    }
    function unregister(id) {
        if (isUnmounted) return;
        // TODO: re-evaluate this line's importance in the future
        // should we only modify the model if mandatory is set.
        // selected.value = selected.value.filter(v => v !== id)
        forceMandatoryValue();
        const index = items.findIndex((item)=>item.id === id);
        items.splice(index, 1);
    }
    // If mandatory and nothing is selected, then select first non-disabled item
    function forceMandatoryValue() {
        const item = items.find((item)=>!item.disabled);
        if (item && props.mandatory === "force" && !selected.value.length) selected.value = [
            item.id
        ];
    }
    (0, _vue.onMounted)(()=>{
        forceMandatoryValue();
    });
    (0, _vue.onBeforeUnmount)(()=>{
        isUnmounted = true;
    });
    function select(id, value) {
        const item = items.find((item)=>item.id === id);
        if (value && item?.disabled) return;
        if (props.multiple) {
            const internalValue = selected.value.slice();
            const index = internalValue.findIndex((v)=>v === id);
            const isSelected = ~index;
            value = value ?? !isSelected;
            // We can't remove value if group is
            // mandatory, value already exists,
            // and it is the only value
            if (isSelected && props.mandatory && internalValue.length <= 1) return;
            // We can't add value if it would
            // cause max limit to be exceeded
            if (!isSelected && props.max != null && internalValue.length + 1 > props.max) return;
            if (index < 0 && value) internalValue.push(id);
            else if (index >= 0 && !value) internalValue.splice(index, 1);
            selected.value = internalValue;
        } else {
            const isSelected = selected.value.includes(id);
            if (props.mandatory && isSelected) return;
            selected.value = value ?? !isSelected ? [
                id
            ] : [];
        }
    }
    function step(offset) {
        // getting an offset from selected value obviously won't work with multiple values
        if (props.multiple) (0, _indexMjs.consoleWarn)('This method is not supported when using "multiple" prop');
        if (!selected.value.length) {
            const item = items.find((item)=>!item.disabled);
            item && (selected.value = [
                item.id
            ]);
        } else {
            const currentId = selected.value[0];
            const currentIndex = items.findIndex((i)=>i.id === currentId);
            let newIndex = (currentIndex + offset) % items.length;
            let newItem = items[newIndex];
            while(newItem.disabled && newIndex !== currentIndex){
                newIndex = (newIndex + offset) % items.length;
                newItem = items[newIndex];
            }
            if (newItem.disabled) return;
            selected.value = [
                items[newIndex].id
            ];
        }
    }
    const state = {
        register,
        unregister,
        selected,
        select,
        disabled: (0, _vue.toRef)(props, "disabled"),
        prev: ()=>step(items.length - 1),
        next: ()=>step(1),
        isSelected: (id)=>selected.value.includes(id),
        selectedClass: (0, _vue.computed)(()=>props.selectedClass),
        items: (0, _vue.computed)(()=>items),
        getItemIndex: (value)=>getItemIndex(items, value)
    };
    (0, _vue.provide)(injectKey, state);
    return state;
}
function getItemIndex(items, value) {
    const ids = getIds(items, [
        value
    ]);
    if (!ids.length) return -1;
    return items.findIndex((item)=>item.id === ids[0]);
}
function getIds(items, modelValue) {
    const ids = [];
    modelValue.forEach((value)=>{
        const item = items.find((item)=>(0, _indexMjs.deepEqual)(value, item.value));
        const itemByIndex = items[value];
        if (item?.value != null) ids.push(item.id);
        else if (itemByIndex != null) ids.push(itemByIndex.id);
    });
    return ids;
}
function getValues(items, ids) {
    const values = [];
    ids.forEach((id)=>{
        const itemIndex = items.findIndex((item)=>item.id === id);
        if (~itemIndex) {
            const item = items[itemIndex];
            values.push(item.value != null ? item.value : itemIndex);
        }
    });
    return values;
}

},{"./proxiedModel.mjs":"bUF28","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2wJue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VIcon", ()=>(0, _viconMjs.VIcon));
parcelHelpers.export(exports, "VComponentIcon", ()=>(0, _iconsMjs.VComponentIcon));
parcelHelpers.export(exports, "VSvgIcon", ()=>(0, _iconsMjs.VSvgIcon));
parcelHelpers.export(exports, "VLigatureIcon", ()=>(0, _iconsMjs.VLigatureIcon));
parcelHelpers.export(exports, "VClassIcon", ()=>(0, _iconsMjs.VClassIcon));
var _viconMjs = require("./VIcon.mjs");
var _iconsMjs = require("../../composables/icons.mjs");

},{"./VIcon.mjs":"4hM73","../../composables/icons.mjs":"ezwoc","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4hM73":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVIconProps", ()=>makeVIconProps);
parcelHelpers.export(exports, "VIcon", ()=>VIcon);
var _vue = require("vue");
// Styles
var _viconCss = require("./VIcon.css");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVIconProps = (0, _indexMjs.propsFactory)({
    color: String,
    start: Boolean,
    end: Boolean,
    icon: (0, _iconsMjs.IconValue),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "i"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VIcon");
const VIcon = (0, _indexMjs.genericComponent)()({
    name: "VIcon",
    props: makeVIconProps(),
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const slotIcon = (0, _vue.ref)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { iconData } = (0, _iconsMjs.useIcon)((0, _vue.computed)(()=>slotIcon.value || props.icon));
        const { sizeClasses } = (0, _sizeMjs.useSize)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "color"));
        (0, _indexMjs.useRender)(()=>{
            const slotValue = slots.default?.();
            if (slotValue) slotIcon.value = (0, _indexMjs.flattenFragments)(slotValue).filter((node)=>node.type === (0, _vue.Text) && node.children && typeof node.children === "string")[0]?.children;
            return (0, _vue.createVNode)(iconData.value.component, {
                "tag": props.tag,
                "icon": iconData.value.icon,
                "class": [
                    "v-icon",
                    "notranslate",
                    themeClasses.value,
                    sizeClasses.value,
                    textColorClasses.value,
                    {
                        "v-icon--clickable": !!attrs.onClick,
                        "v-icon--start": props.start,
                        "v-icon--end": props.end
                    },
                    props.class
                ],
                "style": [
                    !sizeClasses.value ? {
                        fontSize: (0, _indexMjs.convertToUnit)(props.size),
                        height: (0, _indexMjs.convertToUnit)(props.size),
                        width: (0, _indexMjs.convertToUnit)(props.size)
                    } : undefined,
                    textColorStyles.value,
                    props.style
                ],
                "role": attrs.onClick ? "button" : undefined,
                "aria-hidden": !attrs.onClick
            }, {
                default: ()=>[
                        slotValue
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VIcon.css":"7XirY","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/icons.mjs":"ezwoc","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7XirY":[function() {},{}],"jtF5F":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeSizeProps", ()=>makeSizeProps);
parcelHelpers.export(exports, "useSize", ()=>useSize);
var _indexMjs = require("../util/index.mjs"); // Types
const predefinedSizes = [
    "x-small",
    "small",
    "default",
    "large",
    "x-large"
];
const makeSizeProps = (0, _indexMjs.propsFactory)({
    size: {
        type: [
            String,
            Number
        ],
        default: "default"
    }
}, "size");
function useSize(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    return (0, _indexMjs.destructComputed)(()=>{
        let sizeClasses;
        let sizeStyles;
        if ((0, _indexMjs.includes)(predefinedSizes, props.size)) sizeClasses = `${name}--size-${props.size}`;
        else if (props.size) sizeStyles = {
            width: (0, _indexMjs.convertToUnit)(props.size),
            height: (0, _indexMjs.convertToUnit)(props.size)
        };
        return {
            sizeClasses,
            sizeStyles
        };
    });
}

},{"../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2azsA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VProgressCircular", ()=>(0, _vprogressCircularMjs.VProgressCircular));
var _vprogressCircularMjs = require("./VProgressCircular.mjs");

},{"./VProgressCircular.mjs":"4pZOj","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4pZOj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVProgressCircularProps", ()=>makeVProgressCircularProps);
parcelHelpers.export(exports, "VProgressCircular", ()=>VProgressCircular);
var _vue = require("vue");
// Styles
var _vprogressCircularCss = require("./VProgressCircular.css");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _intersectionObserverMjs = require("../../composables/intersectionObserver.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVProgressCircularProps = (0, _indexMjs.propsFactory)({
    bgColor: String,
    color: String,
    indeterminate: [
        Boolean,
        String
    ],
    modelValue: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    rotate: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    width: {
        type: [
            Number,
            String
        ],
        default: 4
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "div"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VProgressCircular");
const VProgressCircular = (0, _indexMjs.genericComponent)()({
    name: "VProgressCircular",
    props: makeVProgressCircularProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const MAGIC_RADIUS_CONSTANT = 20;
        const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
        const root = (0, _vue.ref)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { sizeClasses, sizeStyles } = (0, _sizeMjs.useSize)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "color"));
        const { textColorClasses: underlayColorClasses, textColorStyles: underlayColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "bgColor"));
        const { intersectionRef, isIntersecting } = (0, _intersectionObserverMjs.useIntersectionObserver)();
        const { resizeRef, contentRect } = (0, _resizeObserverMjs.useResizeObserver)();
        const normalizedValue = (0, _vue.computed)(()=>Math.max(0, Math.min(100, parseFloat(props.modelValue))));
        const width = (0, _vue.computed)(()=>Number(props.width));
        const size = (0, _vue.computed)(()=>{
            // Get size from element if size prop value is small, large etc
            return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
        });
        const diameter = (0, _vue.computed)(()=>MAGIC_RADIUS_CONSTANT / (1 - width.value / size.value) * 2);
        const strokeWidth = (0, _vue.computed)(()=>width.value / size.value * diameter.value);
        const strokeDashOffset = (0, _vue.computed)(()=>(0, _indexMjs.convertToUnit)((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
        (0, _vue.watchEffect)(()=>{
            intersectionRef.value = root.value;
            resizeRef.value = root.value;
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "ref": root,
                "class": [
                    "v-progress-circular",
                    {
                        "v-progress-circular--indeterminate": !!props.indeterminate,
                        "v-progress-circular--visible": isIntersecting.value,
                        "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
                    },
                    themeClasses.value,
                    sizeClasses.value,
                    textColorClasses.value,
                    props.class
                ],
                "style": [
                    sizeStyles.value,
                    textColorStyles.value,
                    props.style
                ],
                "role": "progressbar",
                "aria-valuemin": "0",
                "aria-valuemax": "100",
                "aria-valuenow": props.indeterminate ? undefined : normalizedValue.value
            }, {
                default: ()=>[
                        (0, _vue.createVNode)("svg", {
                            "style": {
                                transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
                            },
                            "xmlns": "http://www.w3.org/2000/svg",
                            "viewBox": `0 0 ${diameter.value} ${diameter.value}`
                        }, [
                            (0, _vue.createVNode)("circle", {
                                "class": [
                                    "v-progress-circular__underlay",
                                    underlayColorClasses.value
                                ],
                                "style": underlayColorStyles.value,
                                "fill": "transparent",
                                "cx": "50%",
                                "cy": "50%",
                                "r": MAGIC_RADIUS_CONSTANT,
                                "stroke-width": strokeWidth.value,
                                "stroke-dasharray": CIRCUMFERENCE,
                                "stroke-dashoffset": 0
                            }, null),
                            (0, _vue.createVNode)("circle", {
                                "class": "v-progress-circular__overlay",
                                "fill": "transparent",
                                "cx": "50%",
                                "cy": "50%",
                                "r": MAGIC_RADIUS_CONSTANT,
                                "stroke-width": strokeWidth.value,
                                "stroke-dasharray": CIRCUMFERENCE,
                                "stroke-dashoffset": strokeDashOffset.value
                            }, null)
                        ]),
                        slots.default && (0, _vue.createVNode)("div", {
                            "class": "v-progress-circular__content"
                        }, [
                            slots.default({
                                value: normalizedValue.value
                            })
                        ])
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VProgressCircular.css":"dW5v1","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/intersectionObserver.mjs":"2yOLq","../../composables/resizeObserver.mjs":"byLTu","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dW5v1":[function() {},{}],"2yOLq":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useIntersectionObserver", ()=>useIntersectionObserver);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs");
function useIntersectionObserver(callback, options) {
    const intersectionRef = (0, _vue.ref)();
    const isIntersecting = (0, _vue.shallowRef)(false);
    if (0, _indexMjs.SUPPORTS_INTERSECTION) {
        const observer = new IntersectionObserver((entries)=>{
            callback?.(entries, observer);
            isIntersecting.value = !!entries.find((entry)=>entry.isIntersecting);
        }, options);
        (0, _vue.onBeforeUnmount)(()=>{
            observer.disconnect();
        });
        (0, _vue.watch)(intersectionRef, (newValue, oldValue)=>{
            if (oldValue) {
                observer.unobserve(oldValue);
                isIntersecting.value = false;
            }
            if (newValue) observer.observe(newValue);
        }, {
            flush: "post"
        });
    }
    return {
        intersectionRef,
        isIntersecting
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dJ5WR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeLoaderProps", ()=>makeLoaderProps);
parcelHelpers.export(exports, "useLoader", ()=>useLoader);
parcelHelpers.export(exports, "LoaderSlot", ()=>LoaderSlot);
var _vue = require("vue");
// Components
var _indexMjs = require("../components/VProgressLinear/index.mjs"); // Utilities
var _indexMjs1 = require("../util/index.mjs"); // Types
const makeLoaderProps = (0, _indexMjs1.propsFactory)({
    loading: [
        Boolean,
        String
    ]
}, "loader");
function useLoader(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs1.getCurrentInstanceName)();
    const loaderClasses = (0, _vue.computed)(()=>({
            [`${name}--loading`]: props.loading
        }));
    return {
        loaderClasses
    };
}
function LoaderSlot(props, _ref) {
    let { slots } = _ref;
    return (0, _vue.createVNode)("div", {
        "class": `${props.name}__loader`
    }, [
        slots.default?.({
            color: props.color,
            isActive: props.active
        }) || (0, _vue.createVNode)((0, _indexMjs.VProgressLinear), {
            "active": props.active,
            "color": props.color,
            "height": "2",
            "indeterminate": true
        }, null)
    ]);
}

},{"vue":"ff77s","../components/VProgressLinear/index.mjs":"g9djC","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"g9djC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VProgressLinear", ()=>(0, _vprogressLinearMjs.VProgressLinear));
var _vprogressLinearMjs = require("./VProgressLinear.mjs");

},{"./VProgressLinear.mjs":"aZwfh","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aZwfh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVProgressLinearProps", ()=>makeVProgressLinearProps);
parcelHelpers.export(exports, "VProgressLinear", ()=>VProgressLinear);
var _vue = require("vue");
// Styles
var _vprogressLinearCss = require("./VProgressLinear.css");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _intersectionObserverMjs = require("../../composables/intersectionObserver.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVProgressLinearProps = (0, _indexMjs.propsFactory)({
    absolute: Boolean,
    active: {
        type: Boolean,
        default: true
    },
    bgColor: String,
    bgOpacity: [
        Number,
        String
    ],
    bufferValue: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
        type: [
            Number,
            String
        ],
        default: 4
    },
    indeterminate: Boolean,
    max: {
        type: [
            Number,
            String
        ],
        default: 100
    },
    modelValue: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _locationMjs.makeLocationProps)({
        location: "top"
    }),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VProgressLinear");
const VProgressLinear = (0, _indexMjs.genericComponent)()({
    name: "VProgressLinear",
    props: makeVProgressLinearProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const progress = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { isRtl, rtlClasses } = (0, _localeMjs.useRtl)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)(props, "color");
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.computed)(()=>props.bgColor || props.color));
        const { backgroundColorClasses: barColorClasses, backgroundColorStyles: barColorStyles } = (0, _colorMjs.useBackgroundColor)(props, "color");
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { intersectionRef, isIntersecting } = (0, _intersectionObserverMjs.useIntersectionObserver)();
        const max = (0, _vue.computed)(()=>parseInt(props.max, 10));
        const height = (0, _vue.computed)(()=>parseInt(props.height, 10));
        const normalizedBuffer = (0, _vue.computed)(()=>parseFloat(props.bufferValue) / max.value * 100);
        const normalizedValue = (0, _vue.computed)(()=>parseFloat(progress.value) / max.value * 100);
        const isReversed = (0, _vue.computed)(()=>isRtl.value !== props.reverse);
        const transition = (0, _vue.computed)(()=>props.indeterminate ? "fade-transition" : "slide-x-transition");
        const opacity = (0, _vue.computed)(()=>{
            return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
        });
        function handleClick(e) {
            if (!intersectionRef.value) return;
            const { left, right, width } = intersectionRef.value.getBoundingClientRect();
            const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
            progress.value = Math.round(value / width * max.value);
        }
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "ref": intersectionRef,
                "class": [
                    "v-progress-linear",
                    {
                        "v-progress-linear--absolute": props.absolute,
                        "v-progress-linear--active": props.active && isIntersecting.value,
                        "v-progress-linear--reverse": isReversed.value,
                        "v-progress-linear--rounded": props.rounded,
                        "v-progress-linear--rounded-bar": props.roundedBar,
                        "v-progress-linear--striped": props.striped
                    },
                    roundedClasses.value,
                    themeClasses.value,
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    {
                        bottom: props.location === "bottom" ? 0 : undefined,
                        top: props.location === "top" ? 0 : undefined,
                        height: props.active ? (0, _indexMjs.convertToUnit)(height.value) : 0,
                        "--v-progress-linear-height": (0, _indexMjs.convertToUnit)(height.value),
                        ...locationStyles.value
                    },
                    props.style
                ],
                "role": "progressbar",
                "aria-hidden": props.active ? "false" : "true",
                "aria-valuemin": "0",
                "aria-valuemax": props.max,
                "aria-valuenow": props.indeterminate ? undefined : normalizedValue.value,
                "onClick": props.clickable && handleClick
            }, {
                default: ()=>[
                        props.stream && (0, _vue.createVNode)("div", {
                            "key": "stream",
                            "class": [
                                "v-progress-linear__stream",
                                textColorClasses.value
                            ],
                            "style": {
                                ...textColorStyles.value,
                                [isReversed.value ? "left" : "right"]: (0, _indexMjs.convertToUnit)(-height.value),
                                borderTop: `${(0, _indexMjs.convertToUnit)(height.value / 2)} dotted`,
                                opacity: opacity.value,
                                top: `calc(50% - ${(0, _indexMjs.convertToUnit)(height.value / 4)})`,
                                width: (0, _indexMjs.convertToUnit)(100 - normalizedBuffer.value, "%"),
                                "--v-progress-linear-stream-to": (0, _indexMjs.convertToUnit)(height.value * (isReversed.value ? 1 : -1))
                            }
                        }, null),
                        (0, _vue.createVNode)("div", {
                            "class": [
                                "v-progress-linear__background",
                                backgroundColorClasses.value
                            ],
                            "style": [
                                backgroundColorStyles.value,
                                {
                                    opacity: opacity.value,
                                    width: (0, _indexMjs.convertToUnit)(!props.stream ? 100 : normalizedBuffer.value, "%")
                                }
                            ]
                        }, null),
                        (0, _vue.createVNode)((0, _vue.Transition), {
                            "name": transition.value
                        }, {
                            default: ()=>[
                                    !props.indeterminate ? (0, _vue.createVNode)("div", {
                                        "class": [
                                            "v-progress-linear__determinate",
                                            barColorClasses.value
                                        ],
                                        "style": [
                                            barColorStyles.value,
                                            {
                                                width: (0, _indexMjs.convertToUnit)(normalizedValue.value, "%")
                                            }
                                        ]
                                    }, null) : (0, _vue.createVNode)("div", {
                                        "class": "v-progress-linear__indeterminate"
                                    }, [
                                        [
                                            "long",
                                            "short"
                                        ].map((bar)=>(0, _vue.createVNode)("div", {
                                                "key": bar,
                                                "class": [
                                                    "v-progress-linear__indeterminate",
                                                    bar,
                                                    barColorClasses.value
                                                ],
                                                "style": barColorStyles.value
                                            }, null))
                                    ])
                                ]
                        }),
                        slots.default && (0, _vue.createVNode)("div", {
                            "class": "v-progress-linear__content"
                        }, [
                            slots.default({
                                value: normalizedValue.value,
                                buffer: normalizedBuffer.value
                            })
                        ])
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VProgressLinear.css":"8fJHe","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/intersectionObserver.mjs":"2yOLq","../../composables/locale.mjs":"4MZbL","../../composables/location.mjs":"5z6DF","../../composables/proxiedModel.mjs":"bUF28","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8fJHe":[function() {},{}],"5z6DF":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeLocationProps", ()=>makeLocationProps);
parcelHelpers.export(exports, "useLocation", ()=>useLocation);
var _localeMjs = require("./locale.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const oppositeMap = {
    center: "center",
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
};
const makeLocationProps = (0, _indexMjs.propsFactory)({
    location: String
}, "location");
function useLocation(props) {
    let opposite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let offset = arguments.length > 2 ? arguments[2] : undefined;
    const { isRtl } = (0, _localeMjs.useRtl)();
    const locationStyles = (0, _vue.computed)(()=>{
        if (!props.location) return {};
        const { side, align } = (0, _indexMjs.parseAnchor)(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
        function getOffset(side) {
            return offset ? offset(side) : 0;
        }
        const styles = {};
        if (side !== "center") {
            if (opposite) styles[oppositeMap[side]] = `calc(100% - ${getOffset(side)}px)`;
            else styles[side] = 0;
        }
        if (align !== "center") {
            if (opposite) styles[oppositeMap[align]] = `calc(100% - ${getOffset(align)}px)`;
            else styles[align] = 0;
        } else {
            if (side === "center") styles.top = styles.left = "50%";
            else styles[({
                top: "left",
                bottom: "left",
                left: "top",
                right: "top"
            })[side]] = "50%";
            styles.transform = ({
                top: "translateX(-50%)",
                bottom: "translateX(-50%)",
                left: "translateY(-50%)",
                right: "translateY(-50%)",
                center: "translate(-50%, -50%)"
            })[side];
        }
        return styles;
    });
    return {
        locationStyles
    };
}

},{"./locale.mjs":"4MZbL","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cKISh":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makePositionProps", ()=>makePositionProps);
parcelHelpers.export(exports, "usePosition", ()=>usePosition);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const positionValues = [
    "static",
    "relative",
    "fixed",
    "absolute",
    "sticky"
];
const makePositionProps = (0, _indexMjs.propsFactory)({
    position: {
        type: String,
        validator: /* istanbul ignore next */ (v)=>positionValues.includes(v)
    }
}, "position");
function usePosition(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const positionClasses = (0, _vue.computed)(()=>{
        return props.position ? `${name}--${props.position}` : undefined;
    });
    return {
        positionClasses
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bEBrG":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useRoute", ()=>useRoute);
parcelHelpers.export(exports, "useRouter", ()=>useRouter);
parcelHelpers.export(exports, "useLink", ()=>useLink);
parcelHelpers.export(exports, "makeRouterProps", ()=>makeRouterProps);
parcelHelpers.export(exports, "useBackButton", ()=>useBackButton);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
function useRoute() {
    const vm = (0, _indexMjs.getCurrentInstance)("useRoute");
    return (0, _vue.computed)(()=>vm?.proxy?.$route);
}
function useRouter() {
    return (0, _indexMjs.getCurrentInstance)("useRouter")?.proxy?.$router;
}
function useLink(props, attrs) {
    const RouterLink = (0, _vue.resolveDynamicComponent)("RouterLink");
    const isLink = (0, _vue.computed)(()=>!!(props.href || props.to));
    const isClickable = (0, _vue.computed)(()=>{
        return isLink?.value || (0, _indexMjs.hasEvent)(attrs, "click") || (0, _indexMjs.hasEvent)(props, "click");
    });
    if (typeof RouterLink === "string") return {
        isLink,
        isClickable,
        href: (0, _vue.toRef)(props, "href")
    };
    const link = props.to ? RouterLink.useLink(props) : undefined;
    return {
        isLink,
        isClickable,
        route: link?.route,
        navigate: link?.navigate,
        isActive: link && (0, _vue.computed)(()=>props.exact ? link.isExactActive?.value : link.isActive?.value),
        href: (0, _vue.computed)(()=>props.to ? link?.route.value.href : props.href)
    };
}
const makeRouterProps = (0, _indexMjs.propsFactory)({
    href: String,
    replace: Boolean,
    to: [
        String,
        Object
    ],
    exact: Boolean
}, "router");
let inTransition = false;
function useBackButton(router, cb) {
    let popped = false;
    let removeBefore;
    let removeAfter;
    if (0, _indexMjs.IN_BROWSER) {
        (0, _vue.nextTick)(()=>{
            window.addEventListener("popstate", onPopstate);
            removeBefore = router?.beforeEach((to, from, next)=>{
                if (!inTransition) setTimeout(()=>popped ? cb(next) : next());
                else popped ? cb(next) : next();
                inTransition = true;
            });
            removeAfter = router?.afterEach(()=>{
                inTransition = false;
            });
        });
        (0, _vue.onScopeDispose)(()=>{
            window.removeEventListener("popstate", onPopstate);
            removeBefore?.();
            removeAfter?.();
        });
    }
    function onPopstate(e) {
        if (e.state?.replaced) return;
        popped = true;
        setTimeout(()=>popped = false);
    }
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ivqnJ":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Types
parcelHelpers.export(exports, "useSelectLink", ()=>useSelectLink);
var _vue = require("vue");
function useSelectLink(link, select) {
    (0, _vue.watch)(()=>link.isActive?.value, (isActive)=>{
        if (link.isLink.value && isActive && select) (0, _vue.nextTick)(()=>{
            select(true);
        });
    }, {
        immediate: true
    });
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fTBbe":[function(require,module,exports) {
// Styles
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Ripple", ()=>Ripple);
var _vrippleCss = require("./VRipple.css");
// Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const stopSymbol = Symbol("rippleStop");
const DELAY_RIPPLE = 80;
function transform(el, value) {
    el.style.transform = value;
    el.style.webkitTransform = value;
}
function isTouchEvent(e) {
    return e.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e) {
    return e.constructor.name === "KeyboardEvent";
}
const calculate = function(e, el) {
    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let localX = 0;
    let localY = 0;
    if (!isKeyboardEvent(e)) {
        const offset = el.getBoundingClientRect();
        const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
        localX = target.clientX - offset.left;
        localY = target.clientY - offset.top;
    }
    let radius = 0;
    let scale = 0.3;
    if (el._ripple?.circle) {
        scale = 0.15;
        radius = el.clientWidth / 2;
        radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
    } else radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
    const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
    const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
    const x = value.center ? centerX : `${localX - radius}px`;
    const y = value.center ? centerY : `${localY - radius}px`;
    return {
        radius,
        scale,
        x,
        y,
        centerX,
        centerY
    };
};
const ripples = {
    /* eslint-disable max-statements */ show (e, el) {
        let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (!el?._ripple?.enabled) return;
        const container = document.createElement("span");
        const animation = document.createElement("span");
        container.appendChild(animation);
        container.className = "v-ripple__container";
        if (value.class) container.className += ` ${value.class}`;
        const { radius, scale, x, y, centerX, centerY } = calculate(e, el, value);
        const size = `${radius * 2}px`;
        animation.className = "v-ripple__animation";
        animation.style.width = size;
        animation.style.height = size;
        el.appendChild(container);
        const computed = window.getComputedStyle(el);
        if (computed && computed.position === "static") {
            el.style.position = "relative";
            el.dataset.previousPosition = "static";
        }
        animation.classList.add("v-ripple__animation--enter");
        animation.classList.add("v-ripple__animation--visible");
        transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
        animation.dataset.activated = String(performance.now());
        setTimeout(()=>{
            animation.classList.remove("v-ripple__animation--enter");
            animation.classList.add("v-ripple__animation--in");
            transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
        }, 0);
    },
    hide (el) {
        if (!el?._ripple?.enabled) return;
        const ripples = el.getElementsByClassName("v-ripple__animation");
        if (ripples.length === 0) return;
        const animation = ripples[ripples.length - 1];
        if (animation.dataset.isHiding) return;
        else animation.dataset.isHiding = "true";
        const diff = performance.now() - Number(animation.dataset.activated);
        const delay = Math.max(250 - diff, 0);
        setTimeout(()=>{
            animation.classList.remove("v-ripple__animation--in");
            animation.classList.add("v-ripple__animation--out");
            setTimeout(()=>{
                const ripples = el.getElementsByClassName("v-ripple__animation");
                if (ripples.length === 1 && el.dataset.previousPosition) {
                    el.style.position = el.dataset.previousPosition;
                    delete el.dataset.previousPosition;
                }
                if (animation.parentNode?.parentNode === el) el.removeChild(animation.parentNode);
            }, 300);
        }, delay);
    }
};
function isRippleEnabled(value) {
    return typeof value === "undefined" || !!value;
}
function rippleShow(e) {
    const value = {};
    const element = e.currentTarget;
    if (!element?._ripple || element._ripple.touched || e[stopSymbol]) return;
    // Don't allow the event to trigger ripples on any other elements
    e[stopSymbol] = true;
    if (isTouchEvent(e)) {
        element._ripple.touched = true;
        element._ripple.isTouch = true;
    } else {
        // It's possible for touch events to fire
        // as mouse events on Android/iOS, this
        // will skip the event call if it has
        // already been registered as touch
        if (element._ripple.isTouch) return;
    }
    value.center = element._ripple.centered || isKeyboardEvent(e);
    if (element._ripple.class) value.class = element._ripple.class;
    if (isTouchEvent(e)) {
        // already queued that shows or hides the ripple
        if (element._ripple.showTimerCommit) return;
        element._ripple.showTimerCommit = ()=>{
            ripples.show(e, element, value);
        };
        element._ripple.showTimer = window.setTimeout(()=>{
            if (element?._ripple?.showTimerCommit) {
                element._ripple.showTimerCommit();
                element._ripple.showTimerCommit = null;
            }
        }, DELAY_RIPPLE);
    } else ripples.show(e, element, value);
}
function rippleStop(e) {
    e[stopSymbol] = true;
}
function rippleHide(e) {
    const element = e.currentTarget;
    if (!element?._ripple) return;
    window.clearTimeout(element._ripple.showTimer);
    // The touch interaction occurs before the show timer is triggered.
    // We still want to show ripple effect.
    if (e.type === "touchend" && element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
        // re-queue ripple hiding
        element._ripple.showTimer = window.setTimeout(()=>{
            rippleHide(e);
        });
        return;
    }
    window.setTimeout(()=>{
        if (element._ripple) element._ripple.touched = false;
    });
    ripples.hide(element);
}
function rippleCancelShow(e) {
    const element = e.currentTarget;
    if (!element?._ripple) return;
    if (element._ripple.showTimerCommit) element._ripple.showTimerCommit = null;
    window.clearTimeout(element._ripple.showTimer);
}
let keyboardRipple = false;
function keyboardRippleShow(e) {
    if (!keyboardRipple && (e.keyCode === (0, _indexMjs.keyCodes).enter || e.keyCode === (0, _indexMjs.keyCodes).space)) {
        keyboardRipple = true;
        rippleShow(e);
    }
}
function keyboardRippleHide(e) {
    keyboardRipple = false;
    rippleHide(e);
}
function focusRippleHide(e) {
    if (keyboardRipple) {
        keyboardRipple = false;
        rippleHide(e);
    }
}
function updateRipple(el, binding, wasEnabled) {
    const { value, modifiers } = binding;
    const enabled = isRippleEnabled(value);
    if (!enabled) ripples.hide(el);
    el._ripple = el._ripple ?? {};
    el._ripple.enabled = enabled;
    el._ripple.centered = modifiers.center;
    el._ripple.circle = modifiers.circle;
    if ((0, _indexMjs.isObject)(value) && value.class) el._ripple.class = value.class;
    if (enabled && !wasEnabled) {
        if (modifiers.stop) {
            el.addEventListener("touchstart", rippleStop, {
                passive: true
            });
            el.addEventListener("mousedown", rippleStop);
            return;
        }
        el.addEventListener("touchstart", rippleShow, {
            passive: true
        });
        el.addEventListener("touchend", rippleHide, {
            passive: true
        });
        el.addEventListener("touchmove", rippleCancelShow, {
            passive: true
        });
        el.addEventListener("touchcancel", rippleHide);
        el.addEventListener("mousedown", rippleShow);
        el.addEventListener("mouseup", rippleHide);
        el.addEventListener("mouseleave", rippleHide);
        el.addEventListener("keydown", keyboardRippleShow);
        el.addEventListener("keyup", keyboardRippleHide);
        el.addEventListener("blur", focusRippleHide);
        // Anchor tags can be dragged, causes other hides to fail - #1537
        el.addEventListener("dragstart", rippleHide, {
            passive: true
        });
    } else if (!enabled && wasEnabled) removeListeners(el);
}
function removeListeners(el) {
    el.removeEventListener("mousedown", rippleShow);
    el.removeEventListener("touchstart", rippleShow);
    el.removeEventListener("touchend", rippleHide);
    el.removeEventListener("touchmove", rippleCancelShow);
    el.removeEventListener("touchcancel", rippleHide);
    el.removeEventListener("mouseup", rippleHide);
    el.removeEventListener("mouseleave", rippleHide);
    el.removeEventListener("keydown", keyboardRippleShow);
    el.removeEventListener("keyup", keyboardRippleHide);
    el.removeEventListener("dragstart", rippleHide);
    el.removeEventListener("blur", focusRippleHide);
}
function mounted(el, binding) {
    updateRipple(el, binding, false);
}
function unmounted(el) {
    delete el._ripple;
    removeListeners(el);
}
function updated(el, binding) {
    if (binding.value === binding.oldValue) return;
    const wasEnabled = isRippleEnabled(binding.oldValue);
    updateRipple(el, binding, wasEnabled);
}
const Ripple = {
    mounted,
    unmounted,
    updated
};
exports.default = Ripple;

},{"./VRipple.css":"afYjg","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"afYjg":[function() {},{}],"7QLyL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAppBarTitle", ()=>VAppBarTitle);
var _vue = require("vue");
// Components
var _vtoolbarTitleMjs = require("../VToolbar/VToolbarTitle.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const VAppBarTitle = (0, _indexMjs.genericComponent)()({
    name: "VAppBarTitle",
    props: (0, _vtoolbarTitleMjs.makeVToolbarTitleProps)(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)((0, _vtoolbarTitleMjs.VToolbarTitle), (0, _vue.mergeProps)(props, {
                "class": "v-app-bar-title"
            }), slots));
        return {};
    }
});

},{"vue":"ff77s","../VToolbar/VToolbarTitle.mjs":"i8vFv","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bKic8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAlert", ()=>(0, _valertMjs.VAlert));
parcelHelpers.export(exports, "VAlertTitle", ()=>(0, _valertTitleMjs.VAlertTitle));
var _valertMjs = require("./VAlert.mjs");
var _valertTitleMjs = require("./VAlertTitle.mjs");

},{"./VAlert.mjs":"6rYDn","./VAlertTitle.mjs":"e5rf8","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6rYDn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAlertProps", ()=>makeVAlertProps);
parcelHelpers.export(exports, "VAlert", ()=>VAlert);
var _vue = require("vue");
// Styles
var _valertCss = require("./VAlert.css");
// Components
var _valertTitleMjs = require("./VAlertTitle.mjs");
var _indexMjs = require("../VBtn/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VIcon/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const allowedTypes = [
    "success",
    "info",
    "warning",
    "error"
];
const makeVAlertProps = (0, _indexMjs3.propsFactory)({
    border: {
        type: [
            Boolean,
            String
        ],
        validator: (val)=>{
            return typeof val === "boolean" || [
                "top",
                "end",
                "bottom",
                "start"
            ].includes(val);
        }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$close"
    },
    closeLabel: {
        type: String,
        default: "$vuetify.close"
    },
    icon: {
        type: [
            Boolean,
            String,
            Function,
            Object
        ],
        default: null
    },
    modelValue: {
        type: Boolean,
        default: true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
        type: String,
        validator: (val)=>allowedTypes.includes(val)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _locationMjs.makeLocationProps)(),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "flat"
    })
}, "VAlert");
const VAlert = (0, _indexMjs3.genericComponent)()({
    name: "VAlert",
    props: makeVAlertProps(),
    emits: {
        "click:close": (e)=>true,
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { emit, slots } = _ref;
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const icon = (0, _vue.computed)(()=>{
            if (props.icon === false) return undefined;
            if (!props.type) return props.icon;
            return props.icon ?? `$${props.type}`;
        });
        const variantProps = (0, _vue.computed)(()=>({
                color: props.color ?? props.type,
                variant: props.variant
            }));
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(variantProps);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "borderColor"));
        const { t } = (0, _localeMjs.useLocale)();
        const closeProps = (0, _vue.computed)(()=>({
                "aria-label": t(props.closeLabel),
                onClick (e) {
                    isActive.value = false;
                    emit("click:close", e);
                }
            }));
        return ()=>{
            const hasPrepend = !!(slots.prepend || icon.value);
            const hasTitle = !!(slots.title || props.title);
            const hasClose = !!(slots.close || props.closable);
            return isActive.value && (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-alert",
                    props.border && {
                        "v-alert--border": !!props.border,
                        [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
                    },
                    {
                        "v-alert--prominent": props.prominent
                    },
                    themeClasses.value,
                    colorClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    positionClasses.value,
                    roundedClasses.value,
                    variantClasses.value,
                    props.class
                ],
                "style": [
                    colorStyles.value,
                    dimensionStyles.value,
                    locationStyles.value,
                    props.style
                ],
                "role": "alert"
            }, {
                default: ()=>[
                        (0, _variantMjs.genOverlays)(false, "v-alert"),
                        props.border && (0, _vue.createVNode)("div", {
                            "key": "border",
                            "class": [
                                "v-alert__border",
                                textColorClasses.value
                            ],
                            "style": textColorStyles.value
                        }, null),
                        hasPrepend && (0, _vue.createVNode)("div", {
                            "key": "prepend",
                            "class": "v-alert__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _indexMjs2.VIcon), {
                                "key": "prepend-icon",
                                "density": props.density,
                                "icon": icon.value,
                                "size": props.prominent ? 44 : 28
                            }, null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !icon.value,
                                "defaults": {
                                    VIcon: {
                                        density: props.density,
                                        icon: icon.value,
                                        size: props.prominent ? 44 : 28
                                    }
                                }
                            }, slots.prepend)
                        ]),
                        (0, _vue.createVNode)("div", {
                            "class": "v-alert__content"
                        }, [
                            hasTitle && (0, _vue.createVNode)((0, _valertTitleMjs.VAlertTitle), {
                                "key": "title"
                            }, {
                                default: ()=>[
                                        slots.title?.() ?? props.title
                                    ]
                            }),
                            slots.text?.() ?? props.text,
                            slots.default?.()
                        ]),
                        slots.append && (0, _vue.createVNode)("div", {
                            "key": "append",
                            "class": "v-alert__append"
                        }, [
                            slots.append()
                        ]),
                        hasClose && (0, _vue.createVNode)("div", {
                            "key": "close",
                            "class": "v-alert__close"
                        }, [
                            !slots.close ? (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                "key": "close-btn",
                                "icon": props.closeIcon,
                                "size": "x-small",
                                "variant": "text"
                            }, closeProps.value), null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "close-defaults",
                                "defaults": {
                                    VBtn: {
                                        icon: props.closeIcon,
                                        size: "x-small",
                                        variant: "text"
                                    }
                                }
                            }, {
                                default: ()=>[
                                        slots.close?.({
                                            props: closeProps.value
                                        })
                                    ]
                            })
                        ])
                    ]
            });
        };
    }
});

},{"vue":"ff77s","./VAlert.css":"guaOg","./VAlertTitle.mjs":"e5rf8","../VBtn/index.mjs":"7xV1x","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/proxiedModel.mjs":"bUF28","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"guaOg":[function() {},{}],"e5rf8":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAlertTitle", ()=>VAlertTitle);
var _indexMjs = require("../../util/index.mjs");
const VAlertTitle = (0, _indexMjs.createSimpleFunctional)("v-alert-title");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7xV1x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBtn", ()=>(0, _vbtnMjs.VBtn));
var _vbtnMjs = require("./VBtn.mjs");

},{"./VBtn.mjs":"ewnpF","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"abO3K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAutocomplete", ()=>(0, _vautocompleteMjs.VAutocomplete));
var _vautocompleteMjs = require("./VAutocomplete.mjs");

},{"./VAutocomplete.mjs":"k3jB3","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"k3jB3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAutocompleteProps", ()=>makeVAutocompleteProps);
parcelHelpers.export(exports, "VAutocomplete", ()=>VAutocomplete);
var _vue = require("vue");
// Styles
var _vautocompleteCss = require("./VAutocomplete.css");
// Components
var _indexMjs = require("../VCheckbox/index.mjs");
var _indexMjs1 = require("../VChip/index.mjs");
var _indexMjs2 = require("../VDefaultsProvider/index.mjs");
var _indexMjs3 = require("../VIcon/index.mjs");
var _indexMjs4 = require("../VList/index.mjs");
var _indexMjs5 = require("../VMenu/index.mjs");
var _vselectMjs = require("../VSelect/VSelect.mjs");
var _vtextFieldMjs = require("../VTextField/VTextField.mjs");
var _indexMjs6 = require("../VVirtualScroll/index.mjs"); // Composables
var _useScrollingMjs = require("../VSelect/useScrolling.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _filterMjs = require("../../composables/filter.mjs");
var _formMjs = require("../../composables/form.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _listItemsMjs = require("../../composables/list-items.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs7 = require("../../util/index.mjs"); // Types
function highlightResult(text, matches, length) {
    if (matches == null) return text;
    if (Array.isArray(matches)) throw new Error("Multiple matches is not implemented");
    return typeof matches === "number" && ~matches ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
        (0, _vue.createVNode)("span", {
            "class": "v-autocomplete__unmask"
        }, [
            text.substr(0, matches)
        ]),
        (0, _vue.createVNode)("span", {
            "class": "v-autocomplete__mask"
        }, [
            text.substr(matches, length)
        ]),
        (0, _vue.createVNode)("span", {
            "class": "v-autocomplete__unmask"
        }, [
            text.substr(matches + length)
        ])
    ]) : text;
}
const makeVAutocompleteProps = (0, _indexMjs7.propsFactory)({
    autoSelectFirst: {
        type: [
            Boolean,
            String
        ]
    },
    search: String,
    ...(0, _filterMjs.makeFilterProps)({
        filterKeys: [
            "title"
        ]
    }),
    ...(0, _vselectMjs.makeSelectProps)(),
    ...(0, _indexMjs7.omit)((0, _vtextFieldMjs.makeVTextFieldProps)({
        modelValue: null,
        role: "combobox"
    }), [
        "validationValue",
        "dirty",
        "appendInnerIcon"
    ]),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: false
    })
}, "VAutocomplete");
const VAutocomplete = (0, _indexMjs7.genericComponent)()({
    name: "VAutocomplete",
    props: makeVAutocompleteProps(),
    emits: {
        "update:focused": (focused)=>true,
        "update:search": (val)=>true,
        "update:modelValue": (val)=>true,
        "update:menu": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const vTextFieldRef = (0, _vue.ref)();
        const isFocused = (0, _vue.shallowRef)(false);
        const isPristine = (0, _vue.shallowRef)(true);
        const listHasFocus = (0, _vue.shallowRef)(false);
        const vMenuRef = (0, _vue.ref)();
        const vVirtualScrollRef = (0, _vue.ref)();
        const _menu = (0, _proxiedModelMjs.useProxiedModel)(props, "menu");
        const menu = (0, _vue.computed)({
            get: ()=>_menu.value,
            set: (v)=>{
                if (_menu.value && !v && vMenuRef.value?.Œ®openChildren) return;
                _menu.value = v;
            }
        });
        const selectionIndex = (0, _vue.shallowRef)(-1);
        const color = (0, _vue.computed)(()=>vTextFieldRef.value?.color);
        const label = (0, _vue.computed)(()=>menu.value ? props.closeText : props.openText);
        const { items, transformIn, transformOut } = (0, _listItemsMjs.useItems)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)(color);
        const search = (0, _proxiedModelMjs.useProxiedModel)(props, "search", "");
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", [], (v)=>transformIn(v === null ? [
                null
            ] : (0, _indexMjs7.wrapInArray)(v)), (v)=>{
            const transformed = transformOut(v);
            return props.multiple ? transformed : transformed[0] ?? null;
        });
        const form = (0, _formMjs.useForm)();
        const { filteredItems, getMatches } = (0, _filterMjs.useFilter)(props, items, ()=>isPristine.value ? "" : search.value);
        const displayItems = (0, _vue.computed)(()=>{
            if (props.hideSelected) return filteredItems.value.filter((filteredItem)=>!model.value.some((s)=>s.value === filteredItem.value));
            return filteredItems.value;
        });
        const selectedValues = (0, _vue.computed)(()=>model.value.map((selection)=>selection.props.value));
        const highlightFirst = (0, _vue.computed)(()=>{
            const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === displayItems.value[0]?.title;
            return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = (0, _vue.computed)(()=>props.hideNoData && !items.value.length || props.readonly || form?.isReadonly.value);
        const listRef = (0, _vue.ref)();
        const { onListScroll, onListKeydown } = (0, _useScrollingMjs.useScrolling)(listRef, vTextFieldRef);
        function onClear(e) {
            if (props.openOnClear) menu.value = true;
            search.value = "";
        }
        function onMousedownControl() {
            if (menuDisabled.value) return;
            menu.value = true;
        }
        function onMousedownMenuIcon(e) {
            if (menuDisabled.value) return;
            if (isFocused.value) {
                e.preventDefault();
                e.stopPropagation();
            }
            menu.value = !menu.value;
        }
        function onKeydown(e) {
            if (props.readonly || form?.isReadonly.value) return;
            const selectionStart = vTextFieldRef.value.selectionStart;
            const length = model.value.length;
            if (selectionIndex.value > -1 || [
                "Enter",
                "ArrowDown",
                "ArrowUp"
            ].includes(e.key)) e.preventDefault();
            if ([
                "Enter",
                "ArrowDown"
            ].includes(e.key)) menu.value = true;
            if ([
                "Escape"
            ].includes(e.key)) menu.value = false;
            if (highlightFirst.value && [
                "Enter",
                "Tab"
            ].includes(e.key)) select(displayItems.value[0]);
            if (e.key === "ArrowDown" && highlightFirst.value) listRef.value?.focus("next");
            if (!props.multiple) return;
            if ([
                "Backspace",
                "Delete"
            ].includes(e.key)) {
                if (selectionIndex.value < 0) {
                    if (e.key === "Backspace" && !search.value) selectionIndex.value = length - 1;
                    return;
                }
                const originalSelectionIndex = selectionIndex.value;
                const selectedItem = model.value[selectionIndex.value];
                if (selectedItem) select(selectedItem);
                selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
            }
            if (e.key === "ArrowLeft") {
                if (selectionIndex.value < 0 && selectionStart > 0) return;
                const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
                if (model.value[prev]) selectionIndex.value = prev;
                else {
                    selectionIndex.value = -1;
                    vTextFieldRef.value.setSelectionRange(search.value?.length, search.value?.length);
                }
            }
            if (e.key === "ArrowRight") {
                if (selectionIndex.value < 0) return;
                const next = selectionIndex.value + 1;
                if (model.value[next]) selectionIndex.value = next;
                else {
                    selectionIndex.value = -1;
                    vTextFieldRef.value.setSelectionRange(0, 0);
                }
            }
        }
        function onInput(e) {
            search.value = e.target.value;
        }
        function onChange(e) {
            if ((0, _indexMjs7.matchesSelector)(vTextFieldRef.value, ":autofill") || (0, _indexMjs7.matchesSelector)(vTextFieldRef.value, ":-webkit-autofill")) {
                const item = items.value.find((item)=>item.title === e.target.value);
                if (item) select(item);
            }
        }
        function onAfterLeave() {
            if (isFocused.value) {
                isPristine.value = true;
                vTextFieldRef.value?.focus();
            }
        }
        function onFocusin(e) {
            isFocused.value = true;
            setTimeout(()=>{
                listHasFocus.value = true;
            });
        }
        function onFocusout(e) {
            listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
            if (v == null || v === "" && !props.multiple) model.value = [];
        }
        const isSelecting = (0, _vue.shallowRef)(false);
        function select(item) {
            if (props.multiple) {
                const index = model.value.findIndex((selection)=>props.valueComparator(selection.value, item.value));
                if (index === -1) model.value = [
                    ...model.value,
                    item
                ];
                else {
                    const value = [
                        ...model.value
                    ];
                    value.splice(index, 1);
                    model.value = value;
                }
            } else {
                model.value = [
                    item
                ];
                isSelecting.value = true;
                search.value = item.title;
                menu.value = false;
                isPristine.value = true;
                (0, _vue.nextTick)(()=>isSelecting.value = false);
            }
        }
        (0, _vue.watch)(isFocused, (val, oldVal)=>{
            if (val === oldVal) return;
            if (val) {
                isSelecting.value = true;
                search.value = props.multiple ? "" : String(model.value.at(-1)?.props.title ?? "");
                isPristine.value = true;
                (0, _vue.nextTick)(()=>isSelecting.value = false);
            } else {
                if (!props.multiple && !search.value) model.value = [];
                else if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2)=>{
                    let { value } = _ref2;
                    return value === displayItems.value[0].value;
                })) select(displayItems.value[0]);
                menu.value = false;
                search.value = "";
                selectionIndex.value = -1;
            }
        });
        (0, _vue.watch)(search, (val)=>{
            if (!isFocused.value || isSelecting.value) return;
            if (val) menu.value = true;
            isPristine.value = !val;
        });
        (0, _vue.watch)(menu, ()=>{
            if (!props.hideSelected && menu.value && model.value.length) {
                const index = displayItems.value.findIndex((item)=>model.value.some((s)=>item.value === s.value));
                (0, _indexMjs7.IN_BROWSER) && window.requestAnimationFrame(()=>{
                    index >= 0 && vVirtualScrollRef.value?.scrollToIndex(index);
                });
            }
        });
        (0, _indexMjs7.useRender)(()=>{
            const hasChips = !!(props.chips || slots.chip);
            const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
            const isDirty = model.value.length > 0;
            const [textFieldProps] = (0, _vtextFieldMjs.VTextField).filterProps(props);
            return (0, _vue.createVNode)((0, _vtextFieldMjs.VTextField), (0, _vue.mergeProps)({
                "ref": vTextFieldRef
            }, textFieldProps, {
                "modelValue": search.value,
                "onUpdate:modelValue": onUpdateModelValue,
                "focused": isFocused.value,
                "onUpdate:focused": ($event)=>isFocused.value = $event,
                "validationValue": model.externalValue,
                "dirty": isDirty,
                "onInput": onInput,
                "onChange": onChange,
                "class": [
                    "v-autocomplete",
                    `v-autocomplete--${props.multiple ? "multiple" : "single"}`,
                    {
                        "v-autocomplete--active-menu": menu.value,
                        "v-autocomplete--chips": !!props.chips,
                        "v-autocomplete--selection-slot": !!slots.selection,
                        "v-autocomplete--selecting-index": selectionIndex.value > -1
                    },
                    props.class
                ],
                "style": props.style,
                "readonly": props.readonly,
                "placeholder": isDirty ? undefined : props.placeholder,
                "onClick:clear": onClear,
                "onMousedown:control": onMousedownControl,
                "onKeydown": onKeydown
            }), {
                ...slots,
                default: ()=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        (0, _vue.createVNode)((0, _indexMjs5.VMenu), (0, _vue.mergeProps)({
                            "ref": vMenuRef,
                            "modelValue": menu.value,
                            "onUpdate:modelValue": ($event)=>menu.value = $event,
                            "activator": "parent",
                            "contentClass": "v-autocomplete__content",
                            "disabled": menuDisabled.value,
                            "eager": props.eager,
                            "maxHeight": 310,
                            "openOnClick": false,
                            "closeOnContentClick": false,
                            "transition": props.transition,
                            "onAfterLeave": onAfterLeave
                        }, props.menuProps), {
                            default: ()=>[
                                    hasList && (0, _vue.createVNode)((0, _indexMjs4.VList), {
                                        "ref": listRef,
                                        "selected": selectedValues.value,
                                        "selectStrategy": props.multiple ? "independent" : "single-independent",
                                        "onMousedown": (e)=>e.preventDefault(),
                                        "onKeydown": onListKeydown,
                                        "onFocusin": onFocusin,
                                        "onFocusout": onFocusout,
                                        "onScrollPassive": onListScroll,
                                        "tabindex": "-1",
                                        "color": props.itemColor ?? props.color
                                    }, {
                                        default: ()=>[
                                                slots["prepend-item"]?.(),
                                                !displayItems.value.length && !props.hideNoData && (slots["no-data"]?.() ?? (0, _vue.createVNode)((0, _indexMjs4.VListItem), {
                                                    "title": t(props.noDataText)
                                                }, null)),
                                                (0, _vue.createVNode)((0, _indexMjs6.VVirtualScroll), {
                                                    "ref": vVirtualScrollRef,
                                                    "renderless": true,
                                                    "items": displayItems.value
                                                }, {
                                                    default: (_ref3)=>{
                                                        let { item, index, itemRef } = _ref3;
                                                        const itemProps = (0, _vue.mergeProps)(item.props, {
                                                            ref: itemRef,
                                                            key: index,
                                                            active: highlightFirst.value && index === 0 ? true : undefined,
                                                            onClick: ()=>select(item)
                                                        });
                                                        return slots.item?.({
                                                            item,
                                                            index,
                                                            props: itemProps
                                                        }) ?? (0, _vue.createVNode)((0, _indexMjs4.VListItem), itemProps, {
                                                            prepend: (_ref4)=>{
                                                                let { isSelected } = _ref4;
                                                                return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                                                    props.multiple && !props.hideSelected ? (0, _vue.createVNode)((0, _indexMjs.VCheckboxBtn), {
                                                                        "key": item.value,
                                                                        "modelValue": isSelected,
                                                                        "ripple": false,
                                                                        "tabindex": "-1"
                                                                    }, null) : undefined,
                                                                    item.props.prependIcon && (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                                                        "icon": item.props.prependIcon
                                                                    }, null)
                                                                ]);
                                                            },
                                                            title: ()=>{
                                                                return isPristine.value ? item.title : highlightResult(item.title, getMatches(item)?.title, search.value?.length ?? 0);
                                                            }
                                                        });
                                                    }
                                                }),
                                                slots["append-item"]?.()
                                            ]
                                    })
                                ]
                        }),
                        model.value.map((item, index)=>{
                            function onChipClose(e) {
                                e.stopPropagation();
                                e.preventDefault();
                                select(item);
                            }
                            const slotProps = {
                                "onClick:close": onChipClose,
                                onMousedown (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                },
                                modelValue: true,
                                "onUpdate:modelValue": undefined
                            };
                            return (0, _vue.createVNode)("div", {
                                "key": item.value,
                                "class": [
                                    "v-autocomplete__selection",
                                    index === selectionIndex.value && [
                                        "v-autocomplete__selection--selected",
                                        textColorClasses.value
                                    ]
                                ],
                                "style": index === selectionIndex.value ? textColorStyles.value : {}
                            }, [
                                hasChips ? !slots.chip ? (0, _vue.createVNode)((0, _indexMjs1.VChip), (0, _vue.mergeProps)({
                                    "key": "chip",
                                    "closable": props.closableChips,
                                    "size": "small",
                                    "text": item.title
                                }, slotProps), null) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                    "key": "chip-defaults",
                                    "defaults": {
                                        VChip: {
                                            closable: props.closableChips,
                                            size: "small",
                                            text: item.title
                                        }
                                    }
                                }, {
                                    default: ()=>[
                                            slots.chip?.({
                                                item,
                                                index,
                                                props: slotProps
                                            })
                                        ]
                                }) : slots.selection?.({
                                    item,
                                    index
                                }) ?? (0, _vue.createVNode)("span", {
                                    "class": "v-autocomplete__selection-text"
                                }, [
                                    item.title,
                                    props.multiple && index < model.value.length - 1 && (0, _vue.createVNode)("span", {
                                        "class": "v-autocomplete__selection-comma"
                                    }, [
                                        (0, _vue.createTextVNode)(",")
                                    ])
                                ])
                            ]);
                        })
                    ]),
                "append-inner": function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots["append-inner"]?.(...args),
                        props.menuIcon ? (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                            "class": "v-autocomplete__menu-icon",
                            "icon": props.menuIcon,
                            "onMousedown": onMousedownMenuIcon,
                            "onClick": (0, _indexMjs7.noop),
                            "aria-label": t(label.value),
                            "title": t(label.value)
                        }, null) : undefined
                    ]);
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({
            isFocused,
            isPristine,
            menu,
            search,
            filteredItems,
            select
        }, vTextFieldRef);
    }
});

},{"vue":"ff77s","./VAutocomplete.css":"dnX8x","../VCheckbox/index.mjs":"2g3Bq","../VChip/index.mjs":"9w6oh","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../VList/index.mjs":"1md2l","../VMenu/index.mjs":"fYY6u","../VSelect/VSelect.mjs":"dHfP6","../VTextField/VTextField.mjs":"4p33J","../VVirtualScroll/index.mjs":"7IUqN","../VSelect/useScrolling.mjs":"fZNsR","../../composables/color.mjs":"4pLYX","../../composables/filter.mjs":"fMXi2","../../composables/form.mjs":"Jb6Pn","../../composables/forwardRefs.mjs":"h5grs","../../composables/list-items.mjs":"kVtgo","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dnX8x":[function() {},{}],"2g3Bq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCheckbox", ()=>(0, _vcheckboxMjs.VCheckbox));
parcelHelpers.export(exports, "VCheckboxBtn", ()=>(0, _vcheckboxBtnMjs.VCheckboxBtn));
var _vcheckboxMjs = require("./VCheckbox.mjs");
var _vcheckboxBtnMjs = require("./VCheckboxBtn.mjs");

},{"./VCheckbox.mjs":"jSEAM","./VCheckboxBtn.mjs":"78xuT","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jSEAM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCheckboxProps", ()=>makeVCheckboxProps);
parcelHelpers.export(exports, "VCheckbox", ()=>VCheckbox);
var _vue = require("vue");
// Styles
var _vcheckboxCss = require("./VCheckbox.css");
// Components
var _vcheckboxBtnMjs = require("./VCheckboxBtn.mjs");
var _vinputMjs = require("../VInput/VInput.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVCheckboxProps = (0, _indexMjs.propsFactory)({
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _indexMjs.omit)((0, _vcheckboxBtnMjs.makeVCheckboxBtnProps)(), [
        "inline"
    ])
}, "VCheckbox");
const VCheckbox = (0, _indexMjs.genericComponent)()({
    name: "VCheckbox",
    inheritAttrs: false,
    props: makeVCheckboxProps(),
    emits: {
        "update:modelValue": (value)=>true,
        "update:focused": (focused)=>true
    },
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const uid = (0, _indexMjs.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `checkbox-${uid}`);
        (0, _indexMjs.useRender)(()=>{
            const [rootAttrs, controlAttrs] = (0, _indexMjs.filterInputAttrs)(attrs);
            const [inputProps, _1] = (0, _vinputMjs.VInput).filterProps(props);
            const [checkboxProps, _2] = (0, _vcheckboxBtnMjs.VCheckboxBtn).filterProps(props);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "class": [
                    "v-checkbox",
                    props.class
                ]
            }, rootAttrs, inputProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "id": id.value,
                "focused": isFocused.value,
                "style": props.style
            }), {
                ...slots,
                default: (_ref2)=>{
                    let { id, messagesId, isDisabled, isReadonly } = _ref2;
                    return (0, _vue.createVNode)((0, _vcheckboxBtnMjs.VCheckboxBtn), (0, _vue.mergeProps)(checkboxProps, {
                        "id": id.value,
                        "aria-describedby": messagesId.value,
                        "disabled": isDisabled.value,
                        "readonly": isReadonly.value
                    }, controlAttrs, {
                        "modelValue": model.value,
                        "onUpdate:modelValue": ($event)=>model.value = $event,
                        "onFocus": focus,
                        "onBlur": blur
                    }), slots);
                }
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VCheckbox.css":"f80Jt","./VCheckboxBtn.mjs":"78xuT","../VInput/VInput.mjs":"1hyGZ","../../composables/focus.mjs":"1bQxY","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"f80Jt":[function() {},{}],"78xuT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCheckboxBtnProps", ()=>makeVCheckboxBtnProps);
parcelHelpers.export(exports, "VCheckboxBtn", ()=>VCheckboxBtn);
var _vue = require("vue");
// Components
var _vselectionControlMjs = require("../VSelectionControl/VSelectionControl.mjs"); // Composables
var _iconsMjs = require("../../composables/icons.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVCheckboxBtnProps = (0, _indexMjs.propsFactory)({
    indeterminate: Boolean,
    indeterminateIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$checkboxIndeterminate"
    },
    ...(0, _vselectionControlMjs.makeVSelectionControlProps)({
        falseIcon: "$checkboxOff",
        trueIcon: "$checkboxOn"
    })
}, "VCheckboxBtn");
const VCheckboxBtn = (0, _indexMjs.genericComponent)()({
    name: "VCheckboxBtn",
    props: makeVCheckboxBtnProps(),
    emits: {
        "update:modelValue": (value)=>true,
        "update:indeterminate": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const indeterminate = (0, _proxiedModelMjs.useProxiedModel)(props, "indeterminate");
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        function onChange(v) {
            if (indeterminate.value) indeterminate.value = false;
        }
        const falseIcon = (0, _vue.computed)(()=>{
            return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
        });
        const trueIcon = (0, _vue.computed)(()=>{
            return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
        });
        (0, _indexMjs.useRender)(()=>{
            const controlProps = (0, _indexMjs.omit)((0, _vselectionControlMjs.VSelectionControl).filterProps(props)[0], [
                "modelValue"
            ]);
            return (0, _vue.createVNode)((0, _vselectionControlMjs.VSelectionControl), (0, _vue.mergeProps)(controlProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": [
                    ($event)=>model.value = $event,
                    onChange
                ],
                "class": [
                    "v-checkbox-btn",
                    props.class
                ],
                "style": props.style,
                "type": "checkbox",
                "falseIcon": falseIcon.value,
                "trueIcon": trueIcon.value,
                "aria-checked": indeterminate.value ? "mixed" : undefined
            }), slots);
        });
        return {};
    }
});

},{"vue":"ff77s","../VSelectionControl/VSelectionControl.mjs":"1j5Xu","../../composables/icons.mjs":"ezwoc","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1j5Xu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSelectionControlProps", ()=>makeVSelectionControlProps);
parcelHelpers.export(exports, "useSelectionControl", ()=>useSelectionControl);
parcelHelpers.export(exports, "VSelectionControl", ()=>VSelectionControl);
var _vue = require("vue");
// Styles
var _vselectionControlCss = require("./VSelectionControl.css");
// Components
var _indexMjs = require("../VIcon/index.mjs");
var _indexMjs1 = require("../VLabel/index.mjs");
var _vselectionControlGroupMjs = require("../VSelectionControlGroup/VSelectionControlGroup.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Directives
var _indexMjs2 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVSelectionControlProps = (0, _indexMjs3.propsFactory)({
    label: String,
    trueValue: null,
    falseValue: null,
    value: null,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _vselectionControlGroupMjs.makeSelectionControlGroupProps)()
}, "VSelectionControl");
function useSelectionControl(props) {
    const group = (0, _vue.inject)((0, _vselectionControlGroupMjs.VSelectionControlGroupSymbol), undefined);
    const { densityClasses } = (0, _densityMjs.useDensity)(props);
    const modelValue = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
    const trueValue = (0, _vue.computed)(()=>props.trueValue !== undefined ? props.trueValue : props.value !== undefined ? props.value : true);
    const falseValue = (0, _vue.computed)(()=>props.falseValue !== undefined ? props.falseValue : false);
    const isMultiple = (0, _vue.computed)(()=>!!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
    const model = (0, _vue.computed)({
        get () {
            const val = group ? group.modelValue.value : modelValue.value;
            return isMultiple.value ? val.some((v)=>props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
        },
        set (val) {
            if (props.readonly) return;
            const currentValue = val ? trueValue.value : falseValue.value;
            let newVal = currentValue;
            if (isMultiple.value) newVal = val ? [
                ...(0, _indexMjs3.wrapInArray)(modelValue.value),
                currentValue
            ] : (0, _indexMjs3.wrapInArray)(modelValue.value).filter((item)=>!props.valueComparator(item, trueValue.value));
            if (group) group.modelValue.value = newVal;
            else modelValue.value = newVal;
        }
    });
    const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.computed)(()=>{
        return model.value && !props.error && !props.disabled ? props.color : undefined;
    }));
    const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.computed)(()=>{
        return model.value && !props.error && !props.disabled ? props.color : undefined;
    }));
    const icon = (0, _vue.computed)(()=>model.value ? props.trueIcon : props.falseIcon);
    return {
        group,
        densityClasses,
        trueValue,
        falseValue,
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        icon
    };
}
const VSelectionControl = (0, _indexMjs3.genericComponent)()({
    name: "VSelectionControl",
    directives: {
        Ripple: (0, _indexMjs2.Ripple)
    },
    inheritAttrs: false,
    props: makeVSelectionControlProps(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const { group, densityClasses, icon, model, textColorClasses, textColorStyles, backgroundColorClasses, backgroundColorStyles, trueValue } = useSelectionControl(props);
        const uid = (0, _indexMjs3.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `input-${uid}`);
        const isFocused = (0, _vue.shallowRef)(false);
        const isFocusVisible = (0, _vue.shallowRef)(false);
        const input = (0, _vue.ref)();
        group?.onForceUpdate(()=>{
            if (input.value) input.value.checked = model.value;
        });
        function onFocus(e) {
            isFocused.value = true;
            if ((0, _indexMjs3.matchesSelector)(e.target, ":focus-visible") !== false) isFocusVisible.value = true;
        }
        function onBlur() {
            isFocused.value = false;
            isFocusVisible.value = false;
        }
        function onInput(e) {
            if (props.readonly && group) (0, _vue.nextTick)(()=>group.forceUpdate());
            model.value = e.target.checked;
        }
        (0, _indexMjs3.useRender)(()=>{
            const label = slots.label ? slots.label({
                label: props.label,
                props: {
                    for: id.value
                }
            }) : props.label;
            const [rootAttrs, inputAttrs] = (0, _indexMjs3.filterInputAttrs)(attrs);
            const inputNode = (0, _vue.createVNode)("input", (0, _vue.mergeProps)({
                "ref": input,
                "checked": model.value,
                "disabled": !!(props.readonly || props.disabled),
                "id": id.value,
                "onBlur": onBlur,
                "onFocus": onFocus,
                "onInput": onInput,
                "aria-disabled": !!(props.readonly || props.disabled),
                "type": props.type,
                "value": trueValue.value,
                "name": props.name,
                "aria-checked": props.type === "checkbox" ? model.value : undefined
            }, inputAttrs), null);
            return (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                "class": [
                    "v-selection-control",
                    {
                        "v-selection-control--dirty": model.value,
                        "v-selection-control--disabled": props.disabled,
                        "v-selection-control--error": props.error,
                        "v-selection-control--focused": isFocused.value,
                        "v-selection-control--focus-visible": isFocusVisible.value,
                        "v-selection-control--inline": props.inline
                    },
                    densityClasses.value,
                    props.class
                ]
            }, rootAttrs, {
                "style": props.style
            }), [
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-selection-control__wrapper",
                        textColorClasses.value
                    ],
                    "style": textColorStyles.value
                }, [
                    slots.default?.({
                        backgroundColorClasses,
                        backgroundColorStyles
                    }),
                    (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                        "class": [
                            "v-selection-control__input"
                        ]
                    }, [
                        slots.input?.({
                            model,
                            textColorClasses,
                            textColorStyles,
                            backgroundColorClasses,
                            backgroundColorStyles,
                            inputNode,
                            icon: icon.value,
                            props: {
                                onFocus,
                                onBlur,
                                id: id.value
                            }
                        }) ?? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                            icon.value && (0, _vue.createVNode)((0, _indexMjs.VIcon), {
                                "key": "icon",
                                "icon": icon.value
                            }, null),
                            inputNode
                        ])
                    ]), [
                        [
                            (0, _vue.resolveDirective)("ripple"),
                            props.ripple && [
                                !props.disabled && !props.readonly,
                                null,
                                [
                                    "center",
                                    "circle"
                                ]
                            ]
                        ]
                    ])
                ]),
                label && (0, _vue.createVNode)((0, _indexMjs1.VLabel), {
                    "for": id.value,
                    "clickable": true,
                    "onClick": (e)=>e.stopPropagation()
                }, {
                    default: ()=>[
                            label
                        ]
                })
            ]);
        });
        return {
            isFocused,
            input
        };
    }
});

},{"vue":"ff77s","./VSelectionControl.css":"6ulT0","../VIcon/index.mjs":"2wJue","../VLabel/index.mjs":"cclAn","../VSelectionControlGroup/VSelectionControlGroup.mjs":"2SCkF","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/proxiedModel.mjs":"bUF28","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6ulT0":[function() {},{}],"cclAn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VLabel", ()=>(0, _vlabelMjs.VLabel));
var _vlabelMjs = require("./VLabel.mjs");

},{"./VLabel.mjs":"gmE2a","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gmE2a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVLabelProps", ()=>makeVLabelProps);
parcelHelpers.export(exports, "VLabel", ()=>VLabel);
var _vue = require("vue");
// Styles
var _vlabelCss = require("./VLabel.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVLabelProps = (0, _indexMjs.propsFactory)({
    text: String,
    clickable: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VLabel");
const VLabel = (0, _indexMjs.genericComponent)()({
    name: "VLabel",
    props: makeVLabelProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("label", {
                "class": [
                    "v-label",
                    {
                        "v-label--clickable": props.clickable
                    },
                    props.class
                ],
                "style": props.style
            }, [
                props.text,
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VLabel.css":"dS6q6","../../composables/component.mjs":"jVHld","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dS6q6":[function() {},{}],"2SCkF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSelectionControlGroupSymbol", ()=>VSelectionControlGroupSymbol);
parcelHelpers.export(exports, "makeSelectionControlGroupProps", ()=>makeSelectionControlGroupProps);
parcelHelpers.export(exports, "makeVSelectionControlGroupProps", ()=>makeVSelectionControlGroupProps);
parcelHelpers.export(exports, "VSelectionControlGroup", ()=>VSelectionControlGroup);
var _vue = require("vue");
// Styles
var _vselectionControlGroupCss = require("./VSelectionControlGroup.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
const makeSelectionControlGroupProps = (0, _indexMjs.propsFactory)({
    color: String,
    disabled: {
        type: Boolean,
        default: null
    },
    defaultsTarget: String,
    error: Boolean,
    id: String,
    inline: Boolean,
    falseIcon: (0, _iconsMjs.IconValue),
    trueIcon: (0, _iconsMjs.IconValue),
    ripple: {
        type: Boolean,
        default: true
    },
    multiple: {
        type: Boolean,
        default: null
    },
    name: String,
    readonly: Boolean,
    modelValue: null,
    type: String,
    valueComparator: {
        type: Function,
        default: (0, _indexMjs.deepEqual)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "SelectionControlGroup");
const makeVSelectionControlGroupProps = (0, _indexMjs.propsFactory)({
    ...makeSelectionControlGroupProps({
        defaultsTarget: "VSelectionControl"
    })
}, "VSelectionControlGroup");
const VSelectionControlGroup = (0, _indexMjs.genericComponent)()({
    name: "VSelectionControlGroup",
    props: makeVSelectionControlGroupProps(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const modelValue = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const uid = (0, _indexMjs.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `v-selection-control-group-${uid}`);
        const name = (0, _vue.computed)(()=>props.name || id.value);
        const updateHandlers = new Set();
        (0, _vue.provide)(VSelectionControlGroupSymbol, {
            modelValue,
            forceUpdate: ()=>{
                updateHandlers.forEach((fn)=>fn());
            },
            onForceUpdate: (cb)=>{
                updateHandlers.add(cb);
                (0, _vue.onScopeDispose)(()=>{
                    updateHandlers.delete(cb);
                });
            }
        });
        (0, _defaultsMjs.provideDefaults)({
            [props.defaultsTarget]: {
                color: (0, _vue.toRef)(props, "color"),
                disabled: (0, _vue.toRef)(props, "disabled"),
                density: (0, _vue.toRef)(props, "density"),
                error: (0, _vue.toRef)(props, "error"),
                inline: (0, _vue.toRef)(props, "inline"),
                modelValue,
                multiple: (0, _vue.computed)(()=>!!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
                name,
                falseIcon: (0, _vue.toRef)(props, "falseIcon"),
                trueIcon: (0, _vue.toRef)(props, "trueIcon"),
                readonly: (0, _vue.toRef)(props, "readonly"),
                ripple: (0, _vue.toRef)(props, "ripple"),
                type: (0, _vue.toRef)(props, "type"),
                valueComparator: (0, _vue.toRef)(props, "valueComparator")
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-selection-control-group",
                    {
                        "v-selection-control-group--inline": props.inline
                    },
                    props.class
                ],
                "style": props.style,
                "role": props.type === "radio" ? "radiogroup" : undefined
            }, [
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VSelectionControlGroup.css":"dsg9R","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../composables/proxiedModel.mjs":"bUF28","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dsg9R":[function() {},{}],"1hyGZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVInputProps", ()=>makeVInputProps);
parcelHelpers.export(exports, "VInput", ()=>VInput);
var _vue = require("vue");
// Styles
var _vinputCss = require("./VInput.css");
// Components
var _inputIconMjs = require("./InputIcon.mjs");
var _vmessagesMjs = require("../VMessages/VMessages.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _validationMjs = require("../../composables/validation.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVInputProps = (0, _indexMjs.propsFactory)({
    id: String,
    appendIcon: (0, _iconsMjs.IconValue),
    centerAffix: {
        type: Boolean,
        default: true
    },
    prependIcon: (0, _iconsMjs.IconValue),
    hideDetails: [
        Boolean,
        String
    ],
    hint: String,
    persistentHint: Boolean,
    messages: {
        type: [
            Array,
            String
        ],
        default: ()=>[]
    },
    direction: {
        type: String,
        default: "horizontal",
        validator: (v)=>[
                "horizontal",
                "vertical"
            ].includes(v)
    },
    "onClick:prepend": (0, _indexMjs.EventProp)(),
    "onClick:append": (0, _indexMjs.EventProp)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _validationMjs.makeValidationProps)()
}, "VInput");
const VInput = (0, _indexMjs.genericComponent)()({
    name: "VInput",
    props: {
        ...makeVInputProps()
    },
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, slots, emit } = _ref;
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        const { InputIcon } = (0, _inputIconMjs.useInputIcon)(props);
        const uid = (0, _indexMjs.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `input-${uid}`);
        const messagesId = (0, _vue.computed)(()=>`${id.value}-messages`);
        const { errorMessages, isDirty, isDisabled, isReadonly, isPristine, isValid, isValidating, reset, resetValidation, validate, validationClasses } = (0, _validationMjs.useValidation)(props, "v-input", id);
        const slotProps = (0, _vue.computed)(()=>({
                id,
                messagesId,
                isDirty,
                isDisabled,
                isReadonly,
                isPristine,
                isValid,
                isValidating,
                reset,
                resetValidation,
                validate
            }));
        const messages = (0, _vue.computed)(()=>{
            if (props.errorMessages?.length || !isPristine.value && errorMessages.value.length) return errorMessages.value;
            else if (props.hint && (props.persistentHint || props.focused)) return props.hint;
            else return props.messages;
        });
        (0, _indexMjs.useRender)(()=>{
            const hasPrepend = !!(slots.prepend || props.prependIcon);
            const hasAppend = !!(slots.append || props.appendIcon);
            const hasMessages = messages.value.length > 0;
            const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
            return (0, _vue.createVNode)("div", {
                "class": [
                    "v-input",
                    `v-input--${props.direction}`,
                    {
                        "v-input--center-affix": props.centerAffix
                    },
                    densityClasses.value,
                    rtlClasses.value,
                    validationClasses.value,
                    props.class
                ],
                "style": props.style
            }, [
                hasPrepend && (0, _vue.createVNode)("div", {
                    "key": "prepend",
                    "class": "v-input__prepend"
                }, [
                    slots.prepend?.(slotProps.value),
                    props.prependIcon && (0, _vue.createVNode)(InputIcon, {
                        "key": "prepend-icon",
                        "name": "prepend"
                    }, null)
                ]),
                slots.default && (0, _vue.createVNode)("div", {
                    "class": "v-input__control"
                }, [
                    slots.default?.(slotProps.value)
                ]),
                hasAppend && (0, _vue.createVNode)("div", {
                    "key": "append",
                    "class": "v-input__append"
                }, [
                    props.appendIcon && (0, _vue.createVNode)(InputIcon, {
                        "key": "append-icon",
                        "name": "append"
                    }, null),
                    slots.append?.(slotProps.value)
                ]),
                hasDetails && (0, _vue.createVNode)("div", {
                    "class": "v-input__details"
                }, [
                    (0, _vue.createVNode)((0, _vmessagesMjs.VMessages), {
                        "id": messagesId.value,
                        "active": hasMessages,
                        "messages": messages.value
                    }, {
                        message: slots.message
                    }),
                    slots.details?.(slotProps.value)
                ])
            ]);
        });
        return {
            reset,
            resetValidation,
            validate
        };
    }
});

},{"vue":"ff77s","./VInput.css":"fYNsD","./InputIcon.mjs":"161oe","../VMessages/VMessages.mjs":"9A74R","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/validation.mjs":"1xYwD","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fYNsD":[function() {},{}],"161oe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useInputIcon", ()=>useInputIcon);
var _vue = require("vue");
// Components
var _indexMjs = require("../VIcon/index.mjs"); // Composables
var _localeMjs = require("../../composables/locale.mjs"); // Types
function useInputIcon(props) {
    const { t } = (0, _localeMjs.useLocale)();
    function InputIcon(_ref) {
        let { name } = _ref;
        const localeKey = {
            prepend: "prependAction",
            prependInner: "prependAction",
            append: "appendAction",
            appendInner: "appendAction",
            clear: "clear"
        }[name];
        const listener = props[`onClick:${name}`];
        const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props.label ?? "") : undefined;
        return (0, _vue.createVNode)((0, _indexMjs.VIcon), {
            "icon": props[`${name}Icon`],
            "aria-label": label,
            "onClick": listener
        }, null);
    }
    return {
        InputIcon
    };
}

},{"vue":"ff77s","../VIcon/index.mjs":"2wJue","../../composables/locale.mjs":"4MZbL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9A74R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVMessagesProps", ()=>makeVMessagesProps);
parcelHelpers.export(exports, "VMessages", ()=>VMessages);
var _vue = require("vue");
// Styles
var _vmessagesCss = require("./VMessages.css");
// Components
var _indexMjs = require("../transitions/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVMessagesProps = (0, _indexMjs1.propsFactory)({
    active: Boolean,
    color: String,
    messages: {
        type: [
            Array,
            String
        ],
        default: ()=>[]
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: {
            component: (0, _indexMjs.VSlideYTransition),
            leaveAbsolute: true,
            group: true
        }
    })
}, "VMessages");
const VMessages = (0, _indexMjs1.genericComponent)()({
    name: "VMessages",
    props: makeVMessagesProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const messages = (0, _vue.computed)(()=>(0, _indexMjs1.wrapInArray)(props.messages));
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.computed)(()=>props.color));
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition,
                "tag": "div",
                "class": [
                    "v-messages",
                    textColorClasses.value,
                    props.class
                ],
                "style": [
                    textColorStyles.value,
                    props.style
                ],
                "role": "alert",
                "aria-live": "polite"
            }, {
                default: ()=>[
                        props.active && messages.value.map((message, i)=>(0, _vue.createVNode)("div", {
                                "class": "v-messages__message",
                                "key": `${i}-${messages.value}`
                            }, [
                                slots.message ? slots.message({
                                    message
                                }) : message
                            ]))
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VMessages.css":"9YAtl","../transitions/index.mjs":"oiH7Z","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9YAtl":[function() {},{}],"1xYwD":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeValidationProps", ()=>makeValidationProps);
parcelHelpers.export(exports, "useValidation", ()=>useValidation);
var _focusMjs = require("./focus.mjs");
var _formMjs = require("./form.mjs");
var _proxiedModelMjs = require("./proxiedModel.mjs");
var _toggleScopeMjs = require("./toggleScope.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeValidationProps = (0, _indexMjs.propsFactory)({
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    errorMessages: {
        type: [
            Array,
            String
        ],
        default: ()=>[]
    },
    maxErrors: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    name: String,
    label: String,
    readonly: {
        type: Boolean,
        default: null
    },
    rules: {
        type: Array,
        default: ()=>[]
    },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...(0, _focusMjs.makeFocusProps)()
}, "validation");
function useValidation(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _indexMjs.getUid)();
    const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
    const validationModel = (0, _vue.computed)(()=>props.validationValue === undefined ? model.value : props.validationValue);
    const form = (0, _formMjs.useForm)();
    const internalErrorMessages = (0, _vue.ref)([]);
    const isPristine = (0, _vue.shallowRef)(true);
    const isDirty = (0, _vue.computed)(()=>!!((0, _indexMjs.wrapInArray)(model.value === "" ? null : model.value).length || (0, _indexMjs.wrapInArray)(validationModel.value === "" ? null : validationModel.value).length));
    const isDisabled = (0, _vue.computed)(()=>!!(props.disabled ?? form?.isDisabled.value));
    const isReadonly = (0, _vue.computed)(()=>!!(props.readonly ?? form?.isReadonly.value));
    const errorMessages = (0, _vue.computed)(()=>{
        return props.errorMessages.length ? (0, _indexMjs.wrapInArray)(props.errorMessages).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
    });
    const validateOn = (0, _vue.computed)(()=>{
        let value = (props.validateOn ?? form?.validateOn.value) || "input";
        if (value === "lazy") value = "input lazy";
        const set = new Set(value?.split(" ") ?? []);
        return {
            blur: set.has("blur") || set.has("input"),
            input: set.has("input"),
            submit: set.has("submit"),
            lazy: set.has("lazy")
        };
    });
    const isValid = (0, _vue.computed)(()=>{
        if (props.error || props.errorMessages.length) return false;
        if (!props.rules.length) return true;
        if (isPristine.value) return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
        else return !internalErrorMessages.value.length;
    });
    const isValidating = (0, _vue.shallowRef)(false);
    const validationClasses = (0, _vue.computed)(()=>{
        return {
            [`${name}--error`]: isValid.value === false,
            [`${name}--dirty`]: isDirty.value,
            [`${name}--disabled`]: isDisabled.value,
            [`${name}--readonly`]: isReadonly.value
        };
    });
    const uid = (0, _vue.computed)(()=>props.name ?? (0, _vue.unref)(id));
    (0, _vue.onBeforeMount)(()=>{
        form?.register({
            id: uid.value,
            validate,
            reset,
            resetValidation
        });
    });
    (0, _vue.onBeforeUnmount)(()=>{
        form?.unregister(uid.value);
    });
    (0, _vue.onMounted)(async ()=>{
        if (!validateOn.value.lazy) await validate(true);
        form?.update(uid.value, isValid.value, errorMessages.value);
    });
    (0, _toggleScopeMjs.useToggleScope)(()=>validateOn.value.input, ()=>{
        (0, _vue.watch)(validationModel, ()=>{
            if (validationModel.value != null) validate();
            else if (props.focused) {
                const unwatch = (0, _vue.watch)(()=>props.focused, (val)=>{
                    if (!val) validate();
                    unwatch();
                });
            }
        });
    });
    (0, _toggleScopeMjs.useToggleScope)(()=>validateOn.value.blur, ()=>{
        (0, _vue.watch)(()=>props.focused, (val)=>{
            if (!val) validate();
        });
    });
    (0, _vue.watch)(isValid, ()=>{
        form?.update(uid.value, isValid.value, errorMessages.value);
    });
    function reset() {
        model.value = null;
        (0, _vue.nextTick)(resetValidation);
    }
    function resetValidation() {
        isPristine.value = true;
        if (!validateOn.value.lazy) validate(true);
        else internalErrorMessages.value = [];
    }
    async function validate() {
        let silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        const results = [];
        isValidating.value = true;
        for (const rule of props.rules){
            if (results.length >= +(props.maxErrors ?? 1)) break;
            const handler = typeof rule === "function" ? rule : ()=>rule;
            const result = await handler(validationModel.value);
            if (result === true) continue;
            if (result !== false && typeof result !== "string") {
                // eslint-disable-next-line no-console
                console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
                continue;
            }
            results.push(result || "");
        }
        internalErrorMessages.value = results;
        isValidating.value = false;
        isPristine.value = silent;
        return internalErrorMessages.value;
    }
    return {
        errorMessages,
        isDirty,
        isDisabled,
        isReadonly,
        isPristine,
        isValid,
        isValidating,
        reset,
        resetValidation,
        validate,
        validationClasses
    };
}

},{"./focus.mjs":"1bQxY","./form.mjs":"Jb6Pn","./proxiedModel.mjs":"bUF28","./toggleScope.mjs":"cE29O","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1bQxY":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeFocusProps", ()=>makeFocusProps);
parcelHelpers.export(exports, "useFocus", ()=>useFocus);
var _proxiedModelMjs = require("./proxiedModel.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeFocusProps = (0, _indexMjs.propsFactory)({
    focused: Boolean,
    "onUpdate:focused": (0, _indexMjs.EventProp)()
}, "focus");
function useFocus(props) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _indexMjs.getCurrentInstanceName)();
    const isFocused = (0, _proxiedModelMjs.useProxiedModel)(props, "focused");
    const focusClasses = (0, _vue.computed)(()=>{
        return {
            [`${name}--focused`]: isFocused.value
        };
    });
    function focus() {
        isFocused.value = true;
    }
    function blur() {
        isFocused.value = false;
    }
    return {
        focusClasses,
        isFocused,
        focus,
        blur
    };
}

},{"./proxiedModel.mjs":"bUF28","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"Jb6Pn":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FormKey", ()=>FormKey);
parcelHelpers.export(exports, "makeFormProps", ()=>makeFormProps);
parcelHelpers.export(exports, "createForm", ()=>createForm);
parcelHelpers.export(exports, "useForm", ()=>useForm);
var _proxiedModelMjs = require("./proxiedModel.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const FormKey = Symbol.for("vuetify:form");
const makeFormProps = (0, _indexMjs.propsFactory)({
    disabled: Boolean,
    fastFail: Boolean,
    readonly: Boolean,
    modelValue: {
        type: Boolean,
        default: null
    },
    validateOn: {
        type: String,
        default: "input"
    }
}, "form");
function createForm(props) {
    const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
    const isDisabled = (0, _vue.computed)(()=>props.disabled);
    const isReadonly = (0, _vue.computed)(()=>props.readonly);
    const isValidating = (0, _vue.shallowRef)(false);
    const items = (0, _vue.ref)([]);
    const errors = (0, _vue.ref)([]);
    async function validate() {
        const results = [];
        let valid = true;
        errors.value = [];
        isValidating.value = true;
        for (const item of items.value){
            const itemErrorMessages = await item.validate();
            if (itemErrorMessages.length > 0) {
                valid = false;
                results.push({
                    id: item.id,
                    errorMessages: itemErrorMessages
                });
            }
            if (!valid && props.fastFail) break;
        }
        errors.value = results;
        isValidating.value = false;
        return {
            valid,
            errors: errors.value
        };
    }
    function reset() {
        items.value.forEach((item)=>item.reset());
    }
    function resetValidation() {
        items.value.forEach((item)=>item.resetValidation());
    }
    (0, _vue.watch)(items, ()=>{
        let valid = 0;
        let invalid = 0;
        const results = [];
        for (const item of items.value){
            if (item.isValid === false) {
                invalid++;
                results.push({
                    id: item.id,
                    errorMessages: item.errorMessages
                });
            } else if (item.isValid === true) valid++;
        }
        errors.value = results;
        model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
    }, {
        deep: true
    });
    (0, _vue.provide)(FormKey, {
        register: (_ref)=>{
            let { id, validate, reset, resetValidation } = _ref;
            if (items.value.some((item)=>item.id === id)) (0, _indexMjs.consoleWarn)(`Duplicate input name "${id}"`);
            items.value.push({
                id,
                validate,
                reset,
                resetValidation,
                isValid: null,
                errorMessages: []
            });
        },
        unregister: (id)=>{
            items.value = items.value.filter((item)=>{
                return item.id !== id;
            });
        },
        update: (id, isValid, errorMessages)=>{
            const found = items.value.find((item)=>item.id === id);
            if (!found) return;
            found.isValid = isValid;
            found.errorMessages = errorMessages;
        },
        isDisabled,
        isReadonly,
        isValidating,
        isValid: model,
        items,
        validateOn: (0, _vue.toRef)(props, "validateOn")
    });
    return {
        errors,
        isDisabled,
        isReadonly,
        isValidating,
        isValid: model,
        items,
        validate,
        reset,
        resetValidation
    };
}
function useForm() {
    return (0, _vue.inject)(FormKey, null);
}

},{"./proxiedModel.mjs":"bUF28","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9w6oh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VChip", ()=>(0, _vchipMjs.VChip));
var _vchipMjs = require("./VChip.mjs");

},{"./VChip.mjs":"sSAQL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"sSAQL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVChipProps", ()=>makeVChipProps);
parcelHelpers.export(exports, "VChip", ()=>VChip);
var _vue = require("vue");
/* eslint-disable complexity */ // Styles
var _vchipCss = require("./VChip.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VAvatar/index.mjs");
var _vchipGroupMjs = require("../VChipGroup/VChipGroup.mjs");
var _indexMjs2 = require("../VDefaultsProvider/index.mjs");
var _indexMjs3 = require("../VIcon/index.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Directives
var _indexMjs4 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs5 = require("../../util/index.mjs"); // Types
const makeVChipProps = (0, _indexMjs5.propsFactory)({
    activeClass: String,
    appendAvatar: String,
    appendIcon: (0, _iconsMjs.IconValue),
    closable: Boolean,
    closeIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$delete"
    },
    closeLabel: {
        type: String,
        default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
        type: String,
        default: "$complete"
    },
    label: Boolean,
    link: {
        type: Boolean,
        default: undefined
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: (0, _iconsMjs.IconValue),
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: true
    },
    text: String,
    modelValue: {
        type: Boolean,
        default: true
    },
    onClick: (0, _indexMjs5.EventProp)(),
    onClickOnce: (0, _indexMjs5.EventProp)(),
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _groupMjs.makeGroupItemProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _routerMjs.makeRouterProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "span"
    }),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "tonal"
    })
}, "VChip");
const VChip = (0, _indexMjs5.genericComponent)()({
    name: "VChip",
    directives: {
        Ripple: (0, _indexMjs4.Ripple)
    },
    props: makeVChipProps(),
    emits: {
        "click:close": (e)=>true,
        "update:modelValue": (value)=>true,
        "group:selected": (val)=>true,
        click: (e)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { sizeClasses } = (0, _sizeMjs.useSize)(props);
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const group = (0, _groupMjs.useGroupItem)(props, (0, _vchipGroupMjs.VChipGroupSymbol), false);
        const link = (0, _routerMjs.useLink)(props, attrs);
        const isLink = (0, _vue.computed)(()=>props.link !== false && link.isLink.value);
        const isClickable = (0, _vue.computed)(()=>!props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
        const closeProps = (0, _vue.computed)(()=>({
                "aria-label": t(props.closeLabel),
                onClick (e) {
                    e.stopPropagation();
                    isActive.value = false;
                    emit("click:close", e);
                }
            }));
        function onClick(e) {
            emit("click", e);
            if (!isClickable.value) return;
            link.navigate?.(e);
            group?.toggle();
        }
        function onKeyDown(e) {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                onClick(e);
            }
        }
        return ()=>{
            const Tag = link.isLink.value ? "a" : props.tag;
            const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
            const hasAppend = !!(hasAppendMedia || slots.append);
            const hasClose = !!(slots.close || props.closable);
            const hasFilter = !!(slots.filter || props.filter) && group;
            const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
            const hasPrepend = !!(hasPrependMedia || slots.prepend);
            const hasColor = !group || group.isSelected.value;
            return isActive.value && (0, _vue.withDirectives)((0, _vue.createVNode)(Tag, {
                "class": [
                    "v-chip",
                    {
                        "v-chip--disabled": props.disabled,
                        "v-chip--label": props.label,
                        "v-chip--link": isClickable.value,
                        "v-chip--filter": hasFilter,
                        "v-chip--pill": props.pill
                    },
                    themeClasses.value,
                    borderClasses.value,
                    hasColor ? colorClasses.value : undefined,
                    densityClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    sizeClasses.value,
                    variantClasses.value,
                    group?.selectedClass.value,
                    props.class
                ],
                "style": [
                    hasColor ? colorStyles.value : undefined,
                    props.style
                ],
                "disabled": props.disabled || undefined,
                "draggable": props.draggable,
                "href": link.href.value,
                "tabindex": isClickable.value ? 0 : undefined,
                "onClick": onClick,
                "onKeydown": isClickable.value && !isLink.value && onKeyDown
            }, {
                default: ()=>[
                        (0, _variantMjs.genOverlays)(isClickable.value, "v-chip"),
                        hasFilter && (0, _vue.createVNode)((0, _indexMjs.VExpandXTransition), {
                            "key": "filter"
                        }, {
                            default: ()=>[
                                    (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                                        "class": "v-chip__filter"
                                    }, [
                                        !slots.filter ? (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                            "key": "filter-icon",
                                            "icon": props.filterIcon
                                        }, null) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                            "key": "filter-defaults",
                                            "disabled": !props.filterIcon,
                                            "defaults": {
                                                VIcon: {
                                                    icon: props.filterIcon
                                                }
                                            }
                                        }, slots.filter)
                                    ]), [
                                        [
                                            (0, _vue.vShow),
                                            group.isSelected.value
                                        ]
                                    ])
                                ]
                        }),
                        hasPrepend && (0, _vue.createVNode)("div", {
                            "key": "prepend",
                            "class": "v-chip__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.prependIcon && (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                    "key": "prepend-icon",
                                    "icon": props.prependIcon,
                                    "start": true
                                }, null),
                                props.prependAvatar && (0, _vue.createVNode)((0, _indexMjs1.VAvatar), {
                                    "key": "prepend-avatar",
                                    "image": props.prependAvatar,
                                    "start": true
                                }, null)
                            ]) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !hasPrependMedia,
                                "defaults": {
                                    VAvatar: {
                                        image: props.prependAvatar,
                                        start: true
                                    },
                                    VIcon: {
                                        icon: props.prependIcon,
                                        start: true
                                    }
                                }
                            }, slots.prepend)
                        ]),
                        (0, _vue.createVNode)("div", {
                            "class": "v-chip__content"
                        }, [
                            slots.default?.({
                                isSelected: group?.isSelected.value,
                                selectedClass: group?.selectedClass.value,
                                select: group?.select,
                                toggle: group?.toggle,
                                value: group?.value.value,
                                disabled: props.disabled
                            }) ?? props.text
                        ]),
                        hasAppend && (0, _vue.createVNode)("div", {
                            "key": "append",
                            "class": "v-chip__append"
                        }, [
                            !slots.append ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.appendIcon && (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                    "key": "append-icon",
                                    "end": true,
                                    "icon": props.appendIcon
                                }, null),
                                props.appendAvatar && (0, _vue.createVNode)((0, _indexMjs1.VAvatar), {
                                    "key": "append-avatar",
                                    "end": true,
                                    "image": props.appendAvatar
                                }, null)
                            ]) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                "key": "append-defaults",
                                "disabled": !hasAppendMedia,
                                "defaults": {
                                    VAvatar: {
                                        end: true,
                                        image: props.appendAvatar
                                    },
                                    VIcon: {
                                        end: true,
                                        icon: props.appendIcon
                                    }
                                }
                            }, slots.append)
                        ]),
                        hasClose && (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                            "key": "close",
                            "class": "v-chip__close"
                        }, closeProps.value), [
                            !slots.close ? (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                "key": "close-icon",
                                "icon": props.closeIcon,
                                "size": "x-small"
                            }, null) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                "key": "close-defaults",
                                "defaults": {
                                    VIcon: {
                                        icon: props.closeIcon,
                                        size: "x-small"
                                    }
                                }
                            }, slots.close)
                        ])
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("ripple"),
                    isClickable.value && props.ripple,
                    null
                ]
            ]);
        };
    }
});

},{"vue":"ff77s","./VChip.css":"18vNO","../transitions/index.mjs":"oiH7Z","../VAvatar/index.mjs":"1cQMc","../VChipGroup/VChipGroup.mjs":"eBTRX","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/elevation.mjs":"3BDEa","../../composables/group.mjs":"7LC6J","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/rounded.mjs":"ldhZ9","../../composables/router.mjs":"bEBrG","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"18vNO":[function() {},{}],"1cQMc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAvatar", ()=>(0, _vavatarMjs.VAvatar));
var _vavatarMjs = require("./VAvatar.mjs");

},{"./VAvatar.mjs":"5UZdT","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5UZdT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVAvatarProps", ()=>makeVAvatarProps);
parcelHelpers.export(exports, "VAvatar", ()=>VAvatar);
var _vue = require("vue");
// Styles
var _vavatarCss = require("./VAvatar.css");
// Components
var _indexMjs = require("../VIcon/index.mjs");
var _indexMjs1 = require("../VImg/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs");
const makeVAvatarProps = (0, _indexMjs2.propsFactory)({
    start: Boolean,
    end: Boolean,
    icon: (0, _iconsMjs.IconValue),
    image: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "flat"
    })
}, "VAvatar");
const VAvatar = (0, _indexMjs2.genericComponent)()({
    name: "VAvatar",
    props: makeVAvatarProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { sizeClasses, sizeStyles } = (0, _sizeMjs.useSize)(props);
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-avatar",
                    {
                        "v-avatar--start": props.start,
                        "v-avatar--end": props.end
                    },
                    themeClasses.value,
                    colorClasses.value,
                    densityClasses.value,
                    roundedClasses.value,
                    sizeClasses.value,
                    variantClasses.value,
                    props.class
                ],
                "style": [
                    colorStyles.value,
                    sizeStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        props.image ? (0, _vue.createVNode)((0, _indexMjs1.VImg), {
                            "key": "image",
                            "src": props.image,
                            "alt": "",
                            "cover": true
                        }, null) : props.icon ? (0, _vue.createVNode)((0, _indexMjs.VIcon), {
                            "key": "icon",
                            "icon": props.icon
                        }, null) : slots.default?.(),
                        (0, _variantMjs.genOverlays)(false, "v-avatar")
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VAvatar.css":"h2DoI","../VIcon/index.mjs":"2wJue","../VImg/index.mjs":"87IoX","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../composables/rounded.mjs":"ldhZ9","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"h2DoI":[function() {},{}],"eBTRX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VChipGroupSymbol", ()=>VChipGroupSymbol);
parcelHelpers.export(exports, "makeVChipGroupProps", ()=>makeVChipGroupProps);
parcelHelpers.export(exports, "VChipGroup", ()=>VChipGroup);
var _vue = require("vue");
// Styles
var _vchipGroupCss = require("./VChipGroup.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
const makeVChipGroupProps = (0, _indexMjs.propsFactory)({
    column: Boolean,
    filter: Boolean,
    valueComparator: {
        type: Function,
        default: (0, _indexMjs.deepEqual)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _groupMjs.makeGroupProps)({
        selectedClass: "v-chip--selected"
    }),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "tonal"
    })
}, "VChipGroup");
const VChipGroup = (0, _indexMjs.genericComponent)()({
    name: "VChipGroup",
    props: makeVChipGroupProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { isSelected, select, next, prev, selected } = (0, _groupMjs.useGroup)(props, VChipGroupSymbol);
        (0, _defaultsMjs.provideDefaults)({
            VChip: {
                color: (0, _vue.toRef)(props, "color"),
                disabled: (0, _vue.toRef)(props, "disabled"),
                filter: (0, _vue.toRef)(props, "filter"),
                variant: (0, _vue.toRef)(props, "variant")
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-chip-group",
                    {
                        "v-chip-group--column": props.column
                    },
                    themeClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        slots.default?.({
                            isSelected,
                            select,
                            next,
                            prev,
                            selected: selected.value
                        })
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VChipGroup.css":"dhxD9","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/group.mjs":"7LC6J","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dhxD9":[function() {},{}],"1md2l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VList", ()=>(0, _vlistMjs.VList));
parcelHelpers.export(exports, "VListGroup", ()=>(0, _vlistGroupMjs.VListGroup));
parcelHelpers.export(exports, "VListImg", ()=>(0, _vlistImgMjs.VListImg));
parcelHelpers.export(exports, "VListItem", ()=>(0, _vlistItemMjs.VListItem));
parcelHelpers.export(exports, "VListItemAction", ()=>(0, _vlistItemActionMjs.VListItemAction));
parcelHelpers.export(exports, "VListItemMedia", ()=>(0, _vlistItemMediaMjs.VListItemMedia));
parcelHelpers.export(exports, "VListItemSubtitle", ()=>(0, _vlistItemSubtitleMjs.VListItemSubtitle));
parcelHelpers.export(exports, "VListItemTitle", ()=>(0, _vlistItemTitleMjs.VListItemTitle));
parcelHelpers.export(exports, "VListSubheader", ()=>(0, _vlistSubheaderMjs.VListSubheader));
var _vlistMjs = require("./VList.mjs");
var _vlistGroupMjs = require("./VListGroup.mjs");
var _vlistImgMjs = require("./VListImg.mjs");
var _vlistItemMjs = require("./VListItem.mjs");
var _vlistItemActionMjs = require("./VListItemAction.mjs");
var _vlistItemMediaMjs = require("./VListItemMedia.mjs");
var _vlistItemSubtitleMjs = require("./VListItemSubtitle.mjs");
var _vlistItemTitleMjs = require("./VListItemTitle.mjs");
var _vlistSubheaderMjs = require("./VListSubheader.mjs");

},{"./VList.mjs":"c52Pi","./VListGroup.mjs":"jQXJl","./VListImg.mjs":"1sXJZ","./VListItem.mjs":"3m2RV","./VListItemAction.mjs":"eocvS","./VListItemMedia.mjs":"aKLYY","./VListItemSubtitle.mjs":"iXbVm","./VListItemTitle.mjs":"8XqCQ","./VListSubheader.mjs":"6v7p7","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"c52Pi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListProps", ()=>makeVListProps);
parcelHelpers.export(exports, "VList", ()=>VList);
var _vue = require("vue");
// Styles
var _vlistCss = require("./VList.css");
// Components
var _vlistChildrenMjs = require("./VListChildren.mjs"); // Composables
var _listMjs = require("./list.mjs");
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _listItemsMjs = require("../../composables/list-items.mjs");
var _nestedMjs = require("../../composables/nested/nested.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
}
function transformItem(props, item) {
    const type = (0, _indexMjs.getPropertyFromItem)(item, props.itemType, "item");
    const title = isPrimitive(item) ? item : (0, _indexMjs.getPropertyFromItem)(item, props.itemTitle);
    const value = (0, _indexMjs.getPropertyFromItem)(item, props.itemValue, undefined);
    const children = (0, _indexMjs.getPropertyFromItem)(item, props.itemChildren);
    const itemProps = props.itemProps === true ? (0, _indexMjs.pick)(item, [
        "children"
    ])[1] : (0, _indexMjs.getPropertyFromItem)(item, props.itemProps);
    const _props = {
        title,
        value,
        ...itemProps
    };
    return {
        type,
        title: _props.title,
        value: _props.value,
        props: _props,
        children: type === "item" && children ? transformItems(props, children) : undefined,
        raw: item
    };
}
function transformItems(props, items) {
    const array = [];
    for (const item of items)array.push(transformItem(props, item));
    return array;
}
function useListItems(props) {
    const items = (0, _vue.computed)(()=>transformItems(props, props.items));
    return {
        items
    };
}
const makeVListProps = (0, _indexMjs.propsFactory)({
    baseColor: String,
    /* @deprecated */ activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    lines: {
        type: [
            Boolean,
            String
        ],
        default: "one"
    },
    nav: Boolean,
    ...(0, _nestedMjs.makeNestedProps)({
        selectStrategy: "single-leaf",
        openStrategy: "list"
    }),
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    itemType: {
        type: String,
        default: "type"
    },
    ...(0, _listItemsMjs.makeItemsProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "text"
    })
}, "VList");
const VList = (0, _indexMjs.genericComponent)()({
    name: "VList",
    props: makeVListProps(),
    emits: {
        "update:selected": (val)=>true,
        "update:opened": (val)=>true,
        "click:open": (value)=>true,
        "click:select": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { items } = useListItems(props);
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "bgColor"));
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { open, select } = (0, _nestedMjs.useNested)(props);
        const lineClasses = (0, _vue.computed)(()=>props.lines ? `v-list--${props.lines}-line` : undefined);
        const activeColor = (0, _vue.toRef)(props, "activeColor");
        const baseColor = (0, _vue.toRef)(props, "baseColor");
        const color = (0, _vue.toRef)(props, "color");
        (0, _listMjs.createList)();
        (0, _defaultsMjs.provideDefaults)({
            VListGroup: {
                activeColor,
                baseColor,
                color
            },
            VListItem: {
                activeClass: (0, _vue.toRef)(props, "activeClass"),
                activeColor,
                baseColor,
                color,
                density: (0, _vue.toRef)(props, "density"),
                disabled: (0, _vue.toRef)(props, "disabled"),
                lines: (0, _vue.toRef)(props, "lines"),
                nav: (0, _vue.toRef)(props, "nav"),
                variant: (0, _vue.toRef)(props, "variant")
            }
        });
        const isFocused = (0, _vue.shallowRef)(false);
        const contentRef = (0, _vue.ref)();
        function onFocusin(e) {
            isFocused.value = true;
        }
        function onFocusout(e) {
            isFocused.value = false;
        }
        function onFocus(e) {
            if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget))) focus();
        }
        function onKeydown(e) {
            if (!contentRef.value) return;
            if (e.key === "ArrowDown") focus("next");
            else if (e.key === "ArrowUp") focus("prev");
            else if (e.key === "Home") focus("first");
            else if (e.key === "End") focus("last");
            else return;
            e.preventDefault();
        }
        function focus(location) {
            if (contentRef.value) return (0, _indexMjs.focusChild)(contentRef.value, location);
        }
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)(props.tag, {
                "ref": contentRef,
                "class": [
                    "v-list",
                    {
                        "v-list--disabled": props.disabled,
                        "v-list--nav": props.nav
                    },
                    themeClasses.value,
                    backgroundColorClasses.value,
                    borderClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    lineClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    dimensionStyles.value,
                    props.style
                ],
                "tabindex": props.disabled || isFocused.value ? -1 : 0,
                "role": "listbox",
                "aria-activedescendant": undefined,
                "onFocusin": onFocusin,
                "onFocusout": onFocusout,
                "onFocus": onFocus,
                "onKeydown": onKeydown
            }, {
                default: ()=>[
                        (0, _vue.createVNode)((0, _vlistChildrenMjs.VListChildren), {
                            "items": items.value
                        }, slots)
                    ]
            });
        });
        return {
            open,
            select,
            focus
        };
    }
});

},{"vue":"ff77s","./VList.css":"6WslP","./VListChildren.mjs":"goXIV","./list.mjs":"6kUuk","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/list-items.mjs":"kVtgo","../../composables/nested/nested.mjs":"5YIw3","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6WslP":[function() {},{}],"goXIV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListChildrenProps", ()=>makeVListChildrenProps);
parcelHelpers.export(exports, "VListChildren", ()=>VListChildren);
var _vue = require("vue");
// Components
var _vlistGroupMjs = require("./VListGroup.mjs");
var _vlistItemMjs = require("./VListItem.mjs");
var _vlistSubheaderMjs = require("./VListSubheader.mjs");
var _indexMjs = require("../VDivider/index.mjs"); // Utilities
var _listMjs = require("./list.mjs");
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVListChildrenProps = (0, _indexMjs1.propsFactory)({
    items: Array
}, "VListChildren");
const VListChildren = (0, _indexMjs1.genericComponent)()({
    name: "VListChildren",
    props: makeVListChildrenProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _listMjs.createList)();
        return ()=>slots.default?.() ?? props.items?.map((_ref2)=>{
                let { children, props: itemProps, type, raw: item } = _ref2;
                if (type === "divider") return slots.divider?.({
                    props: itemProps
                }) ?? (0, _vue.createVNode)((0, _indexMjs.VDivider), itemProps, null);
                if (type === "subheader") return slots.subheader?.({
                    props: itemProps
                }) ?? (0, _vue.createVNode)((0, _vlistSubheaderMjs.VListSubheader), itemProps, null);
                const slotsWithItem = {
                    subtitle: slots.subtitle ? (slotProps)=>slots.subtitle?.({
                            ...slotProps,
                            item
                        }) : undefined,
                    prepend: slots.prepend ? (slotProps)=>slots.prepend?.({
                            ...slotProps,
                            item
                        }) : undefined,
                    append: slots.append ? (slotProps)=>slots.append?.({
                            ...slotProps,
                            item
                        }) : undefined,
                    title: slots.title ? (slotProps)=>slots.title?.({
                            ...slotProps,
                            item
                        }) : undefined
                };
                const [listGroupProps, _1] = (0, _vlistGroupMjs.VListGroup).filterProps(itemProps);
                return children ? (0, _vue.createVNode)((0, _vlistGroupMjs.VListGroup), (0, _vue.mergeProps)({
                    "value": itemProps?.value
                }, listGroupProps), {
                    activator: (_ref3)=>{
                        let { props: activatorProps } = _ref3;
                        return slots.header ? slots.header({
                            props: {
                                ...itemProps,
                                ...activatorProps
                            }
                        }) : (0, _vue.createVNode)((0, _vlistItemMjs.VListItem), (0, _vue.mergeProps)(itemProps, activatorProps), slotsWithItem);
                    },
                    default: ()=>(0, _vue.createVNode)(VListChildren, {
                            "items": children
                        }, slots)
                }) : slots.item ? slots.item({
                    props: itemProps
                }) : (0, _vue.createVNode)((0, _vlistItemMjs.VListItem), itemProps, slotsWithItem);
            });
    }
});

},{"vue":"ff77s","./VListGroup.mjs":"jQXJl","./VListItem.mjs":"3m2RV","./VListSubheader.mjs":"6v7p7","../VDivider/index.mjs":"ajcaZ","./list.mjs":"6kUuk","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jQXJl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListGroupProps", ()=>makeVListGroupProps);
parcelHelpers.export(exports, "VListGroup", ()=>VListGroup);
var _vue = require("vue");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs"); // Composables
var _listMjs = require("./list.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _nestedMjs = require("../../composables/nested/nested.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs");
const VListGroupActivator = (0, _indexMjs2.defineComponent)({
    name: "VListGroupActivator",
    setup (_, _ref) {
        let { slots } = _ref;
        (0, _nestedMjs.useNestedGroupActivator)();
        return ()=>slots.default?.();
    }
});
const makeVListGroupProps = (0, _indexMjs2.propsFactory)({
    /* @deprecated */ activeColor: String,
    baseColor: String,
    color: String,
    collapseIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$collapse"
    },
    expandIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$expand"
    },
    prependIcon: (0, _iconsMjs.IconValue),
    appendIcon: (0, _iconsMjs.IconValue),
    fluid: Boolean,
    subgroup: Boolean,
    title: String,
    value: null,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VListGroup");
const VListGroup = (0, _indexMjs2.genericComponent)()({
    name: "VListGroup",
    props: makeVListGroupProps(),
    setup (props, _ref2) {
        let { slots } = _ref2;
        const { isOpen, open, id: _id } = (0, _nestedMjs.useNestedItem)((0, _vue.toRef)(props, "value"), true);
        const id = (0, _vue.computed)(()=>`v-list-group--id-${String(_id.value)}`);
        const list = (0, _listMjs.useList)();
        const { isBooted } = (0, _ssrBootMjs.useSsrBoot)();
        function onClick(e) {
            open(!isOpen.value, e);
        }
        const activatorProps = (0, _vue.computed)(()=>({
                onClick,
                class: "v-list-group__header",
                id: id.value
            }));
        const toggleIcon = (0, _vue.computed)(()=>isOpen.value ? props.collapseIcon : props.expandIcon);
        const activatorDefaults = (0, _vue.computed)(()=>({
                VListItem: {
                    active: isOpen.value,
                    activeColor: props.activeColor,
                    baseColor: props.baseColor,
                    color: props.color,
                    prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
                    appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
                    title: props.title,
                    value: props.value
                }
            }));
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-list-group",
                    {
                        "v-list-group--prepend": list?.hasPrepend.value,
                        "v-list-group--fluid": props.fluid,
                        "v-list-group--subgroup": props.subgroup,
                        "v-list-group--open": isOpen.value
                    },
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        slots.activator && (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                            "defaults": activatorDefaults.value
                        }, {
                            default: ()=>[
                                    (0, _vue.createVNode)(VListGroupActivator, null, {
                                        default: ()=>[
                                                slots.activator({
                                                    props: activatorProps.value,
                                                    isOpen: isOpen.value
                                                })
                                            ]
                                    })
                                ]
                        }),
                        (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                            "transition": {
                                component: (0, _indexMjs.VExpandTransition)
                            },
                            "disabled": !isBooted.value
                        }, {
                            default: ()=>[
                                    (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                                        "class": "v-list-group__items",
                                        "role": "group",
                                        "aria-labelledby": id.value
                                    }, [
                                        slots.default?.()
                                    ]), [
                                        [
                                            (0, _vue.vShow),
                                            isOpen.value
                                        ]
                                    ])
                                ]
                        })
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","../transitions/index.mjs":"oiH7Z","../VDefaultsProvider/index.mjs":"1OIgj","./list.mjs":"6kUuk","../../composables/component.mjs":"jVHld","../../composables/icons.mjs":"ezwoc","../../composables/nested/nested.mjs":"5YIw3","../../composables/ssrBoot.mjs":"b8ivf","../../composables/tag.mjs":"3KkML","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6kUuk":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DepthKey", ()=>DepthKey);
parcelHelpers.export(exports, "useDepth", ()=>useDepth);
parcelHelpers.export(exports, "ListKey", ()=>ListKey);
parcelHelpers.export(exports, "createList", ()=>createList);
parcelHelpers.export(exports, "useList", ()=>useList);
var _vue = require("vue");
const DepthKey = Symbol.for("vuetify:depth");
function useDepth(hasPrepend) {
    const parent = (0, _vue.inject)(DepthKey, (0, _vue.shallowRef)(-1));
    const depth = (0, _vue.computed)(()=>parent.value + 1 + (hasPrepend?.value ? 1 : 0));
    (0, _vue.provide)(DepthKey, depth);
    return depth;
}
const ListKey = Symbol.for("vuetify:list");
function createList() {
    const parent = (0, _vue.inject)(ListKey, {
        hasPrepend: (0, _vue.shallowRef)(false),
        updateHasPrepend: ()=>null
    });
    const data = {
        hasPrepend: (0, _vue.shallowRef)(false),
        updateHasPrepend: (value)=>{
            if (value) data.hasPrepend.value = value;
        }
    };
    (0, _vue.provide)(ListKey, data);
    return parent;
}
function useList() {
    return (0, _vue.inject)(ListKey, null);
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5YIw3":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VNestedSymbol", ()=>VNestedSymbol);
parcelHelpers.export(exports, "emptyNested", ()=>emptyNested);
parcelHelpers.export(exports, "makeNestedProps", ()=>makeNestedProps);
parcelHelpers.export(exports, "useNested", ()=>useNested);
parcelHelpers.export(exports, "useNestedItem", ()=>useNestedItem);
parcelHelpers.export(exports, "useNestedGroupActivator", ()=>useNestedGroupActivator);
var _proxiedModelMjs = require("../proxiedModel.mjs"); // Utilities
var _vue = require("vue");
var _openStrategiesMjs = require("./openStrategies.mjs");
var _selectStrategiesMjs = require("./selectStrategies.mjs");
var _indexMjs = require("../../util/index.mjs"); // Types
const VNestedSymbol = Symbol.for("vuetify:nested");
const emptyNested = {
    id: (0, _vue.shallowRef)(),
    root: {
        register: ()=>null,
        unregister: ()=>null,
        parents: (0, _vue.ref)(new Map()),
        children: (0, _vue.ref)(new Map()),
        open: ()=>null,
        openOnSelect: ()=>null,
        select: ()=>null,
        opened: (0, _vue.ref)(new Set()),
        selected: (0, _vue.ref)(new Map()),
        selectedValues: (0, _vue.ref)([])
    }
};
const makeNestedProps = (0, _indexMjs.propsFactory)({
    selectStrategy: [
        String,
        Function
    ],
    openStrategy: [
        String,
        Object
    ],
    opened: Array,
    selected: Array,
    mandatory: Boolean
}, "nested");
const useNested = (props)=>{
    let isUnmounted = false;
    const children = (0, _vue.ref)(new Map());
    const parents = (0, _vue.ref)(new Map());
    const opened = (0, _proxiedModelMjs.useProxiedModel)(props, "opened", props.opened, (v)=>new Set(v), (v)=>[
            ...v.values()
        ]);
    const selectStrategy = (0, _vue.computed)(()=>{
        if (typeof props.selectStrategy === "object") return props.selectStrategy;
        switch(props.selectStrategy){
            case "single-leaf":
                return (0, _selectStrategiesMjs.leafSingleSelectStrategy)(props.mandatory);
            case "leaf":
                return (0, _selectStrategiesMjs.leafSelectStrategy)(props.mandatory);
            case "independent":
                return (0, _selectStrategiesMjs.independentSelectStrategy)(props.mandatory);
            case "single-independent":
                return (0, _selectStrategiesMjs.independentSingleSelectStrategy)(props.mandatory);
            case "classic":
            default:
                return (0, _selectStrategiesMjs.classicSelectStrategy)(props.mandatory);
        }
    });
    const openStrategy = (0, _vue.computed)(()=>{
        if (typeof props.openStrategy === "object") return props.openStrategy;
        switch(props.openStrategy){
            case "list":
                return 0, _openStrategiesMjs.listOpenStrategy;
            case "single":
                return 0, _openStrategiesMjs.singleOpenStrategy;
            case "multiple":
            default:
                return 0, _openStrategiesMjs.multipleOpenStrategy;
        }
    });
    const selected = (0, _proxiedModelMjs.useProxiedModel)(props, "selected", props.selected, (v)=>selectStrategy.value.in(v, children.value, parents.value), (v)=>selectStrategy.value.out(v, children.value, parents.value));
    (0, _vue.onBeforeUnmount)(()=>{
        isUnmounted = true;
    });
    function getPath(id) {
        const path = [];
        let parent = id;
        while(parent != null){
            path.unshift(parent);
            parent = parents.value.get(parent);
        }
        return path;
    }
    const vm = (0, _indexMjs.getCurrentInstance)("nested");
    const nested = {
        id: (0, _vue.shallowRef)(),
        root: {
            opened,
            selected,
            selectedValues: (0, _vue.computed)(()=>{
                const arr = [];
                for (const [key, value] of selected.value.entries())if (value === "on") arr.push(key);
                return arr;
            }),
            register: (id, parentId, isGroup)=>{
                parentId && id !== parentId && parents.value.set(id, parentId);
                isGroup && children.value.set(id, []);
                if (parentId != null) children.value.set(parentId, [
                    ...children.value.get(parentId) || [],
                    id
                ]);
            },
            unregister: (id)=>{
                if (isUnmounted) return;
                children.value.delete(id);
                const parent = parents.value.get(id);
                if (parent) {
                    const list = children.value.get(parent) ?? [];
                    children.value.set(parent, list.filter((child)=>child !== id));
                }
                parents.value.delete(id);
                opened.value.delete(id);
            },
            open: (id, value, event)=>{
                vm.emit("click:open", {
                    id,
                    value,
                    path: getPath(id),
                    event
                });
                const newOpened = openStrategy.value.open({
                    id,
                    value,
                    opened: new Set(opened.value),
                    children: children.value,
                    parents: parents.value,
                    event
                });
                newOpened && (opened.value = newOpened);
            },
            openOnSelect: (id, value, event)=>{
                const newOpened = openStrategy.value.select({
                    id,
                    value,
                    selected: new Map(selected.value),
                    opened: new Set(opened.value),
                    children: children.value,
                    parents: parents.value,
                    event
                });
                newOpened && (opened.value = newOpened);
            },
            select: (id, value, event)=>{
                vm.emit("click:select", {
                    id,
                    value,
                    path: getPath(id),
                    event
                });
                const newSelected = selectStrategy.value.select({
                    id,
                    value,
                    selected: new Map(selected.value),
                    children: children.value,
                    parents: parents.value,
                    event
                });
                newSelected && (selected.value = newSelected);
                nested.root.openOnSelect(id, value, event);
            },
            children,
            parents
        }
    };
    (0, _vue.provide)(VNestedSymbol, nested);
    return nested.root;
};
const useNestedItem = (id, isGroup)=>{
    const parent = (0, _vue.inject)(VNestedSymbol, emptyNested);
    const uidSymbol = Symbol((0, _indexMjs.getUid)());
    const computedId = (0, _vue.computed)(()=>id.value !== undefined ? id.value : uidSymbol);
    const item = {
        ...parent,
        id: computedId,
        open: (open, e)=>parent.root.open(computedId.value, open, e),
        openOnSelect: (open, e)=>parent.root.openOnSelect(computedId.value, open, e),
        isOpen: (0, _vue.computed)(()=>parent.root.opened.value.has(computedId.value)),
        parent: (0, _vue.computed)(()=>parent.root.parents.value.get(computedId.value)),
        select: (selected, e)=>parent.root.select(computedId.value, selected, e),
        isSelected: (0, _vue.computed)(()=>parent.root.selected.value.get((0, _vue.toRaw)(computedId.value)) === "on"),
        isIndeterminate: (0, _vue.computed)(()=>parent.root.selected.value.get(computedId.value) === "indeterminate"),
        isLeaf: (0, _vue.computed)(()=>!parent.root.children.value.get(computedId.value)),
        isGroupActivator: parent.isGroupActivator
    };
    !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
    (0, _vue.onBeforeUnmount)(()=>{
        !parent.isGroupActivator && parent.root.unregister(computedId.value);
    });
    isGroup && (0, _vue.provide)(VNestedSymbol, item);
    return item;
};
const useNestedGroupActivator = ()=>{
    const parent = (0, _vue.inject)(VNestedSymbol, emptyNested);
    (0, _vue.provide)(VNestedSymbol, {
        ...parent,
        isGroupActivator: true
    });
};

},{"../proxiedModel.mjs":"bUF28","vue":"ff77s","./openStrategies.mjs":"ilYKD","./selectStrategies.mjs":"4PKhm","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ilYKD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "singleOpenStrategy", ()=>singleOpenStrategy);
parcelHelpers.export(exports, "multipleOpenStrategy", ()=>multipleOpenStrategy);
parcelHelpers.export(exports, "listOpenStrategy", ()=>listOpenStrategy);
const singleOpenStrategy = {
    open: (_ref)=>{
        let { id, value, opened, parents } = _ref;
        if (value) {
            const newOpened = new Set();
            newOpened.add(id);
            let parent = parents.get(id);
            while(parent != null){
                newOpened.add(parent);
                parent = parents.get(parent);
            }
            return newOpened;
        } else {
            opened.delete(id);
            return opened;
        }
    },
    select: ()=>null
};
const multipleOpenStrategy = {
    open: (_ref2)=>{
        let { id, value, opened, parents } = _ref2;
        if (value) {
            let parent = parents.get(id);
            opened.add(id);
            while(parent != null && parent !== id){
                opened.add(parent);
                parent = parents.get(parent);
            }
            return opened;
        } else opened.delete(id);
        return opened;
    },
    select: ()=>null
};
const listOpenStrategy = {
    open: multipleOpenStrategy.open,
    select: (_ref3)=>{
        let { id, value, opened, parents } = _ref3;
        if (!value) return opened;
        const path = [];
        let parent = parents.get(id);
        while(parent != null){
            path.push(parent);
            parent = parents.get(parent);
        }
        return new Set(path);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4PKhm":[function(require,module,exports) {
/* eslint-disable sonarjs/no-identical-functions */ // Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "independentSelectStrategy", ()=>independentSelectStrategy);
parcelHelpers.export(exports, "independentSingleSelectStrategy", ()=>independentSingleSelectStrategy);
parcelHelpers.export(exports, "leafSelectStrategy", ()=>leafSelectStrategy);
parcelHelpers.export(exports, "leafSingleSelectStrategy", ()=>leafSingleSelectStrategy);
parcelHelpers.export(exports, "classicSelectStrategy", ()=>classicSelectStrategy);
var _vue = require("vue");
const independentSelectStrategy = (mandatory)=>{
    const strategy = {
        select: (_ref)=>{
            let { id, value, selected } = _ref;
            id = (0, _vue.toRaw)(id);
            // When mandatory and we're trying to deselect when id
            // is the only currently selected item then do nothing
            if (mandatory && !value) {
                const on = Array.from(selected.entries()).reduce((arr, _ref2)=>{
                    let [key, value] = _ref2;
                    return value === "on" ? [
                        ...arr,
                        key
                    ] : arr;
                }, []);
                if (on.length === 1 && on[0] === id) return selected;
            }
            selected.set(id, value ? "on" : "off");
            return selected;
        },
        in: (v, children, parents)=>{
            let map = new Map();
            for (const id of v || [])map = strategy.select({
                id,
                value: true,
                selected: new Map(map),
                children,
                parents
            });
            return map;
        },
        out: (v)=>{
            const arr = [];
            for (const [key, value] of v.entries())if (value === "on") arr.push(key);
            return arr;
        }
    };
    return strategy;
};
const independentSingleSelectStrategy = (mandatory)=>{
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
        select: (_ref3)=>{
            let { selected, id, ...rest } = _ref3;
            id = (0, _vue.toRaw)(id);
            const singleSelected = selected.has(id) ? new Map([
                [
                    id,
                    selected.get(id)
                ]
            ]) : new Map();
            return parentStrategy.select({
                ...rest,
                id,
                selected: singleSelected
            });
        },
        in: (v, children, parents)=>{
            let map = new Map();
            if (v?.length) map = parentStrategy.in(v.slice(0, 1), children, parents);
            return map;
        },
        out: (v, children, parents)=>{
            return parentStrategy.out(v, children, parents);
        }
    };
    return strategy;
};
const leafSelectStrategy = (mandatory)=>{
    const parentStrategy = independentSelectStrategy(mandatory);
    const strategy = {
        select: (_ref4)=>{
            let { id, selected, children, ...rest } = _ref4;
            id = (0, _vue.toRaw)(id);
            if (children.has(id)) return selected;
            return parentStrategy.select({
                id,
                selected,
                children,
                ...rest
            });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
    };
    return strategy;
};
const leafSingleSelectStrategy = (mandatory)=>{
    const parentStrategy = independentSingleSelectStrategy(mandatory);
    const strategy = {
        select: (_ref5)=>{
            let { id, selected, children, ...rest } = _ref5;
            id = (0, _vue.toRaw)(id);
            if (children.has(id)) return selected;
            return parentStrategy.select({
                id,
                selected,
                children,
                ...rest
            });
        },
        in: parentStrategy.in,
        out: parentStrategy.out
    };
    return strategy;
};
const classicSelectStrategy = (mandatory)=>{
    const strategy = {
        select: (_ref6)=>{
            let { id, value, selected, children, parents } = _ref6;
            id = (0, _vue.toRaw)(id);
            const original = new Map(selected);
            const items = [
                id
            ];
            while(items.length){
                const item = items.shift();
                selected.set(item, value ? "on" : "off");
                if (children.has(item)) items.push(...children.get(item));
            }
            let parent = parents.get(id);
            while(parent){
                const childrenIds = children.get(parent);
                const everySelected = childrenIds.every((cid)=>selected.get(cid) === "on");
                const noneSelected = childrenIds.every((cid)=>!selected.has(cid) || selected.get(cid) === "off");
                selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
                parent = parents.get(parent);
            }
            // If mandatory and planned deselect results in no selected
            // items then we can't do it, so return original state
            if (mandatory && !value) {
                const on = Array.from(selected.entries()).reduce((arr, _ref7)=>{
                    let [key, value] = _ref7;
                    return value === "on" ? [
                        ...arr,
                        key
                    ] : arr;
                }, []);
                if (on.length === 0) return original;
            }
            return selected;
        },
        in: (v, children, parents)=>{
            let map = new Map();
            for (const id of v || [])map = strategy.select({
                id,
                value: true,
                selected: new Map(map),
                children,
                parents
            });
            return map;
        },
        out: (v, children)=>{
            const arr = [];
            for (const [key, value] of v.entries())if (value === "on" && !children.has(key)) arr.push(key);
            return arr;
        }
    };
    return strategy;
};

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3m2RV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListItemProps", ()=>makeVListItemProps);
parcelHelpers.export(exports, "VListItem", ()=>VListItem);
var _vue = require("vue");
// Styles
var _vlistItemCss = require("./VListItem.css");
// Components
var _vlistItemSubtitleMjs = require("./VListItemSubtitle.mjs");
var _vlistItemTitleMjs = require("./VListItemTitle.mjs");
var _indexMjs = require("../VAvatar/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VIcon/index.mjs"); // Composables
var _listMjs = require("./list.mjs");
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _nestedMjs = require("../../composables/nested/nested.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Directives
var _indexMjs3 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs4 = require("../../util/index.mjs"); // Types
const makeVListItemProps = (0, _indexMjs4.propsFactory)({
    active: {
        type: Boolean,
        default: undefined
    },
    activeClass: String,
    /* @deprecated */ activeColor: String,
    appendAvatar: String,
    appendIcon: (0, _iconsMjs.IconValue),
    baseColor: String,
    disabled: Boolean,
    lines: String,
    link: {
        type: Boolean,
        default: undefined
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: (0, _iconsMjs.IconValue),
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: true
    },
    subtitle: [
        String,
        Number,
        Boolean
    ],
    title: [
        String,
        Number,
        Boolean
    ],
    value: null,
    onClick: (0, _indexMjs4.EventProp)(),
    onClickOnce: (0, _indexMjs4.EventProp)(),
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _routerMjs.makeRouterProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "text"
    })
}, "VListItem");
const VListItem = (0, _indexMjs4.genericComponent)()({
    name: "VListItem",
    directives: {
        Ripple: (0, _indexMjs3.Ripple)
    },
    props: makeVListItemProps(),
    emits: {
        click: (e)=>true
    },
    setup (props, _ref) {
        let { attrs, slots, emit } = _ref;
        const link = (0, _routerMjs.useLink)(props, attrs);
        const id = (0, _vue.computed)(()=>props.value === undefined ? link.href.value : props.value);
        const { select, isSelected, isIndeterminate, isGroupActivator, root, parent, openOnSelect } = (0, _nestedMjs.useNestedItem)(id, false);
        const list = (0, _listMjs.useList)();
        const isActive = (0, _vue.computed)(()=>props.active !== false && (props.active || link.isActive?.value || isSelected.value));
        const isLink = (0, _vue.computed)(()=>props.link !== false && link.isLink.value);
        const isClickable = (0, _vue.computed)(()=>!props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!list));
        const roundedProps = (0, _vue.computed)(()=>props.rounded || props.nav);
        const color = (0, _vue.computed)(()=>props.color ?? props.activeColor);
        const variantProps = (0, _vue.computed)(()=>({
                color: isActive.value ? color.value ?? props.baseColor : props.baseColor,
                variant: props.variant
            }));
        (0, _vue.watch)(()=>link.isActive?.value, (val)=>{
            if (val && parent.value != null) root.open(parent.value, true);
            if (val) openOnSelect(val);
        }, {
            immediate: true
        });
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(variantProps);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(roundedProps);
        const lineClasses = (0, _vue.computed)(()=>props.lines ? `v-list-item--${props.lines}-line` : undefined);
        const slotProps = (0, _vue.computed)(()=>({
                isActive: isActive.value,
                select,
                isSelected: isSelected.value,
                isIndeterminate: isIndeterminate.value
            }));
        function onClick(e) {
            emit("click", e);
            if (isGroupActivator || !isClickable.value) return;
            link.navigate?.(e);
            props.value != null && select(!isSelected.value, e);
        }
        function onKeyDown(e) {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                onClick(e);
            }
        }
        (0, _indexMjs4.useRender)(()=>{
            const Tag = isLink.value ? "a" : props.tag;
            const hasTitle = slots.title || props.title;
            const hasSubtitle = slots.subtitle || props.subtitle;
            const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
            const hasAppend = !!(hasAppendMedia || slots.append);
            const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
            const hasPrepend = !!(hasPrependMedia || slots.prepend);
            list?.updateHasPrepend(hasPrepend);
            if (props.activeColor) (0, _indexMjs4.deprecate)("active-color", [
                "color",
                "base-color"
            ]);
            return (0, _vue.withDirectives)((0, _vue.createVNode)(Tag, {
                "class": [
                    "v-list-item",
                    {
                        "v-list-item--active": isActive.value,
                        "v-list-item--disabled": props.disabled,
                        "v-list-item--link": isClickable.value,
                        "v-list-item--nav": props.nav,
                        "v-list-item--prepend": !hasPrepend && list?.hasPrepend.value,
                        [`${props.activeClass}`]: props.activeClass && isActive.value
                    },
                    themeClasses.value,
                    borderClasses.value,
                    colorClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    lineClasses.value,
                    roundedClasses.value,
                    variantClasses.value,
                    props.class
                ],
                "style": [
                    colorStyles.value,
                    dimensionStyles.value,
                    props.style
                ],
                "href": link.href.value,
                "tabindex": isClickable.value ? list ? -2 : 0 : undefined,
                "onClick": onClick,
                "onKeydown": isClickable.value && !isLink.value && onKeyDown
            }, {
                default: ()=>[
                        (0, _variantMjs.genOverlays)(isClickable.value || isActive.value, "v-list-item"),
                        hasPrepend && (0, _vue.createVNode)("div", {
                            "key": "prepend",
                            "class": "v-list-item__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.prependAvatar && (0, _vue.createVNode)((0, _indexMjs.VAvatar), {
                                    "key": "prepend-avatar",
                                    "density": props.density,
                                    "image": props.prependAvatar
                                }, null),
                                props.prependIcon && (0, _vue.createVNode)((0, _indexMjs2.VIcon), {
                                    "key": "prepend-icon",
                                    "density": props.density,
                                    "icon": props.prependIcon
                                }, null)
                            ]) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !hasPrependMedia,
                                "defaults": {
                                    VAvatar: {
                                        density: props.density,
                                        image: props.prependAvatar
                                    },
                                    VIcon: {
                                        density: props.density,
                                        icon: props.prependIcon
                                    },
                                    VListItemAction: {
                                        start: true
                                    }
                                }
                            }, {
                                default: ()=>[
                                        slots.prepend?.(slotProps.value)
                                    ]
                            }),
                            (0, _vue.createVNode)("div", {
                                "class": "v-list-item__spacer"
                            }, null)
                        ]),
                        (0, _vue.createVNode)("div", {
                            "class": "v-list-item__content",
                            "data-no-activator": ""
                        }, [
                            hasTitle && (0, _vue.createVNode)((0, _vlistItemTitleMjs.VListItemTitle), {
                                "key": "title"
                            }, {
                                default: ()=>[
                                        slots.title?.({
                                            title: props.title
                                        }) ?? props.title
                                    ]
                            }),
                            hasSubtitle && (0, _vue.createVNode)((0, _vlistItemSubtitleMjs.VListItemSubtitle), {
                                "key": "subtitle"
                            }, {
                                default: ()=>[
                                        slots.subtitle?.({
                                            subtitle: props.subtitle
                                        }) ?? props.subtitle
                                    ]
                            }),
                            slots.default?.(slotProps.value)
                        ]),
                        hasAppend && (0, _vue.createVNode)("div", {
                            "key": "append",
                            "class": "v-list-item__append"
                        }, [
                            !slots.append ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.appendIcon && (0, _vue.createVNode)((0, _indexMjs2.VIcon), {
                                    "key": "append-icon",
                                    "density": props.density,
                                    "icon": props.appendIcon
                                }, null),
                                props.appendAvatar && (0, _vue.createVNode)((0, _indexMjs.VAvatar), {
                                    "key": "append-avatar",
                                    "density": props.density,
                                    "image": props.appendAvatar
                                }, null)
                            ]) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "append-defaults",
                                "disabled": !hasAppendMedia,
                                "defaults": {
                                    VAvatar: {
                                        density: props.density,
                                        image: props.appendAvatar
                                    },
                                    VIcon: {
                                        density: props.density,
                                        icon: props.appendIcon
                                    },
                                    VListItemAction: {
                                        end: true
                                    }
                                }
                            }, {
                                default: ()=>[
                                        slots.append?.(slotProps.value)
                                    ]
                            }),
                            (0, _vue.createVNode)("div", {
                                "class": "v-list-item__spacer"
                            }, null)
                        ])
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("ripple"),
                    isClickable.value && props.ripple
                ]
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VListItem.css":"7s82O","./VListItemSubtitle.mjs":"iXbVm","./VListItemTitle.mjs":"8XqCQ","../VAvatar/index.mjs":"1cQMc","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","./list.mjs":"6kUuk","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/nested/nested.mjs":"5YIw3","../../composables/rounded.mjs":"ldhZ9","../../composables/router.mjs":"bEBrG","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7s82O":[function() {},{}],"iXbVm":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VListItemSubtitle", ()=>VListItemSubtitle);
var _indexMjs = require("../../util/index.mjs");
const VListItemSubtitle = (0, _indexMjs.createSimpleFunctional)("v-list-item-subtitle");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8XqCQ":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VListItemTitle", ()=>VListItemTitle);
var _indexMjs = require("../../util/index.mjs");
const VListItemTitle = (0, _indexMjs.createSimpleFunctional)("v-list-item-title");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6v7p7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListSubheaderProps", ()=>makeVListSubheaderProps);
parcelHelpers.export(exports, "VListSubheader", ()=>VListSubheader);
var _vue = require("vue");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVListSubheaderProps = (0, _indexMjs.propsFactory)({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VListSubheader");
const VListSubheader = (0, _indexMjs.genericComponent)()({
    name: "VListSubheader",
    props: makeVListSubheaderProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "color"));
        (0, _indexMjs.useRender)(()=>{
            const hasText = !!(slots.default || props.title);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-list-subheader",
                    {
                        "v-list-subheader--inset": props.inset,
                        "v-list-subheader--sticky": props.sticky
                    },
                    textColorClasses.value,
                    props.class
                ],
                "style": [
                    {
                        textColorStyles
                    },
                    props.style
                ]
            }, {
                default: ()=>[
                        hasText && (0, _vue.createVNode)("div", {
                            "class": "v-list-subheader__text"
                        }, [
                            slots.default?.() ?? props.title
                        ])
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ajcaZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VDivider", ()=>(0, _vdividerMjs.VDivider));
var _vdividerMjs = require("./VDivider.mjs");

},{"./VDivider.mjs":"1uIh7","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1uIh7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVDividerProps", ()=>makeVDividerProps);
parcelHelpers.export(exports, "VDivider", ()=>VDivider);
var _vue = require("vue");
// Styles
var _vdividerCss = require("./VDivider.css");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVDividerProps = (0, _indexMjs.propsFactory)({
    color: String,
    inset: Boolean,
    length: [
        Number,
        String
    ],
    thickness: [
        Number,
        String
    ],
    vertical: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VDivider");
const VDivider = (0, _indexMjs.genericComponent)()({
    name: "VDivider",
    props: makeVDividerProps(),
    setup (props, _ref) {
        let { attrs } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "color"));
        const dividerStyles = (0, _vue.computed)(()=>{
            const styles = {};
            if (props.length) styles[props.vertical ? "maxHeight" : "maxWidth"] = (0, _indexMjs.convertToUnit)(props.length);
            if (props.thickness) styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = (0, _indexMjs.convertToUnit)(props.thickness);
            return styles;
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("hr", {
                "class": [
                    {
                        "v-divider": true,
                        "v-divider--inset": props.inset,
                        "v-divider--vertical": props.vertical
                    },
                    themeClasses.value,
                    textColorClasses.value,
                    props.class
                ],
                "style": [
                    dividerStyles.value,
                    textColorStyles.value,
                    props.style
                ],
                "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : undefined,
                "role": `${attrs.role || "separator"}`
            }, null));
        return {};
    }
});

},{"vue":"ff77s","./VDivider.css":"iIJbj","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iIJbj":[function() {},{}],"kVtgo":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeItemsProps", ()=>makeItemsProps);
parcelHelpers.export(exports, "transformItem", ()=>transformItem);
parcelHelpers.export(exports, "transformItems", ()=>transformItems);
parcelHelpers.export(exports, "useItems", ()=>useItems);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeItemsProps = (0, _indexMjs.propsFactory)({
    items: {
        type: Array,
        default: ()=>[]
    },
    itemTitle: {
        type: [
            String,
            Array,
            Function
        ],
        default: "title"
    },
    itemValue: {
        type: [
            String,
            Array,
            Function
        ],
        default: "value"
    },
    itemChildren: {
        type: [
            Boolean,
            String,
            Array,
            Function
        ],
        default: "children"
    },
    itemProps: {
        type: [
            Boolean,
            String,
            Array,
            Function
        ],
        default: "props"
    },
    returnObject: Boolean,
    valueComparator: {
        type: Function,
        default: (0, _indexMjs.deepEqual)
    }
}, "list-items");
function transformItem(props, item) {
    const title = (0, _indexMjs.getPropertyFromItem)(item, props.itemTitle, item);
    const value = (0, _indexMjs.getPropertyFromItem)(item, props.itemValue, title);
    const children = (0, _indexMjs.getPropertyFromItem)(item, props.itemChildren);
    const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? (0, _indexMjs.pick)(item, [
        "children"
    ])[1] : item : undefined : (0, _indexMjs.getPropertyFromItem)(item, props.itemProps);
    const _props = {
        title,
        value,
        ...itemProps
    };
    return {
        title: String(_props.title ?? ""),
        value: _props.value,
        props: _props,
        children: Array.isArray(children) ? transformItems(props, children) : undefined,
        raw: item
    };
}
function transformItems(props, items) {
    const array = [];
    for (const item of items)array.push(transformItem(props, item));
    return array;
}
function useItems(props) {
    const items = (0, _vue.computed)(()=>transformItems(props, props.items));
    const hasNullItem = (0, _vue.computed)(()=>items.value.some((item)=>item.value === null));
    function transformIn(value) {
        if (!hasNullItem.value) // When the model value is null, return an InternalItem
        // based on null only if null is one of the items
        value = value.filter((v)=>v !== null);
        return value.map((v)=>{
            if (props.returnObject && typeof v === "string") // String model value means value is a custom input value from combobox
            // Don't look up existing items if the model value is a string
            return transformItem(props, v);
            return items.value.find((item)=>props.valueComparator(v, item.value)) || transformItem(props, v);
        });
    }
    function transformOut(value) {
        return props.returnObject ? value.map((_ref)=>{
            let { raw } = _ref;
            return raw;
        }) : value.map((_ref2)=>{
            let { value } = _ref2;
            return value;
        });
    }
    return {
        items,
        transformIn,
        transformOut
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1sXJZ":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VListImg", ()=>VListImg);
var _indexMjs = require("../../util/index.mjs");
const VListImg = (0, _indexMjs.createSimpleFunctional)("v-list-img");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eocvS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListItemActionProps", ()=>makeVListItemActionProps);
parcelHelpers.export(exports, "VListItemAction", ()=>VListItemAction);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVListItemActionProps = (0, _indexMjs.propsFactory)({
    start: Boolean,
    end: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VListItemAction");
const VListItemAction = (0, _indexMjs.genericComponent)()({
    name: "VListItemAction",
    props: makeVListItemActionProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-list-item-action",
                    {
                        "v-list-item-action--start": props.start,
                        "v-list-item-action--end": props.end
                    },
                    props.class
                ],
                "style": props.style
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aKLYY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVListItemMediaProps", ()=>makeVListItemMediaProps);
parcelHelpers.export(exports, "VListItemMedia", ()=>VListItemMedia);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVListItemMediaProps = (0, _indexMjs.propsFactory)({
    start: Boolean,
    end: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VListItemMedia");
const VListItemMedia = (0, _indexMjs.genericComponent)()({
    name: "VListItemMedia",
    props: makeVListItemMediaProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-list-item-media",
                    {
                        "v-list-item-media--start": props.start,
                        "v-list-item-media--end": props.end
                    },
                    props.class
                ],
                "style": props.style
            }, slots);
        });
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fYY6u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VMenu", ()=>(0, _vmenuMjs.VMenu));
var _vmenuMjs = require("./VMenu.mjs");

},{"./VMenu.mjs":"4YSeO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4YSeO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVMenuProps", ()=>makeVMenuProps);
parcelHelpers.export(exports, "VMenu", ()=>VMenu);
var _vue = require("vue");
// Styles
var _vmenuCss = require("./VMenu.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VOverlay/index.mjs");
var _voverlayMjs = require("../VOverlay/VOverlay.mjs"); // Composables
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs"); // Utilities
var _sharedMjs = require("./shared.mjs");
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVMenuProps = (0, _indexMjs3.propsFactory)({
    // TODO
    // disableKeys: Boolean,
    id: String,
    ...(0, _indexMjs3.omit)((0, _voverlayMjs.makeVOverlayProps)({
        closeDelay: 250,
        closeOnContentClick: true,
        locationStrategy: "connected",
        openDelay: 300,
        scrim: false,
        scrollStrategy: "reposition",
        transition: {
            component: (0, _indexMjs.VDialogTransition)
        }
    }), [
        "absolute"
    ])
}, "VMenu");
const VMenu = (0, _indexMjs3.genericComponent)()({
    name: "VMenu",
    props: makeVMenuProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        const uid = (0, _indexMjs3.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `v-menu-${uid}`);
        const overlay = (0, _vue.ref)();
        const parent = (0, _vue.inject)((0, _sharedMjs.VMenuSymbol), null);
        const openChildren = (0, _vue.shallowRef)(0);
        (0, _vue.provide)((0, _sharedMjs.VMenuSymbol), {
            register () {
                ++openChildren.value;
            },
            unregister () {
                --openChildren.value;
            },
            closeParents () {
                setTimeout(()=>{
                    if (!openChildren.value) {
                        isActive.value = false;
                        parent?.closeParents();
                    }
                }, 40);
            }
        });
        async function onFocusIn(e) {
            const before = e.relatedTarget;
            const after = e.target;
            await (0, _vue.nextTick)();
            if (isActive.value && before !== after && overlay.value?.contentEl && // We're the topmost menu
            overlay.value?.globalTop && // It isn't the document or the menu body
            ![
                document,
                overlay.value.contentEl
            ].includes(after) && // It isn't inside the menu body
            !overlay.value.contentEl.contains(after)) {
                const focusable = (0, _indexMjs3.focusableChildren)(overlay.value.contentEl);
                focusable[0]?.focus();
            }
        }
        (0, _vue.watch)(isActive, (val)=>{
            if (val) {
                parent?.register();
                document.addEventListener("focusin", onFocusIn, {
                    once: true
                });
            } else {
                parent?.unregister();
                document.removeEventListener("focusin", onFocusIn);
            }
        });
        function onClickOutside() {
            parent?.closeParents();
        }
        function onKeydown(e) {
            if (props.disabled) return;
            if (e.key === "Tab") {
                const nextElement = (0, _indexMjs3.getNextElement)((0, _indexMjs3.focusableChildren)(overlay.value?.contentEl, false), e.shiftKey ? "prev" : "next", (el)=>el.tabIndex >= 0);
                if (!nextElement) {
                    isActive.value = false;
                    overlay.value?.activatorEl?.focus();
                }
            }
        }
        function onActivatorKeydown(e) {
            if (props.disabled) return;
            const el = overlay.value?.contentEl;
            if (el && isActive.value) {
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    (0, _indexMjs3.focusChild)(el, "next");
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    (0, _indexMjs3.focusChild)(el, "prev");
                }
            } else if ([
                "ArrowDown",
                "ArrowUp"
            ].includes(e.key)) {
                isActive.value = true;
                e.preventDefault();
                setTimeout(()=>setTimeout(()=>onActivatorKeydown(e)));
            }
        }
        const activatorProps = (0, _vue.computed)(()=>(0, _vue.mergeProps)({
                "aria-haspopup": "menu",
                "aria-expanded": String(isActive.value),
                "aria-owns": id.value,
                onKeydown: onActivatorKeydown
            }, props.activatorProps));
        (0, _indexMjs3.useRender)(()=>{
            const [overlayProps] = (0, _indexMjs2.VOverlay).filterProps(props);
            return (0, _vue.createVNode)((0, _indexMjs2.VOverlay), (0, _vue.mergeProps)({
                "ref": overlay,
                "class": [
                    "v-menu",
                    props.class
                ],
                "style": props.style
            }, overlayProps, {
                "modelValue": isActive.value,
                "onUpdate:modelValue": ($event)=>isActive.value = $event,
                "absolute": true,
                "activatorProps": activatorProps.value,
                "onClick:outside": onClickOutside,
                "onKeydown": onKeydown
            }, scopeId), {
                activator: slots.activator,
                default: function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                        "root": "VMenu"
                    }, {
                        default: ()=>[
                                slots.default?.(...args)
                            ]
                    });
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({
            id,
            Œ®openChildren: openChildren
        }, overlay);
    }
});

},{"vue":"ff77s","./VMenu.css":"fK5W0","../transitions/index.mjs":"oiH7Z","../VDefaultsProvider/index.mjs":"1OIgj","../VOverlay/index.mjs":"28W37","../VOverlay/VOverlay.mjs":"9nMvb","../../composables/forwardRefs.mjs":"h5grs","../../composables/proxiedModel.mjs":"bUF28","../../composables/scopeId.mjs":"78lmg","./shared.mjs":"3gwcw","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fK5W0":[function() {},{}],"28W37":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VOverlay", ()=>(0, _voverlayMjs.VOverlay));
var _voverlayMjs = require("./VOverlay.mjs");

},{"./VOverlay.mjs":"9nMvb","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9nMvb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVOverlayProps", ()=>makeVOverlayProps);
parcelHelpers.export(exports, "VOverlay", ()=>VOverlay);
var _vue = require("vue");
// Styles
var _voverlayCss = require("./VOverlay.css");
// Composables
var _locationStrategiesMjs = require("./locationStrategies.mjs");
var _scrollStrategiesMjs = require("./scrollStrategies.mjs");
var _useActivatorMjs = require("./useActivator.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _hydrationMjs = require("../../composables/hydration.mjs");
var _lazyMjs = require("../../composables/lazy.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs");
var _stackMjs = require("../../composables/stack.mjs");
var _teleportMjs = require("../../composables/teleport.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _toggleScopeMjs = require("../../composables/toggleScope.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Directives
var _indexMjs = require("../../directives/click-outside/index.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
function Scrim(props) {
    const { modelValue, color, ...rest } = props;
    return (0, _vue.createVNode)((0, _vue.Transition), {
        "name": "fade-transition",
        "appear": true
    }, {
        default: ()=>[
                props.modelValue && (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                    "class": [
                        "v-overlay__scrim",
                        props.color.backgroundColorClasses.value
                    ],
                    "style": props.color.backgroundColorStyles.value
                }, rest), null)
            ]
    });
}
const makeVOverlayProps = (0, _indexMjs1.propsFactory)({
    absolute: Boolean,
    attach: [
        Boolean,
        String,
        Object
    ],
    closeOnBack: {
        type: Boolean,
        default: true
    },
    contained: Boolean,
    contentClass: null,
    contentProps: null,
    disabled: Boolean,
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
        type: [
            Boolean,
            String
        ],
        default: true
    },
    zIndex: {
        type: [
            Number,
            String
        ],
        default: 2000
    },
    ...(0, _useActivatorMjs.makeActivatorProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _lazyMjs.makeLazyProps)(),
    ...(0, _locationStrategiesMjs.makeLocationStrategyProps)(),
    ...(0, _scrollStrategiesMjs.makeScrollStrategyProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _transitionMjs.makeTransitionProps)()
}, "VOverlay");
const VOverlay = (0, _indexMjs1.genericComponent)()({
    name: "VOverlay",
    directives: {
        ClickOutside: (0, _indexMjs.ClickOutside)
    },
    inheritAttrs: false,
    props: {
        _disableGlobalStack: Boolean,
        ...makeVOverlayProps()
    },
    emits: {
        "click:outside": (e)=>true,
        "update:modelValue": (value)=>true,
        afterLeave: ()=>true
    },
    setup (props, _ref) {
        let { slots, attrs, emit } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const isActive = (0, _vue.computed)({
            get: ()=>model.value,
            set: (v)=>{
                if (!(v && props.disabled)) model.value = v;
            }
        });
        const { teleportTarget } = (0, _teleportMjs.useTeleport)((0, _vue.computed)(()=>props.attach || props.contained));
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { rtlClasses, isRtl } = (0, _localeMjs.useRtl)();
        const { hasContent, onAfterLeave } = (0, _lazyMjs.useLazy)(props, isActive);
        const scrimColor = (0, _colorMjs.useBackgroundColor)((0, _vue.computed)(()=>{
            return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const { globalTop, localTop, stackStyles } = (0, _stackMjs.useStack)(isActive, (0, _vue.toRef)(props, "zIndex"), props._disableGlobalStack);
        const { activatorEl, activatorRef, activatorEvents, contentEvents, scrimEvents } = (0, _useActivatorMjs.useActivator)(props, {
            isActive,
            isTop: localTop
        });
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const isMounted = (0, _hydrationMjs.useHydration)();
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        (0, _vue.watch)(()=>props.disabled, (v)=>{
            if (v) isActive.value = false;
        });
        const root = (0, _vue.ref)();
        const contentEl = (0, _vue.ref)();
        const { contentStyles, updateLocation } = (0, _locationStrategiesMjs.useLocationStrategies)(props, {
            isRtl,
            contentEl,
            activatorEl,
            isActive
        });
        (0, _scrollStrategiesMjs.useScrollStrategies)(props, {
            root,
            contentEl,
            activatorEl,
            isActive,
            updateLocation
        });
        function onClickOutside(e) {
            emit("click:outside", e);
            if (!props.persistent) isActive.value = false;
            else animateClick();
        }
        function closeConditional() {
            return isActive.value && globalTop.value;
        }
        (0, _indexMjs1.IN_BROWSER) && (0, _vue.watch)(isActive, (val)=>{
            if (val) window.addEventListener("keydown", onKeydown);
            else window.removeEventListener("keydown", onKeydown);
        }, {
            immediate: true
        });
        function onKeydown(e) {
            if (e.key === "Escape" && globalTop.value) {
                if (!props.persistent) {
                    isActive.value = false;
                    if (contentEl.value?.contains(document.activeElement)) activatorEl.value?.focus();
                } else animateClick();
            }
        }
        const router = (0, _routerMjs.useRouter)();
        (0, _toggleScopeMjs.useToggleScope)(()=>props.closeOnBack, ()=>{
            (0, _routerMjs.useBackButton)(router, (next)=>{
                if (globalTop.value && isActive.value) {
                    next(false);
                    if (!props.persistent) isActive.value = false;
                    else animateClick();
                } else next();
            });
        });
        const top = (0, _vue.ref)();
        (0, _vue.watch)(()=>isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val)=>{
            if (val) {
                const scrollParent = (0, _indexMjs1.getScrollParent)(root.value);
                if (scrollParent && scrollParent !== document.scrollingElement) top.value = scrollParent.scrollTop;
            }
        });
        // Add a quick "bounce" animation to the content
        function animateClick() {
            if (props.noClickAnimation) return;
            contentEl.value && (0, _indexMjs1.animate)(contentEl.value, [
                {
                    transformOrigin: "center"
                },
                {
                    transform: "scale(1.03)"
                },
                {
                    transformOrigin: "center"
                }
            ], {
                duration: 150,
                easing: (0, _indexMjs1.standardEasing)
            });
        }
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                slots.activator?.({
                    isActive: isActive.value,
                    props: (0, _vue.mergeProps)({
                        ref: activatorRef
                    }, activatorEvents.value, props.activatorProps)
                }),
                isMounted.value && hasContent.value && (0, _vue.createVNode)((0, _vue.Teleport), {
                    "disabled": !teleportTarget.value,
                    "to": teleportTarget.value
                }, {
                    default: ()=>[
                            (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                                "class": [
                                    "v-overlay",
                                    {
                                        "v-overlay--absolute": props.absolute || props.contained,
                                        "v-overlay--active": isActive.value,
                                        "v-overlay--contained": props.contained
                                    },
                                    themeClasses.value,
                                    rtlClasses.value,
                                    props.class
                                ],
                                "style": [
                                    stackStyles.value,
                                    {
                                        top: (0, _indexMjs1.convertToUnit)(top.value)
                                    },
                                    props.style
                                ],
                                "ref": root
                            }, scopeId, attrs), [
                                (0, _vue.createVNode)(Scrim, (0, _vue.mergeProps)({
                                    "color": scrimColor,
                                    "modelValue": isActive.value && !!props.scrim
                                }, scrimEvents.value), null),
                                (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                                    "appear": true,
                                    "persisted": true,
                                    "transition": props.transition,
                                    "target": activatorEl.value,
                                    "onAfterLeave": ()=>{
                                        onAfterLeave();
                                        emit("afterLeave");
                                    }
                                }, {
                                    default: ()=>[
                                            (0, _vue.withDirectives)((0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                                                "ref": contentEl,
                                                "class": [
                                                    "v-overlay__content",
                                                    props.contentClass
                                                ],
                                                "style": [
                                                    dimensionStyles.value,
                                                    contentStyles.value
                                                ]
                                            }, contentEvents.value, props.contentProps), [
                                                slots.default?.({
                                                    isActive
                                                })
                                            ]), [
                                                [
                                                    (0, _vue.vShow),
                                                    isActive.value
                                                ],
                                                [
                                                    (0, _vue.resolveDirective)("click-outside"),
                                                    {
                                                        handler: onClickOutside,
                                                        closeConditional,
                                                        include: ()=>[
                                                                activatorEl.value
                                                            ]
                                                    }
                                                ]
                                            ])
                                        ]
                                })
                            ])
                        ]
                })
            ]));
        return {
            activatorEl,
            animateClick,
            contentEl,
            globalTop,
            localTop,
            updateLocation
        };
    }
});

},{"vue":"ff77s","./VOverlay.css":"gFxcV","./locationStrategies.mjs":"1NnoA","./scrollStrategies.mjs":"57TUW","./useActivator.mjs":"eEi0c","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../composables/hydration.mjs":"jI0s5","../../composables/lazy.mjs":"au1NJ","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/router.mjs":"bEBrG","../../composables/scopeId.mjs":"78lmg","../../composables/stack.mjs":"fFcSD","../../composables/teleport.mjs":"dTe7e","../../composables/theme.mjs":"9LCgN","../../composables/toggleScope.mjs":"cE29O","../../composables/transition.mjs":"gFVfN","../../directives/click-outside/index.mjs":"gSpMV","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gFxcV":[function() {},{}],"1NnoA":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeLocationStrategyProps", ()=>makeLocationStrategyProps);
parcelHelpers.export(exports, "useLocationStrategies", ()=>useLocationStrategies);
var _toggleScopeMjs = require("../../composables/toggleScope.mjs"); // Utilities
var _vue = require("vue");
var _pointMjs = require("./util/point.mjs");
var _indexMjs = require("../../util/index.mjs");
var _boxMjs = require("../../util/box.mjs"); // Types
const locationStrategies = {
    static: staticLocationStrategy,
    // specific viewport position, usually centered
    connected: connectedLocationStrategy // connected to a certain element
};
const makeLocationStrategyProps = (0, _indexMjs.propsFactory)({
    locationStrategy: {
        type: [
            String,
            Function
        ],
        default: "static",
        validator: (val)=>typeof val === "function" || val in locationStrategies
    },
    location: {
        type: String,
        default: "bottom"
    },
    origin: {
        type: String,
        default: "auto"
    },
    offset: [
        Number,
        String,
        Array
    ]
}, "VOverlay-location-strategies");
function useLocationStrategies(props, data) {
    const contentStyles = (0, _vue.ref)({});
    const updateLocation = (0, _vue.ref)();
    if (0, _indexMjs.IN_BROWSER) {
        (0, _toggleScopeMjs.useToggleScope)(()=>!!(data.isActive.value && props.locationStrategy), (reset)=>{
            (0, _vue.watch)(()=>props.locationStrategy, reset);
            (0, _vue.onScopeDispose)(()=>{
                updateLocation.value = undefined;
            });
            if (typeof props.locationStrategy === "function") updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation;
            else updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation;
        });
        window.addEventListener("resize", onResize, {
            passive: true
        });
        (0, _vue.onScopeDispose)(()=>{
            window.removeEventListener("resize", onResize);
            updateLocation.value = undefined;
        });
    }
    function onResize(e) {
        updateLocation.value?.(e);
    }
    return {
        contentStyles,
        updateLocation
    };
}
function staticLocationStrategy() {
// TODO
}
/** Get size of element ignoring max-width/max-height */ function getIntrinsicSize(el, isRtl) {
    // const scrollables = new Map<Element, [number, number]>()
    // el.querySelectorAll('*').forEach(el => {
    //   const x = el.scrollLeft
    //   const y = el.scrollTop
    //   if (x || y) {
    //     scrollables.set(el, [x, y])
    //   }
    // })
    // const initialMaxWidth = el.style.maxWidth
    // const initialMaxHeight = el.style.maxHeight
    // el.style.removeProperty('max-width')
    // el.style.removeProperty('max-height')
    if (isRtl) el.style.removeProperty("left");
    else el.style.removeProperty("right");
    /* eslint-disable-next-line sonarjs/prefer-immediate-return */ const contentBox = (0, _indexMjs.nullifyTransforms)(el);
    if (isRtl) contentBox.x += parseFloat(el.style.right || 0);
    else contentBox.x -= parseFloat(el.style.left || 0);
    contentBox.y -= parseFloat(el.style.top || 0);
    // el.style.maxWidth = initialMaxWidth
    // el.style.maxHeight = initialMaxHeight
    // scrollables.forEach((position, el) => {
    //   el.scrollTo(...position)
    // })
    return contentBox;
}
function connectedLocationStrategy(data, props, contentStyles) {
    const activatorFixed = (0, _indexMjs.isFixedPosition)(data.activatorEl.value);
    if (activatorFixed) Object.assign(contentStyles.value, {
        position: "fixed",
        top: 0,
        [data.isRtl.value ? "right" : "left"]: 0
    });
    const { preferredAnchor, preferredOrigin } = (0, _indexMjs.destructComputed)(()=>{
        const parsedAnchor = (0, _indexMjs.parseAnchor)(props.location, data.isRtl.value);
        const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? (0, _indexMjs.flipSide)(parsedAnchor) : (0, _indexMjs.parseAnchor)(props.origin, data.isRtl.value);
        // Some combinations of props may produce an invalid origin
        if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === (0, _indexMjs.flipAlign)(parsedOrigin).align) return {
            preferredAnchor: (0, _indexMjs.flipCorner)(parsedAnchor),
            preferredOrigin: (0, _indexMjs.flipCorner)(parsedOrigin)
        };
        else return {
            preferredAnchor: parsedAnchor,
            preferredOrigin: parsedOrigin
        };
    });
    const [minWidth, minHeight, maxWidth, maxHeight] = [
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight"
    ].map((key)=>{
        return (0, _vue.computed)(()=>{
            const val = parseFloat(props[key]);
            return isNaN(val) ? Infinity : val;
        });
    });
    const offset = (0, _vue.computed)(()=>{
        if (Array.isArray(props.offset)) return props.offset;
        if (typeof props.offset === "string") {
            const offset = props.offset.split(" ").map(parseFloat);
            if (offset.length < 2) offset.push(0);
            return offset;
        }
        return typeof props.offset === "number" ? [
            props.offset,
            0
        ] : [
            0,
            0
        ];
    });
    let observe = false;
    const observer = new ResizeObserver(()=>{
        if (observe) updateLocation();
    });
    (0, _vue.watch)([
        data.activatorEl,
        data.contentEl
    ], (_ref, _ref2)=>{
        let [newActivatorEl, newContentEl] = _ref;
        let [oldActivatorEl, oldContentEl] = _ref2;
        if (oldActivatorEl) observer.unobserve(oldActivatorEl);
        if (newActivatorEl) observer.observe(newActivatorEl);
        if (oldContentEl) observer.unobserve(oldContentEl);
        if (newContentEl) observer.observe(newContentEl);
    }, {
        immediate: true
    });
    (0, _vue.onScopeDispose)(()=>{
        observer.disconnect();
    });
    // eslint-disable-next-line max-statements
    function updateLocation() {
        observe = false;
        requestAnimationFrame(()=>{
            requestAnimationFrame(()=>observe = true);
        });
        if (!data.activatorEl.value || !data.contentEl.value) return;
        const targetBox = data.activatorEl.value.getBoundingClientRect();
        const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
        const scrollParents = (0, _indexMjs.getScrollParents)(data.contentEl.value);
        const viewportMargin = 12;
        if (!scrollParents.length) {
            scrollParents.push(document.documentElement);
            if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
                contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
                contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
            }
        }
        const viewport = scrollParents.reduce((box, el)=>{
            const rect = el.getBoundingClientRect();
            const scrollBox = new (0, _boxMjs.Box)({
                x: el === document.documentElement ? 0 : rect.x,
                y: el === document.documentElement ? 0 : rect.y,
                width: el.clientWidth,
                height: el.clientHeight
            });
            if (box) return new (0, _boxMjs.Box)({
                x: Math.max(box.left, scrollBox.left),
                y: Math.max(box.top, scrollBox.top),
                width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
                height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
            });
            return scrollBox;
        }, undefined);
        viewport.x += viewportMargin;
        viewport.y += viewportMargin;
        viewport.width -= viewportMargin * 2;
        viewport.height -= viewportMargin * 2;
        let placement = {
            anchor: preferredAnchor.value,
            origin: preferredOrigin.value
        };
        function checkOverflow(_placement) {
            const box = new (0, _boxMjs.Box)(contentBox);
            const targetPoint = (0, _pointMjs.anchorToPoint)(_placement.anchor, targetBox);
            const contentPoint = (0, _pointMjs.anchorToPoint)(_placement.origin, box);
            let { x, y } = (0, _pointMjs.getOffset)(targetPoint, contentPoint);
            switch(_placement.anchor.side){
                case "top":
                    y -= offset.value[0];
                    break;
                case "bottom":
                    y += offset.value[0];
                    break;
                case "left":
                    x -= offset.value[0];
                    break;
                case "right":
                    x += offset.value[0];
                    break;
            }
            switch(_placement.anchor.align){
                case "top":
                    y -= offset.value[1];
                    break;
                case "bottom":
                    y += offset.value[1];
                    break;
                case "left":
                    x -= offset.value[1];
                    break;
                case "right":
                    x += offset.value[1];
                    break;
            }
            box.x += x;
            box.y += y;
            box.width = Math.min(box.width, maxWidth.value);
            box.height = Math.min(box.height, maxHeight.value);
            const overflows = (0, _boxMjs.getOverflow)(box, viewport);
            return {
                overflows,
                x,
                y
            };
        }
        let x = 0;
        let y = 0;
        const available = {
            x: 0,
            y: 0
        };
        const flipped = {
            x: false,
            y: false
        };
        let resets = -1;
        while(true){
            if (resets++ > 10) {
                (0, _indexMjs.consoleError)("Infinite loop detected in connectedLocationStrategy");
                break;
            }
            const { x: _x, y: _y, overflows } = checkOverflow(placement);
            x += _x;
            y += _y;
            contentBox.x += _x;
            contentBox.y += _y;
            // flip
            {
                const axis = (0, _indexMjs.getAxis)(placement.anchor);
                const hasOverflowX = overflows.x.before || overflows.x.after;
                const hasOverflowY = overflows.y.before || overflows.y.after;
                let reset = false;
                [
                    "x",
                    "y"
                ].forEach((key)=>{
                    if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
                        const newPlacement = {
                            anchor: {
                                ...placement.anchor
                            },
                            origin: {
                                ...placement.origin
                            }
                        };
                        const flip = key === "x" ? axis === "y" ? (0, _indexMjs.flipAlign) : (0, _indexMjs.flipSide) : axis === "y" ? (0, _indexMjs.flipSide) : (0, _indexMjs.flipAlign);
                        newPlacement.anchor = flip(newPlacement.anchor);
                        newPlacement.origin = flip(newPlacement.origin);
                        const { overflows: newOverflows } = checkOverflow(newPlacement);
                        if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
                            placement = newPlacement;
                            reset = flipped[key] = true;
                        }
                    }
                });
                if (reset) continue;
            }
            // shift
            if (overflows.x.before) {
                x += overflows.x.before;
                contentBox.x += overflows.x.before;
            }
            if (overflows.x.after) {
                x -= overflows.x.after;
                contentBox.x -= overflows.x.after;
            }
            if (overflows.y.before) {
                y += overflows.y.before;
                contentBox.y += overflows.y.before;
            }
            if (overflows.y.after) {
                y -= overflows.y.after;
                contentBox.y -= overflows.y.after;
            }
            // size
            {
                const overflows = (0, _boxMjs.getOverflow)(contentBox, viewport);
                available.x = viewport.width - overflows.x.before - overflows.x.after;
                available.y = viewport.height - overflows.y.before - overflows.y.after;
                x += overflows.x.before;
                contentBox.x += overflows.x.before;
                y += overflows.y.before;
                contentBox.y += overflows.y.before;
            }
            break;
        }
        const axis = (0, _indexMjs.getAxis)(placement.anchor);
        Object.assign(contentStyles.value, {
            "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
            transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
            // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
            top: (0, _indexMjs.convertToUnit)(pixelRound(y)),
            left: data.isRtl.value ? undefined : (0, _indexMjs.convertToUnit)(pixelRound(x)),
            right: data.isRtl.value ? (0, _indexMjs.convertToUnit)(pixelRound(-x)) : undefined,
            minWidth: (0, _indexMjs.convertToUnit)(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
            maxWidth: (0, _indexMjs.convertToUnit)(pixelCeil((0, _indexMjs.clamp)(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
            maxHeight: (0, _indexMjs.convertToUnit)(pixelCeil((0, _indexMjs.clamp)(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
        });
        return {
            available,
            contentBox
        };
    }
    (0, _vue.watch)(()=>[
            preferredAnchor.value,
            preferredOrigin.value,
            props.offset,
            props.minWidth,
            props.minHeight,
            props.maxWidth,
            props.maxHeight
        ], ()=>updateLocation());
    (0, _vue.nextTick)(()=>{
        const result = updateLocation();
        // TODO: overflowing content should only require a single updateLocation call
        // Icky hack to make sure the content is positioned consistently
        if (!result) return;
        const { available, contentBox } = result;
        if (contentBox.height > available.y) requestAnimationFrame(()=>{
            updateLocation();
            requestAnimationFrame(()=>{
                updateLocation();
            });
        });
    });
    return {
        updateLocation
    };
}
function pixelRound(val) {
    return Math.round(val * devicePixelRatio) / devicePixelRatio;
}
function pixelCeil(val) {
    return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
}

},{"../../composables/toggleScope.mjs":"cE29O","vue":"ff77s","./util/point.mjs":"5yWB3","../../util/index.mjs":"6uIWw","../../util/box.mjs":"lKLXL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5yWB3":[function(require,module,exports) {
// Types
/** Convert a point in local space to viewport space */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elementToViewport", ()=>elementToViewport);
/** Convert a point in viewport space to local space */ parcelHelpers.export(exports, "viewportToElement", ()=>viewportToElement);
/** Get the difference between two points */ parcelHelpers.export(exports, "getOffset", ()=>getOffset);
/** Convert an anchor object to a point in local space */ parcelHelpers.export(exports, "anchorToPoint", ()=>anchorToPoint);
function elementToViewport(point, offset) {
    return {
        x: point.x + offset.x,
        y: point.y + offset.y
    };
}
function viewportToElement(point, offset) {
    return {
        x: point.x - offset.x,
        y: point.y - offset.y
    };
}
function getOffset(a, b) {
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}
function anchorToPoint(anchor, box) {
    if (anchor.side === "top" || anchor.side === "bottom") {
        const { side, align } = anchor;
        const x = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
        const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
        return elementToViewport({
            x,
            y
        }, box);
    } else if (anchor.side === "left" || anchor.side === "right") {
        const { side, align } = anchor;
        const x = side === "left" ? 0 : side === "right" ? box.width : side;
        const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
        return elementToViewport({
            x,
            y
        }, box);
    }
    return elementToViewport({
        x: box.width / 2,
        y: box.height / 2
    }, box);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"57TUW":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeScrollStrategyProps", ()=>makeScrollStrategyProps);
parcelHelpers.export(exports, "useScrollStrategies", ()=>useScrollStrategies);
var _vue = require("vue");
var _requestNewFrameMjs = require("./requestNewFrame.mjs");
var _indexMjs = require("../../util/index.mjs"); // Types
const scrollStrategies = {
    none: null,
    close: closeScrollStrategy,
    block: blockScrollStrategy,
    reposition: repositionScrollStrategy
};
const makeScrollStrategyProps = (0, _indexMjs.propsFactory)({
    scrollStrategy: {
        type: [
            String,
            Function
        ],
        default: "block",
        validator: (val)=>typeof val === "function" || val in scrollStrategies
    }
}, "VOverlay-scroll-strategies");
function useScrollStrategies(props, data) {
    if (!(0, _indexMjs.IN_BROWSER)) return;
    let scope;
    (0, _vue.watchEffect)(async ()=>{
        scope?.stop();
        if (!(data.isActive.value && props.scrollStrategy)) return;
        scope = (0, _vue.effectScope)();
        await (0, _vue.nextTick)();
        scope.active && scope.run(()=>{
            if (typeof props.scrollStrategy === "function") props.scrollStrategy(data, props, scope);
            else scrollStrategies[props.scrollStrategy]?.(data, props, scope);
        });
    });
    (0, _vue.onScopeDispose)(()=>{
        scope?.stop();
    });
}
function closeScrollStrategy(data) {
    function onScroll(e) {
        data.isActive.value = false;
    }
    bindScroll(data.activatorEl.value ?? data.contentEl.value, onScroll);
}
function blockScrollStrategy(data, props) {
    const offsetParent = data.root.value?.offsetParent;
    const scrollElements = [
        ...new Set([
            ...(0, _indexMjs.getScrollParents)(data.activatorEl.value, props.contained ? offsetParent : undefined),
            ...(0, _indexMjs.getScrollParents)(data.contentEl.value, props.contained ? offsetParent : undefined)
        ])
    ].filter((el)=>!el.classList.contains("v-overlay-scroll-blocked"));
    const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
    const scrollableParent = ((el)=>(0, _indexMjs.hasScrollbar)(el) && el)(offsetParent || document.documentElement);
    if (scrollableParent) data.root.value.classList.add("v-overlay--scroll-blocked");
    scrollElements.forEach((el, i)=>{
        el.style.setProperty("--v-body-scroll-x", (0, _indexMjs.convertToUnit)(-el.scrollLeft));
        el.style.setProperty("--v-body-scroll-y", (0, _indexMjs.convertToUnit)(-el.scrollTop));
        if (el !== document.documentElement) el.style.setProperty("--v-scrollbar-offset", (0, _indexMjs.convertToUnit)(scrollbarWidth));
        el.classList.add("v-overlay-scroll-blocked");
    });
    (0, _vue.onScopeDispose)(()=>{
        scrollElements.forEach((el, i)=>{
            const x = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
            const y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
            el.style.removeProperty("--v-body-scroll-x");
            el.style.removeProperty("--v-body-scroll-y");
            el.style.removeProperty("--v-scrollbar-offset");
            el.classList.remove("v-overlay-scroll-blocked");
            el.scrollLeft = -x;
            el.scrollTop = -y;
        });
        if (scrollableParent) data.root.value.classList.remove("v-overlay--scroll-blocked");
    });
}
function repositionScrollStrategy(data, props, scope) {
    let slow = false;
    let raf = -1;
    let ric = -1;
    function update(e) {
        (0, _requestNewFrameMjs.requestNewFrame)(()=>{
            const start = performance.now();
            data.updateLocation.value?.(e);
            const time = performance.now() - start;
            slow = time / (1000 / 60) > 2;
        });
    }
    ric = (typeof requestIdleCallback === "undefined" ? (cb)=>cb() : requestIdleCallback)(()=>{
        scope.run(()=>{
            bindScroll(data.activatorEl.value ?? data.contentEl.value, (e)=>{
                if (slow) {
                    // If the position calculation is slow,
                    // defer updates until scrolling is finished.
                    // Browsers usually fire one scroll event per frame so
                    // we just wait until we've got two frames without an event
                    cancelAnimationFrame(raf);
                    raf = requestAnimationFrame(()=>{
                        raf = requestAnimationFrame(()=>{
                            update(e);
                        });
                    });
                } else update(e);
            });
        });
    });
    (0, _vue.onScopeDispose)(()=>{
        typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
        cancelAnimationFrame(raf);
    });
}
/** @private */ function bindScroll(el, onScroll) {
    const scrollElements = [
        document,
        ...(0, _indexMjs.getScrollParents)(el)
    ];
    scrollElements.forEach((el)=>{
        el.addEventListener("scroll", onScroll, {
            passive: true
        });
    });
    (0, _vue.onScopeDispose)(()=>{
        scrollElements.forEach((el)=>{
            el.removeEventListener("scroll", onScroll);
        });
    });
}

},{"vue":"ff77s","./requestNewFrame.mjs":"gIg36","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gIg36":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Schedule a task to run in an animation frame on its own
 * This is useful for heavy tasks that may cause jank if all ran together
 */ parcelHelpers.export(exports, "requestNewFrame", ()=>requestNewFrame);
let clean = true;
const frames = [];
function requestNewFrame(cb) {
    if (!clean || frames.length) {
        frames.push(cb);
        run();
    } else {
        clean = false;
        cb();
        run();
    }
}
let raf = -1;
function run() {
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(()=>{
        const frame = frames.shift();
        if (frame) frame();
        if (frames.length) run();
        else clean = true;
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eEi0c":[function(require,module,exports) {
// Components
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeActivatorProps", ()=>makeActivatorProps);
parcelHelpers.export(exports, "useActivator", ()=>useActivator);
var _sharedMjs = require("../VMenu/shared.mjs"); // Composables
var _delayMjs = require("../../composables/delay.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const makeActivatorProps = (0, _indexMjs.propsFactory)({
    activator: [
        String,
        Object
    ],
    activatorProps: {
        type: Object,
        default: ()=>({})
    },
    openOnClick: {
        type: Boolean,
        default: undefined
    },
    openOnHover: Boolean,
    openOnFocus: {
        type: Boolean,
        default: undefined
    },
    closeOnContentClick: Boolean,
    ...(0, _delayMjs.makeDelayProps)()
}, "VOverlay-activator");
function useActivator(props, _ref) {
    let { isActive, isTop } = _ref;
    const activatorEl = (0, _vue.ref)();
    let isHovered = false;
    let isFocused = false;
    let firstEnter = true;
    const openOnFocus = (0, _vue.computed)(()=>props.openOnFocus || props.openOnFocus == null && props.openOnHover);
    const openOnClick = (0, _vue.computed)(()=>props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
    const { runOpenDelay, runCloseDelay } = (0, _delayMjs.useDelay)(props, (value)=>{
        if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
            if (isActive.value !== value) firstEnter = true;
            isActive.value = value;
        }
    });
    const availableEvents = {
        onClick: (e)=>{
            e.stopPropagation();
            activatorEl.value = e.currentTarget || e.target;
            isActive.value = !isActive.value;
        },
        onMouseenter: (e)=>{
            if (e.sourceCapabilities?.firesTouchEvents) return;
            isHovered = true;
            activatorEl.value = e.currentTarget || e.target;
            runOpenDelay();
        },
        onMouseleave: (e)=>{
            isHovered = false;
            runCloseDelay();
        },
        onFocus: (e)=>{
            if ((0, _indexMjs.matchesSelector)(e.target, ":focus-visible") === false) return;
            isFocused = true;
            e.stopPropagation();
            activatorEl.value = e.currentTarget || e.target;
            runOpenDelay();
        },
        onBlur: (e)=>{
            isFocused = false;
            e.stopPropagation();
            runCloseDelay();
        }
    };
    const activatorEvents = (0, _vue.computed)(()=>{
        const events = {};
        if (openOnClick.value) events.onClick = availableEvents.onClick;
        if (props.openOnHover) {
            events.onMouseenter = availableEvents.onMouseenter;
            events.onMouseleave = availableEvents.onMouseleave;
        }
        if (openOnFocus.value) {
            events.onFocus = availableEvents.onFocus;
            events.onBlur = availableEvents.onBlur;
        }
        return events;
    });
    const contentEvents = (0, _vue.computed)(()=>{
        const events = {};
        if (props.openOnHover) {
            events.onMouseenter = ()=>{
                isHovered = true;
                runOpenDelay();
            };
            events.onMouseleave = ()=>{
                isHovered = false;
                runCloseDelay();
            };
        }
        if (openOnFocus.value) {
            events.onFocusin = ()=>{
                isFocused = true;
                runOpenDelay();
            };
            events.onFocusout = ()=>{
                isFocused = false;
                runCloseDelay();
            };
        }
        if (props.closeOnContentClick) {
            const menu = (0, _vue.inject)((0, _sharedMjs.VMenuSymbol), null);
            events.onClick = ()=>{
                isActive.value = false;
                menu?.closeParents();
            };
        }
        return events;
    });
    const scrimEvents = (0, _vue.computed)(()=>{
        const events = {};
        if (props.openOnHover) {
            events.onMouseenter = ()=>{
                if (firstEnter) {
                    isHovered = true;
                    firstEnter = false;
                    runOpenDelay();
                }
            };
            events.onMouseleave = ()=>{
                isHovered = false;
                runCloseDelay();
            };
        }
        return events;
    });
    (0, _vue.watch)(isTop, (val)=>{
        if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) isActive.value = false;
    });
    const activatorRef = (0, _vue.ref)();
    (0, _vue.watchEffect)(()=>{
        if (!activatorRef.value) return;
        (0, _vue.nextTick)(()=>{
            activatorEl.value = (0, _indexMjs.refElement)(activatorRef.value);
        });
    });
    const vm = (0, _indexMjs.getCurrentInstance)("useActivator");
    let scope;
    (0, _vue.watch)(()=>!!props.activator, (val)=>{
        if (val && (0, _indexMjs.IN_BROWSER)) {
            scope = (0, _vue.effectScope)();
            scope.run(()=>{
                _useActivator(props, vm, {
                    activatorEl,
                    activatorEvents
                });
            });
        } else if (scope) scope.stop();
    }, {
        flush: "post",
        immediate: true
    });
    (0, _vue.onScopeDispose)(()=>{
        scope?.stop();
    });
    return {
        activatorEl,
        activatorRef,
        activatorEvents,
        contentEvents,
        scrimEvents
    };
}
function _useActivator(props, vm, _ref2) {
    let { activatorEl, activatorEvents } = _ref2;
    (0, _vue.watch)(()=>props.activator, (val, oldVal)=>{
        if (oldVal && val !== oldVal) {
            const activator = getActivator(oldVal);
            activator && unbindActivatorProps(activator);
        }
        if (val) (0, _vue.nextTick)(()=>bindActivatorProps());
    }, {
        immediate: true
    });
    (0, _vue.watch)(()=>props.activatorProps, ()=>{
        bindActivatorProps();
    });
    (0, _vue.onScopeDispose)(()=>{
        unbindActivatorProps();
    });
    function bindActivatorProps() {
        let el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.activatorProps;
        if (!el) return;
        (0, _indexMjs.bindProps)(el, (0, _vue.mergeProps)(activatorEvents.value, _props));
    }
    function unbindActivatorProps() {
        let el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActivator();
        let _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.activatorProps;
        if (!el) return;
        (0, _indexMjs.unbindProps)(el, (0, _vue.mergeProps)(activatorEvents.value, _props));
    }
    function getActivator() {
        let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : props.activator;
        let activator;
        if (selector) {
            if (selector === "parent") {
                let el = vm?.proxy?.$el?.parentNode;
                while(el?.hasAttribute("data-no-activator"))el = el.parentNode;
                activator = el;
            } else if (typeof selector === "string") // Selector
            activator = document.querySelector(selector);
            else if ("$el" in selector) // Component (ref)
            activator = selector.$el;
            else // HTMLElement | Element
            activator = selector;
        }
        // The activator should only be a valid element (Ignore comments and text nodes)
        activatorEl.value = activator?.nodeType === Node.ELEMENT_NODE ? activator : null;
        return activatorEl.value;
    }
}

},{"../VMenu/shared.mjs":"3gwcw","../../composables/delay.mjs":"jBGDO","vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3gwcw":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VMenuSymbol", ()=>VMenuSymbol);
const VMenuSymbol = Symbol.for("vuetify:v-menu");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jBGDO":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeDelayProps", ()=>makeDelayProps);
parcelHelpers.export(exports, "useDelay", ()=>useDelay);
var _indexMjs = require("../util/index.mjs"); // Types
const makeDelayProps = (0, _indexMjs.propsFactory)({
    closeDelay: [
        Number,
        String
    ],
    openDelay: [
        Number,
        String
    ]
}, "delay");
function useDelay(props, cb) {
    const delays = {};
    const runDelayFactory = (prop)=>()=>{
            // istanbul ignore next
            if (!(0, _indexMjs.IN_BROWSER)) return Promise.resolve(true);
            const active = prop === "openDelay";
            delays.closeDelay && window.clearTimeout(delays.closeDelay);
            delete delays.closeDelay;
            delays.openDelay && window.clearTimeout(delays.openDelay);
            delete delays.openDelay;
            return new Promise((resolve)=>{
                const delay = parseInt(props[prop] ?? 0, 10);
                delays[prop] = window.setTimeout(()=>{
                    cb?.(active);
                    resolve(active);
                }, delay);
            });
        };
    return {
        runCloseDelay: runDelayFactory("closeDelay"),
        runOpenDelay: runDelayFactory("openDelay")
    };
}

},{"../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jI0s5":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useHydration", ()=>useHydration);
var _displayMjs = require("./display.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs");
function useHydration() {
    if (!(0, _indexMjs.IN_BROWSER)) return (0, _vue.shallowRef)(false);
    const { ssr } = (0, _displayMjs.useDisplay)();
    if (ssr) {
        const isMounted = (0, _vue.shallowRef)(false);
        (0, _vue.onMounted)(()=>{
            isMounted.value = true;
        });
        return isMounted;
    } else return (0, _vue.shallowRef)(true);
}

},{"./display.mjs":"6nXZK","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"au1NJ":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeLazyProps", ()=>makeLazyProps);
parcelHelpers.export(exports, "useLazy", ()=>useLazy);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const makeLazyProps = (0, _indexMjs.propsFactory)({
    eager: Boolean
}, "lazy");
function useLazy(props, active) {
    const isBooted = (0, _vue.shallowRef)(false);
    const hasContent = (0, _vue.computed)(()=>isBooted.value || props.eager || active.value);
    (0, _vue.watch)(active, ()=>isBooted.value = true);
    function onAfterLeave() {
        if (!props.eager) isBooted.value = false;
    }
    return {
        isBooted,
        hasContent,
        onAfterLeave
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"78lmg":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useScopeId", ()=>useScopeId);
var _indexMjs = require("../util/index.mjs");
function useScopeId() {
    const vm = (0, _indexMjs.getCurrentInstance)("useScopeId");
    const scopeId = vm.vnode.scopeId;
    return {
        scopeId: scopeId ? {
            [scopeId]: ""
        } : undefined
    };
}

},{"../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fFcSD":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useStack", ()=>useStack);
var _toggleScopeMjs = require("./toggleScope.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const StackSymbol = Symbol.for("vuetify:stack");
const globalStack = (0, _vue.reactive)([]);
function useStack(isActive, zIndex, disableGlobalStack) {
    const vm = (0, _indexMjs.getCurrentInstance)("useStack");
    const createStackEntry = !disableGlobalStack;
    const parent = (0, _vue.inject)(StackSymbol, undefined);
    const stack = (0, _vue.reactive)({
        activeChildren: new Set()
    });
    (0, _vue.provide)(StackSymbol, stack);
    const _zIndex = (0, _vue.shallowRef)(+zIndex.value);
    (0, _toggleScopeMjs.useToggleScope)(isActive, ()=>{
        const lastZIndex = globalStack.at(-1)?.[1];
        _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
        if (createStackEntry) globalStack.push([
            vm.uid,
            _zIndex.value
        ]);
        parent?.activeChildren.add(vm.uid);
        (0, _vue.onScopeDispose)(()=>{
            if (createStackEntry) {
                const idx = (0, _vue.toRaw)(globalStack).findIndex((v)=>v[0] === vm.uid);
                globalStack.splice(idx, 1);
            }
            parent?.activeChildren.delete(vm.uid);
        });
    });
    const globalTop = (0, _vue.shallowRef)(true);
    if (createStackEntry) (0, _vue.watchEffect)(()=>{
        const _isTop = globalStack.at(-1)?.[0] === vm.uid;
        setTimeout(()=>globalTop.value = _isTop);
    });
    const localTop = (0, _vue.computed)(()=>!stack.activeChildren.size);
    return {
        globalTop: (0, _vue.readonly)(globalTop),
        localTop,
        stackStyles: (0, _vue.computed)(()=>({
                zIndex: _zIndex.value
            }))
    };
}

},{"./toggleScope.mjs":"cE29O","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dTe7e":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useTeleport", ()=>useTeleport);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
function useTeleport(target) {
    const teleportTarget = (0, _vue.computed)(()=>{
        const _target = target.value;
        if (_target === true || !(0, _indexMjs.IN_BROWSER)) return undefined;
        const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
        if (targetElement == null) {
            (0, _vue.warn)(`Unable to locate target ${_target}`);
            return undefined;
        }
        let container = targetElement.querySelector(":scope > .v-overlay-container");
        if (!container) {
            container = document.createElement("div");
            container.className = "v-overlay-container";
            targetElement.appendChild(container);
        }
        return container;
    });
    return {
        teleportTarget
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gSpMV":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClickOutside", ()=>ClickOutside);
var _indexMjs = require("../../util/index.mjs"); // Types
function defaultConditional() {
    return true;
}
function checkEvent(e, el, binding) {
    // The include element callbacks below can be expensive
    // so we should avoid calling them when we're not active.
    // Explicitly check for false to allow fallback compatibility
    // with non-toggleable components
    if (!e || checkIsActive(e, binding) === false) return false;
    // If we're clicking inside the shadowroot, then the app root doesn't get the same
    // level of introspection as to _what_ we're clicking. We want to check to see if
    // our target is the shadowroot parent container, and if it is, ignore.
    const root = (0, _indexMjs.attachedRoot)(el);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target) return false;
    // Check if additional elements were passed to be included in check
    // (click must be outside all included elements, if any)
    const elements = (typeof binding.value === "object" && binding.value.include || (()=>[]))();
    // Add the root element for the component this directive was defined on
    elements.push(el);
    // Check if it's a click outside our elements, and then if our callback returns true.
    // Non-toggleable components should take action in their callback and return falsy.
    // Toggleable can return true if it wants to deactivate.
    // Note that, because we're in the capture phase, this callback will occur before
    // the bubbling click event on any outside elements.
    return !elements.some((el)=>el?.contains(e.target));
}
function checkIsActive(e, binding) {
    const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
    return isActive(e);
}
function directive(e, el, binding) {
    const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
    el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(()=>{
        checkIsActive(e, binding) && handler && handler(e);
    }, 0);
}
function handleShadow(el, callback) {
    const root = (0, _indexMjs.attachedRoot)(el);
    callback(document);
    if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) callback(root);
}
const ClickOutside = {
    // [data-app] may not be found
    // if using bind, inserted makes
    // sure that the root element is
    // available, iOS does not support
    // clicks on body
    mounted (el, binding) {
        const onClick = (e)=>directive(e, el, binding);
        const onMousedown = (e)=>{
            el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
        };
        handleShadow(el, (app)=>{
            app.addEventListener("click", onClick, true);
            app.addEventListener("mousedown", onMousedown, true);
        });
        if (!el._clickOutside) el._clickOutside = {
            lastMousedownWasOutside: false
        };
        el._clickOutside[binding.instance.$.uid] = {
            onClick,
            onMousedown
        };
    },
    unmounted (el, binding) {
        if (!el._clickOutside) return;
        handleShadow(el, (app)=>{
            if (!app || !el._clickOutside?.[binding.instance.$.uid]) return;
            const { onClick, onMousedown } = el._clickOutside[binding.instance.$.uid];
            app.removeEventListener("click", onClick, true);
            app.removeEventListener("mousedown", onMousedown, true);
        });
        delete el._clickOutside[binding.instance.$.uid];
    }
};
exports.default = ClickOutside;

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"h5grs":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forwardRefs", ()=>forwardRefs);
const Refs = Symbol("Forwarded refs");
/** Omit properties starting with P */ function getDescriptor(obj, key) {
    let currentObj = obj;
    while(currentObj){
        const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
        if (descriptor) return descriptor;
        currentObj = Object.getPrototypeOf(currentObj);
    }
    return undefined;
}
function forwardRefs(target) {
    for(var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)refs[_key - 1] = arguments[_key];
    target[Refs] = refs;
    return new Proxy(target, {
        get (target, key) {
            if (Reflect.has(target, key)) return Reflect.get(target, key);
            // Skip internal properties
            if (typeof key === "symbol" || key.startsWith("__")) return;
            for (const ref of refs)if (ref.value && Reflect.has(ref.value, key)) {
                const val = Reflect.get(ref.value, key);
                return typeof val === "function" ? val.bind(ref.value) : val;
            }
        },
        has (target, key) {
            if (Reflect.has(target, key)) return true;
            // Skip internal properties
            if (typeof key === "symbol" || key.startsWith("__")) return false;
            for (const ref of refs){
                if (ref.value && Reflect.has(ref.value, key)) return true;
            }
            return false;
        },
        set (target, key, value) {
            if (Reflect.has(target, key)) return Reflect.set(target, key, value);
            // Skip internal properties
            if (typeof key === "symbol" || key.startsWith("__")) return false;
            for (const ref of refs){
                if (ref.value && Reflect.has(ref.value, key)) return Reflect.set(ref.value, key, value);
            }
            return false;
        },
        getOwnPropertyDescriptor (target, key) {
            const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
            if (descriptor) return descriptor;
            // Skip internal properties
            if (typeof key === "symbol" || key.startsWith("__")) return;
            // Check each ref's own properties
            for (const ref of refs){
                if (!ref.value) continue;
                const descriptor = getDescriptor(ref.value, key) ?? ("_" in ref.value ? getDescriptor(ref.value._?.setupState, key) : undefined);
                if (descriptor) return descriptor;
            }
            // Recursive search up each ref's prototype
            for (const ref of refs){
                const childRefs = ref.value && ref.value[Refs];
                if (!childRefs) continue;
                const queue = childRefs.slice();
                while(queue.length){
                    const ref = queue.shift();
                    const descriptor = getDescriptor(ref.value, key);
                    if (descriptor) return descriptor;
                    const childRefs = ref.value && ref.value[Refs];
                    if (childRefs) queue.push(...childRefs);
                }
            }
            return undefined;
        }
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dHfP6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeSelectProps", ()=>makeSelectProps);
parcelHelpers.export(exports, "makeVSelectProps", ()=>makeVSelectProps);
parcelHelpers.export(exports, "VSelect", ()=>VSelect);
var _vue = require("vue");
// Styles
var _vselectCss = require("./VSelect.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VCheckbox/index.mjs");
var _indexMjs2 = require("../VChip/index.mjs");
var _indexMjs3 = require("../VDefaultsProvider/index.mjs");
var _indexMjs4 = require("../VIcon/index.mjs");
var _indexMjs5 = require("../VList/index.mjs");
var _indexMjs6 = require("../VMenu/index.mjs");
var _vtextFieldMjs = require("../VTextField/VTextField.mjs");
var _indexMjs7 = require("../VVirtualScroll/index.mjs"); // Composables
var _useScrollingMjs = require("./useScrolling.mjs");
var _formMjs = require("../../composables/form.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _listItemsMjs = require("../../composables/list-items.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs8 = require("../../util/index.mjs"); // Types
const makeSelectProps = (0, _indexMjs8.propsFactory)({
    chips: Boolean,
    closableChips: Boolean,
    closeText: {
        type: String,
        default: "$vuetify.close"
    },
    openText: {
        type: String,
        default: "$vuetify.open"
    },
    eager: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    menu: Boolean,
    menuIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$dropdown"
    },
    menuProps: {
        type: Object
    },
    multiple: Boolean,
    noDataText: {
        type: String,
        default: "$vuetify.noDataText"
    },
    openOnClear: Boolean,
    itemColor: String,
    ...(0, _listItemsMjs.makeItemsProps)({
        itemChildren: false
    })
}, "Select");
const makeVSelectProps = (0, _indexMjs8.propsFactory)({
    ...makeSelectProps(),
    ...(0, _indexMjs8.omit)((0, _vtextFieldMjs.makeVTextFieldProps)({
        modelValue: null,
        role: "button"
    }), [
        "validationValue",
        "dirty",
        "appendInnerIcon"
    ]),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: {
            component: (0, _indexMjs.VDialogTransition)
        }
    })
}, "VSelect");
const VSelect = (0, _indexMjs8.genericComponent)()({
    name: "VSelect",
    props: makeVSelectProps(),
    emits: {
        "update:focused": (focused)=>true,
        "update:modelValue": (val)=>true,
        "update:menu": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const vTextFieldRef = (0, _vue.ref)();
        const vMenuRef = (0, _vue.ref)();
        const vVirtualScrollRef = (0, _vue.ref)();
        const _menu = (0, _proxiedModelMjs.useProxiedModel)(props, "menu");
        const menu = (0, _vue.computed)({
            get: ()=>_menu.value,
            set: (v)=>{
                if (_menu.value && !v && vMenuRef.value?.Œ®openChildren) return;
                _menu.value = v;
            }
        });
        const { items, transformIn, transformOut } = (0, _listItemsMjs.useItems)(props);
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", [], (v)=>transformIn(v === null ? [
                null
            ] : (0, _indexMjs8.wrapInArray)(v)), (v)=>{
            const transformed = transformOut(v);
            return props.multiple ? transformed : transformed[0] ?? null;
        });
        const form = (0, _formMjs.useForm)();
        const selectedValues = (0, _vue.computed)(()=>model.value.map((selection)=>selection.value));
        const isFocused = (0, _vue.shallowRef)(false);
        const label = (0, _vue.computed)(()=>menu.value ? props.closeText : props.openText);
        let keyboardLookupPrefix = "";
        let keyboardLookupLastTime;
        const displayItems = (0, _vue.computed)(()=>{
            if (props.hideSelected) return items.value.filter((item)=>!model.value.some((s)=>s === item));
            return items.value;
        });
        const menuDisabled = (0, _vue.computed)(()=>props.hideNoData && !items.value.length || props.readonly || form?.isReadonly.value);
        const listRef = (0, _vue.ref)();
        const { onListScroll, onListKeydown } = (0, _useScrollingMjs.useScrolling)(listRef, vTextFieldRef);
        function onClear(e) {
            if (props.openOnClear) menu.value = true;
        }
        function onMousedownControl() {
            if (menuDisabled.value) return;
            menu.value = !menu.value;
        }
        function onKeydown(e) {
            if (!e.key || props.readonly || form?.isReadonly.value) return;
            if ([
                "Enter",
                " ",
                "ArrowDown",
                "ArrowUp",
                "Home",
                "End"
            ].includes(e.key)) e.preventDefault();
            if ([
                "Enter",
                "ArrowDown",
                " "
            ].includes(e.key)) menu.value = true;
            if ([
                "Escape",
                "Tab"
            ].includes(e.key)) menu.value = false;
            if (e.key === "Home") listRef.value?.focus("first");
            else if (e.key === "End") listRef.value?.focus("last");
            // html select hotkeys
            const KEYBOARD_LOOKUP_THRESHOLD = 1000; // milliseconds
            function checkPrintable(e) {
                const isPrintableChar = e.key.length === 1;
                const noModifier = !e.ctrlKey && !e.metaKey && !e.altKey;
                return isPrintableChar && noModifier;
            }
            if (props.multiple || !checkPrintable(e)) return;
            const now = performance.now();
            if (now - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) keyboardLookupPrefix = "";
            keyboardLookupPrefix += e.key.toLowerCase();
            keyboardLookupLastTime = now;
            const item = items.value.find((item)=>item.title.toLowerCase().startsWith(keyboardLookupPrefix));
            if (item !== undefined) model.value = [
                item
            ];
        }
        function select(item) {
            if (props.multiple) {
                const index = model.value.findIndex((selection)=>props.valueComparator(selection.value, item.value));
                if (index === -1) model.value = [
                    ...model.value,
                    item
                ];
                else {
                    const value = [
                        ...model.value
                    ];
                    value.splice(index, 1);
                    model.value = value;
                }
            } else {
                model.value = [
                    item
                ];
                menu.value = false;
            }
        }
        function onBlur(e) {
            if (!listRef.value?.$el.contains(e.relatedTarget)) menu.value = false;
        }
        function onAfterLeave() {
            if (isFocused.value) vTextFieldRef.value?.focus();
        }
        function onFocusin(e) {
            isFocused.value = true;
        }
        function onModelUpdate(v) {
            if (v == null) model.value = [];
            else if ((0, _indexMjs8.matchesSelector)(vTextFieldRef.value, ":autofill") || (0, _indexMjs8.matchesSelector)(vTextFieldRef.value, ":-webkit-autofill")) {
                const item = items.value.find((item)=>item.title === v);
                if (item) select(item);
            } else if (vTextFieldRef.value) vTextFieldRef.value.value = "";
        }
        (0, _vue.watch)(menu, ()=>{
            if (!props.hideSelected && menu.value && model.value.length) {
                const index = displayItems.value.findIndex((item)=>model.value.some((s)=>props.valueComparator(s.value, item.value)));
                (0, _indexMjs8.IN_BROWSER) && window.requestAnimationFrame(()=>{
                    index >= 0 && vVirtualScrollRef.value?.scrollToIndex(index);
                });
            }
        });
        (0, _indexMjs8.useRender)(()=>{
            const hasChips = !!(props.chips || slots.chip);
            const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
            const isDirty = model.value.length > 0;
            const [textFieldProps] = (0, _vtextFieldMjs.VTextField).filterProps(props);
            const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? undefined : props.placeholder;
            return (0, _vue.createVNode)((0, _vtextFieldMjs.VTextField), (0, _vue.mergeProps)({
                "ref": vTextFieldRef
            }, textFieldProps, {
                "modelValue": model.value.map((v)=>v.props.value).join(", "),
                "onUpdate:modelValue": onModelUpdate,
                "focused": isFocused.value,
                "onUpdate:focused": ($event)=>isFocused.value = $event,
                "validationValue": model.externalValue,
                "dirty": isDirty,
                "class": [
                    "v-select",
                    {
                        "v-select--active-menu": menu.value,
                        "v-select--chips": !!props.chips,
                        [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
                        "v-select--selected": model.value.length,
                        "v-select--selection-slot": !!slots.selection
                    },
                    props.class
                ],
                "style": props.style,
                "inputmode": "none",
                "placeholder": placeholder,
                "onClick:clear": onClear,
                "onMousedown:control": onMousedownControl,
                "onBlur": onBlur,
                "onKeydown": onKeydown,
                "aria-label": t(label.value),
                "title": t(label.value)
            }), {
                ...slots,
                default: ()=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        (0, _vue.createVNode)((0, _indexMjs6.VMenu), (0, _vue.mergeProps)({
                            "ref": vMenuRef,
                            "modelValue": menu.value,
                            "onUpdate:modelValue": ($event)=>menu.value = $event,
                            "activator": "parent",
                            "contentClass": "v-select__content",
                            "disabled": menuDisabled.value,
                            "eager": props.eager,
                            "maxHeight": 310,
                            "openOnClick": false,
                            "closeOnContentClick": false,
                            "transition": props.transition,
                            "onAfterLeave": onAfterLeave
                        }, props.menuProps), {
                            default: ()=>[
                                    hasList && (0, _vue.createVNode)((0, _indexMjs5.VList), {
                                        "ref": listRef,
                                        "selected": selectedValues.value,
                                        "selectStrategy": props.multiple ? "independent" : "single-independent",
                                        "onMousedown": (e)=>e.preventDefault(),
                                        "onKeydown": onListKeydown,
                                        "onFocusin": onFocusin,
                                        "onScrollPassive": onListScroll,
                                        "tabindex": "-1",
                                        "color": props.itemColor ?? props.color
                                    }, {
                                        default: ()=>[
                                                slots["prepend-item"]?.(),
                                                !displayItems.value.length && !props.hideNoData && (slots["no-data"]?.() ?? (0, _vue.createVNode)((0, _indexMjs5.VListItem), {
                                                    "title": t(props.noDataText)
                                                }, null)),
                                                (0, _vue.createVNode)((0, _indexMjs7.VVirtualScroll), {
                                                    "ref": vVirtualScrollRef,
                                                    "renderless": true,
                                                    "items": displayItems.value
                                                }, {
                                                    default: (_ref2)=>{
                                                        let { item, index, itemRef } = _ref2;
                                                        const itemProps = (0, _vue.mergeProps)(item.props, {
                                                            ref: itemRef,
                                                            key: index,
                                                            onClick: ()=>select(item)
                                                        });
                                                        return slots.item?.({
                                                            item,
                                                            index,
                                                            props: itemProps
                                                        }) ?? (0, _vue.createVNode)((0, _indexMjs5.VListItem), itemProps, {
                                                            prepend: (_ref3)=>{
                                                                let { isSelected } = _ref3;
                                                                return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                                                    props.multiple && !props.hideSelected ? (0, _vue.createVNode)((0, _indexMjs1.VCheckboxBtn), {
                                                                        "key": item.value,
                                                                        "modelValue": isSelected,
                                                                        "ripple": false,
                                                                        "tabindex": "-1"
                                                                    }, null) : undefined,
                                                                    item.props.prependIcon && (0, _vue.createVNode)((0, _indexMjs4.VIcon), {
                                                                        "icon": item.props.prependIcon
                                                                    }, null)
                                                                ]);
                                                            }
                                                        });
                                                    }
                                                }),
                                                slots["append-item"]?.()
                                            ]
                                    })
                                ]
                        }),
                        model.value.map((item, index)=>{
                            function onChipClose(e) {
                                e.stopPropagation();
                                e.preventDefault();
                                select(item);
                            }
                            const slotProps = {
                                "onClick:close": onChipClose,
                                onMousedown (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                },
                                modelValue: true,
                                "onUpdate:modelValue": undefined
                            };
                            return (0, _vue.createVNode)("div", {
                                "key": item.value,
                                "class": "v-select__selection"
                            }, [
                                hasChips ? !slots.chip ? (0, _vue.createVNode)((0, _indexMjs2.VChip), (0, _vue.mergeProps)({
                                    "key": "chip",
                                    "closable": props.closableChips,
                                    "size": "small",
                                    "text": item.title
                                }, slotProps), null) : (0, _vue.createVNode)((0, _indexMjs3.VDefaultsProvider), {
                                    "key": "chip-defaults",
                                    "defaults": {
                                        VChip: {
                                            closable: props.closableChips,
                                            size: "small",
                                            text: item.title
                                        }
                                    }
                                }, {
                                    default: ()=>[
                                            slots.chip?.({
                                                item,
                                                index,
                                                props: slotProps
                                            })
                                        ]
                                }) : slots.selection?.({
                                    item,
                                    index
                                }) ?? (0, _vue.createVNode)("span", {
                                    "class": "v-select__selection-text"
                                }, [
                                    item.title,
                                    props.multiple && index < model.value.length - 1 && (0, _vue.createVNode)("span", {
                                        "class": "v-select__selection-comma"
                                    }, [
                                        (0, _vue.createTextVNode)(",")
                                    ])
                                ])
                            ]);
                        })
                    ]),
                "append-inner": function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots["append-inner"]?.(...args),
                        props.menuIcon ? (0, _vue.createVNode)((0, _indexMjs4.VIcon), {
                            "class": "v-select__menu-icon",
                            "icon": props.menuIcon
                        }, null) : undefined
                    ]);
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({
            isFocused,
            menu,
            select
        }, vTextFieldRef);
    }
});

},{"vue":"ff77s","./VSelect.css":"aJPTr","../transitions/index.mjs":"oiH7Z","../VCheckbox/index.mjs":"2g3Bq","../VChip/index.mjs":"9w6oh","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../VList/index.mjs":"1md2l","../VMenu/index.mjs":"fYY6u","../VTextField/VTextField.mjs":"4p33J","../VVirtualScroll/index.mjs":"7IUqN","./useScrolling.mjs":"fZNsR","../../composables/form.mjs":"Jb6Pn","../../composables/forwardRefs.mjs":"h5grs","../../composables/icons.mjs":"ezwoc","../../composables/list-items.mjs":"kVtgo","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aJPTr":[function() {},{}],"4p33J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTextFieldProps", ()=>makeVTextFieldProps);
parcelHelpers.export(exports, "VTextField", ()=>VTextField);
var _vue = require("vue");
// Styles
var _vtextFieldCss = require("./VTextField.css");
// Components
var _vcounterMjs = require("../VCounter/VCounter.mjs");
var _vfieldMjs = require("../VField/VField.mjs");
var _vinputMjs = require("../VInput/VInput.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Directives
var _indexMjs = require("../../directives/intersect/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../util/index.mjs"); // Types
const activeTypes = [
    "color",
    "file",
    "time",
    "date",
    "datetime-local",
    "week",
    "month"
];
const makeVTextFieldProps = (0, _indexMjs1.propsFactory)({
    autofocus: Boolean,
    counter: [
        Boolean,
        Number,
        String
    ],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    role: String,
    type: {
        type: String,
        default: "text"
    },
    modelModifiers: Object,
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _vfieldMjs.makeVFieldProps)()
}, "VTextField");
const VTextField = (0, _indexMjs1.genericComponent)()({
    name: "VTextField",
    directives: {
        Intersect: (0, _indexMjsDefault.default)
    },
    inheritAttrs: false,
    props: makeVTextFieldProps(),
    emits: {
        "click:control": (e)=>true,
        "mousedown:control": (e)=>true,
        "update:focused": (focused)=>true,
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const counterValue = (0, _vue.computed)(()=>{
            return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value ?? "").toString().length;
        });
        const max = (0, _vue.computed)(()=>{
            if (attrs.maxlength) return attrs.maxlength;
            if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string") return undefined;
            return props.counter;
        });
        const isPlainOrUnderlined = (0, _vue.computed)(()=>[
                "plain",
                "underlined"
            ].includes(props.variant));
        function onIntersect(isIntersecting, entries) {
            if (!props.autofocus || !isIntersecting) return;
            entries[0].target?.focus?.();
        }
        const vInputRef = (0, _vue.ref)();
        const vFieldRef = (0, _vue.ref)();
        const inputRef = (0, _vue.ref)();
        const isActive = (0, _vue.computed)(()=>activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
            if (inputRef.value !== document.activeElement) inputRef.value?.focus();
            if (!isFocused.value) focus();
        }
        function onControlMousedown(e) {
            emit("mousedown:control", e);
            if (e.target === inputRef.value) return;
            onFocus();
            e.preventDefault();
        }
        function onControlClick(e) {
            onFocus();
            emit("click:control", e);
        }
        function onClear(e) {
            e.stopPropagation();
            onFocus();
            (0, _vue.nextTick)(()=>{
                model.value = null;
                (0, _indexMjs1.callEvent)(props["onClick:clear"], e);
            });
        }
        function onInput(e) {
            const el = e.target;
            model.value = el.value;
            if (props.modelModifiers?.trim && [
                "text",
                "search",
                "password",
                "tel",
                "url"
            ].includes(props.type)) {
                const caretPosition = [
                    el.selectionStart,
                    el.selectionEnd
                ];
                (0, _vue.nextTick)(()=>{
                    el.selectionStart = caretPosition[0];
                    el.selectionEnd = caretPosition[1];
                });
            }
        }
        (0, _indexMjs1.useRender)(()=>{
            const hasCounter = !!(slots.counter || props.counter || props.counterValue);
            const hasDetails = !!(hasCounter || slots.details);
            const [rootAttrs, inputAttrs] = (0, _indexMjs1.filterInputAttrs)(attrs);
            const [{ modelValue: _, ...inputProps }] = (0, _vinputMjs.VInput).filterProps(props);
            const [fieldProps] = (0, _vfieldMjs.filterFieldProps)(props);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "ref": vInputRef,
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "class": [
                    "v-text-field",
                    {
                        "v-text-field--prefixed": props.prefix,
                        "v-text-field--suffixed": props.suffix,
                        "v-text-field--plain-underlined": [
                            "plain",
                            "underlined"
                        ].includes(props.variant)
                    },
                    props.class
                ],
                "style": props.style
            }, rootAttrs, inputProps, {
                "centerAffix": !isPlainOrUnderlined.value,
                "focused": isFocused.value
            }), {
                ...slots,
                default: (_ref2)=>{
                    let { id, isDisabled, isDirty, isReadonly, isValid } = _ref2;
                    return (0, _vue.createVNode)((0, _vfieldMjs.VField), (0, _vue.mergeProps)({
                        "ref": vFieldRef,
                        "onMousedown": onControlMousedown,
                        "onClick": onControlClick,
                        "onClick:clear": onClear,
                        "onClick:prependInner": props["onClick:prependInner"],
                        "onClick:appendInner": props["onClick:appendInner"],
                        "role": props.role
                    }, fieldProps, {
                        "id": id.value,
                        "active": isActive.value || isDirty.value,
                        "dirty": isDirty.value || props.dirty,
                        "disabled": isDisabled.value,
                        "focused": isFocused.value,
                        "error": isValid.value === false
                    }), {
                        ...slots,
                        default: (_ref3)=>{
                            let { props: { class: fieldClass, ...slotProps } } = _ref3;
                            const inputNode = (0, _vue.withDirectives)((0, _vue.createVNode)("input", (0, _vue.mergeProps)({
                                "ref": inputRef,
                                "value": model.value,
                                "onInput": onInput,
                                "autofocus": props.autofocus,
                                "readonly": isReadonly.value,
                                "disabled": isDisabled.value,
                                "name": props.name,
                                "placeholder": props.placeholder,
                                "size": 1,
                                "type": props.type,
                                "onFocus": onFocus,
                                "onBlur": blur
                            }, slotProps, inputAttrs), null), [
                                [
                                    (0, _vue.resolveDirective)("intersect"),
                                    {
                                        handler: onIntersect
                                    },
                                    null,
                                    {
                                        once: true
                                    }
                                ]
                            ]);
                            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.prefix && (0, _vue.createVNode)("span", {
                                    "class": "v-text-field__prefix"
                                }, [
                                    (0, _vue.createVNode)("span", {
                                        "class": "v-text-field__prefix__text"
                                    }, [
                                        props.prefix
                                    ])
                                ]),
                                slots.default ? (0, _vue.createVNode)("div", {
                                    "class": fieldClass,
                                    "data-no-activator": ""
                                }, [
                                    slots.default(),
                                    inputNode
                                ]) : (0, _vue.cloneVNode)(inputNode, {
                                    class: fieldClass
                                }),
                                props.suffix && (0, _vue.createVNode)("span", {
                                    "class": "v-text-field__suffix"
                                }, [
                                    (0, _vue.createVNode)("span", {
                                        "class": "v-text-field__suffix__text"
                                    }, [
                                        props.suffix
                                    ])
                                ])
                            ]);
                        }
                    });
                },
                details: hasDetails ? (slotProps)=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots.details?.(slotProps),
                        hasCounter && (0, _vue.createVNode)((0, _vue.Fragment), null, [
                            (0, _vue.createVNode)("span", null, null),
                            (0, _vue.createVNode)((0, _vcounterMjs.VCounter), {
                                "active": props.persistentCounter || isFocused.value,
                                "value": counterValue.value,
                                "max": max.value
                            }, slots.counter)
                        ])
                    ]) : undefined
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, vInputRef, vFieldRef, inputRef);
    }
});

},{"vue":"ff77s","./VTextField.css":"dFHEd","../VCounter/VCounter.mjs":"16Uel","../VField/VField.mjs":"2knTe","../VInput/VInput.mjs":"1hyGZ","../../composables/focus.mjs":"1bQxY","../../composables/forwardRefs.mjs":"h5grs","../../composables/proxiedModel.mjs":"bUF28","../../directives/intersect/index.mjs":"jD88I","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dFHEd":[function() {},{}],"16Uel":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCounterProps", ()=>makeVCounterProps);
parcelHelpers.export(exports, "VCounter", ()=>VCounter);
var _vue = require("vue");
// Styles
var _vcounterCss = require("./VCounter.css");
// Components
var _indexMjs = require("../transitions/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVCounterProps = (0, _indexMjs1.propsFactory)({
    active: Boolean,
    max: [
        Number,
        String
    ],
    value: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: {
            component: (0, _indexMjs.VSlideYTransition)
        }
    })
}, "VCounter");
const VCounter = (0, _indexMjs1.genericComponent)()({
    name: "VCounter",
    functional: true,
    props: makeVCounterProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const counter = (0, _vue.computed)(()=>{
            return props.max ? `${props.value} / ${props.max}` : String(props.value);
        });
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": props.transition
            }, {
                default: ()=>[
                        (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                            "class": [
                                "v-counter",
                                props.class
                            ],
                            "style": props.style
                        }, [
                            slots.default ? slots.default({
                                counter: counter.value,
                                max: props.max,
                                value: props.value
                            }) : counter.value
                        ]), [
                            [
                                (0, _vue.vShow),
                                props.active
                            ]
                        ])
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VCounter.css":"cXa7U","../transitions/index.mjs":"oiH7Z","../../composables/component.mjs":"jVHld","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cXa7U":[function() {},{}],"2knTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVFieldProps", ()=>makeVFieldProps);
parcelHelpers.export(exports, "VField", ()=>VField);
// TODO: this is kinda slow, might be better to implicitly inherit props instead
parcelHelpers.export(exports, "filterFieldProps", ()=>filterFieldProps);
var _vue = require("vue");
// Styles
var _vfieldCss = require("./VField.css");
// Components
var _vfieldLabelMjs = require("./VFieldLabel.mjs");
var _indexMjs = require("../transitions/index.mjs");
var _inputIconMjs = require("../VInput/InputIcon.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _focusMjs = require("../../composables/focus.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _loaderMjs = require("../../composables/loader.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const allowedVariants = [
    "underlined",
    "outlined",
    "filled",
    "solo",
    "solo-inverted",
    "solo-filled",
    "plain"
];
const makeVFieldProps = (0, _indexMjs1.propsFactory)({
    appendInnerIcon: (0, _iconsMjs.IconValue),
    bgColor: String,
    clearable: Boolean,
    clearIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$clear"
    },
    active: Boolean,
    centerAffix: {
        type: Boolean,
        default: undefined
    },
    color: String,
    baseColor: String,
    dirty: Boolean,
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    flat: Boolean,
    label: String,
    persistentClear: Boolean,
    prependInnerIcon: (0, _iconsMjs.IconValue),
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
        type: String,
        default: "filled",
        validator: (v)=>allowedVariants.includes(v)
    },
    "onClick:clear": (0, _indexMjs1.EventProp)(),
    "onClick:appendInner": (0, _indexMjs1.EventProp)(),
    "onClick:prependInner": (0, _indexMjs1.EventProp)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _loaderMjs.makeLoaderProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VField");
const VField = (0, _indexMjs1.genericComponent)()({
    name: "VField",
    inheritAttrs: false,
    props: {
        id: String,
        ...(0, _focusMjs.makeFocusProps)(),
        ...makeVFieldProps()
    },
    emits: {
        "update:focused": (focused)=>true,
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { loaderClasses } = (0, _loaderMjs.useLoader)(props);
        const { focusClasses, isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const { InputIcon } = (0, _inputIconMjs.useInputIcon)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        const isActive = (0, _vue.computed)(()=>props.dirty || props.active);
        const hasLabel = (0, _vue.computed)(()=>!props.singleLine && !!(props.label || slots.label));
        const uid = (0, _indexMjs1.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `input-${uid}`);
        const messagesId = (0, _vue.computed)(()=>`${id.value}-messages`);
        const labelRef = (0, _vue.ref)();
        const floatingLabelRef = (0, _vue.ref)();
        const controlRef = (0, _vue.ref)();
        const isPlainOrUnderlined = (0, _vue.computed)(()=>[
                "plain",
                "underlined"
            ].includes(props.variant));
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "bgColor"));
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.computed)(()=>{
            return props.error || props.disabled ? undefined : isActive.value && isFocused.value ? props.color : props.baseColor;
        }));
        (0, _vue.watch)(isActive, (val)=>{
            if (hasLabel.value) {
                const el = labelRef.value.$el;
                const targetEl = floatingLabelRef.value.$el;
                requestAnimationFrame(()=>{
                    const rect = (0, _indexMjs1.nullifyTransforms)(el);
                    const targetRect = targetEl.getBoundingClientRect();
                    const x = targetRect.x - rect.x;
                    const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
                    const targetWidth = targetRect.width / 0.75;
                    const width = Math.abs(targetWidth - rect.width) > 1 ? {
                        maxWidth: (0, _indexMjs1.convertToUnit)(targetWidth)
                    } : undefined;
                    const style = getComputedStyle(el);
                    const targetStyle = getComputedStyle(targetEl);
                    const duration = parseFloat(style.transitionDuration) * 1000 || 150;
                    const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
                    const color = targetStyle.getPropertyValue("color");
                    el.style.visibility = "visible";
                    targetEl.style.visibility = "hidden";
                    (0, _indexMjs1.animate)(el, {
                        transform: `translate(${x}px, ${y}px) scale(${scale})`,
                        color,
                        ...width
                    }, {
                        duration,
                        easing: (0, _indexMjs1.standardEasing),
                        direction: val ? "normal" : "reverse"
                    }).finished.then(()=>{
                        el.style.removeProperty("visibility");
                        targetEl.style.removeProperty("visibility");
                    });
                });
            }
        }, {
            flush: "post"
        });
        const slotProps = (0, _vue.computed)(()=>({
                isActive,
                isFocused,
                controlRef,
                blur,
                focus
            }));
        function onClick(e) {
            if (e.target !== document.activeElement) e.preventDefault();
        }
        (0, _indexMjs1.useRender)(()=>{
            const isOutlined = props.variant === "outlined";
            const hasPrepend = slots["prepend-inner"] || props.prependInnerIcon;
            const hasClear = !!(props.clearable || slots.clear);
            const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
            const label = slots.label ? slots.label({
                ...slotProps.value,
                label: props.label,
                props: {
                    for: id.value
                }
            }) : props.label;
            return (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                "class": [
                    "v-field",
                    {
                        "v-field--active": isActive.value,
                        "v-field--appended": hasAppend,
                        "v-field--center-affix": props.centerAffix ?? !isPlainOrUnderlined.value,
                        "v-field--disabled": props.disabled,
                        "v-field--dirty": props.dirty,
                        "v-field--error": props.error,
                        "v-field--flat": props.flat,
                        "v-field--has-background": !!props.bgColor,
                        "v-field--persistent-clear": props.persistentClear,
                        "v-field--prepended": hasPrepend,
                        "v-field--reverse": props.reverse,
                        "v-field--single-line": props.singleLine,
                        "v-field--no-label": !label,
                        [`v-field--variant-${props.variant}`]: true
                    },
                    themeClasses.value,
                    backgroundColorClasses.value,
                    focusClasses.value,
                    loaderClasses.value,
                    roundedClasses.value,
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.style
                ],
                "onClick": onClick
            }, attrs), [
                (0, _vue.createVNode)("div", {
                    "class": "v-field__overlay"
                }, null),
                (0, _vue.createVNode)((0, _loaderMjs.LoaderSlot), {
                    "name": "v-field",
                    "active": !!props.loading,
                    "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
                }, {
                    default: slots.loader
                }),
                hasPrepend && (0, _vue.createVNode)("div", {
                    "key": "prepend",
                    "class": "v-field__prepend-inner"
                }, [
                    props.prependInnerIcon && (0, _vue.createVNode)(InputIcon, {
                        "key": "prepend-icon",
                        "name": "prependInner"
                    }, null),
                    slots["prepend-inner"]?.(slotProps.value)
                ]),
                (0, _vue.createVNode)("div", {
                    "class": "v-field__field",
                    "data-no-activator": ""
                }, [
                    [
                        "filled",
                        "solo",
                        "solo-inverted",
                        "solo-filled"
                    ].includes(props.variant) && hasLabel.value && (0, _vue.createVNode)((0, _vfieldLabelMjs.VFieldLabel), {
                        "key": "floating-label",
                        "ref": floatingLabelRef,
                        "class": [
                            textColorClasses.value
                        ],
                        "floating": true,
                        "for": id.value,
                        "style": textColorStyles.value
                    }, {
                        default: ()=>[
                                label
                            ]
                    }),
                    (0, _vue.createVNode)((0, _vfieldLabelMjs.VFieldLabel), {
                        "ref": labelRef,
                        "for": id.value
                    }, {
                        default: ()=>[
                                label
                            ]
                    }),
                    slots.default?.({
                        ...slotProps.value,
                        props: {
                            id: id.value,
                            class: "v-field__input",
                            "aria-describedby": messagesId.value
                        },
                        focus,
                        blur
                    })
                ]),
                hasClear && (0, _vue.createVNode)((0, _indexMjs.VExpandXTransition), {
                    "key": "clear"
                }, {
                    default: ()=>[
                            (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                                "class": "v-field__clearable",
                                "onMousedown": (e)=>{
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }, [
                                slots.clear ? slots.clear() : (0, _vue.createVNode)(InputIcon, {
                                    "name": "clear"
                                }, null)
                            ]), [
                                [
                                    (0, _vue.vShow),
                                    props.dirty
                                ]
                            ])
                        ]
                }),
                hasAppend && (0, _vue.createVNode)("div", {
                    "key": "append",
                    "class": "v-field__append-inner"
                }, [
                    slots["append-inner"]?.(slotProps.value),
                    props.appendInnerIcon && (0, _vue.createVNode)(InputIcon, {
                        "key": "append-icon",
                        "name": "appendInner"
                    }, null)
                ]),
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-field__outline",
                        textColorClasses.value
                    ],
                    "style": textColorStyles.value
                }, [
                    isOutlined && (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        (0, _vue.createVNode)("div", {
                            "class": "v-field__outline__start"
                        }, null),
                        hasLabel.value && (0, _vue.createVNode)("div", {
                            "class": "v-field__outline__notch"
                        }, [
                            (0, _vue.createVNode)((0, _vfieldLabelMjs.VFieldLabel), {
                                "ref": floatingLabelRef,
                                "floating": true,
                                "for": id.value
                            }, {
                                default: ()=>[
                                        label
                                    ]
                            })
                        ]),
                        (0, _vue.createVNode)("div", {
                            "class": "v-field__outline__end"
                        }, null)
                    ]),
                    isPlainOrUnderlined.value && hasLabel.value && (0, _vue.createVNode)((0, _vfieldLabelMjs.VFieldLabel), {
                        "ref": floatingLabelRef,
                        "floating": true,
                        "for": id.value
                    }, {
                        default: ()=>[
                                label
                            ]
                    })
                ])
            ]);
        });
        return {
            controlRef
        };
    }
});
function filterFieldProps(attrs) {
    const keys = Object.keys(VField.props).filter((k)=>!(0, _indexMjs1.isOn)(k) && k !== "class" && k !== "style");
    return (0, _indexMjs1.pick)(attrs, keys);
}

},{"vue":"ff77s","./VField.css":"gRslj","./VFieldLabel.mjs":"9pUSw","../transitions/index.mjs":"oiH7Z","../VInput/InputIcon.mjs":"161oe","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/focus.mjs":"1bQxY","../../composables/icons.mjs":"ezwoc","../../composables/loader.mjs":"dJ5WR","../../composables/locale.mjs":"4MZbL","../../composables/rounded.mjs":"ldhZ9","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gRslj":[function() {},{}],"9pUSw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVFieldLabelProps", ()=>makeVFieldLabelProps);
parcelHelpers.export(exports, "VFieldLabel", ()=>VFieldLabel);
var _vue = require("vue");
// Components
var _indexMjs = require("../VLabel/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs");
const makeVFieldLabelProps = (0, _indexMjs1.propsFactory)({
    floating: Boolean,
    ...(0, _componentMjs.makeComponentProps)()
}, "VFieldLabel");
const VFieldLabel = (0, _indexMjs1.genericComponent)()({
    name: "VFieldLabel",
    props: makeVFieldLabelProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _indexMjs.VLabel), {
                "class": [
                    "v-field-label",
                    {
                        "v-field-label--floating": props.floating
                    },
                    props.class
                ],
                "style": props.style,
                "aria-hidden": props.floating || undefined
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","../VLabel/index.mjs":"cclAn","../../composables/component.mjs":"jVHld","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7IUqN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VVirtualScroll", ()=>(0, _vvirtualScrollMjs.VVirtualScroll));
var _vvirtualScrollMjs = require("./VVirtualScroll.mjs");

},{"./VVirtualScroll.mjs":"jpjGA","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jpjGA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVVirtualScrollProps", ()=>makeVVirtualScrollProps);
parcelHelpers.export(exports, "VVirtualScroll", ()=>VVirtualScroll);
var _vue = require("vue");
// Styles
var _vvirtualScrollCss = require("./VVirtualScroll.css");
// Components
var _vvirtualScrollItemMjs = require("./VVirtualScrollItem.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _toggleScopeMjs = require("../../composables/toggleScope.mjs");
var _virtualMjs = require("../../composables/virtual.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVVirtualScrollProps = (0, _indexMjs.propsFactory)({
    items: {
        type: Array,
        default: ()=>[]
    },
    renderless: Boolean,
    ...(0, _virtualMjs.makeVirtualProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)()
}, "VVirtualScroll");
const VVirtualScroll = (0, _indexMjs.genericComponent)()({
    name: "VVirtualScroll",
    props: makeVVirtualScrollProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const vm = (0, _indexMjs.getCurrentInstance)("VVirtualScroll");
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { containerRef, handleScroll, handleItemResize, scrollToIndex, paddingTop, paddingBottom, computedItems } = (0, _virtualMjs.useVirtual)(props, (0, _vue.toRef)(props, "items"));
        (0, _toggleScopeMjs.useToggleScope)(()=>props.renderless, ()=>{
            (0, _vue.onMounted)(()=>{
                containerRef.value = (0, _indexMjs.getScrollParent)(vm.vnode.el, true);
                containerRef.value?.addEventListener("scroll", handleScroll);
            });
            (0, _vue.onScopeDispose)(()=>{
                containerRef.value?.removeEventListener("scroll", handleScroll);
            });
        });
        (0, _indexMjs.useRender)(()=>{
            const children = computedItems.value.map((item)=>(0, _vue.createVNode)((0, _vvirtualScrollItemMjs.VVirtualScrollItem), {
                    "key": item.index,
                    "renderless": props.renderless,
                    "onUpdate:height": (height)=>handleItemResize(item.index, height)
                }, {
                    default: (slotProps)=>slots.default?.({
                            item: item.raw,
                            index: item.index,
                            ...slotProps
                        })
                }));
            return props.renderless ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                (0, _vue.createVNode)("div", {
                    "class": "v-virtual-scroll__spacer",
                    "style": {
                        paddingTop: (0, _indexMjs.convertToUnit)(paddingTop.value)
                    }
                }, null),
                children,
                (0, _vue.createVNode)("div", {
                    "class": "v-virtual-scroll__spacer",
                    "style": {
                        paddingBottom: (0, _indexMjs.convertToUnit)(paddingBottom.value)
                    }
                }, null)
            ]) : (0, _vue.createVNode)("div", {
                "ref": containerRef,
                "class": [
                    "v-virtual-scroll",
                    props.class
                ],
                "onScroll": handleScroll,
                "style": [
                    dimensionStyles.value,
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", {
                    "class": "v-virtual-scroll__container",
                    "style": {
                        paddingTop: (0, _indexMjs.convertToUnit)(paddingTop.value),
                        paddingBottom: (0, _indexMjs.convertToUnit)(paddingBottom.value)
                    }
                }, [
                    children
                ])
            ]);
        });
        return {
            scrollToIndex
        };
    }
});

},{"vue":"ff77s","./VVirtualScroll.css":"62zUX","./VVirtualScrollItem.mjs":"80y0o","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../composables/toggleScope.mjs":"cE29O","../../composables/virtual.mjs":"4ySHp","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"62zUX":[function() {},{}],"80y0o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVVirtualScrollItemProps", ()=>makeVVirtualScrollItemProps);
parcelHelpers.export(exports, "VVirtualScrollItem", ()=>VVirtualScrollItem);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVVirtualScrollItemProps = (0, _indexMjs.propsFactory)({
    renderless: Boolean,
    ...(0, _componentMjs.makeComponentProps)()
}, "VVirtualScrollItem");
const VVirtualScrollItem = (0, _indexMjs.genericComponent)()({
    name: "VVirtualScrollItem",
    inheritAttrs: false,
    props: makeVVirtualScrollItemProps(),
    emits: {
        "update:height": (height)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const { resizeRef, contentRect } = (0, _resizeObserverMjs.useResizeObserver)(undefined, "border");
        (0, _vue.watch)(()=>contentRect.value?.height, (height)=>{
            if (height != null) emit("update:height", height);
        });
        (0, _indexMjs.useRender)(()=>props.renderless ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                slots.default?.({
                    itemRef: resizeRef
                })
            ]) : (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                "ref": resizeRef,
                "class": [
                    "v-virtual-scroll__item",
                    props.class
                ],
                "style": props.style
            }, attrs), [
                slots.default?.()
            ]));
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/resizeObserver.mjs":"byLTu","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4ySHp":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVirtualProps", ()=>makeVirtualProps);
parcelHelpers.export(exports, "useVirtual", ()=>useVirtual);
var _displayMjs = require("./display.mjs");
var _resizeObserverMjs = require("./resizeObserver.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const UP = -1;
const DOWN = 1;
const makeVirtualProps = (0, _indexMjs.propsFactory)({
    itemHeight: {
        type: [
            Number,
            String
        ],
        default: 48
    }
}, "virtual");
function useVirtual(props, items, offset) {
    const first = (0, _vue.shallowRef)(0);
    const baseItemHeight = (0, _vue.shallowRef)(props.itemHeight);
    const itemHeight = (0, _vue.computed)({
        get: ()=>parseInt(baseItemHeight.value ?? 0, 10),
        set (val) {
            baseItemHeight.value = val;
        }
    });
    const containerRef = (0, _vue.ref)();
    const { resizeRef, contentRect } = (0, _resizeObserverMjs.useResizeObserver)();
    (0, _vue.watchEffect)(()=>{
        resizeRef.value = containerRef.value;
    });
    const display = (0, _displayMjs.useDisplay)();
    const sizeMap = new Map();
    let sizes = Array.from({
        length: items.value.length
    });
    const visibleItems = (0, _vue.computed)(()=>{
        const height = (!contentRect.value || containerRef.value === document.documentElement ? display.height.value : contentRect.value.height) - (offset?.value ?? 0);
        return Math.ceil(height / itemHeight.value * 1.7 + 1);
    });
    function handleItemResize(index, height) {
        itemHeight.value = Math.max(itemHeight.value, height);
        sizes[index] = height;
        sizeMap.set(items.value[index], height);
    }
    function calculateOffset(index) {
        return sizes.slice(0, index).reduce((acc, val)=>acc + (val || itemHeight.value), 0);
    }
    function calculateMidPointIndex(scrollTop) {
        const end = items.value.length;
        let middle = 0;
        let middleOffset = 0;
        while(middleOffset < scrollTop && middle < end)middleOffset += sizes[middle++] || itemHeight.value;
        return middle - 1;
    }
    let lastScrollTop = 0;
    function handleScroll() {
        if (!containerRef.value || !contentRect.value) return;
        const height = contentRect.value.height - 56;
        const scrollTop = containerRef.value.scrollTop;
        const direction = scrollTop < lastScrollTop ? UP : DOWN;
        const midPointIndex = calculateMidPointIndex(scrollTop + height / 2);
        const buffer = Math.round(visibleItems.value / 3);
        const firstIndex = midPointIndex - buffer;
        const lastIndex = first.value + buffer * 2 - 1;
        if (direction === UP && midPointIndex <= lastIndex) first.value = (0, _indexMjs.clamp)(firstIndex, 0, items.value.length);
        else if (direction === DOWN && midPointIndex >= lastIndex) first.value = (0, _indexMjs.clamp)(firstIndex, 0, items.value.length - visibleItems.value);
        lastScrollTop = scrollTop;
    }
    function scrollToIndex(index) {
        if (!containerRef.value) return;
        const offset = calculateOffset(index);
        containerRef.value.scrollTop = offset;
    }
    const last = (0, _vue.computed)(()=>Math.min(items.value.length, first.value + visibleItems.value));
    const computedItems = (0, _vue.computed)(()=>{
        return items.value.slice(first.value, last.value).map((item, index)=>({
                raw: item,
                index: index + first.value
            }));
    });
    const paddingTop = (0, _vue.computed)(()=>calculateOffset(first.value));
    const paddingBottom = (0, _vue.computed)(()=>calculateOffset(items.value.length) - calculateOffset(last.value));
    (0, _vue.watch)(()=>items.value.length, ()=>{
        sizes = (0, _indexMjs.createRange)(items.value.length).map(()=>itemHeight.value);
        sizeMap.forEach((height, item)=>{
            const index = items.value.indexOf(item);
            if (index === -1) sizeMap.delete(item);
            else sizes[index] = height;
        });
    });
    return {
        containerRef,
        computedItems,
        itemHeight,
        paddingTop,
        paddingBottom,
        scrollToIndex,
        handleScroll,
        handleItemResize
    };
}

},{"./display.mjs":"6nXZK","./resizeObserver.mjs":"byLTu","vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fZNsR":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Types
parcelHelpers.export(exports, "useScrolling", ()=>useScrolling);
var _vue = require("vue");
function useScrolling(listRef, textFieldRef) {
    const isScrolling = (0, _vue.shallowRef)(false);
    let scrollTimeout;
    function onListScroll(e) {
        cancelAnimationFrame(scrollTimeout);
        isScrolling.value = true;
        scrollTimeout = requestAnimationFrame(()=>{
            scrollTimeout = requestAnimationFrame(()=>{
                isScrolling.value = false;
            });
        });
    }
    async function finishScrolling() {
        await new Promise((resolve)=>requestAnimationFrame(resolve));
        await new Promise((resolve)=>requestAnimationFrame(resolve));
        await new Promise((resolve)=>requestAnimationFrame(resolve));
        await new Promise((resolve)=>{
            if (isScrolling.value) {
                const stop = (0, _vue.watch)(isScrolling, ()=>{
                    stop();
                    resolve();
                });
            } else resolve();
        });
    }
    async function onListKeydown(e) {
        if (e.key === "Tab") textFieldRef.value?.focus();
        if (![
            "PageDown",
            "PageUp",
            "Home",
            "End"
        ].includes(e.key)) return;
        const el = listRef.value?.$el;
        if (!el) return;
        if (e.key === "Home" || e.key === "End") el.scrollTo({
            top: e.key === "Home" ? 0 : el.scrollHeight,
            behavior: "smooth"
        });
        await finishScrolling();
        const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
        if (e.key === "PageDown" || e.key === "Home") {
            const top = el.getBoundingClientRect().top;
            for (const child of children)if (child.getBoundingClientRect().top >= top) {
                child.focus();
                break;
            }
        } else {
            const bottom = el.getBoundingClientRect().bottom;
            for (const child of [
                ...children
            ].reverse())if (child.getBoundingClientRect().bottom <= bottom) {
                child.focus();
                break;
            }
        }
    }
    return {
        onListScroll,
        onListKeydown
    };
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fMXi2":[function(require,module,exports) {
/* eslint-disable max-statements */ /* eslint-disable no-labels */ // Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultFilter", ()=>defaultFilter);
parcelHelpers.export(exports, "makeFilterProps", ()=>makeFilterProps);
parcelHelpers.export(exports, "filterItems", ()=>filterItems);
parcelHelpers.export(exports, "useFilter", ()=>useFilter);
var _vue = require("vue");
var _indexMjs = require("../util/index.mjs"); // Types
const defaultFilter = (value, query, item)=>{
    if (value == null || query == null) return -1;
    return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
};
const makeFilterProps = (0, _indexMjs.propsFactory)({
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [
        Array,
        String
    ],
    filterMode: {
        type: String,
        default: "intersection"
    },
    noFilter: Boolean
}, "filter");
function filterItems(items, query, options) {
    const array = [];
    // always ensure we fall back to a functioning filter
    const filter = options?.default ?? defaultFilter;
    const keys = options?.filterKeys ? (0, _indexMjs.wrapInArray)(options.filterKeys) : false;
    const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length;
    if (!items?.length) return array;
    loop: for(let i = 0; i < items.length; i++){
        const [item, transformed = item] = (0, _indexMjs.wrapInArray)(items[i]);
        const customMatches = {};
        const defaultMatches = {};
        let match = -1;
        if (query && !options?.noFilter) {
            if (typeof item === "object") {
                const filterKeys = keys || Object.keys(transformed);
                for (const key of filterKeys){
                    const value = (0, _indexMjs.getPropertyFromItem)(transformed, key, transformed);
                    const keyFilter = options?.customKeyFilter?.[key];
                    match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
                    if (match !== -1 && match !== false) {
                        if (keyFilter) customMatches[key] = match;
                        else defaultMatches[key] = match;
                    } else if (options?.filterMode === "every") continue loop;
                }
            } else {
                match = filter(item, query, item);
                if (match !== -1 && match !== false) defaultMatches.title = match;
            }
            const defaultMatchesLength = Object.keys(defaultMatches).length;
            const customMatchesLength = Object.keys(customMatches).length;
            if (!defaultMatchesLength && !customMatchesLength) continue;
            if (options?.filterMode === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength) continue;
            if (options?.filterMode === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength)) continue;
        }
        array.push({
            index: i,
            matches: {
                ...defaultMatches,
                ...customMatches
            }
        });
    }
    return array;
}
function useFilter(props, items, query, options) {
    const filteredItems = (0, _vue.ref)([]);
    const filteredMatches = (0, _vue.ref)(new Map());
    const transformedItems = (0, _vue.computed)(()=>options?.transform ? (0, _vue.unref)(items).map((item)=>[
                item,
                options.transform(item)
            ]) : (0, _vue.unref)(items));
    (0, _vue.watchEffect)(()=>{
        const _query = typeof query === "function" ? query() : (0, _vue.unref)(query);
        const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
        const results = filterItems(transformedItems.value, strQuery, {
            customKeyFilter: props.customKeyFilter,
            default: props.customFilter,
            filterKeys: props.filterKeys,
            filterMode: props.filterMode,
            noFilter: props.noFilter
        });
        const originalItems = (0, _vue.unref)(items);
        const _filteredItems = [];
        const _filteredMatches = new Map();
        results.forEach((_ref)=>{
            let { index, matches } = _ref;
            const item = originalItems[index];
            _filteredItems.push(item);
            _filteredMatches.set(item.value, matches);
        });
        filteredItems.value = _filteredItems;
        filteredMatches.value = _filteredMatches;
    });
    function getMatches(item) {
        return filteredMatches.value.get(item.value);
    }
    return {
        filteredItems,
        filteredMatches,
        getMatches
    };
}

},{"vue":"ff77s","../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j3ZWY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBadge", ()=>(0, _vbadgeMjs.VBadge));
var _vbadgeMjs = require("./VBadge.mjs");

},{"./VBadge.mjs":"j3gQW","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j3gQW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBadgeProps", ()=>makeVBadgeProps);
parcelHelpers.export(exports, "VBadge", ()=>VBadge);
var _vue = require("vue");
// Styles
var _vbadgeCss = require("./VBadge.css");
// Components
var _indexMjs = require("../VIcon/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs");
const makeVBadgeProps = (0, _indexMjs1.propsFactory)({
    bordered: Boolean,
    color: String,
    content: [
        Number,
        String
    ],
    dot: Boolean,
    floating: Boolean,
    icon: (0, _iconsMjs.IconValue),
    inline: Boolean,
    label: {
        type: String,
        default: "$vuetify.badge"
    },
    max: [
        Number,
        String
    ],
    modelValue: {
        type: Boolean,
        default: true
    },
    offsetX: [
        Number,
        String
    ],
    offsetY: [
        Number,
        String
    ],
    textColor: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _locationMjs.makeLocationProps)({
        location: "top end"
    }),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: "scale-rotate-transition"
    })
}, "VBadge");
const VBadge = (0, _indexMjs1.genericComponent)()({
    name: "VBadge",
    inheritAttrs: false,
    props: makeVBadgeProps(),
    setup (props, ctx) {
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { t } = (0, _localeMjs.useLocale)();
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)((0, _vue.toRef)(props, "textColor"));
        const { themeClasses } = (0, _themeMjs.useTheme)();
        const { locationStyles } = (0, _locationMjs.useLocation)(props, true, (side)=>{
            const base = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
            return base + ([
                "top",
                "bottom"
            ].includes(side) ? +(props.offsetY ?? 0) : [
                "left",
                "right"
            ].includes(side) ? +(props.offsetX ?? 0) : 0);
        });
        (0, _indexMjs1.useRender)(()=>{
            const value = Number(props.content);
            const content = !props.max || isNaN(value) ? props.content : value <= +props.max ? value : `${props.max}+`;
            const [badgeAttrs, attrs] = (0, _indexMjs1.pick)(ctx.attrs, [
                "aria-atomic",
                "aria-label",
                "aria-live",
                "role",
                "title"
            ]);
            return (0, _vue.createVNode)(props.tag, (0, _vue.mergeProps)({
                "class": [
                    "v-badge",
                    {
                        "v-badge--bordered": props.bordered,
                        "v-badge--dot": props.dot,
                        "v-badge--floating": props.floating,
                        "v-badge--inline": props.inline
                    },
                    props.class
                ]
            }, attrs, {
                "style": props.style
            }), {
                default: ()=>[
                        (0, _vue.createVNode)("div", {
                            "class": "v-badge__wrapper"
                        }, [
                            ctx.slots.default?.(),
                            (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                                "transition": props.transition
                            }, {
                                default: ()=>[
                                        (0, _vue.withDirectives)((0, _vue.createVNode)("span", (0, _vue.mergeProps)({
                                            "class": [
                                                "v-badge__badge",
                                                themeClasses.value,
                                                backgroundColorClasses.value,
                                                roundedClasses.value,
                                                textColorClasses.value
                                            ],
                                            "style": [
                                                backgroundColorStyles.value,
                                                textColorStyles.value,
                                                props.inline ? {} : locationStyles.value
                                            ],
                                            "aria-atomic": "true",
                                            "aria-label": t(props.label, value),
                                            "aria-live": "polite",
                                            "role": "status"
                                        }, badgeAttrs), [
                                            props.dot ? undefined : ctx.slots.badge ? ctx.slots.badge?.() : props.icon ? (0, _vue.createVNode)((0, _indexMjs.VIcon), {
                                                "icon": props.icon
                                            }, null) : content
                                        ]), [
                                            [
                                                (0, _vue.vShow),
                                                props.modelValue
                                            ]
                                        ])
                                    ]
                            })
                        ])
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VBadge.css":"2mgt8","../VIcon/index.mjs":"2wJue","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/location.mjs":"5z6DF","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2mgt8":[function() {},{}],"7MGbd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBanner", ()=>(0, _vbannerMjs.VBanner));
parcelHelpers.export(exports, "VBannerActions", ()=>(0, _vbannerActionsMjs.VBannerActions));
parcelHelpers.export(exports, "VBannerText", ()=>(0, _vbannerTextMjs.VBannerText));
var _vbannerMjs = require("./VBanner.mjs");
var _vbannerActionsMjs = require("./VBannerActions.mjs");
var _vbannerTextMjs = require("./VBannerText.mjs");

},{"./VBanner.mjs":"bbF3m","./VBannerActions.mjs":"ccLsX","./VBannerText.mjs":"1bID6","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bbF3m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBannerProps", ()=>makeVBannerProps);
parcelHelpers.export(exports, "VBanner", ()=>VBanner);
var _vue = require("vue");
// Styles
var _vbannerCss = require("./VBanner.css");
// Components
var _vbannerActionsMjs = require("./VBannerActions.mjs");
var _vbannerTextMjs = require("./VBannerText.mjs");
var _indexMjs = require("../VAvatar/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _displayMjs = require("../../composables/display.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVBannerProps = (0, _indexMjs2.propsFactory)({
    avatar: String,
    color: String,
    icon: (0, _iconsMjs.IconValue),
    lines: String,
    stacked: Boolean,
    sticky: Boolean,
    text: String,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _locationMjs.makeLocationProps)(),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VBanner");
const VBanner = (0, _indexMjs2.genericComponent)()({
    name: "VBanner",
    props: makeVBannerProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { mobile } = (0, _displayMjs.useDisplay)();
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const color = (0, _vue.toRef)(props, "color");
        const density = (0, _vue.toRef)(props, "density");
        (0, _defaultsMjs.provideDefaults)({
            VBannerActions: {
                color,
                density
            }
        });
        (0, _indexMjs2.useRender)(()=>{
            const hasText = !!(props.text || slots.text);
            const hasPrependMedia = !!(props.avatar || props.icon);
            const hasPrepend = !!(hasPrependMedia || slots.prepend);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-banner",
                    {
                        "v-banner--stacked": props.stacked || mobile.value,
                        "v-banner--sticky": props.sticky,
                        [`v-banner--${props.lines}-line`]: !!props.lines
                    },
                    borderClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    positionClasses.value,
                    roundedClasses.value,
                    themeClasses.value,
                    props.class
                ],
                "style": [
                    dimensionStyles.value,
                    locationStyles.value,
                    props.style
                ],
                "role": "banner"
            }, {
                default: ()=>[
                        hasPrepend && (0, _vue.createVNode)("div", {
                            "key": "prepend",
                            "class": "v-banner__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _indexMjs.VAvatar), {
                                "key": "prepend-avatar",
                                "color": color.value,
                                "density": density.value,
                                "icon": props.icon,
                                "image": props.avatar
                            }, null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !hasPrependMedia,
                                "defaults": {
                                    VAvatar: {
                                        color: color.value,
                                        density: density.value,
                                        icon: props.icon,
                                        image: props.avatar
                                    }
                                }
                            }, slots.prepend)
                        ]),
                        (0, _vue.createVNode)("div", {
                            "class": "v-banner__content"
                        }, [
                            hasText && (0, _vue.createVNode)((0, _vbannerTextMjs.VBannerText), {
                                "key": "text"
                            }, {
                                default: ()=>[
                                        slots.text?.() ?? props.text
                                    ]
                            }),
                            slots.default?.()
                        ]),
                        slots.actions && (0, _vue.createVNode)((0, _vbannerActionsMjs.VBannerActions), {
                            "key": "actions"
                        }, slots.actions)
                    ]
            });
        });
    }
});

},{"vue":"ff77s","./VBanner.css":"duLhK","./VBannerActions.mjs":"ccLsX","./VBannerText.mjs":"1bID6","../VAvatar/index.mjs":"1cQMc","../VDefaultsProvider/index.mjs":"1OIgj","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/display.mjs":"6nXZK","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"duLhK":[function() {},{}],"ccLsX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBannerActionsProps", ()=>makeVBannerActionsProps);
parcelHelpers.export(exports, "VBannerActions", ()=>VBannerActions);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVBannerActionsProps = (0, _indexMjs.propsFactory)({
    color: String,
    density: String,
    ...(0, _componentMjs.makeComponentProps)()
}, "VBannerActions");
const VBannerActions = (0, _indexMjs.genericComponent)()({
    name: "VBannerActions",
    props: makeVBannerActionsProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                color: props.color,
                density: props.density,
                variant: "text"
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-banner-actions",
                    props.class
                ],
                "style": props.style
            }, [
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1bID6":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBannerText", ()=>VBannerText);
var _indexMjs = require("../../util/index.mjs");
const VBannerText = (0, _indexMjs.createSimpleFunctional)("v-banner-text");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4eVMk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBottomNavigation", ()=>(0, _vbottomNavigationMjs.VBottomNavigation));
var _vbottomNavigationMjs = require("./VBottomNavigation.mjs");

},{"./VBottomNavigation.mjs":"fydRY","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fydRY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBottomNavigationProps", ()=>makeVBottomNavigationProps);
parcelHelpers.export(exports, "VBottomNavigation", ()=>VBottomNavigation);
var _vue = require("vue");
// Styles
var _vbottomNavigationCss = require("./VBottomNavigation.css");
// Components
var _vbtnToggleMjs = require("../VBtnToggle/VBtnToggle.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVBottomNavigationProps = (0, _indexMjs.propsFactory)({
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
        type: String,
        validator: (v)=>!v || [
                "horizontal",
                "shift"
            ].includes(v)
    },
    height: {
        type: [
            Number,
            String
        ],
        default: 56
    },
    active: {
        type: Boolean,
        default: true
    },
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)({
        name: "bottom-navigation"
    }),
    ...(0, _tagMjs.makeTagProps)({
        tag: "header"
    }),
    ...(0, _groupMjs.makeGroupProps)({
        modelValue: true,
        selectedClass: "v-btn--selected"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VBottomNavigation");
const VBottomNavigation = (0, _indexMjs.genericComponent)()({
    name: "VBottomNavigation",
    props: makeVBottomNavigationProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.useTheme)();
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "bgColor"));
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { ssrBootStyles } = (0, _ssrBootMjs.useSsrBoot)();
        const height = (0, _vue.computed)(()=>Number(props.height) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0));
        const isActive = (0, _vue.toRef)(props, "active");
        const { layoutItemStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: (0, _vue.computed)(()=>"bottom"),
            layoutSize: (0, _vue.computed)(()=>isActive.value ? height.value : 0),
            elementSize: height,
            active: isActive,
            absolute: (0, _vue.toRef)(props, "absolute")
        });
        (0, _groupMjs.useGroup)(props, (0, _vbtnToggleMjs.VBtnToggleSymbol));
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                color: (0, _vue.toRef)(props, "color"),
                density: (0, _vue.toRef)(props, "density"),
                stacked: (0, _vue.computed)(()=>props.mode !== "horizontal"),
                variant: "text"
            }
        }, {
            scoped: true
        });
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-bottom-navigation",
                    {
                        "v-bottom-navigation--active": isActive.value,
                        "v-bottom-navigation--grow": props.grow,
                        "v-bottom-navigation--shift": props.mode === "shift"
                    },
                    themeClasses.value,
                    backgroundColorClasses.value,
                    borderClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    layoutItemStyles.value,
                    {
                        height: (0, _indexMjs.convertToUnit)(height.value),
                        transform: `translateY(${(0, _indexMjs.convertToUnit)(!isActive.value ? 100 : 0, "%")})`
                    },
                    ssrBootStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        slots.default && (0, _vue.createVNode)("div", {
                            "class": "v-bottom-navigation__content"
                        }, [
                            slots.default()
                        ])
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VBottomNavigation.css":"1wW9N","../VBtnToggle/VBtnToggle.mjs":"hjTiQ","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/elevation.mjs":"3BDEa","../../composables/group.mjs":"7LC6J","../../composables/layout.mjs":"fPMsf","../../composables/rounded.mjs":"ldhZ9","../../composables/ssrBoot.mjs":"b8ivf","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1wW9N":[function() {},{}],"1kxW3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBreadcrumbs", ()=>(0, _vbreadcrumbsMjs.VBreadcrumbs));
parcelHelpers.export(exports, "VBreadcrumbsItem", ()=>(0, _vbreadcrumbsItemMjs.VBreadcrumbsItem));
parcelHelpers.export(exports, "VBreadcrumbsDivider", ()=>(0, _vbreadcrumbsDividerMjs.VBreadcrumbsDivider));
var _vbreadcrumbsMjs = require("./VBreadcrumbs.mjs");
var _vbreadcrumbsItemMjs = require("./VBreadcrumbsItem.mjs");
var _vbreadcrumbsDividerMjs = require("./VBreadcrumbsDivider.mjs");

},{"./VBreadcrumbs.mjs":"ifGxJ","./VBreadcrumbsItem.mjs":"kSRYF","./VBreadcrumbsDivider.mjs":"fYMsx","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ifGxJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBreadcrumbsProps", ()=>makeVBreadcrumbsProps);
parcelHelpers.export(exports, "VBreadcrumbs", ()=>VBreadcrumbs);
var _vue = require("vue");
// Styles
var _vbreadcrumbsCss = require("./VBreadcrumbs.css");
// Components
var _vbreadcrumbsDividerMjs = require("./VBreadcrumbsDivider.mjs");
var _vbreadcrumbsItemMjs = require("./VBreadcrumbsItem.mjs");
var _indexMjs = require("../VDefaultsProvider/index.mjs");
var _indexMjs1 = require("../VIcon/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVBreadcrumbsProps = (0, _indexMjs2.propsFactory)({
    activeClass: String,
    activeColor: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
        type: String,
        default: "/"
    },
    icon: (0, _iconsMjs.IconValue),
    items: {
        type: Array,
        default: ()=>[]
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "ul"
    })
}, "VBreadcrumbs");
const VBreadcrumbs = (0, _indexMjs2.genericComponent)()({
    name: "VBreadcrumbs",
    props: makeVBreadcrumbsProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "bgColor"));
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        (0, _defaultsMjs.provideDefaults)({
            VBreadcrumbsDivider: {
                divider: (0, _vue.toRef)(props, "divider")
            },
            VBreadcrumbsItem: {
                activeClass: (0, _vue.toRef)(props, "activeClass"),
                activeColor: (0, _vue.toRef)(props, "activeColor"),
                color: (0, _vue.toRef)(props, "color"),
                disabled: (0, _vue.toRef)(props, "disabled")
            }
        });
        const items = (0, _vue.computed)(()=>props.items.map((item)=>{
                return typeof item === "string" ? {
                    item: {
                        title: item
                    },
                    raw: item
                } : {
                    item,
                    raw: item
                };
            }));
        (0, _indexMjs2.useRender)(()=>{
            const hasPrepend = !!(slots.prepend || props.icon);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-breadcrumbs",
                    backgroundColorClasses.value,
                    densityClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        hasPrepend && (0, _vue.createVNode)("li", {
                            "key": "prepend",
                            "class": "v-breadcrumbs__prepend"
                        }, [
                            !slots.prepend ? (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                "key": "prepend-icon",
                                "start": true,
                                "icon": props.icon
                            }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                                "key": "prepend-defaults",
                                "disabled": !props.icon,
                                "defaults": {
                                    VIcon: {
                                        icon: props.icon,
                                        start: true
                                    }
                                }
                            }, slots.prepend)
                        ]),
                        items.value.map((_ref2, index, array)=>{
                            let { item, raw } = _ref2;
                            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                (0, _vue.createVNode)((0, _vbreadcrumbsItemMjs.VBreadcrumbsItem), (0, _vue.mergeProps)({
                                    "key": item.title,
                                    "disabled": index >= array.length - 1
                                }, item), {
                                    default: slots.title ? ()=>slots.title?.({
                                            item: raw,
                                            index
                                        }) : undefined
                                }),
                                index < array.length - 1 && (0, _vue.createVNode)((0, _vbreadcrumbsDividerMjs.VBreadcrumbsDivider), null, {
                                    default: slots.divider ? ()=>slots.divider?.({
                                            item: raw,
                                            index
                                        }) : undefined
                                })
                            ]);
                        }),
                        slots.default?.()
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VBreadcrumbs.css":"l1ANW","./VBreadcrumbsDivider.mjs":"fYMsx","./VBreadcrumbsItem.mjs":"kSRYF","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"l1ANW":[function() {},{}],"fYMsx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBreadcrumbsDividerProps", ()=>makeVBreadcrumbsDividerProps);
parcelHelpers.export(exports, "VBreadcrumbsDivider", ()=>VBreadcrumbsDivider);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVBreadcrumbsDividerProps = (0, _indexMjs.propsFactory)({
    divider: [
        Number,
        String
    ],
    ...(0, _componentMjs.makeComponentProps)()
}, "VBreadcrumbsDivider");
const VBreadcrumbsDivider = (0, _indexMjs.genericComponent)()({
    name: "VBreadcrumbsDivider",
    props: makeVBreadcrumbsDividerProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("li", {
                "class": [
                    "v-breadcrumbs-divider",
                    props.class
                ],
                "style": props.style
            }, [
                slots?.default?.() ?? props.divider
            ]));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kSRYF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVBreadcrumbsItemProps", ()=>makeVBreadcrumbsItemProps);
parcelHelpers.export(exports, "VBreadcrumbsItem", ()=>VBreadcrumbsItem);
var _vue = require("vue");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVBreadcrumbsItemProps = (0, _indexMjs.propsFactory)({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    title: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _routerMjs.makeRouterProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "li"
    })
}, "VBreadcrumbsItem");
const VBreadcrumbsItem = (0, _indexMjs.genericComponent)()({
    name: "VBreadcrumbsItem",
    props: makeVBreadcrumbsItemProps(),
    setup (props, _ref) {
        let { slots, attrs } = _ref;
        const link = (0, _routerMjs.useLink)(props, attrs);
        const isActive = (0, _vue.computed)(()=>props.active || link.isActive?.value);
        const color = (0, _vue.computed)(()=>isActive.value ? props.activeColor : props.color);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)(color);
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-breadcrumbs-item",
                    {
                        "v-breadcrumbs-item--active": isActive.value,
                        "v-breadcrumbs-item--disabled": props.disabled,
                        [`${props.activeClass}`]: isActive.value && props.activeClass
                    },
                    textColorClasses.value,
                    props.class
                ],
                "style": [
                    textColorStyles.value,
                    props.style
                ],
                "aria-current": isActive.value ? "page" : undefined
            }, {
                default: ()=>[
                        !link.isLink.value ? slots.default?.() ?? props.title : (0, _vue.createVNode)("a", {
                            "class": "v-breadcrumbs-item--link",
                            "href": link.href.value,
                            "aria-current": isActive.value ? "page" : undefined,
                            "onClick": link.navigate
                        }, [
                            slots.default?.() ?? props.title
                        ])
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/router.mjs":"bEBrG","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hwVCz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBtnGroup", ()=>(0, _vbtnGroupMjs.VBtnGroup));
var _vbtnGroupMjs = require("./VBtnGroup.mjs");

},{"./VBtnGroup.mjs":"hGrJO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6czdk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VBtnToggle", ()=>(0, _vbtnToggleMjs.VBtnToggle));
var _vbtnToggleMjs = require("./VBtnToggle.mjs");

},{"./VBtnToggle.mjs":"hjTiQ","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jpFL2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCard", ()=>(0, _vcardMjs.VCard));
parcelHelpers.export(exports, "VCardActions", ()=>(0, _vcardActionsMjs.VCardActions));
parcelHelpers.export(exports, "VCardItem", ()=>(0, _vcardItemMjs.VCardItem));
parcelHelpers.export(exports, "VCardSubtitle", ()=>(0, _vcardSubtitleMjs.VCardSubtitle));
parcelHelpers.export(exports, "VCardText", ()=>(0, _vcardTextMjs.VCardText));
parcelHelpers.export(exports, "VCardTitle", ()=>(0, _vcardTitleMjs.VCardTitle));
var _vcardMjs = require("./VCard.mjs");
var _vcardActionsMjs = require("./VCardActions.mjs");
var _vcardItemMjs = require("./VCardItem.mjs");
var _vcardSubtitleMjs = require("./VCardSubtitle.mjs");
var _vcardTextMjs = require("./VCardText.mjs");
var _vcardTitleMjs = require("./VCardTitle.mjs");

},{"./VCard.mjs":"3mihx","./VCardActions.mjs":"20cCk","./VCardItem.mjs":"6xsPs","./VCardSubtitle.mjs":"7H5jc","./VCardText.mjs":"epRSD","./VCardTitle.mjs":"kc4xe","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3mihx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCardProps", ()=>makeVCardProps);
parcelHelpers.export(exports, "VCard", ()=>VCard);
var _vue = require("vue");
/* eslint-disable complexity */ // Styles
var _vcardCss = require("./VCard.css");
// Components
var _vcardActionsMjs = require("./VCardActions.mjs");
var _vcardItemMjs = require("./VCardItem.mjs");
var _vcardTextMjs = require("./VCardText.mjs");
var _indexMjs = require("../VDefaultsProvider/index.mjs");
var _indexMjs1 = require("../VImg/index.mjs"); // Composables
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _loaderMjs = require("../../composables/loader.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Directives
var _indexMjs2 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVCardProps = (0, _indexMjs3.propsFactory)({
    appendAvatar: String,
    appendIcon: (0, _iconsMjs.IconValue),
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
        type: Boolean,
        default: undefined
    },
    prependAvatar: String,
    prependIcon: (0, _iconsMjs.IconValue),
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: true
    },
    subtitle: String,
    text: String,
    title: String,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _loaderMjs.makeLoaderProps)(),
    ...(0, _locationMjs.makeLocationProps)(),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _routerMjs.makeRouterProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "elevated"
    })
}, "VCard");
const VCard = (0, _indexMjs3.genericComponent)()({
    name: "VCard",
    directives: {
        Ripple: (0, _indexMjs2.Ripple)
    },
    props: makeVCardProps(),
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { loaderClasses } = (0, _loaderMjs.useLoader)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const link = (0, _routerMjs.useLink)(props, attrs);
        const isLink = (0, _vue.computed)(()=>props.link !== false && link.isLink.value);
        const isClickable = (0, _vue.computed)(()=>!props.disabled && props.link !== false && (props.link || link.isClickable.value));
        (0, _indexMjs3.useRender)(()=>{
            const Tag = isLink.value ? "a" : props.tag;
            const hasTitle = !!(slots.title || props.title);
            const hasSubtitle = !!(slots.subtitle || props.subtitle);
            const hasHeader = hasTitle || hasSubtitle;
            const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
            const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
            const hasImage = !!(slots.image || props.image);
            const hasCardItem = hasHeader || hasPrepend || hasAppend;
            const hasText = !!(slots.text || props.text);
            return (0, _vue.withDirectives)((0, _vue.createVNode)(Tag, {
                "class": [
                    "v-card",
                    {
                        "v-card--disabled": props.disabled,
                        "v-card--flat": props.flat,
                        "v-card--hover": props.hover && !(props.disabled || props.flat),
                        "v-card--link": isClickable.value
                    },
                    themeClasses.value,
                    borderClasses.value,
                    colorClasses.value,
                    densityClasses.value,
                    elevationClasses.value,
                    loaderClasses.value,
                    positionClasses.value,
                    roundedClasses.value,
                    variantClasses.value,
                    props.class
                ],
                "style": [
                    colorStyles.value,
                    dimensionStyles.value,
                    locationStyles.value,
                    props.style
                ],
                "href": link.href.value,
                "onClick": isClickable.value && link.navigate,
                "tabindex": props.disabled ? -1 : undefined
            }, {
                default: ()=>[
                        hasImage && (0, _vue.createVNode)("div", {
                            "key": "image",
                            "class": "v-card__image"
                        }, [
                            !slots.image ? (0, _vue.createVNode)((0, _indexMjs1.VImg), {
                                "key": "image-img",
                                "cover": true,
                                "src": props.image
                            }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                                "key": "image-defaults",
                                "disabled": !props.image,
                                "defaults": {
                                    VImg: {
                                        cover: true,
                                        src: props.image
                                    }
                                }
                            }, slots.image)
                        ]),
                        (0, _vue.createVNode)((0, _loaderMjs.LoaderSlot), {
                            "name": "v-card",
                            "active": !!props.loading,
                            "color": typeof props.loading === "boolean" ? undefined : props.loading
                        }, {
                            default: slots.loader
                        }),
                        hasCardItem && (0, _vue.createVNode)((0, _vcardItemMjs.VCardItem), {
                            "key": "item",
                            "prependAvatar": props.prependAvatar,
                            "prependIcon": props.prependIcon,
                            "title": props.title,
                            "subtitle": props.subtitle,
                            "appendAvatar": props.appendAvatar,
                            "appendIcon": props.appendIcon
                        }, {
                            default: slots.item,
                            prepend: slots.prepend,
                            title: slots.title,
                            subtitle: slots.subtitle,
                            append: slots.append
                        }),
                        hasText && (0, _vue.createVNode)((0, _vcardTextMjs.VCardText), {
                            "key": "text"
                        }, {
                            default: ()=>[
                                    slots.text?.() ?? props.text
                                ]
                        }),
                        slots.default?.(),
                        slots.actions && (0, _vue.createVNode)((0, _vcardActionsMjs.VCardActions), null, {
                            default: slots.actions
                        }),
                        (0, _variantMjs.genOverlays)(isClickable.value, "v-card")
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("ripple"),
                    isClickable.value && props.ripple
                ]
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VCard.css":"2CE8N","./VCardActions.mjs":"20cCk","./VCardItem.mjs":"6xsPs","./VCardText.mjs":"epRSD","../VDefaultsProvider/index.mjs":"1OIgj","../VImg/index.mjs":"87IoX","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/loader.mjs":"dJ5WR","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/rounded.mjs":"ldhZ9","../../composables/router.mjs":"bEBrG","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2CE8N":[function() {},{}],"20cCk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCardActions", ()=>VCardActions);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const VCardActions = (0, _indexMjs.genericComponent)()({
    name: "VCardActions",
    props: (0, _componentMjs.makeComponentProps)(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                variant: "text"
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-card-actions",
                    props.class
                ],
                "style": props.style
            }, [
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6xsPs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeCardItemProps", ()=>makeCardItemProps);
parcelHelpers.export(exports, "VCardItem", ()=>VCardItem);
var _vue = require("vue");
// Components
var _vcardSubtitleMjs = require("./VCardSubtitle.mjs");
var _vcardTitleMjs = require("./VCardTitle.mjs");
var _indexMjs = require("../VAvatar/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs");
const makeCardItemProps = (0, _indexMjs2.propsFactory)({
    appendAvatar: String,
    appendIcon: (0, _iconsMjs.IconValue),
    prependAvatar: String,
    prependIcon: (0, _iconsMjs.IconValue),
    subtitle: String,
    title: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)()
}, "VCardItem");
const VCardItem = (0, _indexMjs2.genericComponent)()({
    name: "VCardItem",
    props: makeCardItemProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs2.useRender)(()=>{
            const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
            const hasPrepend = !!(hasPrependMedia || slots.prepend);
            const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
            const hasAppend = !!(hasAppendMedia || slots.append);
            const hasTitle = !!(props.title || slots.title);
            const hasSubtitle = !!(props.subtitle || slots.subtitle);
            return (0, _vue.createVNode)("div", {
                "class": [
                    "v-card-item",
                    props.class
                ],
                "style": props.style
            }, [
                hasPrepend && (0, _vue.createVNode)("div", {
                    "key": "prepend",
                    "class": "v-card-item__prepend"
                }, [
                    !slots.prepend ? hasPrependMedia && (0, _vue.createVNode)((0, _indexMjs.VAvatar), {
                        "key": "prepend-avatar",
                        "density": props.density,
                        "icon": props.prependIcon,
                        "image": props.prependAvatar
                    }, null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                        "key": "prepend-defaults",
                        "disabled": !hasPrependMedia,
                        "defaults": {
                            VAvatar: {
                                density: props.density,
                                icon: props.prependIcon,
                                image: props.prependAvatar
                            }
                        }
                    }, slots.prepend)
                ]),
                (0, _vue.createVNode)("div", {
                    "class": "v-card-item__content"
                }, [
                    hasTitle && (0, _vue.createVNode)((0, _vcardTitleMjs.VCardTitle), {
                        "key": "title"
                    }, {
                        default: ()=>[
                                slots.title?.() ?? props.title
                            ]
                    }),
                    hasSubtitle && (0, _vue.createVNode)((0, _vcardSubtitleMjs.VCardSubtitle), {
                        "key": "subtitle"
                    }, {
                        default: ()=>[
                                slots.subtitle?.() ?? props.subtitle
                            ]
                    }),
                    slots.default?.()
                ]),
                hasAppend && (0, _vue.createVNode)("div", {
                    "key": "append",
                    "class": "v-card-item__append"
                }, [
                    !slots.append ? hasAppendMedia && (0, _vue.createVNode)((0, _indexMjs.VAvatar), {
                        "key": "append-avatar",
                        "density": props.density,
                        "icon": props.appendIcon,
                        "image": props.appendAvatar
                    }, null) : (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                        "key": "append-defaults",
                        "disabled": !hasAppendMedia,
                        "defaults": {
                            VAvatar: {
                                density: props.density,
                                icon: props.appendIcon,
                                image: props.appendAvatar
                            }
                        }
                    }, slots.append)
                ])
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VCardSubtitle.mjs":"7H5jc","./VCardTitle.mjs":"kc4xe","../VAvatar/index.mjs":"1cQMc","../VDefaultsProvider/index.mjs":"1OIgj","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7H5jc":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCardSubtitle", ()=>VCardSubtitle);
var _indexMjs = require("../../util/index.mjs");
const VCardSubtitle = (0, _indexMjs.createSimpleFunctional)("v-card-subtitle");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kc4xe":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCardTitle", ()=>VCardTitle);
var _indexMjs = require("../../util/index.mjs");
const VCardTitle = (0, _indexMjs.createSimpleFunctional)("v-card-title");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"epRSD":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCardText", ()=>VCardText);
var _indexMjs = require("../../util/index.mjs");
const VCardText = (0, _indexMjs.createSimpleFunctional)("v-card-text");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"04oa5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCarousel", ()=>(0, _vcarouselMjs.VCarousel));
parcelHelpers.export(exports, "VCarouselItem", ()=>(0, _vcarouselItemMjs.VCarouselItem));
var _vcarouselMjs = require("./VCarousel.mjs");
var _vcarouselItemMjs = require("./VCarouselItem.mjs");

},{"./VCarousel.mjs":"eezEc","./VCarouselItem.mjs":"7EtfD","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eezEc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCarouselProps", ()=>makeVCarouselProps);
parcelHelpers.export(exports, "VCarousel", ()=>VCarousel);
var _vue = require("vue");
// Styles
var _vcarouselCss = require("./VCarousel.css");
// Components
var _indexMjs = require("../VBtn/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VProgressLinear/index.mjs");
var _vwindowMjs = require("../VWindow/VWindow.mjs"); // Composables
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVCarouselProps = (0, _indexMjs3.propsFactory)({
    color: String,
    cycle: Boolean,
    delimiterIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$delimiter"
    },
    height: {
        type: [
            Number,
            String
        ],
        default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
        type: [
            Number,
            String
        ],
        default: 6000,
        validator: (value)=>Number(value) > 0
    },
    progress: [
        Boolean,
        String
    ],
    verticalDelimiters: [
        Boolean,
        String
    ],
    ...(0, _vwindowMjs.makeVWindowProps)({
        continuous: true,
        mandatory: "force",
        showArrows: true
    })
}, "VCarousel");
const VCarousel = (0, _indexMjs3.genericComponent)()({
    name: "VCarousel",
    props: makeVCarouselProps(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { t } = (0, _localeMjs.useLocale)();
        const windowRef = (0, _vue.ref)();
        let slideTimeout = -1;
        (0, _vue.watch)(model, restartTimeout);
        (0, _vue.watch)(()=>props.interval, restartTimeout);
        (0, _vue.watch)(()=>props.cycle, (val)=>{
            if (val) restartTimeout();
            else window.clearTimeout(slideTimeout);
        });
        (0, _vue.onMounted)(startTimeout);
        function startTimeout() {
            if (!props.cycle || !windowRef.value) return;
            slideTimeout = window.setTimeout(windowRef.value.group.next, +props.interval > 0 ? +props.interval : 6000);
        }
        function restartTimeout() {
            window.clearTimeout(slideTimeout);
            window.requestAnimationFrame(startTimeout);
        }
        (0, _indexMjs3.useRender)(()=>{
            const [windowProps] = (0, _vwindowMjs.VWindow).filterProps(props);
            return (0, _vue.createVNode)((0, _vwindowMjs.VWindow), (0, _vue.mergeProps)({
                "ref": windowRef
            }, windowProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "class": [
                    "v-carousel",
                    {
                        "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
                        "v-carousel--vertical-delimiters": props.verticalDelimiters
                    },
                    props.class
                ],
                "style": [
                    {
                        height: (0, _indexMjs3.convertToUnit)(props.height)
                    },
                    props.style
                ]
            }), {
                default: slots.default,
                additional: (_ref2)=>{
                    let { group } = _ref2;
                    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        !props.hideDelimiters && (0, _vue.createVNode)("div", {
                            "class": "v-carousel__controls",
                            "style": {
                                left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
                                right: props.verticalDelimiters === "right" ? 0 : "auto"
                            }
                        }, [
                            group.items.value.length > 0 && (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                                "defaults": {
                                    VBtn: {
                                        color: props.color,
                                        icon: props.delimiterIcon,
                                        size: "x-small",
                                        variant: "text"
                                    }
                                },
                                "scoped": true
                            }, {
                                default: ()=>[
                                        group.items.value.map((item, index)=>{
                                            const props = {
                                                id: `carousel-item-${item.id}`,
                                                "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index + 1, group.items.value.length),
                                                class: [
                                                    group.isSelected(item.id) && "v-btn--active"
                                                ],
                                                onClick: ()=>group.select(item.id, true)
                                            };
                                            return slots.item ? slots.item({
                                                props,
                                                item
                                            }) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)(item, props), null);
                                        })
                                    ]
                            })
                        ]),
                        props.progress && (0, _vue.createVNode)((0, _indexMjs2.VProgressLinear), {
                            "class": "v-carousel__progress",
                            "color": typeof props.progress === "string" ? props.progress : undefined,
                            "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
                        }, null)
                    ]);
                },
                prev: slots.prev,
                next: slots.next
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VCarousel.css":"kagnJ","../VBtn/index.mjs":"7xV1x","../VDefaultsProvider/index.mjs":"1OIgj","../VProgressLinear/index.mjs":"g9djC","../VWindow/VWindow.mjs":"jFojd","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kagnJ":[function() {},{}],"jFojd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VWindowSymbol", ()=>VWindowSymbol);
parcelHelpers.export(exports, "VWindowGroupSymbol", ()=>VWindowGroupSymbol);
parcelHelpers.export(exports, "makeVWindowProps", ()=>makeVWindowProps);
parcelHelpers.export(exports, "VWindow", ()=>VWindow);
var _vue = require("vue");
// Styles
var _vwindowCss = require("./VWindow.css");
// Components
var _indexMjs = require("../VBtn/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Directives
var _indexMjs1 = require("../../directives/touch/index.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const VWindowSymbol = Symbol.for("vuetify:v-window");
const VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
const makeVWindowProps = (0, _indexMjs2.propsFactory)({
    continuous: Boolean,
    nextIcon: {
        type: [
            Boolean,
            String,
            Function,
            Object
        ],
        default: "$next"
    },
    prevIcon: {
        type: [
            Boolean,
            String,
            Function,
            Object
        ],
        default: "$prev"
    },
    reverse: Boolean,
    showArrows: {
        type: [
            Boolean,
            String
        ],
        validator: (v)=>typeof v === "boolean" || v === "hover"
    },
    touch: {
        type: [
            Object,
            Boolean
        ],
        default: undefined
    },
    direction: {
        type: String,
        default: "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
        type: String,
        default: "v-window-item--active"
    },
    // TODO: mandatory should probably not be exposed but do this for now
    mandatory: {
        type: [
            Boolean,
            String
        ],
        default: "force"
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VWindow");
const VWindow = (0, _indexMjs2.genericComponent)()({
    name: "VWindow",
    directives: {
        Touch: (0, _indexMjs1.Touch)
    },
    props: makeVWindowProps(),
    emits: {
        "update:modelValue": (v)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { isRtl } = (0, _localeMjs.useRtl)();
        const { t } = (0, _localeMjs.useLocale)();
        const group = (0, _groupMjs.useGroup)(props, VWindowGroupSymbol);
        const rootRef = (0, _vue.ref)();
        const isRtlReverse = (0, _vue.computed)(()=>isRtl.value ? !props.reverse : props.reverse);
        const isReversed = (0, _vue.shallowRef)(false);
        const transition = (0, _vue.computed)(()=>{
            const axis = props.direction === "vertical" ? "y" : "x";
            const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
            const direction = reverse ? "-reverse" : "";
            return `v-window-${axis}${direction}-transition`;
        });
        const transitionCount = (0, _vue.shallowRef)(0);
        const transitionHeight = (0, _vue.ref)(undefined);
        const activeIndex = (0, _vue.computed)(()=>{
            return group.items.value.findIndex((item)=>group.selected.value.includes(item.id));
        });
        (0, _vue.watch)(activeIndex, (newVal, oldVal)=>{
            const itemsLength = group.items.value.length;
            const lastIndex = itemsLength - 1;
            if (itemsLength <= 2) isReversed.value = newVal < oldVal;
            else if (newVal === lastIndex && oldVal === 0) isReversed.value = true;
            else if (newVal === 0 && oldVal === lastIndex) isReversed.value = false;
            else isReversed.value = newVal < oldVal;
        });
        (0, _vue.provide)(VWindowSymbol, {
            transition,
            isReversed,
            transitionCount,
            transitionHeight,
            rootRef
        });
        const canMoveBack = (0, _vue.computed)(()=>props.continuous || activeIndex.value !== 0);
        const canMoveForward = (0, _vue.computed)(()=>props.continuous || activeIndex.value !== group.items.value.length - 1);
        function prev() {
            canMoveBack.value && group.prev();
        }
        function next() {
            canMoveForward.value && group.next();
        }
        const arrows = (0, _vue.computed)(()=>{
            const arrows = [];
            const prevProps = {
                icon: isRtl.value ? props.nextIcon : props.prevIcon,
                class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
                onClick: group.prev,
                ariaLabel: t("$vuetify.carousel.prev")
            };
            arrows.push(canMoveBack.value ? slots.prev ? slots.prev({
                props: prevProps
            }) : (0, _vue.createVNode)((0, _indexMjs.VBtn), prevProps, null) : (0, _vue.createVNode)("div", null, null));
            const nextProps = {
                icon: isRtl.value ? props.prevIcon : props.nextIcon,
                class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
                onClick: group.next,
                ariaLabel: t("$vuetify.carousel.next")
            };
            arrows.push(canMoveForward.value ? slots.next ? slots.next({
                props: nextProps
            }) : (0, _vue.createVNode)((0, _indexMjs.VBtn), nextProps, null) : (0, _vue.createVNode)("div", null, null));
            return arrows;
        });
        const touchOptions = (0, _vue.computed)(()=>{
            if (props.touch === false) return props.touch;
            const options = {
                left: ()=>{
                    isRtlReverse.value ? prev() : next();
                },
                right: ()=>{
                    isRtlReverse.value ? next() : prev();
                },
                start: (_ref2)=>{
                    let { originalEvent } = _ref2;
                    originalEvent.stopPropagation();
                }
            };
            return {
                ...options,
                ...props.touch === true ? {} : props.touch
            };
        });
        (0, _indexMjs2.useRender)(()=>(0, _vue.withDirectives)((0, _vue.createVNode)(props.tag, {
                "ref": rootRef,
                "class": [
                    "v-window",
                    {
                        "v-window--show-arrows-on-hover": props.showArrows === "hover"
                    },
                    themeClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        (0, _vue.createVNode)("div", {
                            "class": "v-window__container",
                            "style": {
                                height: transitionHeight.value
                            }
                        }, [
                            slots.default?.({
                                group
                            }),
                            props.showArrows !== false && (0, _vue.createVNode)("div", {
                                "class": "v-window__controls"
                            }, [
                                arrows.value
                            ])
                        ]),
                        slots.additional?.({
                            group
                        })
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("touch"),
                    touchOptions.value
                ]
            ]));
        return {
            group
        };
    }
});

},{"vue":"ff77s","./VWindow.css":"672wJ","../VBtn/index.mjs":"7xV1x","../../composables/component.mjs":"jVHld","../../composables/group.mjs":"7LC6J","../../composables/locale.mjs":"4MZbL","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../directives/touch/index.mjs":"aIkdf","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"672wJ":[function() {},{}],"aIkdf":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Touch", ()=>Touch);
var _indexMjs = require("../../util/index.mjs"); // Types
const handleGesture = (wrapper)=>{
    const { touchstartX, touchendX, touchstartY, touchendY } = wrapper;
    const dirRatio = 0.5;
    const minDistance = 16;
    wrapper.offsetX = touchendX - touchstartX;
    wrapper.offsetY = touchendY - touchstartY;
    if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
        wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
        wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
    }
    if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
        wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
        wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
    }
};
function touchstart(event, wrapper) {
    const touch = event.changedTouches[0];
    wrapper.touchstartX = touch.clientX;
    wrapper.touchstartY = touch.clientY;
    wrapper.start?.({
        originalEvent: event,
        ...wrapper
    });
}
function touchend(event, wrapper) {
    const touch = event.changedTouches[0];
    wrapper.touchendX = touch.clientX;
    wrapper.touchendY = touch.clientY;
    wrapper.end?.({
        originalEvent: event,
        ...wrapper
    });
    handleGesture(wrapper);
}
function touchmove(event, wrapper) {
    const touch = event.changedTouches[0];
    wrapper.touchmoveX = touch.clientX;
    wrapper.touchmoveY = touch.clientY;
    wrapper.move?.({
        originalEvent: event,
        ...wrapper
    });
}
function createHandlers() {
    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const wrapper = {
        touchstartX: 0,
        touchstartY: 0,
        touchendX: 0,
        touchendY: 0,
        touchmoveX: 0,
        touchmoveY: 0,
        offsetX: 0,
        offsetY: 0,
        left: value.left,
        right: value.right,
        up: value.up,
        down: value.down,
        start: value.start,
        move: value.move,
        end: value.end
    };
    return {
        touchstart: (e)=>touchstart(e, wrapper),
        touchend: (e)=>touchend(e, wrapper),
        touchmove: (e)=>touchmove(e, wrapper)
    };
}
function mounted(el, binding) {
    const value = binding.value;
    const target = value?.parent ? el.parentElement : el;
    const options = value?.options ?? {
        passive: true
    };
    const uid = binding.instance?.$.uid; // TODO: use custom uid generator
    if (!target || !uid) return;
    const handlers = createHandlers(binding.value);
    target._touchHandlers = target._touchHandlers ?? Object.create(null);
    target._touchHandlers[uid] = handlers;
    (0, _indexMjs.keys)(handlers).forEach((eventName)=>{
        target.addEventListener(eventName, handlers[eventName], options);
    });
}
function unmounted(el, binding) {
    const target = binding.value?.parent ? el.parentElement : el;
    const uid = binding.instance?.$.uid;
    if (!target?._touchHandlers || !uid) return;
    const handlers = target._touchHandlers[uid];
    (0, _indexMjs.keys)(handlers).forEach((eventName)=>{
        target.removeEventListener(eventName, handlers[eventName]);
    });
    delete target._touchHandlers[uid];
}
const Touch = {
    mounted,
    unmounted
};
exports.default = Touch;

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7EtfD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVCarouselItemProps", ()=>makeVCarouselItemProps);
parcelHelpers.export(exports, "VCarouselItem", ()=>VCarouselItem);
var _vue = require("vue");
// Components
var _vimgMjs = require("../VImg/VImg.mjs");
var _vwindowItemMjs = require("../VWindow/VWindowItem.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVCarouselItemProps = (0, _indexMjs.propsFactory)({
    ...(0, _vimgMjs.makeVImgProps)(),
    ...(0, _vwindowItemMjs.makeVWindowItemProps)()
}, "VCarouselItem");
const VCarouselItem = (0, _indexMjs.genericComponent)()({
    name: "VCarouselItem",
    inheritAttrs: false,
    props: makeVCarouselItemProps(),
    setup (props, _ref) {
        let { slots, attrs } = _ref;
        (0, _indexMjs.useRender)(()=>{
            const [imgProps] = (0, _vimgMjs.VImg).filterProps(props);
            const [windowItemProps] = (0, _vwindowItemMjs.VWindowItem).filterProps(props);
            return (0, _vue.createVNode)((0, _vwindowItemMjs.VWindowItem), (0, _vue.mergeProps)({
                "class": "v-carousel-item"
            }, windowItemProps), {
                default: ()=>[
                        (0, _vue.createVNode)((0, _vimgMjs.VImg), (0, _vue.mergeProps)(attrs, imgProps), slots)
                    ]
            });
        });
    }
});

},{"vue":"ff77s","../VImg/VImg.mjs":"hdpTE","../VWindow/VWindowItem.mjs":"kFkAY","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kFkAY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVWindowItemProps", ()=>makeVWindowItemProps);
parcelHelpers.export(exports, "VWindowItem", ()=>VWindowItem);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _lazyMjs = require("../../composables/lazy.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Directives
var _indexMjs = require("../../directives/touch/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../util/index.mjs"); // Types
var _vwindowMjs = require("./VWindow.mjs");
const makeVWindowItemProps = (0, _indexMjs1.propsFactory)({
    reverseTransition: {
        type: [
            Boolean,
            String
        ],
        default: undefined
    },
    transition: {
        type: [
            Boolean,
            String
        ],
        default: undefined
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _groupMjs.makeGroupItemProps)(),
    ...(0, _lazyMjs.makeLazyProps)()
}, "VWindowItem");
const VWindowItem = (0, _indexMjs1.genericComponent)()({
    name: "VWindowItem",
    directives: {
        Touch: (0, _indexMjsDefault.default)
    },
    props: makeVWindowItemProps(),
    emits: {
        "group:selected": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const window = (0, _vue.inject)((0, _vwindowMjs.VWindowSymbol));
        const groupItem = (0, _groupMjs.useGroupItem)(props, (0, _vwindowMjs.VWindowGroupSymbol));
        const { isBooted } = (0, _ssrBootMjs.useSsrBoot)();
        if (!window || !groupItem) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
        const isTransitioning = (0, _vue.shallowRef)(false);
        const hasTransition = (0, _vue.computed)(()=>isBooted.value && (window.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
        function onAfterTransition() {
            if (!isTransitioning.value || !window) return;
            // Finalize transition state.
            isTransitioning.value = false;
            if (window.transitionCount.value > 0) {
                window.transitionCount.value -= 1;
                // Remove container height if we are out of transition.
                if (window.transitionCount.value === 0) window.transitionHeight.value = undefined;
            }
        }
        function onBeforeTransition() {
            if (isTransitioning.value || !window) return;
            // Initialize transition state here.
            isTransitioning.value = true;
            if (window.transitionCount.value === 0) // Set initial height for height transition.
            window.transitionHeight.value = (0, _indexMjs1.convertToUnit)(window.rootRef.value?.clientHeight);
            window.transitionCount.value += 1;
        }
        function onTransitionCancelled() {
            onAfterTransition(); // This should have the same path as normal transition end.
        }
        function onEnterTransition(el) {
            if (!isTransitioning.value) return;
            (0, _vue.nextTick)(()=>{
                // Do not set height if no transition or cancelled.
                if (!hasTransition.value || !isTransitioning.value || !window) return;
                // Set transition target height.
                window.transitionHeight.value = (0, _indexMjs1.convertToUnit)(el.clientHeight);
            });
        }
        const transition = (0, _vue.computed)(()=>{
            const name = window.isReversed.value ? props.reverseTransition : props.transition;
            return !hasTransition.value ? false : {
                name: typeof name !== "string" ? window.transition.value : name,
                onBeforeEnter: onBeforeTransition,
                onAfterEnter: onAfterTransition,
                onEnterCancelled: onTransitionCancelled,
                onBeforeLeave: onBeforeTransition,
                onAfterLeave: onAfterTransition,
                onLeaveCancelled: onTransitionCancelled,
                onEnter: onEnterTransition
            };
        });
        const { hasContent } = (0, _lazyMjs.useLazy)(props, groupItem.isSelected);
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                "transition": transition.value,
                "disabled": !isBooted.value
            }, {
                default: ()=>[
                        (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                            "class": [
                                "v-window-item",
                                groupItem.selectedClass.value,
                                props.class
                            ],
                            "style": props.style
                        }, [
                            hasContent.value && slots.default?.()
                        ]), [
                            [
                                (0, _vue.vShow),
                                groupItem.isSelected.value
                            ]
                        ])
                    ]
            }));
        return {
            groupItem
        };
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/group.mjs":"7LC6J","../../composables/lazy.mjs":"au1NJ","../../composables/ssrBoot.mjs":"b8ivf","../../composables/transition.mjs":"gFVfN","../../directives/touch/index.mjs":"aIkdf","../../util/index.mjs":"6uIWw","./VWindow.mjs":"jFojd","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8Mo8M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VChipGroup", ()=>(0, _vchipGroupMjs.VChipGroup));
var _vchipGroupMjs = require("./VChipGroup.mjs");

},{"./VChipGroup.mjs":"eBTRX","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8vejh":[function(require,module,exports) {
// Styles
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCode", ()=>VCode);
var _vcodeCss = require("./VCode.css");
// Utilities
var _indexMjs = require("../../util/index.mjs");
const VCode = (0, _indexMjs.createSimpleFunctional)("v-code");

},{"./VCode.css":"fiG7x","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fiG7x":[function() {},{}],"cxXRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VColorPicker", ()=>(0, _vcolorPickerMjs.VColorPicker));
var _vcolorPickerMjs = require("./VColorPicker.mjs");

},{"./VColorPicker.mjs":"3pW7g","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3pW7g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColorPickerProps", ()=>makeVColorPickerProps);
parcelHelpers.export(exports, "VColorPicker", ()=>VColorPicker);
var _vue = require("vue");
// Styles
var _vcolorPickerCss = require("./VColorPicker.css");
// Components
var _vcolorPickerCanvasMjs = require("./VColorPickerCanvas.mjs");
var _vcolorPickerEditMjs = require("./VColorPickerEdit.mjs");
var _vcolorPickerPreviewMjs = require("./VColorPickerPreview.mjs");
var _vcolorPickerSwatchesMjs = require("./VColorPickerSwatches.mjs");
var _vsheetMjs = require("../VSheet/VSheet.mjs"); // Composables
var _defaultsMjs = require("../../composables/defaults.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs = require("./util/index.mjs");
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVColorPickerProps = (0, _indexMjs1.propsFactory)({
    canvasHeight: {
        type: [
            String,
            Number
        ],
        default: 150
    },
    disabled: Boolean,
    dotSize: {
        type: [
            Number,
            String
        ],
        default: 10
    },
    hideCanvas: Boolean,
    hideSliders: Boolean,
    hideInputs: Boolean,
    mode: {
        type: String,
        default: "rgba",
        validator: (v)=>Object.keys((0, _indexMjs.modes)).includes(v)
    },
    modes: {
        type: Array,
        default: ()=>Object.keys((0, _indexMjs.modes)),
        validator: (v)=>Array.isArray(v) && v.every((m)=>Object.keys((0, _indexMjs.modes)).includes(m))
    },
    showSwatches: Boolean,
    swatches: Array,
    swatchesMaxHeight: {
        type: [
            Number,
            String
        ],
        default: 150
    },
    modelValue: {
        type: [
            Object,
            String
        ]
    },
    ...(0, _indexMjs1.omit)((0, _vsheetMjs.makeVSheetProps)({
        width: 300
    }), [
        "height",
        "location",
        "minHeight",
        "maxHeight",
        "minWidth",
        "maxWidth"
    ])
}, "VColorPicker");
const VColorPicker = (0, _indexMjs1.defineComponent)({
    name: "VColorPicker",
    props: makeVColorPickerProps(),
    emits: {
        "update:modelValue": (color)=>true,
        "update:mode": (mode)=>true
    },
    setup (props) {
        const mode = (0, _proxiedModelMjs.useProxiedModel)(props, "mode");
        const lastPickedColor = (0, _vue.ref)(null);
        const currentColor = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", undefined, (v)=>{
            if (v == null || v === "") return null;
            let c;
            try {
                c = (0, _indexMjs1.RGBtoHSV)((0, _indexMjs1.parseColor)(v));
            } catch (err) {
                (0, _indexMjs1.consoleWarn)(err);
                return null;
            }
            if (lastPickedColor.value) {
                c = {
                    ...c,
                    h: lastPickedColor.value.h
                };
                lastPickedColor.value = null;
            }
            return c;
        }, (v)=>{
            if (!v) return null;
            return (0, _indexMjs.extractColor)(v, props.modelValue);
        });
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        const updateColor = (hsva)=>{
            currentColor.value = hsva;
            lastPickedColor.value = hsva;
        };
        (0, _vue.onMounted)(()=>{
            if (!props.modes.includes(mode.value)) mode.value = props.modes[0];
        });
        (0, _defaultsMjs.provideDefaults)({
            VSlider: {
                color: undefined,
                trackColor: undefined,
                trackFillColor: undefined
            }
        });
        (0, _indexMjs1.useRender)(()=>{
            const [sheetProps] = (0, _vsheetMjs.VSheet).filterProps(props);
            return (0, _vue.createVNode)((0, _vsheetMjs.VSheet), (0, _vue.mergeProps)({
                "rounded": props.rounded,
                "elevation": props.elevation,
                "theme": props.theme,
                "class": [
                    "v-color-picker",
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    {
                        "--v-color-picker-color-hsv": (0, _indexMjs1.HSVtoCSS)({
                            ...currentColor.value ?? (0, _indexMjs.nullColor),
                            a: 1
                        })
                    },
                    props.style
                ]
            }, sheetProps, {
                "maxWidth": props.width
            }), {
                default: ()=>[
                        !props.hideCanvas && (0, _vue.createVNode)((0, _vcolorPickerCanvasMjs.VColorPickerCanvas), {
                            "key": "canvas",
                            "color": currentColor.value,
                            "onUpdate:color": updateColor,
                            "disabled": props.disabled,
                            "dotSize": props.dotSize,
                            "width": props.width,
                            "height": props.canvasHeight
                        }, null),
                        (!props.hideSliders || !props.hideInputs) && (0, _vue.createVNode)("div", {
                            "key": "controls",
                            "class": "v-color-picker__controls"
                        }, [
                            !props.hideSliders && (0, _vue.createVNode)((0, _vcolorPickerPreviewMjs.VColorPickerPreview), {
                                "key": "preview",
                                "color": currentColor.value,
                                "onUpdate:color": updateColor,
                                "hideAlpha": !mode.value.endsWith("a"),
                                "disabled": props.disabled
                            }, null),
                            !props.hideInputs && (0, _vue.createVNode)((0, _vcolorPickerEditMjs.VColorPickerEdit), {
                                "key": "edit",
                                "modes": props.modes,
                                "mode": mode.value,
                                "onUpdate:mode": (m)=>mode.value = m,
                                "color": currentColor.value,
                                "onUpdate:color": updateColor,
                                "disabled": props.disabled
                            }, null)
                        ]),
                        props.showSwatches && (0, _vue.createVNode)((0, _vcolorPickerSwatchesMjs.VColorPickerSwatches), {
                            "key": "swatches",
                            "color": currentColor.value,
                            "onUpdate:color": updateColor,
                            "maxHeight": props.swatchesMaxHeight,
                            "swatches": props.swatches,
                            "disabled": props.disabled
                        }, null)
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VColorPicker.css":"1ODBw","./VColorPickerCanvas.mjs":"3psEN","./VColorPickerEdit.mjs":"7yAXu","./VColorPickerPreview.mjs":"da76V","./VColorPickerSwatches.mjs":"eYDSi","../VSheet/VSheet.mjs":"5AMLv","../../composables/defaults.mjs":"11B6w","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","./util/index.mjs":"jp0T1","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1ODBw":[function() {},{}],"3psEN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColorPickerCanvasProps", ()=>makeVColorPickerCanvasProps);
parcelHelpers.export(exports, "VColorPickerCanvas", ()=>VColorPickerCanvas);
var _vue = require("vue");
// Styles
var _vcolorPickerCanvasCss = require("./VColorPickerCanvas.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVColorPickerCanvasProps = (0, _indexMjs.propsFactory)({
    color: {
        type: Object
    },
    disabled: Boolean,
    dotSize: {
        type: [
            Number,
            String
        ],
        default: 10
    },
    height: {
        type: [
            Number,
            String
        ],
        default: 150
    },
    width: {
        type: [
            Number,
            String
        ],
        default: 300
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VColorPickerCanvas");
const VColorPickerCanvas = (0, _indexMjs.defineComponent)({
    name: "VColorPickerCanvas",
    props: makeVColorPickerCanvasProps(),
    emits: {
        "update:color": (color)=>true,
        "update:position": (hue)=>true
    },
    setup (props, _ref) {
        let { emit } = _ref;
        const isInteracting = (0, _vue.shallowRef)(false);
        const canvasRef = (0, _vue.ref)();
        const canvasWidth = (0, _vue.shallowRef)(parseFloat(props.width));
        const canvasHeight = (0, _vue.shallowRef)(parseFloat(props.height));
        const _dotPosition = (0, _vue.ref)({
            x: 0,
            y: 0
        });
        const dotPosition = (0, _vue.computed)({
            get: ()=>_dotPosition.value,
            set (val) {
                if (!canvasRef.value) return;
                const { x, y } = val;
                emit("update:color", {
                    h: props.color?.h ?? 0,
                    s: (0, _indexMjs.clamp)(x, 0, canvasWidth.value) / canvasWidth.value,
                    v: 1 - (0, _indexMjs.clamp)(y, 0, canvasHeight.value) / canvasHeight.value,
                    a: props.color?.a ?? 1
                });
            }
        });
        const dotStyles = (0, _vue.computed)(()=>{
            const { x, y } = dotPosition.value;
            const radius = parseInt(props.dotSize, 10) / 2;
            return {
                width: (0, _indexMjs.convertToUnit)(props.dotSize),
                height: (0, _indexMjs.convertToUnit)(props.dotSize),
                transform: `translate(${(0, _indexMjs.convertToUnit)(x - radius)}, ${(0, _indexMjs.convertToUnit)(y - radius)})`
            };
        });
        const { resizeRef } = (0, _resizeObserverMjs.useResizeObserver)((entries)=>{
            if (!resizeRef.value?.offsetParent) return;
            const { width, height } = entries[0].contentRect;
            canvasWidth.value = width;
            canvasHeight.value = height;
        });
        function updateDotPosition(x, y, rect) {
            const { left, top, width, height } = rect;
            dotPosition.value = {
                x: (0, _indexMjs.clamp)(x - left, 0, width),
                y: (0, _indexMjs.clamp)(y - top, 0, height)
            };
        }
        function handleMouseDown(e) {
            if (e.type === "mousedown") // Prevent text selection while dragging
            e.preventDefault();
            if (props.disabled) return;
            handleMouseMove(e);
            window.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", handleMouseUp);
            window.addEventListener("touchmove", handleMouseMove);
            window.addEventListener("touchend", handleMouseUp);
        }
        function handleMouseMove(e) {
            if (props.disabled || !canvasRef.value) return;
            isInteracting.value = true;
            const coords = (0, _indexMjs.getEventCoordinates)(e);
            updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());
        }
        function handleMouseUp() {
            window.removeEventListener("mousemove", handleMouseMove);
            window.removeEventListener("mouseup", handleMouseUp);
            window.removeEventListener("touchmove", handleMouseMove);
            window.removeEventListener("touchend", handleMouseUp);
        }
        function updateCanvas() {
            if (!canvasRef.value) return;
            const canvas = canvasRef.value;
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            saturationGradient.addColorStop(0, "hsla(0, 0%, 100%, 1)"); // white
            saturationGradient.addColorStop(1, `hsla(${props.color?.h ?? 0}, 100%, 50%, 1)`);
            ctx.fillStyle = saturationGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            valueGradient.addColorStop(0, "hsla(0, 0%, 100%, 0)"); // transparent
            valueGradient.addColorStop(1, "hsla(0, 0%, 0%, 1)"); // black
            ctx.fillStyle = valueGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        (0, _vue.watch)(()=>props.color?.h, updateCanvas, {
            immediate: true
        });
        (0, _vue.watch)(()=>[
                canvasWidth.value,
                canvasHeight.value
            ], (newVal, oldVal)=>{
            updateCanvas();
            _dotPosition.value = {
                x: dotPosition.value.x * newVal[0] / oldVal[0],
                y: dotPosition.value.y * newVal[1] / oldVal[1]
            };
        }, {
            flush: "post"
        });
        (0, _vue.watch)(()=>props.color, ()=>{
            if (isInteracting.value) {
                isInteracting.value = false;
                return;
            }
            _dotPosition.value = props.color ? {
                x: props.color.s * canvasWidth.value,
                y: (1 - props.color.v) * canvasHeight.value
            } : {
                x: 0,
                y: 0
            };
        }, {
            deep: true,
            immediate: true
        });
        (0, _vue.onMounted)(()=>updateCanvas());
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "ref": resizeRef,
                "class": [
                    "v-color-picker-canvas",
                    props.class
                ],
                "style": props.style,
                "onMousedown": handleMouseDown,
                "onTouchstartPassive": handleMouseDown
            }, [
                (0, _vue.createVNode)("canvas", {
                    "ref": canvasRef,
                    "width": canvasWidth.value,
                    "height": canvasHeight.value
                }, null),
                props.color && (0, _vue.createVNode)("div", {
                    "class": [
                        "v-color-picker-canvas__dot",
                        {
                            "v-color-picker-canvas__dot--disabled": props.disabled
                        }
                    ],
                    "style": dotStyles.value
                }, null)
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VColorPickerCanvas.css":"7q3Yg","../../composables/component.mjs":"jVHld","../../composables/resizeObserver.mjs":"byLTu","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7q3Yg":[function() {},{}],"7yAXu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColorPickerEditProps", ()=>makeVColorPickerEditProps);
parcelHelpers.export(exports, "VColorPickerEdit", ()=>VColorPickerEdit);
var _vue = require("vue");
// Styles
var _vcolorPickerEditCss = require("./VColorPickerEdit.css");
// Components
var _indexMjs = require("../VBtn/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs"); // Utilities
var _indexMjs1 = require("./util/index.mjs");
var _indexMjs2 = require("../../util/index.mjs"); // Types
const VColorPickerInput = (_ref)=>{
    let { label, ...rest } = _ref;
    return (0, _vue.createVNode)("div", {
        "class": "v-color-picker-edit__input"
    }, [
        (0, _vue.createVNode)("input", rest, null),
        (0, _vue.createVNode)("span", null, [
            label
        ])
    ]);
};
const makeVColorPickerEditProps = (0, _indexMjs2.propsFactory)({
    color: Object,
    disabled: Boolean,
    mode: {
        type: String,
        default: "rgba",
        validator: (v)=>Object.keys((0, _indexMjs1.modes)).includes(v)
    },
    modes: {
        type: Array,
        default: ()=>Object.keys((0, _indexMjs1.modes)),
        validator: (v)=>Array.isArray(v) && v.every((m)=>Object.keys((0, _indexMjs1.modes)).includes(m))
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VColorPickerEdit");
const VColorPickerEdit = (0, _indexMjs2.defineComponent)({
    name: "VColorPickerEdit",
    props: makeVColorPickerEditProps(),
    emits: {
        "update:color": (color)=>true,
        "update:mode": (mode)=>true
    },
    setup (props, _ref2) {
        let { emit } = _ref2;
        const enabledModes = (0, _vue.computed)(()=>{
            return props.modes.map((key)=>({
                    ...(0, _indexMjs1.modes)[key],
                    name: key
                }));
        });
        const inputs = (0, _vue.computed)(()=>{
            const mode = enabledModes.value.find((m)=>m.name === props.mode);
            if (!mode) return [];
            const color = props.color ? mode.to(props.color) : null;
            return mode.inputs?.map((_ref3)=>{
                let { getValue, getColor, ...inputProps } = _ref3;
                return {
                    ...mode.inputProps,
                    ...inputProps,
                    disabled: props.disabled,
                    value: color && getValue(color),
                    onChange: (e)=>{
                        const target = e.target;
                        if (!target) return;
                        emit("update:color", mode.from(getColor(color ?? (0, _indexMjs1.nullColor), target.value)));
                    }
                };
            });
        });
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-color-picker-edit",
                    props.class
                ],
                "style": props.style
            }, [
                inputs.value?.map((props)=>(0, _vue.createVNode)(VColorPickerInput, props, null)),
                enabledModes.value.length > 1 && (0, _vue.createVNode)((0, _indexMjs.VBtn), {
                    "icon": "$unfold",
                    "size": "x-small",
                    "variant": "plain",
                    "onClick": ()=>{
                        const mi = enabledModes.value.findIndex((m)=>m.name === props.mode);
                        emit("update:mode", enabledModes.value[(mi + 1) % enabledModes.value.length].name);
                    }
                }, null)
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VColorPickerEdit.css":"fbGhq","../VBtn/index.mjs":"7xV1x","../../composables/component.mjs":"jVHld","./util/index.mjs":"jp0T1","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fbGhq":[function() {},{}],"jp0T1":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractColor", ()=>extractColor);
parcelHelpers.export(exports, "hasAlpha", ()=>hasAlpha);
parcelHelpers.export(exports, "nullColor", ()=>nullColor);
parcelHelpers.export(exports, "modes", ()=>modes);
var _colorUtilsMjs = require("../../../util/colorUtils.mjs");
var _helpersMjs = require("../../../util/helpers.mjs"); // Types
function stripAlpha(color, stripAlpha) {
    if (stripAlpha) {
        const { a, ...rest } = color;
        return rest;
    }
    return color;
}
function extractColor(color, input) {
    if (input == null || typeof input === "string") {
        const hex = (0, _colorUtilsMjs.HSVtoHex)(color);
        if (color.a === 1) return hex.slice(0, 7);
        else return hex;
    }
    if (typeof input === "object") {
        let converted;
        if ((0, _helpersMjs.has)(input, [
            "r",
            "g",
            "b"
        ])) converted = (0, _colorUtilsMjs.HSVtoRGB)(color);
        else if ((0, _helpersMjs.has)(input, [
            "h",
            "s",
            "l"
        ])) converted = (0, _colorUtilsMjs.HSVtoHSL)(color);
        else if ((0, _helpersMjs.has)(input, [
            "h",
            "s",
            "v"
        ])) converted = color;
        return stripAlpha(converted, !(0, _helpersMjs.has)(input, [
            "a"
        ]) && color.a === 1);
    }
    return color;
}
function hasAlpha(color) {
    if (!color) return false;
    if (typeof color === "string") return color.length > 7;
    if (typeof color === "object") return (0, _helpersMjs.has)(color, [
        "a"
    ]) || (0, _helpersMjs.has)(color, [
        "alpha"
    ]);
    return false;
}
const nullColor = {
    h: 0,
    s: 0,
    v: 1,
    a: 1
};
const rgba = {
    inputProps: {
        type: "number",
        min: 0
    },
    inputs: [
        {
            label: "R",
            max: 255,
            step: 1,
            getValue: (c)=>Math.round(c.r),
            getColor: (c, v)=>({
                    ...c,
                    r: Number(v)
                })
        },
        {
            label: "G",
            max: 255,
            step: 1,
            getValue: (c)=>Math.round(c.g),
            getColor: (c, v)=>({
                    ...c,
                    g: Number(v)
                })
        },
        {
            label: "B",
            max: 255,
            step: 1,
            getValue: (c)=>Math.round(c.b),
            getColor: (c, v)=>({
                    ...c,
                    b: Number(v)
                })
        },
        {
            label: "A",
            max: 1,
            step: 0.01,
            getValue: (_ref)=>{
                let { a } = _ref;
                return a != null ? Math.round(a * 100) / 100 : 1;
            },
            getColor: (c, v)=>({
                    ...c,
                    a: Number(v)
                })
        }
    ],
    to: (0, _colorUtilsMjs.HSVtoRGB),
    from: (0, _colorUtilsMjs.RGBtoHSV)
};
const rgb = {
    ...rgba,
    inputs: rgba.inputs?.slice(0, 3)
};
const hsla = {
    inputProps: {
        type: "number",
        min: 0
    },
    inputs: [
        {
            label: "H",
            max: 360,
            step: 1,
            getValue: (c)=>Math.round(c.h),
            getColor: (c, v)=>({
                    ...c,
                    h: Number(v)
                })
        },
        {
            label: "S",
            max: 1,
            step: 0.01,
            getValue: (c)=>Math.round(c.s * 100) / 100,
            getColor: (c, v)=>({
                    ...c,
                    s: Number(v)
                })
        },
        {
            label: "L",
            max: 1,
            step: 0.01,
            getValue: (c)=>Math.round(c.l * 100) / 100,
            getColor: (c, v)=>({
                    ...c,
                    l: Number(v)
                })
        },
        {
            label: "A",
            max: 1,
            step: 0.01,
            getValue: (_ref2)=>{
                let { a } = _ref2;
                return a != null ? Math.round(a * 100) / 100 : 1;
            },
            getColor: (c, v)=>({
                    ...c,
                    a: Number(v)
                })
        }
    ],
    to: (0, _colorUtilsMjs.HSVtoHSL),
    from: (0, _colorUtilsMjs.HSLtoHSV)
};
const hsl = {
    ...hsla,
    inputs: hsla.inputs.slice(0, 3)
};
const hexa = {
    inputProps: {
        type: "text"
    },
    inputs: [
        {
            label: "HEXA",
            getValue: (c)=>c,
            getColor: (c, v)=>v
        }
    ],
    to: (0, _colorUtilsMjs.HSVtoHex),
    from: (0, _colorUtilsMjs.HexToHSV)
};
const hex = {
    ...hexa,
    inputs: [
        {
            label: "HEX",
            getValue: (c)=>c.slice(0, 7),
            getColor: (c, v)=>v
        }
    ]
};
const modes = {
    rgb,
    rgba,
    hsl,
    hsla,
    hex,
    hexa
};

},{"../../../util/colorUtils.mjs":"7U9Hi","../../../util/helpers.mjs":"fcCSo","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"da76V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColorPickerPreviewProps", ()=>makeVColorPickerPreviewProps);
parcelHelpers.export(exports, "VColorPickerPreview", ()=>VColorPickerPreview);
var _vue = require("vue");
// Styles
var _vcolorPickerPreviewCss = require("./VColorPickerPreview.css");
// Components
var _indexMjs = require("../VSlider/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs"); // Utilities
var _indexMjs1 = require("./util/index.mjs");
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVColorPickerPreviewProps = (0, _indexMjs2.propsFactory)({
    color: {
        type: Object
    },
    disabled: Boolean,
    hideAlpha: Boolean,
    ...(0, _componentMjs.makeComponentProps)()
}, "VColorPickerPreview");
const VColorPickerPreview = (0, _indexMjs2.defineComponent)({
    name: "VColorPickerPreview",
    props: makeVColorPickerPreviewProps(),
    emits: {
        "update:color": (color)=>true
    },
    setup (props, _ref) {
        let { emit } = _ref;
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-color-picker-preview",
                    {
                        "v-color-picker-preview--hide-alpha": props.hideAlpha
                    },
                    props.class
                ],
                "style": props.style
            }, [
                (0, _vue.createVNode)("div", {
                    "class": "v-color-picker-preview__dot"
                }, [
                    (0, _vue.createVNode)("div", {
                        "style": {
                            background: (0, _indexMjs2.HSVtoCSS)(props.color ?? (0, _indexMjs1.nullColor))
                        }
                    }, null)
                ]),
                (0, _vue.createVNode)("div", {
                    "class": "v-color-picker-preview__sliders"
                }, [
                    (0, _vue.createVNode)((0, _indexMjs.VSlider), {
                        "class": "v-color-picker-preview__track v-color-picker-preview__hue",
                        "modelValue": props.color?.h,
                        "onUpdate:modelValue": (h)=>emit("update:color", {
                                ...props.color ?? (0, _indexMjs1.nullColor),
                                h
                            }),
                        "step": 0,
                        "min": 0,
                        "max": 360,
                        "disabled": props.disabled,
                        "thumbSize": 14,
                        "trackSize": 8,
                        "trackFillColor": "white",
                        "hideDetails": true
                    }, null),
                    !props.hideAlpha && (0, _vue.createVNode)((0, _indexMjs.VSlider), {
                        "class": "v-color-picker-preview__track v-color-picker-preview__alpha",
                        "modelValue": props.color?.a ?? 1,
                        "onUpdate:modelValue": (a)=>emit("update:color", {
                                ...props.color ?? (0, _indexMjs1.nullColor),
                                a
                            }),
                        "step": 1 / 256,
                        "min": 0,
                        "max": 1,
                        "disabled": props.disabled,
                        "thumbSize": 14,
                        "trackSize": 8,
                        "trackFillColor": "white",
                        "hideDetails": true
                    }, null)
                ])
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VColorPickerPreview.css":"iMMju","../VSlider/index.mjs":"bQcEZ","../../composables/component.mjs":"jVHld","./util/index.mjs":"jp0T1","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"iMMju":[function() {},{}],"bQcEZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSlider", ()=>(0, _vsliderMjs.VSlider));
var _vsliderMjs = require("./VSlider.mjs");

},{"./VSlider.mjs":"kzleD","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kzleD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSliderProps", ()=>makeVSliderProps);
parcelHelpers.export(exports, "VSlider", ()=>VSlider);
var _vue = require("vue");
// Styles
var _vsliderCss = require("./VSlider.css");
// Components
var _vsliderThumbMjs = require("./VSliderThumb.mjs");
var _vsliderTrackMjs = require("./VSliderTrack.mjs");
var _vinputMjs = require("../VInput/VInput.mjs");
var _indexMjs = require("../VLabel/index.mjs"); // Composables
var _sliderMjs = require("./slider.mjs");
var _focusMjs = require("../../composables/focus.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVSliderProps = (0, _indexMjs1.propsFactory)({
    ...(0, _focusMjs.makeFocusProps)(),
    ...(0, _sliderMjs.makeSliderProps)(),
    ...(0, _vinputMjs.makeVInputProps)(),
    modelValue: {
        type: [
            Number,
            String
        ],
        default: 0
    }
}, "VSlider");
const VSlider = (0, _indexMjs1.genericComponent)()({
    name: "VSlider",
    props: makeVSliderProps(),
    emits: {
        "update:focused": (value)=>true,
        "update:modelValue": (v)=>true,
        start: (value)=>true,
        end: (value)=>true
    },
    setup (props, _ref) {
        let { slots, emit } = _ref;
        const thumbContainerRef = (0, _vue.ref)();
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        const steps = (0, _sliderMjs.useSteps)(props);
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", undefined, (value)=>{
            return steps.roundValue(value == null ? steps.min.value : value);
        });
        const { min, max, mousePressed, roundValue, onSliderMousedown, onSliderTouchstart, trackContainerRef, position, hasLabels, readonly } = (0, _sliderMjs.useSlider)({
            props,
            steps,
            onSliderStart: ()=>{
                emit("start", model.value);
            },
            onSliderEnd: (_ref2)=>{
                let { value } = _ref2;
                const roundedValue = roundValue(value);
                model.value = roundedValue;
                emit("end", roundedValue);
            },
            onSliderMove: (_ref3)=>{
                let { value } = _ref3;
                return model.value = roundValue(value);
            },
            getActiveThumb: ()=>thumbContainerRef.value?.$el
        });
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const trackStop = (0, _vue.computed)(()=>position(model.value));
        (0, _indexMjs1.useRender)(()=>{
            const [inputProps, _] = (0, _vinputMjs.VInput).filterProps(props);
            const hasPrepend = !!(props.label || slots.label || slots.prepend);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "class": [
                    "v-slider",
                    {
                        "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
                        "v-slider--focused": isFocused.value,
                        "v-slider--pressed": mousePressed.value,
                        "v-slider--disabled": props.disabled
                    },
                    rtlClasses.value,
                    props.class
                ],
                "style": props.style
            }, inputProps, {
                "focused": isFocused.value
            }), {
                ...slots,
                prepend: hasPrepend ? (slotProps)=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots.label?.(slotProps) ?? props.label ? (0, _vue.createVNode)((0, _indexMjs.VLabel), {
                            "id": slotProps.id.value,
                            "class": "v-slider__label",
                            "text": props.label
                        }, null) : undefined,
                        slots.prepend?.(slotProps)
                    ]) : undefined,
                default: (_ref4)=>{
                    let { id, messagesId } = _ref4;
                    return (0, _vue.createVNode)("div", {
                        "class": "v-slider__container",
                        "onMousedown": !readonly.value ? onSliderMousedown : undefined,
                        "onTouchstartPassive": !readonly.value ? onSliderTouchstart : undefined
                    }, [
                        (0, _vue.createVNode)("input", {
                            "id": id.value,
                            "name": props.name || id.value,
                            "disabled": !!props.disabled,
                            "readonly": !!props.readonly,
                            "tabindex": "-1",
                            "value": model.value
                        }, null),
                        (0, _vue.createVNode)((0, _vsliderTrackMjs.VSliderTrack), {
                            "ref": trackContainerRef,
                            "start": 0,
                            "stop": trackStop.value
                        }, {
                            "tick-label": slots["tick-label"]
                        }),
                        (0, _vue.createVNode)((0, _vsliderThumbMjs.VSliderThumb), {
                            "ref": thumbContainerRef,
                            "aria-describedby": messagesId.value,
                            "focused": isFocused.value,
                            "min": min.value,
                            "max": max.value,
                            "modelValue": model.value,
                            "onUpdate:modelValue": (v)=>model.value = v,
                            "position": trackStop.value,
                            "elevation": props.elevation,
                            "onFocus": focus,
                            "onBlur": blur
                        }, {
                            "thumb-label": slots["thumb-label"]
                        })
                    ]);
                }
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VSlider.css":"dkVqj","./VSliderThumb.mjs":"ilHYH","./VSliderTrack.mjs":"eZdmp","../VInput/VInput.mjs":"1hyGZ","../VLabel/index.mjs":"cclAn","./slider.mjs":"6FCha","../../composables/focus.mjs":"1bQxY","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dkVqj":[function() {},{}],"ilHYH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSliderThumbProps", ()=>makeVSliderThumbProps);
parcelHelpers.export(exports, "VSliderThumb", ()=>VSliderThumb);
var _vue = require("vue");
// Styles
var _vsliderThumbCss = require("./VSliderThumb.css");
// Components
var _sliderMjs = require("./slider.mjs");
var _indexMjs = require("../transitions/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _localeMjs = require("../../composables/locale.mjs"); // Directives
var _indexMjs1 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVSliderThumbProps = (0, _indexMjs2.propsFactory)({
    focused: Boolean,
    max: {
        type: Number,
        required: true
    },
    min: {
        type: Number,
        required: true
    },
    modelValue: {
        type: Number,
        required: true
    },
    position: {
        type: Number,
        required: true
    },
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: true
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VSliderThumb");
const VSliderThumb = (0, _indexMjs2.genericComponent)()({
    name: "VSliderThumb",
    directives: {
        Ripple: (0, _indexMjsDefault.default)
    },
    props: makeVSliderThumbProps(),
    emits: {
        "update:modelValue": (v)=>true
    },
    setup (props, _ref) {
        let { slots, emit } = _ref;
        const slider = (0, _vue.inject)((0, _sliderMjs.VSliderSymbol));
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        if (!slider) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
        const { thumbColor, step, vertical, disabled, thumbSize, thumbLabel, direction, readonly, elevation, isReversed, horizontalDirection, mousePressed, decimals } = slider;
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)(thumbColor);
        const { pageup, pagedown, end, home, left, right, down, up } = (0, _indexMjs2.keyValues);
        const relevantKeys = [
            pageup,
            pagedown,
            end,
            home,
            left,
            right,
            down,
            up
        ];
        const multipliers = (0, _vue.computed)(()=>{
            if (step.value) return [
                1,
                2,
                3
            ];
            else return [
                1,
                5,
                10
            ];
        });
        function parseKeydown(e, value) {
            if (!relevantKeys.includes(e.key)) return;
            e.preventDefault();
            const _step = step.value || 0.1;
            const steps = (props.max - props.min) / _step;
            if ([
                left,
                right,
                down,
                up
            ].includes(e.key)) {
                const increase = horizontalDirection.value === "rtl" ? [
                    left,
                    up
                ] : [
                    right,
                    up
                ];
                const direction = increase.includes(e.key) ? 1 : -1;
                const multiplier = e.shiftKey ? 2 : e.ctrlKey ? 1 : 0;
                value = value + direction * _step * multipliers.value[multiplier];
            } else if (e.key === home) value = props.min;
            else if (e.key === end) value = props.max;
            else {
                const direction = e.key === pagedown ? 1 : -1;
                value = value - direction * _step * (steps > 100 ? steps / 10 : 10);
            }
            return Math.max(props.min, Math.min(props.max, value));
        }
        function onKeydown(e) {
            const newValue = parseKeydown(e, props.modelValue);
            newValue != null && emit("update:modelValue", newValue);
        }
        (0, _indexMjs2.useRender)(()=>{
            const positionPercentage = (0, _indexMjs2.convertToUnit)(vertical.value || isReversed.value ? 100 - props.position : props.position, "%");
            const { elevationClasses } = (0, _elevationMjs.useElevation)((0, _vue.computed)(()=>!disabled.value ? elevation.value : undefined));
            return (0, _vue.createVNode)("div", {
                "class": [
                    "v-slider-thumb",
                    {
                        "v-slider-thumb--focused": props.focused,
                        "v-slider-thumb--pressed": props.focused && mousePressed.value
                    },
                    props.class,
                    rtlClasses.value
                ],
                "style": [
                    {
                        "--v-slider-thumb-position": positionPercentage,
                        "--v-slider-thumb-size": (0, _indexMjs2.convertToUnit)(thumbSize.value)
                    },
                    props.style
                ],
                "role": "slider",
                "tabindex": disabled.value ? -1 : 0,
                "aria-valuemin": props.min,
                "aria-valuemax": props.max,
                "aria-valuenow": props.modelValue,
                "aria-readonly": !!readonly.value,
                "aria-orientation": direction.value,
                "onKeydown": !readonly.value ? onKeydown : undefined
            }, [
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-slider-thumb__surface",
                        textColorClasses.value,
                        elevationClasses.value
                    ],
                    "style": {
                        ...textColorStyles.value
                    }
                }, null),
                (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                    "class": [
                        "v-slider-thumb__ripple",
                        textColorClasses.value
                    ],
                    "style": textColorStyles.value
                }, null), [
                    [
                        (0, _vue.resolveDirective)("ripple"),
                        props.ripple,
                        null,
                        {
                            circle: true,
                            center: true
                        }
                    ]
                ]),
                (0, _vue.createVNode)((0, _indexMjs.VScaleTransition), {
                    "origin": "bottom center"
                }, {
                    default: ()=>[
                            (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                                "class": "v-slider-thumb__label-container"
                            }, [
                                (0, _vue.createVNode)("div", {
                                    "class": [
                                        "v-slider-thumb__label"
                                    ]
                                }, [
                                    (0, _vue.createVNode)("div", null, [
                                        slots["thumb-label"]?.({
                                            modelValue: props.modelValue
                                        }) ?? props.modelValue.toFixed(step.value ? decimals.value : 1)
                                    ])
                                ])
                            ]), [
                                [
                                    (0, _vue.vShow),
                                    thumbLabel.value && props.focused || thumbLabel.value === "always"
                                ]
                            ])
                        ]
                })
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VSliderThumb.css":"1Ox1x","./slider.mjs":"6FCha","../transitions/index.mjs":"oiH7Z","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/elevation.mjs":"3BDEa","../../composables/locale.mjs":"4MZbL","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1Ox1x":[function() {},{}],"6FCha":[function(require,module,exports) {
/* eslint-disable max-statements */ // Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSliderSymbol", ()=>VSliderSymbol);
parcelHelpers.export(exports, "getOffset", ()=>getOffset);
parcelHelpers.export(exports, "makeSliderProps", ()=>makeSliderProps);
parcelHelpers.export(exports, "useSteps", ()=>useSteps);
parcelHelpers.export(exports, "useSlider", ()=>useSlider);
var _elevationMjs = require("../../composables/elevation.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _roundedMjs = require("../../composables/rounded.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const VSliderSymbol = Symbol.for("vuetify:v-slider");
function getOffset(e, el, direction) {
    const vertical = direction === "vertical";
    const rect = el.getBoundingClientRect();
    const touch = "touches" in e ? e.touches[0] : e;
    return vertical ? touch.clientY - (rect.top + rect.height / 2) : touch.clientX - (rect.left + rect.width / 2);
}
function getPosition(e, position) {
    if ("touches" in e && e.touches.length) return e.touches[0][position];
    else if ("changedTouches" in e && e.changedTouches.length) return e.changedTouches[0][position];
    else return e[position];
}
const makeSliderProps = (0, _indexMjs.propsFactory)({
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    readonly: {
        type: Boolean,
        default: null
    },
    max: {
        type: [
            Number,
            String
        ],
        default: 100
    },
    min: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    step: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    thumbColor: String,
    thumbLabel: {
        type: [
            Boolean,
            String
        ],
        default: undefined,
        validator: (v)=>typeof v === "boolean" || v === "always"
    },
    thumbSize: {
        type: [
            Number,
            String
        ],
        default: 20
    },
    showTicks: {
        type: [
            Boolean,
            String
        ],
        default: false,
        validator: (v)=>typeof v === "boolean" || v === "always"
    },
    ticks: {
        type: [
            Array,
            Object
        ]
    },
    tickSize: {
        type: [
            Number,
            String
        ],
        default: 2
    },
    color: String,
    trackColor: String,
    trackFillColor: String,
    trackSize: {
        type: [
            Number,
            String
        ],
        default: 4
    },
    direction: {
        type: String,
        default: "horizontal",
        validator: (v)=>[
                "vertical",
                "horizontal"
            ].includes(v)
    },
    reverse: Boolean,
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _elevationMjs.makeElevationProps)({
        elevation: 2
    })
}, "Slider");
const useSteps = (props)=>{
    const min = (0, _vue.computed)(()=>parseFloat(props.min));
    const max = (0, _vue.computed)(()=>parseFloat(props.max));
    const step = (0, _vue.computed)(()=>+props.step > 0 ? parseFloat(props.step) : 0);
    const decimals = (0, _vue.computed)(()=>Math.max((0, _indexMjs.getDecimals)(step.value), (0, _indexMjs.getDecimals)(min.value)));
    function roundValue(value) {
        value = parseFloat(value);
        if (step.value <= 0) return value;
        const clamped = (0, _indexMjs.clamp)(value, min.value, max.value);
        const offset = min.value % step.value;
        const newValue = Math.round((clamped - offset) / step.value) * step.value + offset;
        return parseFloat(Math.min(newValue, max.value).toFixed(decimals.value));
    }
    return {
        min,
        max,
        step,
        decimals,
        roundValue
    };
};
const useSlider = (_ref)=>{
    let { props, steps, onSliderStart, onSliderMove, onSliderEnd, getActiveThumb } = _ref;
    const { isRtl } = (0, _localeMjs.useRtl)();
    const isReversed = (0, _vue.toRef)(props, "reverse");
    const horizontalDirection = (0, _vue.computed)(()=>{
        let hd = isRtl.value ? "rtl" : "ltr";
        if (props.reverse) hd = hd === "rtl" ? "ltr" : "rtl";
        return hd;
    });
    const { min, max, step, decimals, roundValue } = steps;
    const thumbSize = (0, _vue.computed)(()=>parseInt(props.thumbSize, 10));
    const tickSize = (0, _vue.computed)(()=>parseInt(props.tickSize, 10));
    const trackSize = (0, _vue.computed)(()=>parseInt(props.trackSize, 10));
    const numTicks = (0, _vue.computed)(()=>(max.value - min.value) / step.value);
    const disabled = (0, _vue.toRef)(props, "disabled");
    const vertical = (0, _vue.computed)(()=>props.direction === "vertical");
    const thumbColor = (0, _vue.computed)(()=>props.error || props.disabled ? undefined : props.thumbColor ?? props.color);
    const trackColor = (0, _vue.computed)(()=>props.error || props.disabled ? undefined : props.trackColor ?? props.color);
    const trackFillColor = (0, _vue.computed)(()=>props.error || props.disabled ? undefined : props.trackFillColor ?? props.color);
    const mousePressed = (0, _vue.shallowRef)(false);
    const startOffset = (0, _vue.shallowRef)(0);
    const trackContainerRef = (0, _vue.ref)();
    const activeThumbRef = (0, _vue.ref)();
    function parseMouseMove(e) {
        const vertical = props.direction === "vertical";
        const start = vertical ? "top" : "left";
        const length = vertical ? "height" : "width";
        const position = vertical ? "clientY" : "clientX";
        const { [start]: trackStart, [length]: trackLength } = trackContainerRef.value?.$el.getBoundingClientRect();
        const clickOffset = getPosition(e, position);
        // It is possible for left to be NaN, force to number
        let clickPos = Math.min(Math.max((clickOffset - trackStart - startOffset.value) / trackLength, 0), 1) || 0;
        if (vertical || horizontalDirection.value === "rtl") clickPos = 1 - clickPos;
        return roundValue(min.value + clickPos * (max.value - min.value));
    }
    const handleStop = (e)=>{
        onSliderEnd({
            value: parseMouseMove(e)
        });
        mousePressed.value = false;
        startOffset.value = 0;
    };
    const handleStart = (e)=>{
        activeThumbRef.value = getActiveThumb(e);
        if (!activeThumbRef.value) return;
        activeThumbRef.value.focus();
        mousePressed.value = true;
        if (activeThumbRef.value.contains(e.target)) startOffset.value = getOffset(e, activeThumbRef.value, props.direction);
        else {
            startOffset.value = 0;
            onSliderMove({
                value: parseMouseMove(e)
            });
        }
        onSliderStart({
            value: parseMouseMove(e)
        });
    };
    const moveListenerOptions = {
        passive: true,
        capture: true
    };
    function onMouseMove(e) {
        onSliderMove({
            value: parseMouseMove(e)
        });
    }
    function onSliderMouseUp(e) {
        e.stopPropagation();
        e.preventDefault();
        handleStop(e);
        window.removeEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.removeEventListener("mouseup", onSliderMouseUp);
    }
    function onSliderTouchend(e) {
        handleStop(e);
        window.removeEventListener("touchmove", onMouseMove, moveListenerOptions);
        e.target?.removeEventListener("touchend", onSliderTouchend);
    }
    function onSliderTouchstart(e) {
        handleStart(e);
        window.addEventListener("touchmove", onMouseMove, moveListenerOptions);
        e.target?.addEventListener("touchend", onSliderTouchend, {
            passive: false
        });
    }
    function onSliderMousedown(e) {
        e.preventDefault();
        handleStart(e);
        window.addEventListener("mousemove", onMouseMove, moveListenerOptions);
        window.addEventListener("mouseup", onSliderMouseUp, {
            passive: false
        });
    }
    const position = (val)=>{
        const percentage = (val - min.value) / (max.value - min.value) * 100;
        return (0, _indexMjs.clamp)(isNaN(percentage) ? 0 : percentage, 0, 100);
    };
    const showTicks = (0, _vue.toRef)(props, "showTicks");
    const parsedTicks = (0, _vue.computed)(()=>{
        if (!showTicks.value) return [];
        if (!props.ticks) return numTicks.value !== Infinity ? (0, _indexMjs.createRange)(numTicks.value + 1).map((t)=>{
            const value = min.value + t * step.value;
            return {
                value,
                position: position(value)
            };
        }) : [];
        if (Array.isArray(props.ticks)) return props.ticks.map((t)=>({
                value: t,
                position: position(t),
                label: t.toString()
            }));
        return Object.keys(props.ticks).map((key)=>({
                value: parseFloat(key),
                position: position(parseFloat(key)),
                label: props.ticks[key]
            }));
    });
    const hasLabels = (0, _vue.computed)(()=>parsedTicks.value.some((_ref2)=>{
            let { label } = _ref2;
            return !!label;
        }));
    const data = {
        activeThumbRef,
        color: (0, _vue.toRef)(props, "color"),
        decimals,
        disabled,
        direction: (0, _vue.toRef)(props, "direction"),
        elevation: (0, _vue.toRef)(props, "elevation"),
        hasLabels,
        horizontalDirection,
        isReversed,
        min,
        max,
        mousePressed,
        numTicks,
        onSliderMousedown,
        onSliderTouchstart,
        parsedTicks,
        parseMouseMove,
        position,
        readonly: (0, _vue.toRef)(props, "readonly"),
        rounded: (0, _vue.toRef)(props, "rounded"),
        roundValue,
        showTicks,
        startOffset,
        step,
        thumbSize,
        thumbColor,
        thumbLabel: (0, _vue.toRef)(props, "thumbLabel"),
        ticks: (0, _vue.toRef)(props, "ticks"),
        tickSize,
        trackColor,
        trackContainerRef,
        trackFillColor,
        trackSize,
        vertical
    };
    (0, _vue.provide)(VSliderSymbol, data);
    return data;
};

},{"../../composables/elevation.mjs":"3BDEa","../../composables/locale.mjs":"4MZbL","../../composables/rounded.mjs":"ldhZ9","vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eZdmp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSliderTrackProps", ()=>makeVSliderTrackProps);
parcelHelpers.export(exports, "VSliderTrack", ()=>VSliderTrack);
var _vue = require("vue");
// Styles
var _vsliderTrackCss = require("./VSliderTrack.css");
// Components
var _sliderMjs = require("./slider.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _roundedMjs = require("../../composables/rounded.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVSliderTrackProps = (0, _indexMjs.propsFactory)({
    start: {
        type: Number,
        required: true
    },
    stop: {
        type: Number,
        required: true
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VSliderTrack");
const VSliderTrack = (0, _indexMjs.genericComponent)()({
    name: "VSliderTrack",
    props: makeVSliderTrackProps(),
    emits: {},
    setup (props, _ref) {
        let { slots } = _ref;
        const slider = (0, _vue.inject)((0, _sliderMjs.VSliderSymbol));
        if (!slider) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
        const { color, horizontalDirection, parsedTicks, rounded, showTicks, tickSize, trackColor, trackFillColor, trackSize, vertical, min, max } = slider;
        const { roundedClasses } = (0, _roundedMjs.useRounded)(rounded);
        const { backgroundColorClasses: trackFillColorClasses, backgroundColorStyles: trackFillColorStyles } = (0, _colorMjs.useBackgroundColor)(trackFillColor);
        const { backgroundColorClasses: trackColorClasses, backgroundColorStyles: trackColorStyles } = (0, _colorMjs.useBackgroundColor)(trackColor);
        const startDir = (0, _vue.computed)(()=>`inset-${vertical.value ? "block-end" : "inline-start"}`);
        const endDir = (0, _vue.computed)(()=>vertical.value ? "height" : "width");
        const backgroundStyles = (0, _vue.computed)(()=>{
            return {
                [startDir.value]: "0%",
                [endDir.value]: "100%"
            };
        });
        const trackFillWidth = (0, _vue.computed)(()=>props.stop - props.start);
        const trackFillStyles = (0, _vue.computed)(()=>{
            return {
                [startDir.value]: (0, _indexMjs.convertToUnit)(props.start, "%"),
                [endDir.value]: (0, _indexMjs.convertToUnit)(trackFillWidth.value, "%")
            };
        });
        const computedTicks = (0, _vue.computed)(()=>{
            if (!showTicks.value) return [];
            const ticks = vertical.value ? parsedTicks.value.slice().reverse() : parsedTicks.value;
            return ticks.map((tick, index)=>{
                const directionProperty = vertical.value ? "bottom" : "margin-inline-start";
                const directionValue = tick.value !== min.value && tick.value !== max.value ? (0, _indexMjs.convertToUnit)(tick.position, "%") : undefined;
                return (0, _vue.createVNode)("div", {
                    "key": tick.value,
                    "class": [
                        "v-slider-track__tick",
                        {
                            "v-slider-track__tick--filled": tick.position >= props.start && tick.position <= props.stop,
                            "v-slider-track__tick--first": tick.value === min.value,
                            "v-slider-track__tick--last": tick.value === max.value
                        }
                    ],
                    "style": {
                        [directionProperty]: directionValue
                    }
                }, [
                    (tick.label || slots["tick-label"]) && (0, _vue.createVNode)("div", {
                        "class": "v-slider-track__tick-label"
                    }, [
                        slots["tick-label"]?.({
                            tick,
                            index
                        }) ?? tick.label
                    ])
                ]);
            });
        });
        (0, _indexMjs.useRender)(()=>{
            return (0, _vue.createVNode)("div", {
                "class": [
                    "v-slider-track",
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    {
                        "--v-slider-track-size": (0, _indexMjs.convertToUnit)(trackSize.value),
                        "--v-slider-tick-size": (0, _indexMjs.convertToUnit)(tickSize.value),
                        direction: !vertical.value ? horizontalDirection.value : undefined
                    },
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-slider-track__background",
                        trackColorClasses.value,
                        {
                            "v-slider-track__background--opacity": !!color.value || !trackFillColor.value
                        }
                    ],
                    "style": {
                        ...backgroundStyles.value,
                        ...trackColorStyles.value
                    }
                }, null),
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-slider-track__fill",
                        trackFillColorClasses.value
                    ],
                    "style": {
                        ...trackFillStyles.value,
                        ...trackFillColorStyles.value
                    }
                }, null),
                showTicks.value && (0, _vue.createVNode)("div", {
                    "class": [
                        "v-slider-track__ticks",
                        {
                            "v-slider-track__ticks--always-show": showTicks.value === "always"
                        }
                    ]
                }, [
                    computedTicks.value
                ])
            ]);
        });
        return {};
    }
});

},{"vue":"ff77s","./VSliderTrack.css":"5a1WF","./slider.mjs":"6FCha","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/rounded.mjs":"ldhZ9","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5a1WF":[function() {},{}],"eYDSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColorPickerSwatchesProps", ()=>makeVColorPickerSwatchesProps);
parcelHelpers.export(exports, "VColorPickerSwatches", ()=>VColorPickerSwatches);
var _vue = require("vue");
// Styles
var _vcolorPickerSwatchesCss = require("./VColorPickerSwatches.css");
// Components
var _indexMjs = require("../VIcon/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs");
var _colorsMjs = require("../../util/colors.mjs"); // Types
var _colorsMjsDefault = parcelHelpers.interopDefault(_colorsMjs);
const makeVColorPickerSwatchesProps = (0, _indexMjs1.propsFactory)({
    swatches: {
        type: Array,
        default: ()=>parseDefaultColors((0, _colorsMjsDefault.default))
    },
    disabled: Boolean,
    color: Object,
    maxHeight: [
        Number,
        String
    ],
    ...(0, _componentMjs.makeComponentProps)()
}, "VColorPickerSwatches");
function parseDefaultColors(colors) {
    return Object.keys(colors).map((key)=>{
        const color = colors[key];
        return color.base ? [
            color.base,
            color.darken4,
            color.darken3,
            color.darken2,
            color.darken1,
            color.lighten1,
            color.lighten2,
            color.lighten3,
            color.lighten4,
            color.lighten5
        ] : [
            color.black,
            color.white,
            color.transparent
        ];
    });
}
const VColorPickerSwatches = (0, _indexMjs1.defineComponent)({
    name: "VColorPickerSwatches",
    props: makeVColorPickerSwatchesProps(),
    emits: {
        "update:color": (color)=>true
    },
    setup (props, _ref) {
        let { emit } = _ref;
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-color-picker-swatches",
                    props.class
                ],
                "style": [
                    {
                        maxHeight: (0, _indexMjs1.convertToUnit)(props.maxHeight)
                    },
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", null, [
                    props.swatches.map((swatch)=>(0, _vue.createVNode)("div", {
                            "class": "v-color-picker-swatches__swatch"
                        }, [
                            swatch.map((color)=>{
                                const rgba = (0, _indexMjs1.parseColor)(color);
                                const hsva = (0, _indexMjs1.RGBtoHSV)(rgba);
                                const background = (0, _indexMjs1.RGBtoCSS)(rgba);
                                return (0, _vue.createVNode)("div", {
                                    "class": "v-color-picker-swatches__color",
                                    "onClick": ()=>hsva && emit("update:color", hsva)
                                }, [
                                    (0, _vue.createVNode)("div", {
                                        "style": {
                                            background
                                        }
                                    }, [
                                        props.color && (0, _indexMjs1.deepEqual)(props.color, hsva) ? (0, _vue.createVNode)((0, _indexMjs.VIcon), {
                                            "size": "x-small",
                                            "icon": "$success",
                                            "color": (0, _indexMjs1.getContrast)(color, "#FFFFFF") > 2 ? "white" : "black"
                                        }, null) : undefined
                                    ])
                                ]);
                            })
                        ]))
                ])
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VColorPickerSwatches.css":"jwZvy","../VIcon/index.mjs":"2wJue","../../composables/component.mjs":"jVHld","../../util/index.mjs":"6uIWw","../../util/colors.mjs":"daXqk","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jwZvy":[function() {},{}],"daXqk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const red = Object.freeze({
    base: "#f44336",
    lighten5: "#ffebee",
    lighten4: "#ffcdd2",
    lighten3: "#ef9a9a",
    lighten2: "#e57373",
    lighten1: "#ef5350",
    darken1: "#e53935",
    darken2: "#d32f2f",
    darken3: "#c62828",
    darken4: "#b71c1c",
    accent1: "#ff8a80",
    accent2: "#ff5252",
    accent3: "#ff1744",
    accent4: "#d50000"
});
const pink = Object.freeze({
    base: "#e91e63",
    lighten5: "#fce4ec",
    lighten4: "#f8bbd0",
    lighten3: "#f48fb1",
    lighten2: "#f06292",
    lighten1: "#ec407a",
    darken1: "#d81b60",
    darken2: "#c2185b",
    darken3: "#ad1457",
    darken4: "#880e4f",
    accent1: "#ff80ab",
    accent2: "#ff4081",
    accent3: "#f50057",
    accent4: "#c51162"
});
const purple = Object.freeze({
    base: "#9c27b0",
    lighten5: "#f3e5f5",
    lighten4: "#e1bee7",
    lighten3: "#ce93d8",
    lighten2: "#ba68c8",
    lighten1: "#ab47bc",
    darken1: "#8e24aa",
    darken2: "#7b1fa2",
    darken3: "#6a1b9a",
    darken4: "#4a148c",
    accent1: "#ea80fc",
    accent2: "#e040fb",
    accent3: "#d500f9",
    accent4: "#aa00ff"
});
const deepPurple = Object.freeze({
    base: "#673ab7",
    lighten5: "#ede7f6",
    lighten4: "#d1c4e9",
    lighten3: "#b39ddb",
    lighten2: "#9575cd",
    lighten1: "#7e57c2",
    darken1: "#5e35b1",
    darken2: "#512da8",
    darken3: "#4527a0",
    darken4: "#311b92",
    accent1: "#b388ff",
    accent2: "#7c4dff",
    accent3: "#651fff",
    accent4: "#6200ea"
});
const indigo = Object.freeze({
    base: "#3f51b5",
    lighten5: "#e8eaf6",
    lighten4: "#c5cae9",
    lighten3: "#9fa8da",
    lighten2: "#7986cb",
    lighten1: "#5c6bc0",
    darken1: "#3949ab",
    darken2: "#303f9f",
    darken3: "#283593",
    darken4: "#1a237e",
    accent1: "#8c9eff",
    accent2: "#536dfe",
    accent3: "#3d5afe",
    accent4: "#304ffe"
});
const blue = Object.freeze({
    base: "#2196f3",
    lighten5: "#e3f2fd",
    lighten4: "#bbdefb",
    lighten3: "#90caf9",
    lighten2: "#64b5f6",
    lighten1: "#42a5f5",
    darken1: "#1e88e5",
    darken2: "#1976d2",
    darken3: "#1565c0",
    darken4: "#0d47a1",
    accent1: "#82b1ff",
    accent2: "#448aff",
    accent3: "#2979ff",
    accent4: "#2962ff"
});
const lightBlue = Object.freeze({
    base: "#03a9f4",
    lighten5: "#e1f5fe",
    lighten4: "#b3e5fc",
    lighten3: "#81d4fa",
    lighten2: "#4fc3f7",
    lighten1: "#29b6f6",
    darken1: "#039be5",
    darken2: "#0288d1",
    darken3: "#0277bd",
    darken4: "#01579b",
    accent1: "#80d8ff",
    accent2: "#40c4ff",
    accent3: "#00b0ff",
    accent4: "#0091ea"
});
const cyan = Object.freeze({
    base: "#00bcd4",
    lighten5: "#e0f7fa",
    lighten4: "#b2ebf2",
    lighten3: "#80deea",
    lighten2: "#4dd0e1",
    lighten1: "#26c6da",
    darken1: "#00acc1",
    darken2: "#0097a7",
    darken3: "#00838f",
    darken4: "#006064",
    accent1: "#84ffff",
    accent2: "#18ffff",
    accent3: "#00e5ff",
    accent4: "#00b8d4"
});
const teal = Object.freeze({
    base: "#009688",
    lighten5: "#e0f2f1",
    lighten4: "#b2dfdb",
    lighten3: "#80cbc4",
    lighten2: "#4db6ac",
    lighten1: "#26a69a",
    darken1: "#00897b",
    darken2: "#00796b",
    darken3: "#00695c",
    darken4: "#004d40",
    accent1: "#a7ffeb",
    accent2: "#64ffda",
    accent3: "#1de9b6",
    accent4: "#00bfa5"
});
const green = Object.freeze({
    base: "#4caf50",
    lighten5: "#e8f5e9",
    lighten4: "#c8e6c9",
    lighten3: "#a5d6a7",
    lighten2: "#81c784",
    lighten1: "#66bb6a",
    darken1: "#43a047",
    darken2: "#388e3c",
    darken3: "#2e7d32",
    darken4: "#1b5e20",
    accent1: "#b9f6ca",
    accent2: "#69f0ae",
    accent3: "#00e676",
    accent4: "#00c853"
});
const lightGreen = Object.freeze({
    base: "#8bc34a",
    lighten5: "#f1f8e9",
    lighten4: "#dcedc8",
    lighten3: "#c5e1a5",
    lighten2: "#aed581",
    lighten1: "#9ccc65",
    darken1: "#7cb342",
    darken2: "#689f38",
    darken3: "#558b2f",
    darken4: "#33691e",
    accent1: "#ccff90",
    accent2: "#b2ff59",
    accent3: "#76ff03",
    accent4: "#64dd17"
});
const lime = Object.freeze({
    base: "#cddc39",
    lighten5: "#f9fbe7",
    lighten4: "#f0f4c3",
    lighten3: "#e6ee9c",
    lighten2: "#dce775",
    lighten1: "#d4e157",
    darken1: "#c0ca33",
    darken2: "#afb42b",
    darken3: "#9e9d24",
    darken4: "#827717",
    accent1: "#f4ff81",
    accent2: "#eeff41",
    accent3: "#c6ff00",
    accent4: "#aeea00"
});
const yellow = Object.freeze({
    base: "#ffeb3b",
    lighten5: "#fffde7",
    lighten4: "#fff9c4",
    lighten3: "#fff59d",
    lighten2: "#fff176",
    lighten1: "#ffee58",
    darken1: "#fdd835",
    darken2: "#fbc02d",
    darken3: "#f9a825",
    darken4: "#f57f17",
    accent1: "#ffff8d",
    accent2: "#ffff00",
    accent3: "#ffea00",
    accent4: "#ffd600"
});
const amber = Object.freeze({
    base: "#ffc107",
    lighten5: "#fff8e1",
    lighten4: "#ffecb3",
    lighten3: "#ffe082",
    lighten2: "#ffd54f",
    lighten1: "#ffca28",
    darken1: "#ffb300",
    darken2: "#ffa000",
    darken3: "#ff8f00",
    darken4: "#ff6f00",
    accent1: "#ffe57f",
    accent2: "#ffd740",
    accent3: "#ffc400",
    accent4: "#ffab00"
});
const orange = Object.freeze({
    base: "#ff9800",
    lighten5: "#fff3e0",
    lighten4: "#ffe0b2",
    lighten3: "#ffcc80",
    lighten2: "#ffb74d",
    lighten1: "#ffa726",
    darken1: "#fb8c00",
    darken2: "#f57c00",
    darken3: "#ef6c00",
    darken4: "#e65100",
    accent1: "#ffd180",
    accent2: "#ffab40",
    accent3: "#ff9100",
    accent4: "#ff6d00"
});
const deepOrange = Object.freeze({
    base: "#ff5722",
    lighten5: "#fbe9e7",
    lighten4: "#ffccbc",
    lighten3: "#ffab91",
    lighten2: "#ff8a65",
    lighten1: "#ff7043",
    darken1: "#f4511e",
    darken2: "#e64a19",
    darken3: "#d84315",
    darken4: "#bf360c",
    accent1: "#ff9e80",
    accent2: "#ff6e40",
    accent3: "#ff3d00",
    accent4: "#dd2c00"
});
const brown = Object.freeze({
    base: "#795548",
    lighten5: "#efebe9",
    lighten4: "#d7ccc8",
    lighten3: "#bcaaa4",
    lighten2: "#a1887f",
    lighten1: "#8d6e63",
    darken1: "#6d4c41",
    darken2: "#5d4037",
    darken3: "#4e342e",
    darken4: "#3e2723"
});
const blueGrey = Object.freeze({
    base: "#607d8b",
    lighten5: "#eceff1",
    lighten4: "#cfd8dc",
    lighten3: "#b0bec5",
    lighten2: "#90a4ae",
    lighten1: "#78909c",
    darken1: "#546e7a",
    darken2: "#455a64",
    darken3: "#37474f",
    darken4: "#263238"
});
const grey = Object.freeze({
    base: "#9e9e9e",
    lighten5: "#fafafa",
    lighten4: "#f5f5f5",
    lighten3: "#eeeeee",
    lighten2: "#e0e0e0",
    lighten1: "#bdbdbd",
    darken1: "#757575",
    darken2: "#616161",
    darken3: "#424242",
    darken4: "#212121"
});
const shades = Object.freeze({
    black: "#000000",
    white: "#ffffff",
    transparent: "#ffffff00"
});
exports.default = Object.freeze({
    red,
    pink,
    purple,
    deepPurple,
    indigo,
    blue,
    lightBlue,
    cyan,
    teal,
    green,
    lightGreen,
    lime,
    yellow,
    amber,
    orange,
    deepOrange,
    brown,
    blueGrey,
    grey,
    shades
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5AMLv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSheetProps", ()=>makeVSheetProps);
parcelHelpers.export(exports, "VSheet", ()=>VSheet);
var _vue = require("vue");
// Styles
var _vsheetCss = require("./VSheet.css");
// Composables
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVSheetProps = (0, _indexMjs.propsFactory)({
    color: String,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _locationMjs.makeLocationProps)(),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VSheet");
const VSheet = (0, _indexMjs.genericComponent)()({
    name: "VSheet",
    props: makeVSheetProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-sheet",
                    themeClasses.value,
                    backgroundColorClasses.value,
                    borderClasses.value,
                    elevationClasses.value,
                    positionClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    dimensionStyles.value,
                    locationStyles.value,
                    props.style
                ]
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VSheet.css":"9r3d1","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9r3d1":[function() {},{}],"5cy5y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCombobox", ()=>(0, _vcomboboxMjs.VCombobox));
var _vcomboboxMjs = require("./VCombobox.mjs");

},{"./VCombobox.mjs":"9mtRH","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9mtRH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVComboboxProps", ()=>makeVComboboxProps);
parcelHelpers.export(exports, "VCombobox", ()=>VCombobox);
var _vue = require("vue");
// Styles
var _vcomboboxCss = require("./VCombobox.css");
// Components
var _indexMjs = require("../VCheckbox/index.mjs");
var _indexMjs1 = require("../VChip/index.mjs");
var _indexMjs2 = require("../VDefaultsProvider/index.mjs");
var _indexMjs3 = require("../VIcon/index.mjs");
var _indexMjs4 = require("../VList/index.mjs");
var _indexMjs5 = require("../VMenu/index.mjs");
var _vselectMjs = require("../VSelect/VSelect.mjs");
var _indexMjs6 = require("../VTextField/index.mjs");
var _vtextFieldMjs = require("../VTextField/VTextField.mjs");
var _indexMjs7 = require("../VVirtualScroll/index.mjs"); // Composables
var _useScrollingMjs = require("../VSelect/useScrolling.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _filterMjs = require("../../composables/filter.mjs");
var _formMjs = require("../../composables/form.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _listItemsMjs = require("../../composables/list-items.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Utilities
var _indexMjs8 = require("../../util/index.mjs"); // Types
function highlightResult(text, matches, length) {
    if (matches == null) return text;
    if (Array.isArray(matches)) throw new Error("Multiple matches is not implemented");
    return typeof matches === "number" && ~matches ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
        (0, _vue.createVNode)("span", {
            "class": "v-combobox__unmask"
        }, [
            text.substr(0, matches)
        ]),
        (0, _vue.createVNode)("span", {
            "class": "v-combobox__mask"
        }, [
            text.substr(matches, length)
        ]),
        (0, _vue.createVNode)("span", {
            "class": "v-combobox__unmask"
        }, [
            text.substr(matches + length)
        ])
    ]) : text;
}
const makeVComboboxProps = (0, _indexMjs8.propsFactory)({
    autoSelectFirst: {
        type: [
            Boolean,
            String
        ]
    },
    delimiters: Array,
    ...(0, _filterMjs.makeFilterProps)({
        filterKeys: [
            "title"
        ]
    }),
    ...(0, _vselectMjs.makeSelectProps)({
        hideNoData: true,
        returnObject: true
    }),
    ...(0, _indexMjs8.omit)((0, _vtextFieldMjs.makeVTextFieldProps)({
        modelValue: null,
        role: "combobox"
    }), [
        "validationValue",
        "dirty",
        "appendInnerIcon"
    ]),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: false
    })
}, "VCombobox");
const VCombobox = (0, _indexMjs8.genericComponent)()({
    name: "VCombobox",
    props: makeVComboboxProps(),
    emits: {
        "update:focused": (focused)=>true,
        "update:modelValue": (val)=>true,
        "update:search": (val)=>true,
        "update:menu": (val)=>true
    },
    setup (props, _ref) {
        let { emit, slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const vTextFieldRef = (0, _vue.ref)();
        const isFocused = (0, _vue.shallowRef)(false);
        const isPristine = (0, _vue.shallowRef)(true);
        const listHasFocus = (0, _vue.shallowRef)(false);
        const vMenuRef = (0, _vue.ref)();
        const vVirtualScrollRef = (0, _vue.ref)();
        const _menu = (0, _proxiedModelMjs.useProxiedModel)(props, "menu");
        const menu = (0, _vue.computed)({
            get: ()=>_menu.value,
            set: (v)=>{
                if (_menu.value && !v && vMenuRef.value?.Œ®openChildren) return;
                _menu.value = v;
            }
        });
        const selectionIndex = (0, _vue.shallowRef)(-1);
        let cleared = false;
        const color = (0, _vue.computed)(()=>vTextFieldRef.value?.color);
        const label = (0, _vue.computed)(()=>menu.value ? props.closeText : props.openText);
        const { items, transformIn, transformOut } = (0, _listItemsMjs.useItems)(props);
        const { textColorClasses, textColorStyles } = (0, _colorMjs.useTextColor)(color);
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", [], (v)=>transformIn((0, _indexMjs8.wrapInArray)(v)), (v)=>{
            const transformed = transformOut(v);
            return props.multiple ? transformed : transformed[0] ?? null;
        });
        const form = (0, _formMjs.useForm)();
        const _search = (0, _vue.shallowRef)(!props.multiple ? model.value[0]?.title ?? "" : "");
        const search = (0, _vue.computed)({
            get: ()=>{
                return _search.value;
            },
            set: (val)=>{
                _search.value = val;
                if (!props.multiple) model.value = [
                    (0, _listItemsMjs.transformItem)(props, val)
                ];
                if (val && props.multiple && props.delimiters?.length) {
                    const values = val.split(new RegExp(`(?:${props.delimiters.join("|")})+`));
                    if (values.length > 1) {
                        values.forEach((v)=>{
                            v = v.trim();
                            if (v) select((0, _listItemsMjs.transformItem)(props, v));
                        });
                        _search.value = "";
                    }
                }
                if (!val) selectionIndex.value = -1;
                isPristine.value = !val;
            }
        });
        (0, _vue.watch)(_search, (value)=>{
            if (cleared) // wait for clear to finish, VTextField sets _search to null
            // then search computed triggers and updates _search to ''
            (0, _vue.nextTick)(()=>cleared = false);
            else if (isFocused.value && !menu.value) menu.value = true;
            emit("update:search", value);
        });
        (0, _vue.watch)(model, (value)=>{
            if (!props.multiple) _search.value = value[0]?.title ?? "";
        });
        const { filteredItems, getMatches } = (0, _filterMjs.useFilter)(props, items, ()=>isPristine.value ? "" : search.value);
        const displayItems = (0, _vue.computed)(()=>{
            if (props.hideSelected) return filteredItems.value.filter((filteredItem)=>!model.value.some((s)=>s.value === filteredItem.value));
            return filteredItems.value;
        });
        const selectedValues = (0, _vue.computed)(()=>model.value.map((selection)=>selection.value));
        const highlightFirst = (0, _vue.computed)(()=>{
            const selectFirst = props.autoSelectFirst === true || props.autoSelectFirst === "exact" && search.value === displayItems.value[0]?.title;
            return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
        });
        const menuDisabled = (0, _vue.computed)(()=>props.hideNoData && !items.value.length || props.readonly || form?.isReadonly.value);
        const listRef = (0, _vue.ref)();
        const { onListScroll, onListKeydown } = (0, _useScrollingMjs.useScrolling)(listRef, vTextFieldRef);
        function onClear(e) {
            cleared = true;
            if (props.openOnClear) menu.value = true;
        }
        function onMousedownControl() {
            if (menuDisabled.value) return;
            menu.value = true;
        }
        function onMousedownMenuIcon(e) {
            if (menuDisabled.value) return;
            if (isFocused.value) {
                e.preventDefault();
                e.stopPropagation();
            }
            menu.value = !menu.value;
        }
        function onKeydown(e) {
            if (props.readonly || form?.isReadonly.value) return;
            const selectionStart = vTextFieldRef.value.selectionStart;
            const length = model.value.length;
            if (selectionIndex.value > -1 || [
                "Enter",
                "ArrowDown",
                "ArrowUp"
            ].includes(e.key)) e.preventDefault();
            if ([
                "Enter",
                "ArrowDown"
            ].includes(e.key)) menu.value = true;
            if ([
                "Escape"
            ].includes(e.key)) menu.value = false;
            if ([
                "Enter",
                "Escape",
                "Tab"
            ].includes(e.key)) {
                if (highlightFirst.value && [
                    "Enter",
                    "Tab"
                ].includes(e.key)) select(filteredItems.value[0]);
                isPristine.value = true;
            }
            if (e.key === "ArrowDown" && highlightFirst.value) listRef.value?.focus("next");
            if (!props.multiple) return;
            if ([
                "Backspace",
                "Delete"
            ].includes(e.key)) {
                if (selectionIndex.value < 0) {
                    if (e.key === "Backspace" && !search.value) selectionIndex.value = length - 1;
                    return;
                }
                const originalSelectionIndex = selectionIndex.value;
                const selectedItem = model.value[selectionIndex.value];
                if (selectedItem) select(selectedItem);
                selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
            }
            if (e.key === "ArrowLeft") {
                if (selectionIndex.value < 0 && selectionStart > 0) return;
                const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
                if (model.value[prev]) selectionIndex.value = prev;
                else {
                    selectionIndex.value = -1;
                    vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
                }
            }
            if (e.key === "ArrowRight") {
                if (selectionIndex.value < 0) return;
                const next = selectionIndex.value + 1;
                if (model.value[next]) selectionIndex.value = next;
                else {
                    selectionIndex.value = -1;
                    vTextFieldRef.value.setSelectionRange(0, 0);
                }
            }
            if (e.key === "Enter" && search.value) {
                select((0, _listItemsMjs.transformItem)(props, search.value));
                search.value = "";
            }
        }
        function onAfterLeave() {
            if (isFocused.value) {
                isPristine.value = true;
                vTextFieldRef.value?.focus();
            }
        }
        function select(item) {
            if (props.multiple) {
                const index = model.value.findIndex((selection)=>props.valueComparator(selection.value, item.value));
                if (index === -1) model.value = [
                    ...model.value,
                    item
                ];
                else {
                    const value = [
                        ...model.value
                    ];
                    value.splice(index, 1);
                    model.value = value;
                }
                search.value = "";
            } else {
                model.value = [
                    item
                ];
                _search.value = item.title;
                // watch for search watcher to trigger
                (0, _vue.nextTick)(()=>{
                    menu.value = false;
                    isPristine.value = true;
                });
            }
        }
        function onFocusin(e) {
            isFocused.value = true;
            setTimeout(()=>{
                listHasFocus.value = true;
            });
        }
        function onFocusout(e) {
            listHasFocus.value = false;
        }
        function onUpdateModelValue(v) {
            if (v == null || v === "" && !props.multiple) model.value = [];
        }
        (0, _vue.watch)(filteredItems, (val)=>{
            if (!val.length && props.hideNoData) menu.value = false;
        });
        (0, _vue.watch)(isFocused, (val, oldVal)=>{
            if (val || val === oldVal) return;
            selectionIndex.value = -1;
            menu.value = false;
            if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2)=>{
                let { value } = _ref2;
                return value === displayItems.value[0].value;
            })) select(displayItems.value[0]);
            else if (props.multiple && search.value) {
                model.value = [
                    ...model.value,
                    (0, _listItemsMjs.transformItem)(props, search.value)
                ];
                search.value = "";
            }
        });
        (0, _vue.watch)(menu, ()=>{
            if (!props.hideSelected && menu.value && model.value.length) {
                const index = displayItems.value.findIndex((item)=>model.value.some((s)=>props.valueComparator(s.value, item.value)));
                (0, _indexMjs8.IN_BROWSER) && window.requestAnimationFrame(()=>{
                    index >= 0 && vVirtualScrollRef.value?.scrollToIndex(index);
                });
            }
        });
        (0, _indexMjs8.useRender)(()=>{
            const hasChips = !!(props.chips || slots.chip);
            const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
            const isDirty = model.value.length > 0;
            const [textFieldProps] = (0, _indexMjs6.VTextField).filterProps(props);
            return (0, _vue.createVNode)((0, _indexMjs6.VTextField), (0, _vue.mergeProps)({
                "ref": vTextFieldRef
            }, textFieldProps, {
                "modelValue": search.value,
                "onUpdate:modelValue": [
                    ($event)=>search.value = $event,
                    onUpdateModelValue
                ],
                "focused": isFocused.value,
                "onUpdate:focused": ($event)=>isFocused.value = $event,
                "validationValue": model.externalValue,
                "dirty": isDirty,
                "class": [
                    "v-combobox",
                    {
                        "v-combobox--active-menu": menu.value,
                        "v-combobox--chips": !!props.chips,
                        "v-combobox--selection-slot": !!slots.selection,
                        "v-combobox--selecting-index": selectionIndex.value > -1,
                        [`v-combobox--${props.multiple ? "multiple" : "single"}`]: true
                    },
                    props.class
                ],
                "style": props.style,
                "readonly": props.readonly,
                "placeholder": isDirty ? undefined : props.placeholder,
                "onClick:clear": onClear,
                "onMousedown:control": onMousedownControl,
                "onKeydown": onKeydown
            }), {
                ...slots,
                default: ()=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        (0, _vue.createVNode)((0, _indexMjs5.VMenu), (0, _vue.mergeProps)({
                            "ref": vMenuRef,
                            "modelValue": menu.value,
                            "onUpdate:modelValue": ($event)=>menu.value = $event,
                            "activator": "parent",
                            "contentClass": "v-combobox__content",
                            "disabled": menuDisabled.value,
                            "eager": props.eager,
                            "maxHeight": 310,
                            "openOnClick": false,
                            "closeOnContentClick": false,
                            "transition": props.transition,
                            "onAfterLeave": onAfterLeave
                        }, props.menuProps), {
                            default: ()=>[
                                    hasList && (0, _vue.createVNode)((0, _indexMjs4.VList), {
                                        "ref": listRef,
                                        "selected": selectedValues.value,
                                        "selectStrategy": props.multiple ? "independent" : "single-independent",
                                        "onMousedown": (e)=>e.preventDefault(),
                                        "onKeydown": onListKeydown,
                                        "onFocusin": onFocusin,
                                        "onFocusout": onFocusout,
                                        "onScrollPassive": onListScroll,
                                        "tabindex": "-1",
                                        "color": props.itemColor ?? props.color
                                    }, {
                                        default: ()=>[
                                                slots["prepend-item"]?.(),
                                                !displayItems.value.length && !props.hideNoData && (slots["no-data"]?.() ?? (0, _vue.createVNode)((0, _indexMjs4.VListItem), {
                                                    "title": t(props.noDataText)
                                                }, null)),
                                                (0, _vue.createVNode)((0, _indexMjs7.VVirtualScroll), {
                                                    "ref": vVirtualScrollRef,
                                                    "renderless": true,
                                                    "items": displayItems.value
                                                }, {
                                                    default: (_ref3)=>{
                                                        let { item, index, itemRef } = _ref3;
                                                        const itemProps = (0, _vue.mergeProps)(item.props, {
                                                            ref: itemRef,
                                                            key: index,
                                                            active: highlightFirst.value && index === 0 ? true : undefined,
                                                            onClick: ()=>select(item)
                                                        });
                                                        return slots.item?.({
                                                            item,
                                                            index,
                                                            props: itemProps
                                                        }) ?? (0, _vue.createVNode)((0, _indexMjs4.VListItem), itemProps, {
                                                            prepend: (_ref4)=>{
                                                                let { isSelected } = _ref4;
                                                                return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                                                    props.multiple && !props.hideSelected ? (0, _vue.createVNode)((0, _indexMjs.VCheckboxBtn), {
                                                                        "key": item.value,
                                                                        "modelValue": isSelected,
                                                                        "ripple": false,
                                                                        "tabindex": "-1"
                                                                    }, null) : undefined,
                                                                    item.props.prependIcon && (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                                                                        "icon": item.props.prependIcon
                                                                    }, null)
                                                                ]);
                                                            },
                                                            title: ()=>{
                                                                return isPristine.value ? item.title : highlightResult(item.title, getMatches(item)?.title, search.value?.length ?? 0);
                                                            }
                                                        });
                                                    }
                                                }),
                                                slots["append-item"]?.()
                                            ]
                                    })
                                ]
                        }),
                        model.value.map((item, index)=>{
                            function onChipClose(e) {
                                e.stopPropagation();
                                e.preventDefault();
                                select(item);
                            }
                            const slotProps = {
                                "onClick:close": onChipClose,
                                onMousedown (e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                },
                                modelValue: true,
                                "onUpdate:modelValue": undefined
                            };
                            return (0, _vue.createVNode)("div", {
                                "key": item.value,
                                "class": [
                                    "v-combobox__selection",
                                    index === selectionIndex.value && [
                                        "v-combobox__selection--selected",
                                        textColorClasses.value
                                    ]
                                ],
                                "style": index === selectionIndex.value ? textColorStyles.value : {}
                            }, [
                                hasChips ? !slots.chip ? (0, _vue.createVNode)((0, _indexMjs1.VChip), (0, _vue.mergeProps)({
                                    "key": "chip",
                                    "closable": props.closableChips,
                                    "size": "small",
                                    "text": item.title
                                }, slotProps), null) : (0, _vue.createVNode)((0, _indexMjs2.VDefaultsProvider), {
                                    "key": "chip-defaults",
                                    "defaults": {
                                        VChip: {
                                            closable: props.closableChips,
                                            size: "small",
                                            text: item.title
                                        }
                                    }
                                }, {
                                    default: ()=>[
                                            slots.chip?.({
                                                item,
                                                index,
                                                props: slotProps
                                            })
                                        ]
                                }) : slots.selection?.({
                                    item,
                                    index
                                }) ?? (0, _vue.createVNode)("span", {
                                    "class": "v-combobox__selection-text"
                                }, [
                                    item.title,
                                    props.multiple && index < model.value.length - 1 && (0, _vue.createVNode)("span", {
                                        "class": "v-combobox__selection-comma"
                                    }, [
                                        (0, _vue.createTextVNode)(",")
                                    ])
                                ])
                            ]);
                        })
                    ]),
                "append-inner": function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots["append-inner"]?.(...args),
                        (!props.hideNoData || props.items.length) && props.menuIcon ? (0, _vue.createVNode)((0, _indexMjs3.VIcon), {
                            "class": "v-combobox__menu-icon",
                            "icon": props.menuIcon,
                            "onMousedown": onMousedownMenuIcon,
                            "onClick": (0, _indexMjs8.noop),
                            "aria-label": t(label.value),
                            "title": t(label.value)
                        }, null) : undefined
                    ]);
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({
            isFocused,
            isPristine,
            menu,
            search,
            selectionIndex,
            filteredItems,
            select
        }, vTextFieldRef);
    }
});

},{"vue":"ff77s","./VCombobox.css":"8lmkH","../VCheckbox/index.mjs":"2g3Bq","../VChip/index.mjs":"9w6oh","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../VList/index.mjs":"1md2l","../VMenu/index.mjs":"fYY6u","../VSelect/VSelect.mjs":"dHfP6","../VTextField/index.mjs":"kjCqu","../VTextField/VTextField.mjs":"4p33J","../VVirtualScroll/index.mjs":"7IUqN","../VSelect/useScrolling.mjs":"fZNsR","../../composables/color.mjs":"4pLYX","../../composables/filter.mjs":"fMXi2","../../composables/form.mjs":"Jb6Pn","../../composables/forwardRefs.mjs":"h5grs","../../composables/list-items.mjs":"kVtgo","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/transition.mjs":"gFVfN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8lmkH":[function() {},{}],"kjCqu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTextField", ()=>(0, _vtextFieldMjs.VTextField));
var _vtextFieldMjs = require("./VTextField.mjs");

},{"./VTextField.mjs":"4p33J","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fn25z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VCounter", ()=>(0, _vcounterMjs.VCounter));
var _vcounterMjs = require("./VCounter.mjs");

},{"./VCounter.mjs":"16Uel","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jqeGZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VDialog", ()=>(0, _vdialogMjs.VDialog));
var _vdialogMjs = require("./VDialog.mjs");

},{"./VDialog.mjs":"4PrFr","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4PrFr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVDialogProps", ()=>makeVDialogProps);
parcelHelpers.export(exports, "VDialog", ()=>VDialog);
var _vue = require("vue");
// Styles
var _vdialogCss = require("./VDialog.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VDefaultsProvider/index.mjs");
var _indexMjs2 = require("../VOverlay/index.mjs");
var _voverlayMjs = require("../VOverlay/VOverlay.mjs"); // Composables
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVDialogProps = (0, _indexMjs3.propsFactory)({
    fullscreen: Boolean,
    retainFocus: {
        type: Boolean,
        default: true
    },
    scrollable: Boolean,
    ...(0, _voverlayMjs.makeVOverlayProps)({
        origin: "center center",
        scrollStrategy: "block",
        transition: {
            component: (0, _indexMjs.VDialogTransition)
        },
        zIndex: 2400
    })
}, "VDialog");
const VDialog = (0, _indexMjs3.genericComponent)()({
    name: "VDialog",
    props: makeVDialogProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        const overlay = (0, _vue.ref)();
        function onFocusin(e) {
            const before = e.relatedTarget;
            const after = e.target;
            if (before !== after && overlay.value?.contentEl && // We're the topmost dialog
            overlay.value?.globalTop && // It isn't the document or the dialog body
            ![
                document,
                overlay.value.contentEl
            ].includes(after) && // It isn't inside the dialog body
            !overlay.value.contentEl.contains(after)) {
                const focusable = (0, _indexMjs3.focusableChildren)(overlay.value.contentEl);
                if (!focusable.length) return;
                const firstElement = focusable[0];
                const lastElement = focusable[focusable.length - 1];
                if (before === firstElement) lastElement.focus();
                else firstElement.focus();
            }
        }
        if (0, _indexMjs3.IN_BROWSER) (0, _vue.watch)(()=>isActive.value && props.retainFocus, (val)=>{
            val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
        }, {
            immediate: true
        });
        (0, _vue.watch)(isActive, async (val)=>{
            await (0, _vue.nextTick)();
            if (val) overlay.value.contentEl?.focus({
                preventScroll: true
            });
            else overlay.value.activatorEl?.focus({
                preventScroll: true
            });
        });
        const activatorProps = (0, _vue.computed)(()=>(0, _vue.mergeProps)({
                "aria-haspopup": "dialog",
                "aria-expanded": String(isActive.value)
            }, props.activatorProps));
        (0, _indexMjs3.useRender)(()=>{
            const [overlayProps] = (0, _indexMjs2.VOverlay).filterProps(props);
            return (0, _vue.createVNode)((0, _indexMjs2.VOverlay), (0, _vue.mergeProps)({
                "ref": overlay,
                "class": [
                    "v-dialog",
                    {
                        "v-dialog--fullscreen": props.fullscreen,
                        "v-dialog--scrollable": props.scrollable
                    },
                    props.class
                ],
                "style": props.style
            }, overlayProps, {
                "modelValue": isActive.value,
                "onUpdate:modelValue": ($event)=>isActive.value = $event,
                "aria-modal": "true",
                "activatorProps": activatorProps.value,
                "role": "dialog"
            }, scopeId), {
                activator: slots.activator,
                default: function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return (0, _vue.createVNode)((0, _indexMjs1.VDefaultsProvider), {
                        "root": "VDialog"
                    }, {
                        default: ()=>[
                                slots.default?.(...args)
                            ]
                    });
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, overlay);
    }
});

},{"vue":"ff77s","./VDialog.css":"8GpGg","../transitions/index.mjs":"oiH7Z","../VDefaultsProvider/index.mjs":"1OIgj","../VOverlay/index.mjs":"28W37","../VOverlay/VOverlay.mjs":"9nMvb","../../composables/forwardRefs.mjs":"h5grs","../../composables/proxiedModel.mjs":"bUF28","../../composables/scopeId.mjs":"78lmg","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8GpGg":[function() {},{}],"JN3Sr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VExpansionPanels", ()=>(0, _vexpansionPanelsMjs.VExpansionPanels));
parcelHelpers.export(exports, "VExpansionPanel", ()=>(0, _vexpansionPanelMjs.VExpansionPanel));
parcelHelpers.export(exports, "VExpansionPanelText", ()=>(0, _vexpansionPanelTextMjs.VExpansionPanelText));
parcelHelpers.export(exports, "VExpansionPanelTitle", ()=>(0, _vexpansionPanelTitleMjs.VExpansionPanelTitle));
var _vexpansionPanelsMjs = require("./VExpansionPanels.mjs");
var _vexpansionPanelMjs = require("./VExpansionPanel.mjs");
var _vexpansionPanelTextMjs = require("./VExpansionPanelText.mjs");
var _vexpansionPanelTitleMjs = require("./VExpansionPanelTitle.mjs");

},{"./VExpansionPanels.mjs":"gto7U","./VExpansionPanel.mjs":"4IZXT","./VExpansionPanelText.mjs":"i9aL4","./VExpansionPanelTitle.mjs":"5y92S","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gto7U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VExpansionPanelSymbol", ()=>VExpansionPanelSymbol);
parcelHelpers.export(exports, "makeVExpansionPanelsProps", ()=>makeVExpansionPanelsProps);
parcelHelpers.export(exports, "VExpansionPanels", ()=>VExpansionPanels);
var _vue = require("vue");
// Styles
var _vexpansionPanelCss = require("./VExpansionPanel.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
const allowedVariants = [
    "default",
    "accordion",
    "inset",
    "popout"
];
const makeVExpansionPanelsProps = (0, _indexMjs.propsFactory)({
    color: String,
    variant: {
        type: String,
        default: "default",
        validator: (v)=>allowedVariants.includes(v)
    },
    readonly: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _groupMjs.makeGroupProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VExpansionPanels");
const VExpansionPanels = (0, _indexMjs.genericComponent)()({
    name: "VExpansionPanels",
    props: makeVExpansionPanelsProps(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _groupMjs.useGroup)(props, VExpansionPanelSymbol);
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const variantClass = (0, _vue.computed)(()=>props.variant && `v-expansion-panels--variant-${props.variant}`);
        (0, _defaultsMjs.provideDefaults)({
            VExpansionPanel: {
                color: (0, _vue.toRef)(props, "color")
            },
            VExpansionPanelTitle: {
                readonly: (0, _vue.toRef)(props, "readonly")
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-expansion-panels",
                    themeClasses.value,
                    variantClass.value,
                    props.class
                ],
                "style": props.style
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VExpansionPanel.css":"6jNbO","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/group.mjs":"7LC6J","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6jNbO":[function() {},{}],"4IZXT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVExpansionPanelProps", ()=>makeVExpansionPanelProps);
parcelHelpers.export(exports, "VExpansionPanel", ()=>VExpansionPanel);
var _vue = require("vue");
// Components
var _vexpansionPanelsMjs = require("./VExpansionPanels.mjs");
var _vexpansionPanelTextMjs = require("./VExpansionPanelText.mjs");
var _vexpansionPanelTitleMjs = require("./VExpansionPanelTitle.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _lazyMjs = require("../../composables/lazy.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVExpansionPanelProps = (0, _indexMjs.propsFactory)({
    title: String,
    text: String,
    bgColor: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _groupMjs.makeGroupItemProps)(),
    ...(0, _lazyMjs.makeLazyProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _vexpansionPanelTitleMjs.makeVExpansionPanelTitleProps)()
}, "VExpansionPanel");
const VExpansionPanel = (0, _indexMjs.genericComponent)()({
    name: "VExpansionPanel",
    props: makeVExpansionPanelProps(),
    emits: {
        "group:selected": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const groupItem = (0, _groupMjs.useGroupItem)(props, (0, _vexpansionPanelsMjs.VExpansionPanelSymbol));
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)(props, "bgColor");
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const isDisabled = (0, _vue.computed)(()=>groupItem?.disabled.value || props.disabled);
        const selectedIndices = (0, _vue.computed)(()=>groupItem.group.items.value.reduce((arr, item, index)=>{
                if (groupItem.group.selected.value.includes(item.id)) arr.push(index);
                return arr;
            }, []));
        const isBeforeSelected = (0, _vue.computed)(()=>{
            const index = groupItem.group.items.value.findIndex((item)=>item.id === groupItem.id);
            return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex)=>selectedIndex - index === 1);
        });
        const isAfterSelected = (0, _vue.computed)(()=>{
            const index = groupItem.group.items.value.findIndex((item)=>item.id === groupItem.id);
            return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex)=>selectedIndex - index === -1);
        });
        (0, _vue.provide)((0, _vexpansionPanelsMjs.VExpansionPanelSymbol), groupItem);
        (0, _defaultsMjs.provideDefaults)({
            VExpansionPanelText: {
                eager: (0, _vue.toRef)(props, "eager")
            }
        });
        (0, _indexMjs.useRender)(()=>{
            const hasText = !!(slots.text || props.text);
            const hasTitle = !!(slots.title || props.title);
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-expansion-panel",
                    {
                        "v-expansion-panel--active": groupItem.isSelected.value,
                        "v-expansion-panel--before-active": isBeforeSelected.value,
                        "v-expansion-panel--after-active": isAfterSelected.value,
                        "v-expansion-panel--disabled": isDisabled.value
                    },
                    roundedClasses.value,
                    backgroundColorClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        (0, _vue.createVNode)("div", {
                            "class": [
                                "v-expansion-panel__shadow",
                                ...elevationClasses.value
                            ]
                        }, null),
                        hasTitle && (0, _vue.createVNode)((0, _vexpansionPanelTitleMjs.VExpansionPanelTitle), {
                            "key": "title",
                            "collapseIcon": props.collapseIcon,
                            "color": props.color,
                            "expandIcon": props.expandIcon,
                            "hideActions": props.hideActions,
                            "ripple": props.ripple
                        }, {
                            default: ()=>[
                                    slots.title ? slots.title() : props.title
                                ]
                        }),
                        hasText && (0, _vue.createVNode)((0, _vexpansionPanelTextMjs.VExpansionPanelText), {
                            "key": "text"
                        }, {
                            default: ()=>[
                                    slots.text ? slots.text() : props.text
                                ]
                        }),
                        slots.default?.()
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VExpansionPanels.mjs":"gto7U","./VExpansionPanelText.mjs":"i9aL4","./VExpansionPanelTitle.mjs":"5y92S","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/elevation.mjs":"3BDEa","../../composables/group.mjs":"7LC6J","../../composables/lazy.mjs":"au1NJ","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"i9aL4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVExpansionPanelTextProps", ()=>makeVExpansionPanelTextProps);
parcelHelpers.export(exports, "VExpansionPanelText", ()=>VExpansionPanelText);
var _vue = require("vue");
// Components
var _vexpansionPanelsMjs = require("./VExpansionPanels.mjs");
var _indexMjs = require("../transitions/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _lazyMjs = require("../../composables/lazy.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs");
const makeVExpansionPanelTextProps = (0, _indexMjs1.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _lazyMjs.makeLazyProps)()
}, "VExpansionPanelText");
const VExpansionPanelText = (0, _indexMjs1.genericComponent)()({
    name: "VExpansionPanelText",
    props: makeVExpansionPanelTextProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const expansionPanel = (0, _vue.inject)((0, _vexpansionPanelsMjs.VExpansionPanelSymbol));
        if (!expansionPanel) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
        const { hasContent, onAfterLeave } = (0, _lazyMjs.useLazy)(props, expansionPanel.isSelected);
        (0, _indexMjs1.useRender)(()=>(0, _vue.createVNode)((0, _indexMjs.VExpandTransition), {
                "onAfterLeave": onAfterLeave
            }, {
                default: ()=>[
                        (0, _vue.withDirectives)((0, _vue.createVNode)("div", {
                            "class": [
                                "v-expansion-panel-text",
                                props.class
                            ],
                            "style": props.style
                        }, [
                            slots.default && hasContent.value && (0, _vue.createVNode)("div", {
                                "class": "v-expansion-panel-text__wrapper"
                            }, [
                                slots.default?.()
                            ])
                        ]), [
                            [
                                (0, _vue.vShow),
                                expansionPanel.isSelected.value
                            ]
                        ])
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VExpansionPanels.mjs":"gto7U","../transitions/index.mjs":"oiH7Z","../../composables/component.mjs":"jVHld","../../composables/lazy.mjs":"au1NJ","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5y92S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVExpansionPanelTitleProps", ()=>makeVExpansionPanelTitleProps);
parcelHelpers.export(exports, "VExpansionPanelTitle", ()=>VExpansionPanelTitle);
var _vue = require("vue");
// Components
var _vexpansionPanelsMjs = require("./VExpansionPanels.mjs");
var _indexMjs = require("../VIcon/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _iconsMjs = require("../../composables/icons.mjs"); // Directives
var _indexMjs1 = require("../../directives/ripple/index.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVExpansionPanelTitleProps = (0, _indexMjs2.propsFactory)({
    color: String,
    expandIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$expand"
    },
    collapseIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$collapse"
    },
    hideActions: Boolean,
    ripple: {
        type: [
            Boolean,
            Object
        ],
        default: false
    },
    readonly: Boolean,
    ...(0, _componentMjs.makeComponentProps)()
}, "VExpansionPanelTitle");
const VExpansionPanelTitle = (0, _indexMjs2.genericComponent)()({
    name: "VExpansionPanelTitle",
    directives: {
        Ripple: (0, _indexMjs1.Ripple)
    },
    props: makeVExpansionPanelTitleProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const expansionPanel = (0, _vue.inject)((0, _vexpansionPanelsMjs.VExpansionPanelSymbol));
        if (!expansionPanel) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)(props, "color");
        const slotProps = (0, _vue.computed)(()=>({
                collapseIcon: props.collapseIcon,
                disabled: expansionPanel.disabled.value,
                expanded: expansionPanel.isSelected.value,
                expandIcon: props.expandIcon,
                readonly: props.readonly
            }));
        (0, _indexMjs2.useRender)(()=>(0, _vue.withDirectives)((0, _vue.createVNode)("button", {
                "class": [
                    "v-expansion-panel-title",
                    {
                        "v-expansion-panel-title--active": expansionPanel.isSelected.value
                    },
                    backgroundColorClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.style
                ],
                "type": "button",
                "tabindex": expansionPanel.disabled.value ? -1 : undefined,
                "disabled": expansionPanel.disabled.value,
                "aria-expanded": expansionPanel.isSelected.value,
                "onClick": !props.readonly ? expansionPanel.toggle : undefined
            }, [
                (0, _vue.createVNode)("span", {
                    "class": "v-expansion-panel-title__overlay"
                }, null),
                slots.default?.(slotProps.value),
                !props.hideActions && (0, _vue.createVNode)("span", {
                    "class": "v-expansion-panel-title__icon"
                }, [
                    slots.actions ? slots.actions(slotProps.value) : (0, _vue.createVNode)((0, _indexMjs.VIcon), {
                        "icon": expansionPanel.isSelected.value ? props.collapseIcon : props.expandIcon
                    }, null)
                ])
            ]), [
                [
                    (0, _vue.resolveDirective)("ripple"),
                    props.ripple
                ]
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VExpansionPanels.mjs":"gto7U","../VIcon/index.mjs":"2wJue","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/icons.mjs":"ezwoc","../../directives/ripple/index.mjs":"fTBbe","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"b1DV7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VField", ()=>(0, _vfieldMjs.VField));
parcelHelpers.export(exports, "VFieldLabel", ()=>(0, _vfieldLabelMjs.VFieldLabel));
var _vfieldMjs = require("./VField.mjs");
var _vfieldLabelMjs = require("./VFieldLabel.mjs");

},{"./VField.mjs":"2knTe","./VFieldLabel.mjs":"9pUSw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cxUZw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VFileInput", ()=>(0, _vfileInputMjs.VFileInput));
var _vfileInputMjs = require("./VFileInput.mjs");

},{"./VFileInput.mjs":"bPb36","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bPb36":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVFileInputProps", ()=>makeVFileInputProps);
parcelHelpers.export(exports, "VFileInput", ()=>VFileInput);
var _vue = require("vue");
// Styles
var _vfileInputCss = require("./VFileInput.css");
// Components
var _indexMjs = require("../VChip/index.mjs");
var _indexMjs1 = require("../VCounter/index.mjs");
var _indexMjs2 = require("../VField/index.mjs");
var _vfieldMjs = require("../VField/VField.mjs");
var _vinputMjs = require("../VInput/VInput.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVFileInputProps = (0, _indexMjs3.propsFactory)({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
        type: String,
        default: "$vuetify.fileInput.counterSize"
    },
    counterString: {
        type: String,
        default: "$vuetify.fileInput.counter"
    },
    multiple: Boolean,
    showSize: {
        type: [
            Boolean,
            Number
        ],
        default: false,
        validator: (v)=>{
            return typeof v === "boolean" || [
                1000,
                1024
            ].includes(v);
        }
    },
    ...(0, _vinputMjs.makeVInputProps)({
        prependIcon: "$file"
    }),
    modelValue: {
        type: Array,
        default: ()=>[],
        validator: (val)=>{
            return (0, _indexMjs3.wrapInArray)(val).every((v)=>v != null && typeof v === "object");
        }
    },
    ...(0, _vfieldMjs.makeVFieldProps)({
        clearable: true
    })
}, "VFileInput");
const VFileInput = (0, _indexMjs3.genericComponent)()({
    name: "VFileInput",
    inheritAttrs: false,
    props: makeVFileInputProps(),
    emits: {
        "click:control": (e)=>true,
        "mousedown:control": (e)=>true,
        "update:focused": (focused)=>true,
        "update:modelValue": (files)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const base = (0, _vue.computed)(()=>typeof props.showSize !== "boolean" ? props.showSize : undefined);
        const totalBytes = (0, _vue.computed)(()=>(model.value ?? []).reduce((bytes, _ref2)=>{
                let { size = 0 } = _ref2;
                return bytes + size;
            }, 0));
        const totalBytesReadable = (0, _vue.computed)(()=>(0, _indexMjs3.humanReadableFileSize)(totalBytes.value, base.value));
        const fileNames = (0, _vue.computed)(()=>(model.value ?? []).map((file)=>{
                const { name = "", size = 0 } = file;
                return !props.showSize ? name : `${name} (${(0, _indexMjs3.humanReadableFileSize)(size, base.value)})`;
            }));
        const counterValue = (0, _vue.computed)(()=>{
            const fileCount = model.value?.length ?? 0;
            if (props.showSize) return t(props.counterSizeString, fileCount, totalBytesReadable.value);
            else return t(props.counterString, fileCount);
        });
        const vInputRef = (0, _vue.ref)();
        const vFieldRef = (0, _vue.ref)();
        const inputRef = (0, _vue.ref)();
        const isActive = (0, _vue.computed)(()=>isFocused.value || props.active);
        const isPlainOrUnderlined = (0, _vue.computed)(()=>[
                "plain",
                "underlined"
            ].includes(props.variant));
        function onFocus() {
            if (inputRef.value !== document.activeElement) inputRef.value?.focus();
            if (!isFocused.value) focus();
        }
        function onClickPrepend(e) {
            onControlClick(e);
        }
        function onControlMousedown(e) {
            emit("mousedown:control", e);
        }
        function onControlClick(e) {
            inputRef.value?.click();
            emit("click:control", e);
        }
        function onClear(e) {
            e.stopPropagation();
            onFocus();
            (0, _vue.nextTick)(()=>{
                model.value = [];
                (0, _indexMjs3.callEvent)(props["onClick:clear"], e);
            });
        }
        (0, _vue.watch)(model, (newValue)=>{
            const hasModelReset = !Array.isArray(newValue) || !newValue.length;
            if (hasModelReset && inputRef.value) inputRef.value.value = "";
        });
        (0, _indexMjs3.useRender)(()=>{
            const hasCounter = !!(slots.counter || props.counter);
            const hasDetails = !!(hasCounter || slots.details);
            const [rootAttrs, inputAttrs] = (0, _indexMjs3.filterInputAttrs)(attrs);
            const [{ modelValue: _, ...inputProps }] = (0, _vinputMjs.VInput).filterProps(props);
            const [fieldProps] = (0, _vfieldMjs.filterFieldProps)(props);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "ref": vInputRef,
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "class": [
                    "v-file-input",
                    {
                        "v-text-field--plain-underlined": isPlainOrUnderlined.value
                    },
                    props.class
                ],
                "style": props.style,
                "onClick:prepend": onClickPrepend
            }, rootAttrs, inputProps, {
                "centerAffix": !isPlainOrUnderlined.value,
                "focused": isFocused.value
            }), {
                ...slots,
                default: (_ref3)=>{
                    let { id, isDisabled, isDirty, isReadonly, isValid } = _ref3;
                    return (0, _vue.createVNode)((0, _indexMjs2.VField), (0, _vue.mergeProps)({
                        "ref": vFieldRef,
                        "prepend-icon": props.prependIcon,
                        "onMousedown": onControlMousedown,
                        "onClick": onControlClick,
                        "onClick:clear": onClear,
                        "onClick:prependInner": props["onClick:prependInner"],
                        "onClick:appendInner": props["onClick:appendInner"]
                    }, fieldProps, {
                        "id": id.value,
                        "active": isActive.value || isDirty.value,
                        "dirty": isDirty.value,
                        "disabled": isDisabled.value,
                        "focused": isFocused.value,
                        "error": isValid.value === false
                    }), {
                        ...slots,
                        default: (_ref4)=>{
                            let { props: { class: fieldClass, ...slotProps } } = _ref4;
                            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                (0, _vue.createVNode)("input", (0, _vue.mergeProps)({
                                    "ref": inputRef,
                                    "type": "file",
                                    "readonly": isReadonly.value,
                                    "disabled": isDisabled.value,
                                    "multiple": props.multiple,
                                    "name": props.name,
                                    "onClick": (e)=>{
                                        e.stopPropagation();
                                        if (isReadonly.value) e.preventDefault();
                                        onFocus();
                                    },
                                    "onChange": (e)=>{
                                        if (!e.target) return;
                                        const target = e.target;
                                        model.value = [
                                            ...target.files ?? []
                                        ];
                                    },
                                    "onFocus": onFocus,
                                    "onBlur": blur
                                }, slotProps, inputAttrs), null),
                                (0, _vue.createVNode)("div", {
                                    "class": fieldClass
                                }, [
                                    !!model.value?.length && (slots.selection ? slots.selection({
                                        fileNames: fileNames.value,
                                        totalBytes: totalBytes.value,
                                        totalBytesReadable: totalBytesReadable.value
                                    }) : props.chips ? fileNames.value.map((text)=>(0, _vue.createVNode)((0, _indexMjs.VChip), {
                                            "key": text,
                                            "size": "small",
                                            "color": props.color
                                        }, {
                                            default: ()=>[
                                                    text
                                                ]
                                        })) : fileNames.value.join(", "))
                                ])
                            ]);
                        }
                    });
                },
                details: hasDetails ? (slotProps)=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots.details?.(slotProps),
                        hasCounter && (0, _vue.createVNode)((0, _vue.Fragment), null, [
                            (0, _vue.createVNode)("span", null, null),
                            (0, _vue.createVNode)((0, _indexMjs1.VCounter), {
                                "active": !!model.value?.length,
                                "value": counterValue.value
                            }, slots.counter)
                        ])
                    ]) : undefined
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, vInputRef, vFieldRef, inputRef);
    }
});

},{"vue":"ff77s","./VFileInput.css":"c3NyB","../VChip/index.mjs":"9w6oh","../VCounter/index.mjs":"fn25z","../VField/index.mjs":"b1DV7","../VField/VField.mjs":"2knTe","../VInput/VInput.mjs":"1hyGZ","../../composables/focus.mjs":"1bQxY","../../composables/forwardRefs.mjs":"h5grs","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"c3NyB":[function() {},{}],"kJKqg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VFooter", ()=>(0, _vfooterMjs.VFooter));
var _vfooterMjs = require("./VFooter.mjs");

},{"./VFooter.mjs":"huaQL","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"huaQL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVFooterProps", ()=>makeVFooterProps);
parcelHelpers.export(exports, "VFooter", ()=>VFooter);
var _vue = require("vue");
// Styles
var _vfooterCss = require("./VFooter.css");
// Composables
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVFooterProps = (0, _indexMjs.propsFactory)({
    app: Boolean,
    color: String,
    height: {
        type: [
            Number,
            String
        ],
        default: "auto"
    },
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "footer"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VFooter");
const VFooter = (0, _indexMjs.genericComponent)()({
    name: "VFooter",
    props: makeVFooterProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const autoHeight = (0, _vue.shallowRef)(32);
        const { resizeRef } = (0, _resizeObserverMjs.useResizeObserver)((entries)=>{
            if (!entries.length) return;
            autoHeight.value = entries[0].target.clientHeight;
        });
        const height = (0, _vue.computed)(()=>props.height === "auto" ? autoHeight.value : parseInt(props.height, 10));
        const { layoutItemStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: (0, _vue.computed)(()=>"bottom"),
            layoutSize: height,
            elementSize: (0, _vue.computed)(()=>props.height === "auto" ? undefined : height.value),
            active: (0, _vue.computed)(()=>props.app),
            absolute: (0, _vue.toRef)(props, "absolute")
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "ref": resizeRef,
                "class": [
                    "v-footer",
                    themeClasses.value,
                    backgroundColorClasses.value,
                    borderClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    props.app ? layoutItemStyles.value : {
                        height: (0, _indexMjs.convertToUnit)(props.height)
                    },
                    props.style
                ]
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VFooter.css":"ZBTUi","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/elevation.mjs":"3BDEa","../../composables/layout.mjs":"fPMsf","../../composables/resizeObserver.mjs":"byLTu","../../composables/rounded.mjs":"ldhZ9","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ZBTUi":[function() {},{}],"leMHZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VForm", ()=>(0, _vformMjs.VForm));
var _vformMjs = require("./VForm.mjs");

},{"./VForm.mjs":"em9wz","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"em9wz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVFormProps", ()=>makeVFormProps);
parcelHelpers.export(exports, "VForm", ()=>VForm);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _formMjs = require("../../composables/form.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVFormProps = (0, _indexMjs.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _formMjs.makeFormProps)()
}, "VForm");
const VForm = (0, _indexMjs.genericComponent)()({
    name: "VForm",
    props: makeVFormProps(),
    emits: {
        "update:modelValue": (val)=>true,
        submit: (e)=>true
    },
    setup (props, _ref) {
        let { slots, emit } = _ref;
        const form = (0, _formMjs.createForm)(props);
        const formRef = (0, _vue.ref)();
        function onReset(e) {
            e.preventDefault();
            form.reset();
        }
        function onSubmit(_e) {
            const e = _e;
            const ready = form.validate();
            e.then = ready.then.bind(ready);
            e.catch = ready.catch.bind(ready);
            e.finally = ready.finally.bind(ready);
            emit("submit", e);
            if (!e.defaultPrevented) ready.then((_ref2)=>{
                let { valid } = _ref2;
                if (valid) formRef.value?.submit();
            });
            e.preventDefault();
        }
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("form", {
                "ref": formRef,
                "class": [
                    "v-form",
                    props.class
                ],
                "style": props.style,
                "novalidate": true,
                "onReset": onReset,
                "onSubmit": onSubmit
            }, [
                slots.default?.(form)
            ]));
        return (0, _forwardRefsMjs.forwardRefs)(form, formRef);
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/form.mjs":"Jb6Pn","../../composables/forwardRefs.mjs":"h5grs","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8lAfd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VContainer", ()=>(0, _vcontainerMjs.VContainer));
parcelHelpers.export(exports, "VCol", ()=>(0, _vcolMjs.VCol));
parcelHelpers.export(exports, "VRow", ()=>(0, _vrowMjs.VRow));
parcelHelpers.export(exports, "VSpacer", ()=>(0, _vspacerMjs.VSpacer));
var _vcontainerMjs = require("./VContainer.mjs");
var _vcolMjs = require("./VCol.mjs");
var _vrowMjs = require("./VRow.mjs");
var _vspacerMjs = require("./VSpacer.mjs");

},{"./VContainer.mjs":"cO8XV","./VCol.mjs":"dA0Ki","./VRow.mjs":"1mi1W","./VSpacer.mjs":"fIsf4","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cO8XV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVContainerProps", ()=>makeVContainerProps);
parcelHelpers.export(exports, "VContainer", ()=>VContainer);
var _vue = require("vue");
// Styles
var _vgridCss = require("./VGrid.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVContainerProps = (0, _indexMjs.propsFactory)({
    fluid: {
        type: Boolean,
        default: false
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VContainer");
const VContainer = (0, _indexMjs.genericComponent)()({
    name: "VContainer",
    props: makeVContainerProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-container",
                    {
                        "v-container--fluid": props.fluid
                    },
                    rtlClasses.value,
                    props.class
                ],
                "style": props.style
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VGrid.css":"4BBPc","../../composables/component.mjs":"jVHld","../../composables/locale.mjs":"4MZbL","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4BBPc":[function() {},{}],"dA0Ki":[function(require,module,exports) {
// Styles
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVColProps", ()=>makeVColProps);
parcelHelpers.export(exports, "VCol", ()=>VCol);
var _vgridCss = require("./VGrid.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _displayMjs = require("../../composables/display.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const breakpointProps = (()=>{
    return (0, _displayMjs.breakpoints).reduce((props, val)=>{
        props[val] = {
            type: [
                Boolean,
                String,
                Number
            ],
            default: false
        };
        return props;
    }, {});
})();
const offsetProps = (()=>{
    return (0, _displayMjs.breakpoints).reduce((props, val)=>{
        const offsetKey = "offset" + (0, _vue.capitalize)(val);
        props[offsetKey] = {
            type: [
                String,
                Number
            ],
            default: null
        };
        return props;
    }, {});
})();
const orderProps = (()=>{
    return (0, _displayMjs.breakpoints).reduce((props, val)=>{
        const orderKey = "order" + (0, _vue.capitalize)(val);
        props[orderKey] = {
            type: [
                String,
                Number
            ],
            default: null
        };
        return props;
    }, {});
})();
const propMap = {
    col: Object.keys(breakpointProps),
    offset: Object.keys(offsetProps),
    order: Object.keys(orderProps)
};
function breakpointClass(type, prop, val) {
    let className = type;
    if (val == null || val === false) return undefined;
    if (prop) {
        const breakpoint = prop.replace(type, "");
        className += `-${breakpoint}`;
    }
    if (type === "col") className = "v-" + className;
    // Handling the boolean style prop when accepting [Boolean, String, Number]
    // means Vue will not convert <v-col sm></v-col> to sm: true for us.
    // Since the default is false, an empty string indicates the prop's presence.
    if (type === "col" && (val === "" || val === true)) // .v-col-md
    return className.toLowerCase();
    // .order-md-6
    className += `-${val}`;
    return className.toLowerCase();
}
const ALIGN_SELF_VALUES = [
    "auto",
    "start",
    "end",
    "center",
    "baseline",
    "stretch"
];
const makeVColProps = (0, _indexMjs.propsFactory)({
    cols: {
        type: [
            Boolean,
            String,
            Number
        ],
        default: false
    },
    ...breakpointProps,
    offset: {
        type: [
            String,
            Number
        ],
        default: null
    },
    ...offsetProps,
    order: {
        type: [
            String,
            Number
        ],
        default: null
    },
    ...orderProps,
    alignSelf: {
        type: String,
        default: null,
        validator: (str)=>ALIGN_SELF_VALUES.includes(str)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VCol");
const VCol = (0, _indexMjs.genericComponent)()({
    name: "VCol",
    props: makeVColProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const classes = (0, _vue.computed)(()=>{
            const classList = [];
            // Loop through `col`, `offset`, `order` breakpoint props
            let type;
            for(type in propMap)propMap[type].forEach((prop)=>{
                const value = props[prop];
                const className = breakpointClass(type, prop, value);
                if (className) classList.push(className);
            });
            const hasColClasses = classList.some((className)=>className.startsWith("v-col-"));
            classList.push({
                // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
                "v-col": !hasColClasses || !props.cols,
                [`v-col-${props.cols}`]: props.cols,
                [`offset-${props.offset}`]: props.offset,
                [`order-${props.order}`]: props.order,
                [`align-self-${props.alignSelf}`]: props.alignSelf
            });
            return classList;
        });
        return ()=>(0, _vue.h)(props.tag, {
                class: [
                    classes.value,
                    props.class
                ],
                style: props.style
            }, slots.default?.());
    }
});

},{"./VGrid.css":"4BBPc","../../composables/component.mjs":"jVHld","../../composables/display.mjs":"6nXZK","../../composables/tag.mjs":"3KkML","vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4BBPc":[function() {},{}],"1mi1W":[function(require,module,exports) {
// Styles
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVRowProps", ()=>makeVRowProps);
parcelHelpers.export(exports, "VRow", ()=>VRow);
var _vgridCss = require("./VGrid.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _displayMjs = require("../../composables/display.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
const ALIGNMENT = [
    "start",
    "end",
    "center"
];
const SPACE = [
    "space-between",
    "space-around",
    "space-evenly"
];
function makeRowProps(prefix, def) {
    return (0, _displayMjs.breakpoints).reduce((props, val)=>{
        const prefixKey = prefix + (0, _vue.capitalize)(val);
        props[prefixKey] = def();
        return props;
    }, {});
}
const ALIGN_VALUES = [
    ...ALIGNMENT,
    "baseline",
    "stretch"
];
const alignValidator = (str)=>ALIGN_VALUES.includes(str);
const alignProps = makeRowProps("align", ()=>({
        type: String,
        default: null,
        validator: alignValidator
    }));
const JUSTIFY_VALUES = [
    ...ALIGNMENT,
    ...SPACE
];
const justifyValidator = (str)=>JUSTIFY_VALUES.includes(str);
const justifyProps = makeRowProps("justify", ()=>({
        type: String,
        default: null,
        validator: justifyValidator
    }));
const ALIGN_CONTENT_VALUES = [
    ...ALIGNMENT,
    ...SPACE,
    "stretch"
];
const alignContentValidator = (str)=>ALIGN_CONTENT_VALUES.includes(str);
const alignContentProps = makeRowProps("alignContent", ()=>({
        type: String,
        default: null,
        validator: alignContentValidator
    }));
const propMap = {
    align: Object.keys(alignProps),
    justify: Object.keys(justifyProps),
    alignContent: Object.keys(alignContentProps)
};
const classMap = {
    align: "align",
    justify: "justify",
    alignContent: "align-content"
};
function breakpointClass(type, prop, val) {
    let className = classMap[type];
    if (val == null) return undefined;
    if (prop) {
        // alignSm -> Sm
        const breakpoint = prop.replace(type, "");
        className += `-${breakpoint}`;
    }
    // .align-items-sm-center
    className += `-${val}`;
    return className.toLowerCase();
}
const makeVRowProps = (0, _indexMjs.propsFactory)({
    dense: Boolean,
    noGutters: Boolean,
    align: {
        type: String,
        default: null,
        validator: alignValidator
    },
    ...alignProps,
    justify: {
        type: String,
        default: null,
        validator: justifyValidator
    },
    ...justifyProps,
    alignContent: {
        type: String,
        default: null,
        validator: alignContentValidator
    },
    ...alignContentProps,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VRow");
const VRow = (0, _indexMjs.genericComponent)()({
    name: "VRow",
    props: makeVRowProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const classes = (0, _vue.computed)(()=>{
            const classList = [];
            // Loop through `align`, `justify`, `alignContent` breakpoint props
            let type;
            for(type in propMap)propMap[type].forEach((prop)=>{
                const value = props[prop];
                const className = breakpointClass(type, prop, value);
                if (className) classList.push(className);
            });
            classList.push({
                "v-row--no-gutters": props.noGutters,
                "v-row--dense": props.dense,
                [`align-${props.align}`]: props.align,
                [`justify-${props.justify}`]: props.justify,
                [`align-content-${props.alignContent}`]: props.alignContent
            });
            return classList;
        });
        return ()=>(0, _vue.h)(props.tag, {
                class: [
                    "v-row",
                    classes.value,
                    props.class
                ],
                style: props.style
            }, slots.default?.());
    }
});

},{"./VGrid.css":"4BBPc","../../composables/component.mjs":"jVHld","../../composables/display.mjs":"6nXZK","../../composables/tag.mjs":"3KkML","vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4BBPc":[function() {},{}],"fIsf4":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSpacer", ()=>VSpacer);
var _indexMjs = require("../../util/index.mjs");
const VSpacer = (0, _indexMjs.createSimpleFunctional)("v-spacer", "div", "VSpacer");

},{"../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7iKVm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VHover", ()=>(0, _vhoverMjs.VHover));
var _vhoverMjs = require("./VHover.mjs");

},{"./VHover.mjs":"5RUcg","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5RUcg":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVHoverProps", ()=>makeVHoverProps);
parcelHelpers.export(exports, "VHover", ()=>VHover);
var _delayMjs = require("../../composables/delay.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVHoverProps = (0, _indexMjs.propsFactory)({
    disabled: Boolean,
    modelValue: {
        type: Boolean,
        default: undefined
    },
    ...(0, _delayMjs.makeDelayProps)()
}, "VHover");
const VHover = (0, _indexMjs.genericComponent)()({
    name: "VHover",
    props: makeVHoverProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const isHovering = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { runOpenDelay, runCloseDelay } = (0, _delayMjs.useDelay)(props, (value)=>!props.disabled && (isHovering.value = value));
        return ()=>slots.default?.({
                isHovering: isHovering.value,
                props: {
                    onMouseenter: runOpenDelay,
                    onMouseleave: runCloseDelay
                }
            });
    }
});

},{"../../composables/delay.mjs":"jBGDO","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gMYJL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VInput", ()=>(0, _vinputMjs.VInput));
var _vinputMjs = require("./VInput.mjs");

},{"./VInput.mjs":"1hyGZ","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5ohEj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VItemGroup", ()=>(0, _vitemGroupMjs.VItemGroup));
parcelHelpers.export(exports, "VItem", ()=>(0, _vitemMjs.VItem));
var _vitemGroupMjs = require("./VItemGroup.mjs");
var _vitemMjs = require("./VItem.mjs");

},{"./VItemGroup.mjs":"cqX1z","./VItem.mjs":"kIPCv","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cqX1z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VItemGroupSymbol", ()=>VItemGroupSymbol);
parcelHelpers.export(exports, "makeVItemGroupProps", ()=>makeVItemGroupProps);
parcelHelpers.export(exports, "VItemGroup", ()=>VItemGroup);
var _vue = require("vue");
// Styles
var _vitemGroupCss = require("./VItemGroup.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const VItemGroupSymbol = Symbol.for("vuetify:v-item-group");
const makeVItemGroupProps = (0, _indexMjs.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _groupMjs.makeGroupProps)({
        selectedClass: "v-item--selected"
    }),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VItemGroup");
const VItemGroup = (0, _indexMjs.genericComponent)()({
    name: "VItemGroup",
    props: makeVItemGroupProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { isSelected, select, next, prev, selected } = (0, _groupMjs.useGroup)(props, VItemGroupSymbol);
        return ()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-item-group",
                    themeClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        slots.default?.({
                            isSelected,
                            select,
                            next,
                            prev,
                            selected: selected.value
                        })
                    ]
            });
    }
});

},{"vue":"ff77s","./VItemGroup.css":"k0HdZ","../../composables/component.mjs":"jVHld","../../composables/group.mjs":"7LC6J","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"k0HdZ":[function() {},{}],"kIPCv":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VItem", ()=>VItem);
var _vitemGroupMjs = require("./VItemGroup.mjs");
var _groupMjs = require("../../composables/group.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const VItem = (0, _indexMjs.genericComponent)()({
    name: "VItem",
    props: (0, _groupMjs.makeGroupItemProps)(),
    emits: {
        "group:selected": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { isSelected, select, toggle, selectedClass, value, disabled } = (0, _groupMjs.useGroupItem)(props, (0, _vitemGroupMjs.VItemGroupSymbol));
        return ()=>slots.default?.({
                isSelected: isSelected.value,
                selectedClass: selectedClass.value,
                select,
                toggle,
                value: value.value,
                disabled: disabled.value
            });
    }
});

},{"./VItemGroup.mjs":"cqX1z","../../composables/group.mjs":"7LC6J","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4tlLn":[function(require,module,exports) {
// Styles
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VKbd", ()=>VKbd);
var _vkbdCss = require("./VKbd.css");
// Utilities
var _indexMjs = require("../../util/index.mjs");
const VKbd = (0, _indexMjs.createSimpleFunctional)("v-kbd");

},{"./VKbd.css":"codWc","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"codWc":[function() {},{}],"dUgae":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VLayout", ()=>(0, _vlayoutMjs.VLayout));
parcelHelpers.export(exports, "VLayoutItem", ()=>(0, _vlayoutItemMjs.VLayoutItem));
var _vlayoutMjs = require("./VLayout.mjs");
var _vlayoutItemMjs = require("./VLayoutItem.mjs");

},{"./VLayout.mjs":"9ItS2","./VLayoutItem.mjs":"dCddU","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9ItS2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVLayoutProps", ()=>makeVLayoutProps);
parcelHelpers.export(exports, "VLayout", ()=>VLayout);
var _vue = require("vue");
// Styles
var _vlayoutCss = require("./VLayout.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _layoutMjs = require("../../composables/layout.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVLayoutProps = (0, _indexMjs.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _layoutMjs.makeLayoutProps)()
}, "VLayout");
const VLayout = (0, _indexMjs.genericComponent)()({
    name: "VLayout",
    props: makeVLayoutProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { layoutClasses, layoutStyles, getLayoutItem, items, layoutRef } = (0, _layoutMjs.createLayout)(props);
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "ref": layoutRef,
                "class": [
                    layoutClasses.value,
                    props.class
                ],
                "style": [
                    layoutStyles.value,
                    props.style
                ]
            }, [
                slots.default?.()
            ]));
        return {
            getLayoutItem,
            items
        };
    }
});

},{"vue":"ff77s","./VLayout.css":"gYsaJ","../../composables/component.mjs":"jVHld","../../composables/layout.mjs":"fPMsf","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gYsaJ":[function() {},{}],"dCddU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVLayoutItemProps", ()=>makeVLayoutItemProps);
parcelHelpers.export(exports, "VLayoutItem", ()=>VLayoutItem);
var _vue = require("vue");
// Styles
var _vlayoutItemCss = require("./VLayoutItem.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _layoutMjs = require("../../composables/layout.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVLayoutItemProps = (0, _indexMjs.propsFactory)({
    position: {
        type: String,
        required: true
    },
    size: {
        type: [
            Number,
            String
        ],
        default: 300
    },
    modelValue: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)()
}, "VLayoutItem");
const VLayoutItem = (0, _indexMjs.genericComponent)()({
    name: "VLayoutItem",
    props: makeVLayoutItemProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { layoutItemStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: (0, _vue.toRef)(props, "position"),
            elementSize: (0, _vue.toRef)(props, "size"),
            layoutSize: (0, _vue.toRef)(props, "size"),
            active: (0, _vue.toRef)(props, "modelValue"),
            absolute: (0, _vue.toRef)(props, "absolute")
        });
        return ()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-layout-item",
                    props.class
                ],
                "style": [
                    layoutItemStyles.value,
                    props.style
                ]
            }, [
                slots.default?.()
            ]);
    }
});

},{"vue":"ff77s","./VLayoutItem.css":"1tpr6","../../composables/component.mjs":"jVHld","../../composables/layout.mjs":"fPMsf","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1tpr6":[function() {},{}],"caroX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VLazy", ()=>(0, _vlazyMjs.VLazy));
var _vlazyMjs = require("./VLazy.mjs");

},{"./VLazy.mjs":"dvEip","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dvEip":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVLazyProps", ()=>makeVLazyProps);
parcelHelpers.export(exports, "VLazy", ()=>VLazy);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _transitionMjs = require("../../composables/transition.mjs"); // Directives
var _indexMjs = require("../../directives/intersect/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs);
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVLazyProps = (0, _indexMjs1.propsFactory)({
    modelValue: Boolean,
    options: {
        type: Object,
        // For more information on types, navigate to:
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        default: ()=>({
                root: undefined,
                rootMargin: undefined,
                threshold: undefined
            })
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _transitionMjs.makeTransitionProps)({
        transition: "fade-transition"
    })
}, "VLazy");
const VLazy = (0, _indexMjs1.genericComponent)()({
    name: "VLazy",
    directives: {
        intersect: (0, _indexMjsDefault.default)
    },
    props: makeVLazyProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        function onIntersect(isIntersecting) {
            if (isActive.value) return;
            isActive.value = isIntersecting;
        }
        (0, _indexMjs1.useRender)(()=>(0, _vue.withDirectives)((0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-lazy",
                    props.class
                ],
                "style": [
                    dimensionStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        isActive.value && (0, _vue.createVNode)((0, _transitionMjs.MaybeTransition), {
                            "transition": props.transition,
                            "appear": true
                        }, {
                            default: ()=>[
                                    slots.default?.()
                                ]
                        })
                    ]
            }), [
                [
                    (0, _vue.resolveDirective)("intersect"),
                    {
                        handler: onIntersect,
                        options: props.options
                    },
                    null
                ]
            ]));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../composables/proxiedModel.mjs":"bUF28","../../composables/tag.mjs":"3KkML","../../composables/transition.mjs":"gFVfN","../../directives/intersect/index.mjs":"jD88I","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eqswv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VLocaleProvider", ()=>(0, _vlocaleProviderMjs.VLocaleProvider));
var _vlocaleProviderMjs = require("./VLocaleProvider.mjs");

},{"./VLocaleProvider.mjs":"lvLJv","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lvLJv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVLocaleProviderProps", ()=>makeVLocaleProviderProps);
parcelHelpers.export(exports, "VLocaleProvider", ()=>VLocaleProvider);
var _vue = require("vue");
// Styles
var _vlocaleProviderCss = require("./VLocaleProvider.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _localeMjs = require("../../composables/locale.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVLocaleProviderProps = (0, _indexMjs.propsFactory)({
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
        type: Boolean,
        default: undefined
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VLocaleProvider");
const VLocaleProvider = (0, _indexMjs.genericComponent)()({
    name: "VLocaleProvider",
    props: makeVLocaleProviderProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { rtlClasses } = (0, _localeMjs.provideLocale)(props);
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-locale-provider",
                    rtlClasses.value,
                    props.class
                ],
                "style": props.style
            }, [
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VLocaleProvider.css":"j8rX0","../../composables/component.mjs":"jVHld","../../composables/locale.mjs":"4MZbL","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"j8rX0":[function() {},{}],"fLV4C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VMain", ()=>(0, _vmainMjs.VMain));
var _vmainMjs = require("./VMain.mjs");

},{"./VMain.mjs":"bMVIO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bMVIO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVMainProps", ()=>makeVMainProps);
parcelHelpers.export(exports, "VMain", ()=>VMain);
var _vue = require("vue");
// Styles
var _vmainCss = require("./VMain.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVMainProps = (0, _indexMjs.propsFactory)({
    scrollable: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "main"
    })
}, "VMain");
const VMain = (0, _indexMjs.genericComponent)()({
    name: "VMain",
    props: makeVMainProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { mainStyles } = (0, _layoutMjs.useLayout)();
        const { ssrBootStyles } = (0, _ssrBootMjs.useSsrBoot)();
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-main",
                    {
                        "v-main--scrollable": props.scrollable
                    },
                    props.class
                ],
                "style": [
                    mainStyles.value,
                    ssrBootStyles.value,
                    props.style
                ]
            }, {
                default: ()=>[
                        props.scrollable ? (0, _vue.createVNode)("div", {
                            "class": "v-main__scroller"
                        }, [
                            slots.default?.()
                        ]) : slots.default?.()
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VMain.css":"fMsFT","../../composables/component.mjs":"jVHld","../../composables/layout.mjs":"fPMsf","../../composables/ssrBoot.mjs":"b8ivf","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fMsFT":[function() {},{}],"acqI7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VMessages", ()=>(0, _vmessagesMjs.VMessages));
var _vmessagesMjs = require("./VMessages.mjs");

},{"./VMessages.mjs":"9A74R","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dC6sN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VNavigationDrawer", ()=>(0, _vnavigationDrawerMjs.VNavigationDrawer));
var _vnavigationDrawerMjs = require("./VNavigationDrawer.mjs");

},{"./VNavigationDrawer.mjs":"6DAvP","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6DAvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVNavigationDrawerProps", ()=>makeVNavigationDrawerProps);
parcelHelpers.export(exports, "VNavigationDrawer", ()=>VNavigationDrawer);
var _vue = require("vue");
// Styles
var _vnavigationDrawerCss = require("./VNavigationDrawer.css");
// Composables
var _stickyMjs = require("./sticky.mjs");
var _touchMjs = require("./touch.mjs");
var _indexMjs = require("../../composables/index.mjs");
var _borderMjs = require("../../composables/border.mjs");
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _displayMjs = require("../../composables/display.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _routerMjs = require("../../composables/router.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const locations = [
    "start",
    "end",
    "left",
    "right",
    "top",
    "bottom"
];
const makeVNavigationDrawerProps = (0, _indexMjs1.propsFactory)({
    color: String,
    disableResizeWatcher: Boolean,
    disableRouteWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
        type: Boolean,
        default: null
    },
    permanent: Boolean,
    rail: {
        type: Boolean,
        default: null
    },
    railWidth: {
        type: [
            Number,
            String
        ],
        default: 56
    },
    scrim: {
        type: [
            Boolean,
            String
        ],
        default: true
    },
    image: String,
    temporary: Boolean,
    touchless: Boolean,
    width: {
        type: [
            Number,
            String
        ],
        default: 256
    },
    location: {
        type: String,
        default: "start",
        validator: (value)=>locations.includes(value)
    },
    sticky: Boolean,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "nav"
    }),
    ...(0, _themeMjs.makeThemeProps)()
}, "VNavigationDrawer");
const VNavigationDrawer = (0, _indexMjs1.genericComponent)()({
    name: "VNavigationDrawer",
    props: makeVNavigationDrawerProps(),
    emits: {
        "update:modelValue": (val)=>true,
        "update:rail": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const { isRtl } = (0, _indexMjs.useRtl)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { borderClasses } = (0, _borderMjs.useBorder)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { mobile } = (0, _displayMjs.useDisplay)();
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const router = (0, _routerMjs.useRouter)();
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", null, (v)=>!!v);
        const { ssrBootStyles } = (0, _ssrBootMjs.useSsrBoot)();
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        const rootEl = (0, _vue.ref)();
        const isHovering = (0, _vue.shallowRef)(false);
        const width = (0, _vue.computed)(()=>{
            return props.rail && props.expandOnHover && isHovering.value ? Number(props.width) : Number(props.rail ? props.railWidth : props.width);
        });
        const location = (0, _vue.computed)(()=>{
            return (0, _indexMjs1.toPhysical)(props.location, isRtl.value);
        });
        const isTemporary = (0, _vue.computed)(()=>!props.permanent && (mobile.value || props.temporary));
        const isSticky = (0, _vue.computed)(()=>props.sticky && !isTemporary.value && location.value !== "bottom");
        if (props.expandOnHover && props.rail != null) (0, _vue.watch)(isHovering, (val)=>emit("update:rail", !val));
        if (!props.disableResizeWatcher) (0, _vue.watch)(isTemporary, (val)=>!props.permanent && (0, _vue.nextTick)(()=>isActive.value = !val));
        if (!props.disableRouteWatcher && router) (0, _vue.watch)(router.currentRoute, ()=>isTemporary.value && (isActive.value = false));
        (0, _vue.watch)(()=>props.permanent, (val)=>{
            if (val) isActive.value = true;
        });
        (0, _vue.onBeforeMount)(()=>{
            if (props.modelValue != null || isTemporary.value) return;
            isActive.value = props.permanent || !mobile.value;
        });
        const { isDragging, dragProgress, dragStyles } = (0, _touchMjs.useTouch)({
            isActive,
            isTemporary,
            width,
            touchless: (0, _vue.toRef)(props, "touchless"),
            position: location
        });
        const layoutSize = (0, _vue.computed)(()=>{
            const size = isTemporary.value ? 0 : props.rail && props.expandOnHover ? Number(props.railWidth) : width.value;
            return isDragging.value ? size * dragProgress.value : size;
        });
        const { layoutItemStyles, layoutItemScrimStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: location,
            layoutSize,
            elementSize: width,
            active: (0, _vue.computed)(()=>isActive.value || isDragging.value),
            disableTransitions: (0, _vue.computed)(()=>isDragging.value),
            absolute: (0, _vue.computed)(()=>// eslint-disable-next-line @typescript-eslint/no-use-before-define
                props.absolute || isSticky.value && typeof isStuck.value !== "string")
        });
        const { isStuck, stickyStyles } = (0, _stickyMjs.useSticky)({
            rootEl,
            isSticky,
            layoutItemStyles
        });
        const scrimColor = (0, _colorMjs.useBackgroundColor)((0, _vue.computed)(()=>{
            return typeof props.scrim === "string" ? props.scrim : null;
        }));
        const scrimStyles = (0, _vue.computed)(()=>({
                ...isDragging.value ? {
                    opacity: dragProgress.value * 0.2,
                    transition: "none"
                } : undefined,
                ...layoutItemScrimStyles.value
            }));
        (0, _defaultsMjs.provideDefaults)({
            VList: {
                bgColor: "transparent"
            }
        });
        function onMouseenter() {
            isHovering.value = true;
        }
        function onMouseleave() {
            isHovering.value = false;
        }
        (0, _indexMjs1.useRender)(()=>{
            const hasImage = slots.image || props.image;
            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                (0, _vue.createVNode)(props.tag, (0, _vue.mergeProps)({
                    "ref": rootEl,
                    "onMouseenter": onMouseenter,
                    "onMouseleave": onMouseleave,
                    "class": [
                        "v-navigation-drawer",
                        `v-navigation-drawer--${location.value}`,
                        {
                            "v-navigation-drawer--expand-on-hover": props.expandOnHover,
                            "v-navigation-drawer--floating": props.floating,
                            "v-navigation-drawer--is-hovering": isHovering.value,
                            "v-navigation-drawer--rail": props.rail,
                            "v-navigation-drawer--temporary": isTemporary.value,
                            "v-navigation-drawer--active": isActive.value,
                            "v-navigation-drawer--sticky": isSticky.value
                        },
                        themeClasses.value,
                        backgroundColorClasses.value,
                        borderClasses.value,
                        elevationClasses.value,
                        roundedClasses.value,
                        props.class
                    ],
                    "style": [
                        backgroundColorStyles.value,
                        layoutItemStyles.value,
                        dragStyles.value,
                        ssrBootStyles.value,
                        stickyStyles.value,
                        props.style
                    ]
                }, scopeId, attrs), {
                    default: ()=>[
                            hasImage && (0, _vue.createVNode)("div", {
                                "key": "image",
                                "class": "v-navigation-drawer__img"
                            }, [
                                slots.image ? slots.image?.({
                                    image: props.image
                                }) : (0, _vue.createVNode)("img", {
                                    "src": props.image,
                                    "alt": ""
                                }, null)
                            ]),
                            slots.prepend && (0, _vue.createVNode)("div", {
                                "class": "v-navigation-drawer__prepend"
                            }, [
                                slots.prepend?.()
                            ]),
                            (0, _vue.createVNode)("div", {
                                "class": "v-navigation-drawer__content"
                            }, [
                                slots.default?.()
                            ]),
                            slots.append && (0, _vue.createVNode)("div", {
                                "class": "v-navigation-drawer__append"
                            }, [
                                slots.append?.()
                            ])
                        ]
                }),
                (0, _vue.createVNode)((0, _vue.Transition), {
                    "name": "fade-transition"
                }, {
                    default: ()=>[
                            isTemporary.value && (isDragging.value || isActive.value) && !!props.scrim && (0, _vue.createVNode)("div", (0, _vue.mergeProps)({
                                "class": [
                                    "v-navigation-drawer__scrim",
                                    scrimColor.backgroundColorClasses.value
                                ],
                                "style": [
                                    scrimStyles.value,
                                    scrimColor.backgroundColorStyles.value
                                ],
                                "onClick": ()=>isActive.value = false
                            }, scopeId), null)
                        ]
                })
            ]);
        });
        return {
            isStuck
        };
    }
});

},{"vue":"ff77s","./VNavigationDrawer.css":"5NkDr","./sticky.mjs":"pMJ3Y","./touch.mjs":"1KUEf","../../composables/index.mjs":"lUqcD","../../composables/border.mjs":"3nPTz","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/display.mjs":"6nXZK","../../composables/elevation.mjs":"3BDEa","../../composables/layout.mjs":"fPMsf","../../composables/proxiedModel.mjs":"bUF28","../../composables/rounded.mjs":"ldhZ9","../../composables/router.mjs":"bEBrG","../../composables/scopeId.mjs":"78lmg","../../composables/ssrBoot.mjs":"b8ivf","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5NkDr":[function() {},{}],"pMJ3Y":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useSticky", ()=>useSticky);
var _vue = require("vue");
var _indexMjs = require("../../util/index.mjs"); // Types
function useSticky(_ref) {
    let { rootEl, isSticky, layoutItemStyles } = _ref;
    const isStuck = (0, _vue.shallowRef)(false);
    const stuckPosition = (0, _vue.shallowRef)(0);
    const stickyStyles = (0, _vue.computed)(()=>{
        const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
        return [
            isSticky.value ? {
                top: "auto",
                bottom: "auto",
                height: undefined
            } : undefined,
            isStuck.value ? {
                [side]: (0, _indexMjs.convertToUnit)(stuckPosition.value)
            } : {
                top: layoutItemStyles.value.top
            }
        ];
    });
    (0, _vue.onMounted)(()=>{
        (0, _vue.watch)(isSticky, (val)=>{
            if (val) window.addEventListener("scroll", onScroll, {
                passive: true
            });
            else window.removeEventListener("scroll", onScroll);
        }, {
            immediate: true
        });
    });
    (0, _vue.onBeforeUnmount)(()=>{
        window.removeEventListener("scroll", onScroll);
    });
    let lastScrollTop = 0;
    function onScroll() {
        const direction = lastScrollTop > window.scrollY ? "up" : "down";
        const rect = rootEl.value.getBoundingClientRect();
        const layoutTop = parseFloat(layoutItemStyles.value.top ?? 0);
        const top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
        const bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
        const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
        if (rect.height < window.innerHeight - layoutTop) {
            isStuck.value = "top";
            stuckPosition.value = layoutTop;
        } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
            stuckPosition.value = window.scrollY + rect.top - bodyScroll;
            isStuck.value = true;
        } else if (direction === "down" && bottom <= 0) {
            stuckPosition.value = 0;
            isStuck.value = "bottom";
        } else if (direction === "up" && top <= 0) {
            if (!bodyScroll) {
                stuckPosition.value = rect.top + top;
                isStuck.value = "top";
            } else if (isStuck.value !== "top") {
                stuckPosition.value = -top + bodyScroll + layoutTop;
                isStuck.value = "top";
            }
        }
        lastScrollTop = window.scrollY;
    }
    return {
        isStuck,
        stickyStyles
    };
}

},{"vue":"ff77s","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"1KUEf":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Types
parcelHelpers.export(exports, "useTouch", ()=>useTouch);
var _touchMjs = require("../../composables/touch.mjs"); // Utilities
var _vue = require("vue");
function useTouch(_ref) {
    let { isActive, isTemporary, width, touchless, position } = _ref;
    (0, _vue.onMounted)(()=>{
        window.addEventListener("touchstart", onTouchstart, {
            passive: true
        });
        window.addEventListener("touchmove", onTouchmove, {
            passive: false
        });
        window.addEventListener("touchend", onTouchend, {
            passive: true
        });
    });
    (0, _vue.onBeforeUnmount)(()=>{
        window.removeEventListener("touchstart", onTouchstart);
        window.removeEventListener("touchmove", onTouchmove);
        window.removeEventListener("touchend", onTouchend);
    });
    const isHorizontal = (0, _vue.computed)(()=>[
            "left",
            "right"
        ].includes(position.value));
    const { addMovement, endTouch, getVelocity } = (0, _touchMjs.useVelocity)();
    let maybeDragging = false;
    const isDragging = (0, _vue.shallowRef)(false);
    const dragProgress = (0, _vue.shallowRef)(0);
    const offset = (0, _vue.shallowRef)(0);
    let start;
    function getOffset(pos, active) {
        return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);
    }
    function getProgress(pos) {
        let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();
        return limit ? Math.max(0, Math.min(1, progress)) : progress;
    }
    function onTouchstart(e) {
        if (touchless.value) return;
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        const touchZone = 25;
        const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
        const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
        if (inTouchZone || inElement || isActive.value && isTemporary.value) {
            maybeDragging = true;
            start = [
                touchX,
                touchY
            ];
            offset.value = getOffset(isHorizontal.value ? touchX : touchY, isActive.value);
            dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
            endTouch(e);
            addMovement(e);
        }
    }
    function onTouchmove(e) {
        const touchX = e.changedTouches[0].clientX;
        const touchY = e.changedTouches[0].clientY;
        if (maybeDragging) {
            if (!e.cancelable) {
                maybeDragging = false;
                return;
            }
            const dx = Math.abs(touchX - start[0]);
            const dy = Math.abs(touchY - start[1]);
            const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
            if (thresholdMet) {
                isDragging.value = true;
                maybeDragging = false;
            } else if ((isHorizontal.value ? dy : dx) > 3) maybeDragging = false;
        }
        if (!isDragging.value) return;
        e.preventDefault();
        addMovement(e);
        const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
        dragProgress.value = Math.max(0, Math.min(1, progress));
        if (progress > 1) offset.value = getOffset(isHorizontal.value ? touchX : touchY, true);
        else if (progress < 0) offset.value = getOffset(isHorizontal.value ? touchX : touchY, false);
    }
    function onTouchend(e) {
        maybeDragging = false;
        if (!isDragging.value) return;
        addMovement(e);
        isDragging.value = false;
        const velocity = getVelocity(e.changedTouches[0].identifier);
        const vx = Math.abs(velocity.x);
        const vy = Math.abs(velocity.y);
        const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
        if (thresholdMet) isActive.value = velocity.direction === (({
            left: "right",
            right: "left",
            top: "down",
            bottom: "up"
        })[position.value] || oops());
        else isActive.value = dragProgress.value > 0.5;
    }
    const dragStyles = (0, _vue.computed)(()=>{
        return isDragging.value ? {
            transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),
            transition: "none"
        } : undefined;
    });
    return {
        isDragging,
        dragProgress,
        dragStyles
    };
}
function oops() {
    throw new Error();
}

},{"../../composables/touch.mjs":"ifRFX","vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ifRFX":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns pointer velocity in px/s
 */ parcelHelpers.export(exports, "calculateImpulseVelocity", ()=>calculateImpulseVelocity);
parcelHelpers.export(exports, "useVelocity", ()=>useVelocity);
var _indexMjs = require("../util/index.mjs");
const HORIZON = 100; // ms
const HISTORY = 20; // number of samples to keep
/** @see https://android.googlesource.com/platform/frameworks/native/+/master/libs/input/VelocityTracker.cpp */ function kineticEnergyToVelocity(work) {
    const sqrt2 = 1.41421356237;
    return (work < 0 ? -1 : 1.0) * Math.sqrt(Math.abs(work)) * sqrt2;
}
function calculateImpulseVelocity(samples) {
    // The input should be in reversed time order (most recent sample at index i=0)
    if (samples.length < 2) // if 0 or 1 points, velocity is zero
    return 0;
    // if (samples[1].t > samples[0].t) {
    //   // Algorithm will still work, but not perfectly
    //   consoleWarn('Samples provided to calculateImpulseVelocity in the wrong order')
    // }
    if (samples.length === 2) {
        // if 2 points, basic linear calculation
        if (samples[1].t === samples[0].t) // consoleWarn(`Events have identical time stamps t=${samples[0].t}, setting velocity = 0`)
        return 0;
        return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
    }
    // Guaranteed to have at least 3 points here
    // start with the oldest sample and go forward in time
    let work = 0;
    for(let i = samples.length - 1; i > 0; i--){
        if (samples[i].t === samples[i - 1].t) continue;
        const vprev = kineticEnergyToVelocity(work); // v[i-1]
        const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t); // v[i]
        work += (vcurr - vprev) * Math.abs(vcurr);
        if (i === samples.length - 1) work *= 0.5;
    }
    return kineticEnergyToVelocity(work) * 1000;
}
function useVelocity() {
    const touches = {};
    function addMovement(e) {
        Array.from(e.changedTouches).forEach((touch)=>{
            const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new (0, _indexMjs.CircularBuffer)(HISTORY));
            samples.push([
                e.timeStamp,
                touch
            ]);
        });
    }
    function endTouch(e) {
        Array.from(e.changedTouches).forEach((touch)=>{
            delete touches[touch.identifier];
        });
    }
    function getVelocity(id) {
        const samples = touches[id]?.values().reverse();
        if (!samples) throw new Error(`No samples for touch id ${id}`);
        const newest = samples[0];
        const x = [];
        const y = [];
        for (const val of samples){
            if (newest[0] - val[0] > HORIZON) break;
            x.push({
                t: val[0],
                d: val[1].clientX
            });
            y.push({
                t: val[0],
                d: val[1].clientY
            });
        }
        return {
            x: calculateImpulseVelocity(x),
            y: calculateImpulseVelocity(y),
            get direction () {
                const { x, y } = this;
                const [absX, absY] = [
                    Math.abs(x),
                    Math.abs(y)
                ];
                return absX > absY && x >= 0 ? "right" : absX > absY && x <= 0 ? "left" : absY > absX && y >= 0 ? "down" : absY > absX && y <= 0 ? "up" : oops();
            }
        };
    }
    return {
        addMovement,
        endTouch,
        getVelocity
    };
}
function oops() {
    throw new Error();
}

},{"../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"fH3GW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VNoSsr", ()=>(0, _vnoSsrMjs.VNoSsr));
var _vnoSsrMjs = require("./VNoSsr.mjs");

},{"./VNoSsr.mjs":"inbcu","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"inbcu":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VNoSsr", ()=>VNoSsr);
var _hydrationMjs = require("../../composables/hydration.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const VNoSsr = (0, _indexMjs.defineComponent)({
    name: "VNoSsr",
    setup (_, _ref) {
        let { slots } = _ref;
        const show = (0, _hydrationMjs.useHydration)();
        return ()=>show.value && slots.default?.();
    }
});

},{"../../composables/hydration.mjs":"jI0s5","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"l82dR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VPagination", ()=>(0, _vpaginationMjs.VPagination));
var _vpaginationMjs = require("./VPagination.mjs");

},{"./VPagination.mjs":"2rvms","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2rvms":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVPaginationProps", ()=>makeVPaginationProps);
parcelHelpers.export(exports, "VPagination", ()=>VPagination);
var _vue = require("vue");
// Styles
var _vpaginationCss = require("./VPagination.css");
// Components
var _indexMjs = require("../VBtn/index.mjs"); // Composables
var _indexMjs1 = require("../../composables/index.mjs");
var _borderMjs = require("../../composables/border.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _refsMjs = require("../../composables/refs.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVPaginationProps = (0, _indexMjs2.propsFactory)({
    activeColor: String,
    start: {
        type: [
            Number,
            String
        ],
        default: 1
    },
    modelValue: {
        type: Number,
        default: (props)=>props.start
    },
    disabled: Boolean,
    length: {
        type: [
            Number,
            String
        ],
        default: 1,
        validator: (val)=>val % 1 === 0
    },
    totalVisible: [
        Number,
        String
    ],
    firstIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$first"
    },
    prevIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$prev"
    },
    nextIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$next"
    },
    lastIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$last"
    },
    ariaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
        type: String,
        default: "..."
    },
    showFirstLastPage: Boolean,
    ...(0, _borderMjs.makeBorderProps)(),
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)({
        tag: "nav"
    }),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "text"
    })
}, "VPagination");
const VPagination = (0, _indexMjs2.genericComponent)()({
    name: "VPagination",
    props: makeVPaginationProps(),
    emits: {
        "update:modelValue": (value)=>true,
        first: (value)=>true,
        prev: (value)=>true,
        next: (value)=>true,
        last: (value)=>true
    },
    setup (props, _ref) {
        let { slots, emit } = _ref;
        const page = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { t, n } = (0, _localeMjs.useLocale)();
        const { isRtl } = (0, _localeMjs.useRtl)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { width } = (0, _indexMjs1.useDisplay)();
        const maxButtons = (0, _vue.shallowRef)(-1);
        (0, _defaultsMjs.provideDefaults)(undefined, {
            scoped: true
        });
        const { resizeRef } = (0, _resizeObserverMjs.useResizeObserver)((entries)=>{
            if (!entries.length) return;
            const { target, contentRect } = entries[0];
            const firstItem = target.querySelector(".v-pagination__list > *");
            if (!firstItem) return;
            const totalWidth = contentRect.width;
            const itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
            maxButtons.value = getMax(totalWidth, itemWidth);
        });
        const length = (0, _vue.computed)(()=>parseInt(props.length, 10));
        const start = (0, _vue.computed)(()=>parseInt(props.start, 10));
        const totalVisible = (0, _vue.computed)(()=>{
            if (props.totalVisible) return parseInt(props.totalVisible, 10);
            else if (maxButtons.value >= 0) return maxButtons.value;
            return getMax(width.value, 58);
        });
        function getMax(totalWidth, itemWidth) {
            const minButtons = props.showFirstLastPage ? 5 : 3;
            return Math.max(0, Math.floor(// Round to two decimal places to avoid floating point errors
            +((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2)));
        }
        const range = (0, _vue.computed)(()=>{
            if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER) return [];
            if (totalVisible.value <= 1) return [
                page.value
            ];
            if (length.value <= totalVisible.value) return (0, _indexMjs2.createRange)(length.value, start.value);
            const even = totalVisible.value % 2 === 0;
            const middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
            const left = even ? middle : middle + 1;
            const right = length.value - middle;
            if (left - page.value >= 0) return [
                ...(0, _indexMjs2.createRange)(Math.max(1, totalVisible.value - 1), start.value),
                props.ellipsis,
                length.value
            ];
            else if (page.value - right >= (even ? 1 : 0)) {
                const rangeLength = totalVisible.value - 1;
                const rangeStart = length.value - rangeLength + start.value;
                return [
                    start.value,
                    props.ellipsis,
                    ...(0, _indexMjs2.createRange)(rangeLength, rangeStart)
                ];
            } else {
                const rangeLength = Math.max(1, totalVisible.value - 3);
                const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
                return [
                    start.value,
                    props.ellipsis,
                    ...(0, _indexMjs2.createRange)(rangeLength, rangeStart),
                    props.ellipsis,
                    length.value
                ];
            }
        });
        // TODO: 'first' | 'prev' | 'next' | 'last' does not work here?
        function setValue(e, value, event) {
            e.preventDefault();
            page.value = value;
            event && emit(event, value);
        }
        const { refs, updateRef } = (0, _refsMjs.useRefs)();
        (0, _defaultsMjs.provideDefaults)({
            VPaginationBtn: {
                color: (0, _vue.toRef)(props, "color"),
                border: (0, _vue.toRef)(props, "border"),
                density: (0, _vue.toRef)(props, "density"),
                size: (0, _vue.toRef)(props, "size"),
                variant: (0, _vue.toRef)(props, "variant"),
                rounded: (0, _vue.toRef)(props, "rounded"),
                elevation: (0, _vue.toRef)(props, "elevation")
            }
        });
        const items = (0, _vue.computed)(()=>{
            return range.value.map((item, index)=>{
                const ref = (e)=>updateRef(e, index);
                if (typeof item === "string") return {
                    isActive: false,
                    key: `ellipsis-${index}`,
                    page: item,
                    props: {
                        ref,
                        ellipsis: true,
                        icon: true,
                        disabled: true
                    }
                };
                else {
                    const isActive = item === page.value;
                    return {
                        isActive,
                        key: item,
                        page: n(item),
                        props: {
                            ref,
                            ellipsis: false,
                            icon: true,
                            disabled: !!props.disabled || +props.length < 2,
                            color: isActive ? props.activeColor : props.color,
                            ariaCurrent: isActive,
                            ariaLabel: t(isActive ? props.currentPageAriaLabel : props.pageAriaLabel, item),
                            onClick: (e)=>setValue(e, item)
                        }
                    };
                }
            });
        });
        const controls = (0, _vue.computed)(()=>{
            const prevDisabled = !!props.disabled || page.value <= start.value;
            const nextDisabled = !!props.disabled || page.value >= start.value + length.value - 1;
            return {
                first: props.showFirstLastPage ? {
                    icon: isRtl.value ? props.lastIcon : props.firstIcon,
                    onClick: (e)=>setValue(e, start.value, "first"),
                    disabled: prevDisabled,
                    ariaLabel: t(props.firstAriaLabel),
                    ariaDisabled: prevDisabled
                } : undefined,
                prev: {
                    icon: isRtl.value ? props.nextIcon : props.prevIcon,
                    onClick: (e)=>setValue(e, page.value - 1, "prev"),
                    disabled: prevDisabled,
                    ariaLabel: t(props.previousAriaLabel),
                    ariaDisabled: prevDisabled
                },
                next: {
                    icon: isRtl.value ? props.prevIcon : props.nextIcon,
                    onClick: (e)=>setValue(e, page.value + 1, "next"),
                    disabled: nextDisabled,
                    ariaLabel: t(props.nextAriaLabel),
                    ariaDisabled: nextDisabled
                },
                last: props.showFirstLastPage ? {
                    icon: isRtl.value ? props.firstIcon : props.lastIcon,
                    onClick: (e)=>setValue(e, start.value + length.value - 1, "last"),
                    disabled: nextDisabled,
                    ariaLabel: t(props.lastAriaLabel),
                    ariaDisabled: nextDisabled
                } : undefined
            };
        });
        function updateFocus() {
            const currentIndex = page.value - start.value;
            refs.value[currentIndex]?.$el.focus();
        }
        function onKeydown(e) {
            if (e.key === (0, _indexMjs2.keyValues).left && !props.disabled && page.value > +props.start) {
                page.value = page.value - 1;
                (0, _vue.nextTick)(updateFocus);
            } else if (e.key === (0, _indexMjs2.keyValues).right && !props.disabled && page.value < start.value + length.value - 1) {
                page.value = page.value + 1;
                (0, _vue.nextTick)(updateFocus);
            }
        }
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "ref": resizeRef,
                "class": [
                    "v-pagination",
                    themeClasses.value,
                    props.class
                ],
                "style": props.style,
                "role": "navigation",
                "aria-label": t(props.ariaLabel),
                "onKeydown": onKeydown,
                "data-test": "v-pagination-root"
            }, {
                default: ()=>[
                        (0, _vue.createVNode)("ul", {
                            "class": "v-pagination__list"
                        }, [
                            props.showFirstLastPage && (0, _vue.createVNode)("li", {
                                "key": "first",
                                "class": "v-pagination__first",
                                "data-test": "v-pagination-first"
                            }, [
                                slots.first ? slots.first(controls.value.first) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                    "_as": "VPaginationBtn"
                                }, controls.value.first), null)
                            ]),
                            (0, _vue.createVNode)("li", {
                                "key": "prev",
                                "class": "v-pagination__prev",
                                "data-test": "v-pagination-prev"
                            }, [
                                slots.prev ? slots.prev(controls.value.prev) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                    "_as": "VPaginationBtn"
                                }, controls.value.prev), null)
                            ]),
                            items.value.map((item, index)=>(0, _vue.createVNode)("li", {
                                    "key": item.key,
                                    "class": [
                                        "v-pagination__item",
                                        {
                                            "v-pagination__item--is-active": item.isActive
                                        }
                                    ],
                                    "data-test": "v-pagination-item"
                                }, [
                                    slots.item ? slots.item(item) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                        "_as": "VPaginationBtn"
                                    }, item.props), {
                                        default: ()=>[
                                                item.page
                                            ]
                                    })
                                ])),
                            (0, _vue.createVNode)("li", {
                                "key": "next",
                                "class": "v-pagination__next",
                                "data-test": "v-pagination-next"
                            }, [
                                slots.next ? slots.next(controls.value.next) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                    "_as": "VPaginationBtn"
                                }, controls.value.next), null)
                            ]),
                            props.showFirstLastPage && (0, _vue.createVNode)("li", {
                                "key": "last",
                                "class": "v-pagination__last",
                                "data-test": "v-pagination-last"
                            }, [
                                slots.last ? slots.last(controls.value.last) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                                    "_as": "VPaginationBtn"
                                }, controls.value.last), null)
                            ])
                        ])
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VPagination.css":"ftuyG","../VBtn/index.mjs":"7xV1x","../../composables/index.mjs":"lUqcD","../../composables/border.mjs":"3nPTz","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/refs.mjs":"gI2oc","../../composables/resizeObserver.mjs":"byLTu","../../composables/rounded.mjs":"ldhZ9","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ftuyG":[function() {},{}],"gI2oc":[function(require,module,exports) {
// Utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Types
parcelHelpers.export(exports, "useRefs", ()=>useRefs);
var _vue = require("vue");
function useRefs() {
    const refs = (0, _vue.ref)([]);
    (0, _vue.onBeforeUpdate)(()=>refs.value = []);
    function updateRef(e, i) {
        refs.value[i] = e;
    }
    return {
        refs,
        updateRef
    };
}

},{"vue":"ff77s","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"lFFWx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VParallax", ()=>(0, _vparallaxMjs.VParallax));
var _vparallaxMjs = require("./VParallax.mjs");

},{"./VParallax.mjs":"4uWGA","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4uWGA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVParallaxProps", ()=>makeVParallaxProps);
parcelHelpers.export(exports, "VParallax", ()=>VParallax);
var _vue = require("vue");
// Styles
var _vparallaxCss = require("./VParallax.css");
// Components
var _indexMjs = require("../VImg/index.mjs"); // Composables
var _indexMjs1 = require("../../composables/index.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _intersectionObserverMjs = require("../../composables/intersectionObserver.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
function floor(val) {
    return Math.floor(Math.abs(val)) * Math.sign(val);
}
const makeVParallaxProps = (0, _indexMjs2.propsFactory)({
    scale: {
        type: [
            Number,
            String
        ],
        default: 0.5
    },
    ...(0, _componentMjs.makeComponentProps)()
}, "VParallax");
const VParallax = (0, _indexMjs2.genericComponent)()({
    name: "VParallax",
    props: makeVParallaxProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { intersectionRef, isIntersecting } = (0, _intersectionObserverMjs.useIntersectionObserver)();
        const { resizeRef, contentRect } = (0, _resizeObserverMjs.useResizeObserver)();
        const { height: displayHeight } = (0, _indexMjs1.useDisplay)();
        const root = (0, _vue.ref)();
        (0, _vue.watchEffect)(()=>{
            intersectionRef.value = resizeRef.value = root.value?.$el;
        });
        let scrollParent;
        (0, _vue.watch)(isIntersecting, (val)=>{
            if (val) {
                scrollParent = (0, _indexMjs2.getScrollParent)(intersectionRef.value);
                scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;
                scrollParent.addEventListener("scroll", onScroll, {
                    passive: true
                });
                onScroll();
            } else scrollParent.removeEventListener("scroll", onScroll);
        });
        (0, _vue.onBeforeUnmount)(()=>{
            scrollParent?.removeEventListener("scroll", onScroll);
        });
        (0, _vue.watch)(displayHeight, onScroll);
        (0, _vue.watch)(()=>contentRect.value?.height, onScroll);
        const scale = (0, _vue.computed)(()=>{
            return 1 - (0, _indexMjs2.clamp)(+props.scale);
        });
        let frame = -1;
        function onScroll() {
            if (!isIntersecting.value) return;
            cancelAnimationFrame(frame);
            frame = requestAnimationFrame(()=>{
                const el = root.value?.$el.querySelector(".v-img__img");
                if (!el) return;
                const scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;
                const scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;
                const top = intersectionRef.value.getBoundingClientRect().top + scrollPos;
                const height = contentRect.value.height;
                const center = top + (height - scrollHeight) / 2;
                const translate = floor((scrollPos - center) * scale.value);
                const sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);
                el.style.setProperty("transform", `translateY(${translate}px) scale(${sizeScale})`);
            });
        }
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)((0, _indexMjs.VImg), {
                "class": [
                    "v-parallax",
                    {
                        "v-parallax--active": isIntersecting.value
                    },
                    props.class
                ],
                "style": props.style,
                "ref": root,
                "cover": true,
                "onLoadstart": onScroll,
                "onLoad": onScroll
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VParallax.css":"hQtlU","../VImg/index.mjs":"87IoX","../../composables/index.mjs":"lUqcD","../../composables/component.mjs":"jVHld","../../composables/intersectionObserver.mjs":"2yOLq","../../composables/resizeObserver.mjs":"byLTu","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hQtlU":[function() {},{}],"eeYly":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VRadio", ()=>(0, _vradioMjs.VRadio));
var _vradioMjs = require("./VRadio.mjs");

},{"./VRadio.mjs":"2VD8z","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2VD8z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVRadioProps", ()=>makeVRadioProps);
parcelHelpers.export(exports, "VRadio", ()=>VRadio);
var _vue = require("vue");
// Components
var _vselectionControlMjs = require("../VSelectionControl/VSelectionControl.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVRadioProps = (0, _indexMjs.propsFactory)({
    ...(0, _vselectionControlMjs.makeVSelectionControlProps)({
        falseIcon: "$radioOff",
        trueIcon: "$radioOn"
    })
}, "VRadio");
const VRadio = (0, _indexMjs.genericComponent)()({
    name: "VRadio",
    props: makeVRadioProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)((0, _vselectionControlMjs.VSelectionControl), (0, _vue.mergeProps)(props, {
                "class": [
                    "v-radio",
                    props.class
                ],
                "style": props.style,
                "type": "radio"
            }), slots));
        return {};
    }
});

},{"vue":"ff77s","../VSelectionControl/VSelectionControl.mjs":"1j5Xu","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cgoyM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VRadioGroup", ()=>(0, _vradioGroupMjs.VRadioGroup));
var _vradioGroupMjs = require("./VRadioGroup.mjs");

},{"./VRadioGroup.mjs":"hFASO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hFASO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVRadioGroupProps", ()=>makeVRadioGroupProps);
parcelHelpers.export(exports, "VRadioGroup", ()=>VRadioGroup);
var _vue = require("vue");
// Styles
var _vradioGroupCss = require("./VRadioGroup.css");
// Components
var _vinputMjs = require("../VInput/VInput.mjs");
var _indexMjs = require("../VLabel/index.mjs");
var _indexMjs1 = require("../VSelectionControl/index.mjs");
var _vselectionControlGroupMjs = require("../VSelectionControlGroup/VSelectionControlGroup.mjs"); // Composables
var _iconsMjs = require("../../composables/icons.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVRadioGroupProps = (0, _indexMjs2.propsFactory)({
    height: {
        type: [
            Number,
            String
        ],
        default: "auto"
    },
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _indexMjs2.omit)((0, _vselectionControlGroupMjs.makeSelectionControlGroupProps)(), [
        "multiple"
    ]),
    trueIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$radioOn"
    },
    falseIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$radioOff"
    },
    type: {
        type: String,
        default: "radio"
    }
}, "VRadioGroup");
const VRadioGroup = (0, _indexMjs2.genericComponent)()({
    name: "VRadioGroup",
    inheritAttrs: false,
    props: makeVRadioGroupProps(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const uid = (0, _indexMjs2.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `radio-group-${uid}`);
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        (0, _indexMjs2.useRender)(()=>{
            const [rootAttrs, controlAttrs] = (0, _indexMjs2.filterInputAttrs)(attrs);
            const [inputProps, _1] = (0, _vinputMjs.VInput).filterProps(props);
            const [controlProps, _2] = (0, _indexMjs1.VSelectionControl).filterProps(props);
            const label = slots.label ? slots.label({
                label: props.label,
                props: {
                    for: id.value
                }
            }) : props.label;
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "class": [
                    "v-radio-group",
                    props.class
                ],
                "style": props.style
            }, rootAttrs, inputProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "id": id.value
            }), {
                ...slots,
                default: (_ref2)=>{
                    let { id, messagesId, isDisabled, isReadonly } = _ref2;
                    return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                        label && (0, _vue.createVNode)((0, _indexMjs.VLabel), {
                            "id": id.value
                        }, {
                            default: ()=>[
                                    label
                                ]
                        }),
                        (0, _vue.createVNode)((0, _vselectionControlGroupMjs.VSelectionControlGroup), (0, _vue.mergeProps)(controlProps, {
                            "id": id.value,
                            "aria-describedby": messagesId.value,
                            "defaultsTarget": "VRadio",
                            "trueIcon": props.trueIcon,
                            "falseIcon": props.falseIcon,
                            "type": props.type,
                            "disabled": isDisabled.value,
                            "readonly": isReadonly.value,
                            "aria-labelledby": label ? id.value : undefined,
                            "multiple": false
                        }, controlAttrs, {
                            "modelValue": model.value,
                            "onUpdate:modelValue": ($event)=>model.value = $event
                        }), slots)
                    ]);
                }
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VRadioGroup.css":"8eGUP","../VInput/VInput.mjs":"1hyGZ","../VLabel/index.mjs":"cclAn","../VSelectionControl/index.mjs":"e5hfd","../VSelectionControlGroup/VSelectionControlGroup.mjs":"2SCkF","../../composables/icons.mjs":"ezwoc","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8eGUP":[function() {},{}],"e5hfd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSelectionControl", ()=>(0, _vselectionControlMjs.VSelectionControl));
var _vselectionControlMjs = require("./VSelectionControl.mjs");

},{"./VSelectionControl.mjs":"1j5Xu","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"3DspP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VRangeSlider", ()=>(0, _vrangeSliderMjs.VRangeSlider));
var _vrangeSliderMjs = require("./VRangeSlider.mjs");

},{"./VRangeSlider.mjs":"7YGcI","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7YGcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVRangeSliderProps", ()=>makeVRangeSliderProps);
parcelHelpers.export(exports, "VRangeSlider", ()=>VRangeSlider);
var _vue = require("vue");
// Styles
var _vsliderCss = require("../VSlider/VSlider.css");
// Components
var _vinputMjs = require("../VInput/VInput.mjs");
var _indexMjs = require("../VLabel/index.mjs");
var _sliderMjs = require("../VSlider/slider.mjs");
var _vsliderThumbMjs = require("../VSlider/VSliderThumb.mjs");
var _vsliderTrackMjs = require("../VSlider/VSliderTrack.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVRangeSliderProps = (0, _indexMjs1.propsFactory)({
    ...(0, _focusMjs.makeFocusProps)(),
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _sliderMjs.makeSliderProps)(),
    strict: Boolean,
    modelValue: {
        type: Array,
        default: ()=>[
                0,
                0
            ]
    }
}, "VRangeSlider");
const VRangeSlider = (0, _indexMjs1.genericComponent)()({
    name: "VRangeSlider",
    props: makeVRangeSliderProps(),
    emits: {
        "update:focused": (value)=>true,
        "update:modelValue": (value)=>true,
        end: (value)=>true,
        start: (value)=>true
    },
    setup (props, _ref) {
        let { slots, emit } = _ref;
        const startThumbRef = (0, _vue.ref)();
        const stopThumbRef = (0, _vue.ref)();
        const inputRef = (0, _vue.ref)();
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        function getActiveThumb(e) {
            if (!startThumbRef.value || !stopThumbRef.value) return;
            const startOffset = (0, _sliderMjs.getOffset)(e, startThumbRef.value.$el, props.direction);
            const stopOffset = (0, _sliderMjs.getOffset)(e, stopThumbRef.value.$el, props.direction);
            const a = Math.abs(startOffset);
            const b = Math.abs(stopOffset);
            return a < b || a === b && startOffset < 0 ? startThumbRef.value.$el : stopThumbRef.value.$el;
        }
        const steps = (0, _sliderMjs.useSteps)(props);
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue", undefined, (arr)=>{
            if (!arr?.length) return [
                0,
                0
            ];
            return arr.map((value)=>steps.roundValue(value));
        });
        const { activeThumbRef, hasLabels, max, min, mousePressed, onSliderMousedown, onSliderTouchstart, position, trackContainerRef } = (0, _sliderMjs.useSlider)({
            props,
            steps,
            onSliderStart: ()=>{
                emit("start", model.value);
            },
            onSliderEnd: (_ref2)=>{
                let { value } = _ref2;
                const newValue = activeThumbRef.value === startThumbRef.value?.$el ? [
                    value,
                    model.value[1]
                ] : [
                    model.value[0],
                    value
                ];
                if (!props.strict && newValue[0] < newValue[1]) model.value = newValue;
                emit("end", model.value);
            },
            onSliderMove: (_ref3)=>{
                let { value } = _ref3;
                const [start, stop] = model.value;
                if (!props.strict && start === stop && start !== min.value) {
                    activeThumbRef.value = value > start ? stopThumbRef.value?.$el : startThumbRef.value?.$el;
                    activeThumbRef.value?.focus();
                }
                if (activeThumbRef.value === startThumbRef.value?.$el) model.value = [
                    Math.min(value, stop),
                    stop
                ];
                else model.value = [
                    start,
                    Math.max(start, value)
                ];
            },
            getActiveThumb
        });
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const trackStart = (0, _vue.computed)(()=>position(model.value[0]));
        const trackStop = (0, _vue.computed)(()=>position(model.value[1]));
        (0, _indexMjs1.useRender)(()=>{
            const [inputProps, _] = (0, _vinputMjs.VInput).filterProps(props);
            const hasPrepend = !!(props.label || slots.label || slots.prepend);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "class": [
                    "v-slider",
                    "v-range-slider",
                    {
                        "v-slider--has-labels": !!slots["tick-label"] || hasLabels.value,
                        "v-slider--focused": isFocused.value,
                        "v-slider--pressed": mousePressed.value,
                        "v-slider--disabled": props.disabled
                    },
                    rtlClasses.value,
                    props.class
                ],
                "style": props.style,
                "ref": inputRef
            }, inputProps, {
                "focused": isFocused.value
            }), {
                ...slots,
                prepend: hasPrepend ? (slotProps)=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots.label?.(slotProps) ?? props.label ? (0, _vue.createVNode)((0, _indexMjs.VLabel), {
                            "class": "v-slider__label",
                            "text": props.label
                        }, null) : undefined,
                        slots.prepend?.(slotProps)
                    ]) : undefined,
                default: (_ref4)=>{
                    let { id, messagesId } = _ref4;
                    return (0, _vue.createVNode)("div", {
                        "class": "v-slider__container",
                        "onMousedown": onSliderMousedown,
                        "onTouchstartPassive": onSliderTouchstart
                    }, [
                        (0, _vue.createVNode)("input", {
                            "id": `${id.value}_start`,
                            "name": props.name || id.value,
                            "disabled": !!props.disabled,
                            "readonly": !!props.readonly,
                            "tabindex": "-1",
                            "value": model.value[0]
                        }, null),
                        (0, _vue.createVNode)("input", {
                            "id": `${id.value}_stop`,
                            "name": props.name || id.value,
                            "disabled": !!props.disabled,
                            "readonly": !!props.readonly,
                            "tabindex": "-1",
                            "value": model.value[1]
                        }, null),
                        (0, _vue.createVNode)((0, _vsliderTrackMjs.VSliderTrack), {
                            "ref": trackContainerRef,
                            "start": trackStart.value,
                            "stop": trackStop.value
                        }, {
                            "tick-label": slots["tick-label"]
                        }),
                        (0, _vue.createVNode)((0, _vsliderThumbMjs.VSliderThumb), {
                            "ref": startThumbRef,
                            "aria-describedby": messagesId.value,
                            "focused": isFocused && activeThumbRef.value === startThumbRef.value?.$el,
                            "modelValue": model.value[0],
                            "onUpdate:modelValue": (v)=>model.value = [
                                    v,
                                    model.value[1]
                                ],
                            "onFocus": (e)=>{
                                focus();
                                activeThumbRef.value = startThumbRef.value?.$el;
                                // Make sure second thumb is focused if
                                // the thumbs are on top of each other
                                // and they are both at minimum value
                                // but only if focused from outside.
                                if (model.value[0] === model.value[1] && model.value[1] === min.value && e.relatedTarget !== stopThumbRef.value?.$el) {
                                    startThumbRef.value?.$el.blur();
                                    stopThumbRef.value?.$el.focus();
                                }
                            },
                            "onBlur": ()=>{
                                blur();
                                activeThumbRef.value = undefined;
                            },
                            "min": min.value,
                            "max": model.value[1],
                            "position": trackStart.value
                        }, {
                            "thumb-label": slots["thumb-label"]
                        }),
                        (0, _vue.createVNode)((0, _vsliderThumbMjs.VSliderThumb), {
                            "ref": stopThumbRef,
                            "aria-describedby": messagesId.value,
                            "focused": isFocused && activeThumbRef.value === stopThumbRef.value?.$el,
                            "modelValue": model.value[1],
                            "onUpdate:modelValue": (v)=>model.value = [
                                    model.value[0],
                                    v
                                ],
                            "onFocus": (e)=>{
                                focus();
                                activeThumbRef.value = stopThumbRef.value?.$el;
                                // Make sure first thumb is focused if
                                // the thumbs are on top of each other
                                // and they are both at maximum value
                                // but only if focused from outside.
                                if (model.value[0] === model.value[1] && model.value[0] === max.value && e.relatedTarget !== startThumbRef.value?.$el) {
                                    stopThumbRef.value?.$el.blur();
                                    startThumbRef.value?.$el.focus();
                                }
                            },
                            "onBlur": ()=>{
                                blur();
                                activeThumbRef.value = undefined;
                            },
                            "min": model.value[0],
                            "max": max.value,
                            "position": trackStop.value
                        }, {
                            "thumb-label": slots["thumb-label"]
                        })
                    ]);
                }
            });
        });
        return {};
    }
});

},{"vue":"ff77s","../VSlider/VSlider.css":"dkVqj","../VInput/VInput.mjs":"1hyGZ","../VLabel/index.mjs":"cclAn","../VSlider/slider.mjs":"6FCha","../VSlider/VSliderThumb.mjs":"ilHYH","../VSlider/VSliderTrack.mjs":"eZdmp","../../composables/focus.mjs":"1bQxY","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dkVqj":[function() {},{}],"aoL48":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VRating", ()=>(0, _vratingMjs.VRating));
var _vratingMjs = require("./VRating.mjs");

},{"./VRating.mjs":"5UP3Q","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5UP3Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVRatingProps", ()=>makeVRatingProps);
parcelHelpers.export(exports, "VRating", ()=>VRating);
var _vue = require("vue");
// Styles
var _vratingCss = require("./VRating.css");
// Components
var _indexMjs = require("../VBtn/index.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVRatingProps = (0, _indexMjs1.propsFactory)({
    name: String,
    itemAriaLabel: {
        type: String,
        default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$ratingEmpty"
    },
    fullIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
        type: [
            Number,
            String
        ],
        default: 5
    },
    readonly: Boolean,
    modelValue: {
        type: [
            Number,
            String
        ],
        default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
        type: String,
        default: "top",
        validator: (v)=>[
                "top",
                "bottom"
            ].includes(v)
    },
    ripple: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VRating");
const VRating = (0, _indexMjs1.genericComponent)()({
    name: "VRating",
    props: makeVRatingProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { t } = (0, _localeMjs.useLocale)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const rating = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const normalizedValue = (0, _vue.computed)(()=>(0, _indexMjs1.clamp)(parseFloat(rating.value), 0, +props.length));
        const range = (0, _vue.computed)(()=>(0, _indexMjs1.createRange)(Number(props.length), 1));
        const increments = (0, _vue.computed)(()=>range.value.flatMap((v)=>props.halfIncrements ? [
                    v - 0.5,
                    v
                ] : [
                    v
                ]));
        const hoverIndex = (0, _vue.shallowRef)(-1);
        const itemState = (0, _vue.computed)(()=>increments.value.map((value)=>{
                const isHovering = props.hover && hoverIndex.value > -1;
                const isFilled = normalizedValue.value >= value;
                const isHovered = hoverIndex.value >= value;
                const isFullIcon = isHovering ? isHovered : isFilled;
                const icon = isFullIcon ? props.fullIcon : props.emptyIcon;
                const activeColor = props.activeColor ?? props.color;
                const color = isFilled || isHovered ? activeColor : props.color;
                return {
                    isFilled,
                    isHovered,
                    icon,
                    color
                };
            }));
        const eventState = (0, _vue.computed)(()=>[
                0,
                ...increments.value
            ].map((value)=>{
                function onMouseenter() {
                    hoverIndex.value = value;
                }
                function onMouseleave() {
                    hoverIndex.value = -1;
                }
                function onClick() {
                    if (props.disabled || props.readonly) return;
                    rating.value = normalizedValue.value === value && props.clearable ? 0 : value;
                }
                return {
                    onMouseenter: props.hover ? onMouseenter : undefined,
                    onMouseleave: props.hover ? onMouseleave : undefined,
                    onClick
                };
            }));
        const name = (0, _vue.computed)(()=>props.name ?? `v-rating-${(0, _indexMjs1.getUid)()}`);
        function VRatingItem(_ref2) {
            let { value, index, showStar = true } = _ref2;
            const { onMouseenter, onMouseleave, onClick } = eventState.value[index + 1];
            const id = `${name.value}-${String(value).replace(".", "-")}`;
            const btnProps = {
                color: itemState.value[index]?.color,
                density: props.density,
                disabled: props.disabled,
                icon: itemState.value[index]?.icon,
                ripple: props.ripple,
                size: props.size,
                variant: "plain"
            };
            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                (0, _vue.createVNode)("label", {
                    "for": id,
                    "class": {
                        "v-rating__item--half": props.halfIncrements && value % 1 > 0,
                        "v-rating__item--full": props.halfIncrements && value % 1 === 0
                    },
                    "onMouseenter": onMouseenter,
                    "onMouseleave": onMouseleave,
                    "onClick": onClick
                }, [
                    (0, _vue.createVNode)("span", {
                        "class": "v-rating__hidden"
                    }, [
                        t(props.itemAriaLabel, value, props.length)
                    ]),
                    !showStar ? undefined : slots.item ? slots.item({
                        ...itemState.value[index],
                        props: btnProps,
                        value,
                        index,
                        rating: normalizedValue.value
                    }) : (0, _vue.createVNode)((0, _indexMjs.VBtn), (0, _vue.mergeProps)({
                        "aria-label": t(props.itemAriaLabel, value, props.length)
                    }, btnProps), null)
                ]),
                (0, _vue.createVNode)("input", {
                    "class": "v-rating__hidden",
                    "name": name.value,
                    "id": id,
                    "type": "radio",
                    "value": value,
                    "checked": normalizedValue.value === value,
                    "tabindex": -1,
                    "readonly": props.readonly,
                    "disabled": props.disabled
                }, null)
            ]);
        }
        function createLabel(labelProps) {
            if (slots["item-label"]) return slots["item-label"](labelProps);
            if (labelProps.label) return (0, _vue.createVNode)("span", null, [
                labelProps.label
            ]);
            return (0, _vue.createVNode)("span", null, [
                (0, _vue.createTextVNode)("\xa0")
            ]);
        }
        (0, _indexMjs1.useRender)(()=>{
            const hasLabels = !!props.itemLabels?.length || slots["item-label"];
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-rating",
                    {
                        "v-rating--hover": props.hover,
                        "v-rating--readonly": props.readonly
                    },
                    themeClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        (0, _vue.createVNode)(VRatingItem, {
                            "value": 0,
                            "index": -1,
                            "showStar": false
                        }, null),
                        range.value.map((value, i)=>(0, _vue.createVNode)("div", {
                                "class": "v-rating__wrapper"
                            }, [
                                hasLabels && props.itemLabelPosition === "top" ? createLabel({
                                    value,
                                    index: i,
                                    label: props.itemLabels?.[i]
                                }) : undefined,
                                (0, _vue.createVNode)("div", {
                                    "class": "v-rating__item"
                                }, [
                                    props.halfIncrements ? (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                        (0, _vue.createVNode)(VRatingItem, {
                                            "value": value - 0.5,
                                            "index": i * 2
                                        }, null),
                                        (0, _vue.createVNode)(VRatingItem, {
                                            "value": value,
                                            "index": i * 2 + 1
                                        }, null)
                                    ]) : (0, _vue.createVNode)(VRatingItem, {
                                        "value": value,
                                        "index": i
                                    }, null)
                                ]),
                                hasLabels && props.itemLabelPosition === "bottom" ? createLabel({
                                    value,
                                    index: i,
                                    label: props.itemLabels?.[i]
                                }) : undefined
                            ]))
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VRating.css":"9H4iv","../VBtn/index.mjs":"7xV1x","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/proxiedModel.mjs":"bUF28","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9H4iv":[function() {},{}],"kOixX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VResponsive", ()=>(0, _vresponsiveMjs.VResponsive));
var _vresponsiveMjs = require("./VResponsive.mjs");

},{"./VResponsive.mjs":"jzmwG","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"jMuFA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSelect", ()=>(0, _vselectMjs.VSelect));
var _vselectMjs = require("./VSelect.mjs");

},{"./VSelect.mjs":"dHfP6","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aTTRm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSelectionControlGroup", ()=>(0, _vselectionControlGroupMjs.VSelectionControlGroup));
var _vselectionControlGroupMjs = require("./VSelectionControlGroup.mjs");

},{"./VSelectionControlGroup.mjs":"2SCkF","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4Lo8P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSheet", ()=>(0, _vsheetMjs.VSheet));
var _vsheetMjs = require("./VSheet.mjs");

},{"./VSheet.mjs":"5AMLv","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5SDTw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSlideGroup", ()=>(0, _vslideGroupMjs.VSlideGroup));
parcelHelpers.export(exports, "VSlideGroupItem", ()=>(0, _vslideGroupItemMjs.VSlideGroupItem));
var _vslideGroupMjs = require("./VSlideGroup.mjs");
var _vslideGroupItemMjs = require("./VSlideGroupItem.mjs");

},{"./VSlideGroup.mjs":"gMPfk","./VSlideGroupItem.mjs":"5dXzO","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gMPfk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSlideGroupSymbol", ()=>VSlideGroupSymbol);
parcelHelpers.export(exports, "makeVSlideGroupProps", ()=>makeVSlideGroupProps);
parcelHelpers.export(exports, "VSlideGroup", ()=>VSlideGroup);
var _vue = require("vue");
// Styles
var _vslideGroupCss = require("./VSlideGroup.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VIcon/index.mjs"); // Composables
var _indexMjs2 = require("../../composables/index.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _groupMjs = require("../../composables/group.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _resizeObserverMjs = require("../../composables/resizeObserver.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _helpersMjs = require("./helpers.mjs");
var _indexMjs3 = require("../../util/index.mjs"); // Types
const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
const makeVSlideGroupProps = (0, _indexMjs3.propsFactory)({
    centerActive: Boolean,
    direction: {
        type: String,
        default: "horizontal"
    },
    symbol: {
        type: null,
        default: VSlideGroupSymbol
    },
    nextIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$next"
    },
    prevIcon: {
        type: (0, _iconsMjs.IconValue),
        default: "$prev"
    },
    showArrows: {
        type: [
            Boolean,
            String
        ],
        validator: (v)=>typeof v === "boolean" || [
                "always",
                "desktop",
                "mobile"
            ].includes(v)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _groupMjs.makeGroupProps)({
        selectedClass: "v-slide-group-item--active"
    })
}, "VSlideGroup");
const VSlideGroup = (0, _indexMjs3.genericComponent)()({
    name: "VSlideGroup",
    props: makeVSlideGroupProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const { isRtl } = (0, _localeMjs.useRtl)();
        const { mobile } = (0, _indexMjs2.useDisplay)();
        const group = (0, _groupMjs.useGroup)(props, props.symbol);
        const isOverflowing = (0, _vue.shallowRef)(false);
        const scrollOffset = (0, _vue.shallowRef)(0);
        const containerSize = (0, _vue.shallowRef)(0);
        const contentSize = (0, _vue.shallowRef)(0);
        const isHorizontal = (0, _vue.computed)(()=>props.direction === "horizontal");
        const { resizeRef: containerRef, contentRect: containerRect } = (0, _resizeObserverMjs.useResizeObserver)();
        const { resizeRef: contentRef, contentRect } = (0, _resizeObserverMjs.useResizeObserver)();
        const firstSelectedIndex = (0, _vue.computed)(()=>{
            if (!group.selected.value.length) return -1;
            return group.items.value.findIndex((item)=>item.id === group.selected.value[0]);
        });
        const lastSelectedIndex = (0, _vue.computed)(()=>{
            if (!group.selected.value.length) return -1;
            return group.items.value.findIndex((item)=>item.id === group.selected.value[group.selected.value.length - 1]);
        });
        if (0, _indexMjs3.IN_BROWSER) {
            let frame = -1;
            (0, _vue.watch)(()=>[
                    group.selected.value,
                    containerRect.value,
                    contentRect.value,
                    isHorizontal.value
                ], ()=>{
                cancelAnimationFrame(frame);
                frame = requestAnimationFrame(()=>{
                    if (containerRect.value && contentRect.value) {
                        const sizeProperty = isHorizontal.value ? "width" : "height";
                        containerSize.value = containerRect.value[sizeProperty];
                        contentSize.value = contentRect.value[sizeProperty];
                        isOverflowing.value = containerSize.value + 1 < contentSize.value;
                    }
                    if (firstSelectedIndex.value >= 0 && contentRef.value) {
                        // TODO: Is this too naive? Should we store element references in group composable?
                        const selectedElement = contentRef.value.children[lastSelectedIndex.value];
                        if (firstSelectedIndex.value === 0 || !isOverflowing.value) scrollOffset.value = 0;
                        else if (props.centerActive) scrollOffset.value = (0, _helpersMjs.calculateCenteredOffset)({
                            selectedElement,
                            containerSize: containerSize.value,
                            contentSize: contentSize.value,
                            isRtl: isRtl.value,
                            isHorizontal: isHorizontal.value
                        });
                        else if (isOverflowing.value) scrollOffset.value = (0, _helpersMjs.calculateUpdatedOffset)({
                            selectedElement,
                            containerSize: containerSize.value,
                            contentSize: contentSize.value,
                            isRtl: isRtl.value,
                            currentScrollOffset: scrollOffset.value,
                            isHorizontal: isHorizontal.value
                        });
                    }
                });
            });
        }
        const disableTransition = (0, _vue.shallowRef)(false);
        let startTouch = 0;
        let startOffset = 0;
        function onTouchstart(e) {
            const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
            const sign = isRtl.value && isHorizontal.value ? -1 : 1;
            startOffset = sign * scrollOffset.value;
            startTouch = e.touches[0][sizeProperty];
            disableTransition.value = true;
        }
        function onTouchmove(e) {
            if (!isOverflowing.value) return;
            const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
            const sign = isRtl.value && isHorizontal.value ? -1 : 1;
            scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);
        }
        function onTouchend(e) {
            const maxScrollOffset = contentSize.value - containerSize.value;
            if (scrollOffset.value < 0 || !isOverflowing.value) scrollOffset.value = 0;
            else if (scrollOffset.value >= maxScrollOffset) scrollOffset.value = maxScrollOffset;
            disableTransition.value = false;
        }
        function onScroll() {
            if (!containerRef.value) return;
            containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
        }
        const isFocused = (0, _vue.shallowRef)(false);
        function onFocusin(e) {
            isFocused.value = true;
            if (!isOverflowing.value || !contentRef.value) return;
            // Focused element is likely to be the root of an item, so a
            // breadth-first search will probably find it in the first iteration
            for (const el of e.composedPath()){
                for (const item of contentRef.value.children)if (item === el) {
                    scrollOffset.value = (0, _helpersMjs.calculateUpdatedOffset)({
                        selectedElement: item,
                        containerSize: containerSize.value,
                        contentSize: contentSize.value,
                        isRtl: isRtl.value,
                        currentScrollOffset: scrollOffset.value,
                        isHorizontal: isHorizontal.value
                    });
                    return;
                }
            }
        }
        function onFocusout(e) {
            isFocused.value = false;
        }
        function onFocus(e) {
            if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget))) focus();
        }
        function onKeydown(e) {
            if (!contentRef.value) return;
            if (isHorizontal.value) {
                if (e.key === "ArrowRight") focus(isRtl.value ? "prev" : "next");
                else if (e.key === "ArrowLeft") focus(isRtl.value ? "next" : "prev");
            } else {
                if (e.key === "ArrowDown") focus("next");
                else if (e.key === "ArrowUp") focus("prev");
            }
            if (e.key === "Home") focus("first");
            else if (e.key === "End") focus("last");
        }
        function focus(location) {
            if (!contentRef.value) return;
            if (!location) {
                const focusable = (0, _indexMjs3.focusableChildren)(contentRef.value);
                focusable[0]?.focus();
            } else if (location === "next") {
                const el = contentRef.value.querySelector(":focus")?.nextElementSibling;
                if (el) el.focus();
                else focus("first");
            } else if (location === "prev") {
                const el = contentRef.value.querySelector(":focus")?.previousElementSibling;
                if (el) el.focus();
                else focus("last");
            } else if (location === "first") contentRef.value.firstElementChild?.focus();
            else if (location === "last") contentRef.value.lastElementChild?.focus();
        }
        function scrollTo(location) {
            const newAbsoluteOffset = scrollOffset.value + (location === "prev" ? -1 : 1) * containerSize.value;
            scrollOffset.value = (0, _indexMjs3.clamp)(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
        }
        const contentStyles = (0, _vue.computed)(()=>{
            // This adds friction when scrolling the 'wrong' way when at max offset
            let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + (0, _helpersMjs.bias)(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
            // This adds friction when scrolling the 'wrong' way when at min offset
            if (scrollOffset.value <= 0) scrollAmount = (0, _helpersMjs.bias)(-scrollOffset.value);
            const sign = isRtl.value && isHorizontal.value ? -1 : 1;
            return {
                transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign * scrollAmount}px)`,
                transition: disableTransition.value ? "none" : "",
                willChange: disableTransition.value ? "transform" : ""
            };
        });
        const slotProps = (0, _vue.computed)(()=>({
                next: group.next,
                prev: group.prev,
                select: group.select,
                isSelected: group.isSelected
            }));
        const hasAffixes = (0, _vue.computed)(()=>{
            switch(props.showArrows){
                // Always show arrows on desktop & mobile
                case "always":
                    return true;
                // Always show arrows on desktop
                case "desktop":
                    return !mobile.value;
                // Show arrows on mobile when overflowing.
                // This matches the default 2.2 behavior
                case true:
                    return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
                // Always show on mobile
                case "mobile":
                    return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
                // https://material.io/components/tabs#scrollable-tabs
                // Always show arrows when
                // overflowed on desktop
                default:
                    return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
            }
        });
        const hasPrev = (0, _vue.computed)(()=>{
            return Math.abs(scrollOffset.value) > 0;
        });
        const hasNext = (0, _vue.computed)(()=>{
            // Check one scroll ahead to know the width of right-most item
            return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
        });
        (0, _indexMjs3.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-slide-group",
                    {
                        "v-slide-group--vertical": !isHorizontal.value,
                        "v-slide-group--has-affixes": hasAffixes.value,
                        "v-slide-group--is-overflowing": isOverflowing.value
                    },
                    props.class
                ],
                "style": props.style,
                "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
                "onFocus": onFocus
            }, {
                default: ()=>[
                        hasAffixes.value && (0, _vue.createVNode)("div", {
                            "key": "prev",
                            "class": [
                                "v-slide-group__prev",
                                {
                                    "v-slide-group__prev--disabled": !hasPrev.value
                                }
                            ],
                            "onClick": ()=>scrollTo("prev")
                        }, [
                            slots.prev?.(slotProps.value) ?? (0, _vue.createVNode)((0, _indexMjs.VFadeTransition), null, {
                                default: ()=>[
                                        (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                            "icon": isRtl.value ? props.nextIcon : props.prevIcon
                                        }, null)
                                    ]
                            })
                        ]),
                        (0, _vue.createVNode)("div", {
                            "key": "container",
                            "ref": containerRef,
                            "class": "v-slide-group__container",
                            "onScroll": onScroll
                        }, [
                            (0, _vue.createVNode)("div", {
                                "ref": contentRef,
                                "class": "v-slide-group__content",
                                "style": contentStyles.value,
                                "onTouchstartPassive": onTouchstart,
                                "onTouchmovePassive": onTouchmove,
                                "onTouchendPassive": onTouchend,
                                "onFocusin": onFocusin,
                                "onFocusout": onFocusout,
                                "onKeydown": onKeydown
                            }, [
                                slots.default?.(slotProps.value)
                            ])
                        ]),
                        hasAffixes.value && (0, _vue.createVNode)("div", {
                            "key": "next",
                            "class": [
                                "v-slide-group__next",
                                {
                                    "v-slide-group__next--disabled": !hasNext.value
                                }
                            ],
                            "onClick": ()=>scrollTo("next")
                        }, [
                            slots.next?.(slotProps.value) ?? (0, _vue.createVNode)((0, _indexMjs.VFadeTransition), null, {
                                default: ()=>[
                                        (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                            "icon": isRtl.value ? props.prevIcon : props.nextIcon
                                        }, null)
                                    ]
                            })
                        ])
                    ]
            }));
        return {
            selected: group.selected,
            scrollTo,
            scrollOffset,
            focus
        };
    }
});

},{"vue":"ff77s","./VSlideGroup.css":"gz0Sz","../transitions/index.mjs":"oiH7Z","../VIcon/index.mjs":"2wJue","../../composables/index.mjs":"lUqcD","../../composables/component.mjs":"jVHld","../../composables/group.mjs":"7LC6J","../../composables/icons.mjs":"ezwoc","../../composables/locale.mjs":"4MZbL","../../composables/resizeObserver.mjs":"byLTu","../../composables/tag.mjs":"3KkML","./helpers.mjs":"2TvpY","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"gz0Sz":[function() {},{}],"2TvpY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bias", ()=>bias);
parcelHelpers.export(exports, "calculateUpdatedOffset", ()=>calculateUpdatedOffset);
parcelHelpers.export(exports, "calculateCenteredOffset", ()=>calculateCenteredOffset);
function bias(val) {
    const c = 0.501;
    const x = Math.abs(val);
    return Math.sign(val) * (x / ((1 / c - 2) * (1 - x) + 1));
}
function calculateUpdatedOffset(_ref) {
    let { selectedElement, containerSize, contentSize, isRtl, currentScrollOffset, isHorizontal } = _ref;
    const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
    const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
    const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
    const totalSize = containerSize + currentScrollOffset;
    const itemOffset = clientSize + adjustedOffsetStart;
    const additionalOffset = clientSize * 0.4;
    if (adjustedOffsetStart <= currentScrollOffset) currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
    else if (totalSize <= itemOffset) currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
    return currentScrollOffset;
}
function calculateCenteredOffset(_ref2) {
    let { selectedElement, containerSize, contentSize, isRtl, isHorizontal } = _ref2;
    const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
    const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
    const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
    return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5dXzO":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSlideGroupItem", ()=>VSlideGroupItem);
var _groupMjs = require("../../composables/group.mjs"); // Utilities
var _vslideGroupMjs = require("./VSlideGroup.mjs");
var _indexMjs = require("../../util/index.mjs"); // Types
const VSlideGroupItem = (0, _indexMjs.genericComponent)()({
    name: "VSlideGroupItem",
    props: (0, _groupMjs.makeGroupItemProps)(),
    emits: {
        "group:selected": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const slideGroupItem = (0, _groupMjs.useGroupItem)(props, (0, _vslideGroupMjs.VSlideGroupSymbol));
        return ()=>slots.default?.({
                isSelected: slideGroupItem.isSelected.value,
                select: slideGroupItem.select,
                toggle: slideGroupItem.toggle,
                selectedClass: slideGroupItem.selectedClass.value
            });
    }
});

},{"../../composables/group.mjs":"7LC6J","./VSlideGroup.mjs":"gMPfk","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"7rs2U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSnackbar", ()=>(0, _vsnackbarMjs.VSnackbar));
var _vsnackbarMjs = require("./VSnackbar.mjs");

},{"./VSnackbar.mjs":"9Wd39","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9Wd39":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSnackbarProps", ()=>makeVSnackbarProps);
parcelHelpers.export(exports, "VSnackbar", ()=>VSnackbar);
var _vue = require("vue");
// Styles
var _vsnackbarCss = require("./VSnackbar.css");
// Components
var _indexMjs = require("../VDefaultsProvider/index.mjs");
var _indexMjs1 = require("../VOverlay/index.mjs");
var _voverlayMjs = require("../VOverlay/VOverlay.mjs"); // Composables
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _locationMjs = require("../../composables/location.mjs");
var _positionMjs = require("../../composables/position.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs");
var _themeMjs = require("../../composables/theme.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs");
const makeVSnackbarProps = (0, _indexMjs2.propsFactory)({
    multiLine: Boolean,
    timeout: {
        type: [
            Number,
            String
        ],
        default: 5000
    },
    vertical: Boolean,
    ...(0, _locationMjs.makeLocationProps)({
        location: "bottom"
    }),
    ...(0, _positionMjs.makePositionProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _variantMjs.makeVariantProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _indexMjs2.omit)((0, _voverlayMjs.makeVOverlayProps)({
        transition: "v-snackbar-transition"
    }), [
        "persistent",
        "noClickAnimation",
        "scrim",
        "scrollStrategy"
    ])
}, "VSnackbar");
const VSnackbar = (0, _indexMjs2.genericComponent)()({
    name: "VSnackbar",
    props: makeVSnackbarProps(),
    emits: {
        "update:modelValue": (v)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { locationStyles } = (0, _locationMjs.useLocation)(props);
        const { positionClasses } = (0, _positionMjs.usePosition)(props);
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { colorClasses, colorStyles, variantClasses } = (0, _variantMjs.useVariant)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const overlay = (0, _vue.ref)();
        (0, _vue.watch)(isActive, startTimeout);
        (0, _vue.watch)(()=>props.timeout, startTimeout);
        (0, _vue.onMounted)(()=>{
            if (isActive.value) startTimeout();
        });
        let activeTimeout = -1;
        function startTimeout() {
            window.clearTimeout(activeTimeout);
            const timeout = Number(props.timeout);
            if (!isActive.value || timeout === -1) return;
            activeTimeout = window.setTimeout(()=>{
                isActive.value = false;
            }, timeout);
        }
        function onPointerenter() {
            window.clearTimeout(activeTimeout);
        }
        (0, _indexMjs2.useRender)(()=>{
            const [overlayProps] = (0, _indexMjs1.VOverlay).filterProps(props);
            return (0, _vue.createVNode)((0, _indexMjs1.VOverlay), (0, _vue.mergeProps)({
                "ref": overlay,
                "class": [
                    "v-snackbar",
                    {
                        "v-snackbar--active": isActive.value,
                        "v-snackbar--multi-line": props.multiLine && !props.vertical,
                        "v-snackbar--vertical": props.vertical
                    },
                    positionClasses.value,
                    props.class
                ],
                "style": props.style
            }, overlayProps, {
                "modelValue": isActive.value,
                "onUpdate:modelValue": ($event)=>isActive.value = $event,
                "contentProps": (0, _vue.mergeProps)({
                    class: [
                        "v-snackbar__wrapper",
                        themeClasses.value,
                        colorClasses.value,
                        roundedClasses.value,
                        variantClasses.value
                    ],
                    style: [
                        locationStyles.value,
                        colorStyles.value
                    ],
                    onPointerenter,
                    onPointerleave: startTimeout
                }, overlayProps.contentProps),
                "persistent": true,
                "noClickAnimation": true,
                "scrim": false,
                "scrollStrategy": "none",
                "_disableGlobalStack": true
            }, scopeId), {
                default: ()=>[
                        (0, _variantMjs.genOverlays)(false, "v-snackbar"),
                        slots.default && (0, _vue.createVNode)("div", {
                            "class": "v-snackbar__content",
                            "role": "status",
                            "aria-live": "polite"
                        }, [
                            slots.default()
                        ]),
                        slots.actions && (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                            "defaults": {
                                VBtn: {
                                    variant: "text",
                                    ripple: false
                                }
                            }
                        }, {
                            default: ()=>[
                                    (0, _vue.createVNode)("div", {
                                        "class": "v-snackbar__actions"
                                    }, [
                                        slots.actions()
                                    ])
                                ]
                        })
                    ],
                activator: slots.activator
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, overlay);
    }
});

},{"vue":"ff77s","./VSnackbar.css":"hi1ay","../VDefaultsProvider/index.mjs":"1OIgj","../VOverlay/index.mjs":"28W37","../VOverlay/VOverlay.mjs":"9nMvb","../../composables/forwardRefs.mjs":"h5grs","../../composables/location.mjs":"5z6DF","../../composables/position.mjs":"cKISh","../../composables/proxiedModel.mjs":"bUF28","../../composables/rounded.mjs":"ldhZ9","../../composables/scopeId.mjs":"78lmg","../../composables/theme.mjs":"9LCgN","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hi1ay":[function() {},{}],"RAHVW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSwitch", ()=>(0, _vswitchMjs.VSwitch));
var _vswitchMjs = require("./VSwitch.mjs");

},{"./VSwitch.mjs":"4uBda","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4uBda":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSwitchProps", ()=>makeVSwitchProps);
parcelHelpers.export(exports, "VSwitch", ()=>VSwitch);
var _vue = require("vue");
// Styles
var _vswitchCss = require("./VSwitch.css");
// Components
var _indexMjs = require("../transitions/index.mjs");
var _indexMjs1 = require("../VIcon/index.mjs");
var _vinputMjs = require("../VInput/VInput.mjs");
var _indexMjs2 = require("../VProgressCircular/index.mjs");
var _vselectionControlMjs = require("../VSelectionControl/VSelectionControl.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _loaderMjs = require("../../composables/loader.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Utilities
var _indexMjs3 = require("../../util/index.mjs"); // Types
const makeVSwitchProps = (0, _indexMjs3.propsFactory)({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
        type: [
            Boolean,
            String
        ],
        default: false
    },
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _vselectionControlMjs.makeVSelectionControlProps)()
}, "VSwitch");
const VSwitch = (0, _indexMjs3.genericComponent)()({
    name: "VSwitch",
    inheritAttrs: false,
    props: makeVSwitchProps(),
    emits: {
        "update:focused": (focused)=>true,
        "update:modelValue": ()=>true,
        "update:indeterminate": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, slots } = _ref;
        const indeterminate = (0, _proxiedModelMjs.useProxiedModel)(props, "indeterminate");
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { loaderClasses } = (0, _loaderMjs.useLoader)(props);
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const control = (0, _vue.ref)();
        const loaderColor = (0, _vue.computed)(()=>{
            return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
        });
        const uid = (0, _indexMjs3.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `switch-${uid}`);
        function onChange() {
            if (indeterminate.value) indeterminate.value = false;
        }
        function onTrackClick(e) {
            e.stopPropagation();
            e.preventDefault();
            control.value?.input?.click();
        }
        (0, _indexMjs3.useRender)(()=>{
            const [rootAttrs, controlAttrs] = (0, _indexMjs3.filterInputAttrs)(attrs);
            const [inputProps, _1] = (0, _vinputMjs.VInput).filterProps(props);
            const [controlProps, _2] = (0, _vselectionControlMjs.VSelectionControl).filterProps(props);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "class": [
                    "v-switch",
                    {
                        "v-switch--inset": props.inset
                    },
                    {
                        "v-switch--indeterminate": indeterminate.value
                    },
                    loaderClasses.value,
                    props.class
                ],
                "style": props.style
            }, rootAttrs, inputProps, {
                "id": id.value,
                "focused": isFocused.value
            }), {
                ...slots,
                default: (_ref2)=>{
                    let { id, messagesId, isDisabled, isReadonly, isValid } = _ref2;
                    return (0, _vue.createVNode)((0, _vselectionControlMjs.VSelectionControl), (0, _vue.mergeProps)({
                        "ref": control
                    }, controlProps, {
                        "modelValue": model.value,
                        "onUpdate:modelValue": [
                            ($event)=>model.value = $event,
                            onChange
                        ],
                        "id": id.value,
                        "aria-describedby": messagesId.value,
                        "type": "checkbox",
                        "aria-checked": indeterminate.value ? "mixed" : undefined,
                        "disabled": isDisabled.value,
                        "readonly": isReadonly.value,
                        "onFocus": focus,
                        "onBlur": blur
                    }, controlAttrs), {
                        ...slots,
                        default: (_ref3)=>{
                            let { backgroundColorClasses, backgroundColorStyles } = _ref3;
                            return (0, _vue.createVNode)("div", {
                                "class": [
                                    "v-switch__track",
                                    ...backgroundColorClasses.value
                                ],
                                "style": backgroundColorStyles.value,
                                "onClick": onTrackClick
                            }, null);
                        },
                        input: (_ref4)=>{
                            let { inputNode, icon, backgroundColorClasses, backgroundColorStyles } = _ref4;
                            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                inputNode,
                                (0, _vue.createVNode)("div", {
                                    "class": [
                                        "v-switch__thumb",
                                        {
                                            "v-switch__thumb--filled": icon || props.loading
                                        },
                                        props.inset ? undefined : backgroundColorClasses.value
                                    ],
                                    "style": props.inset ? undefined : backgroundColorStyles.value
                                }, [
                                    (0, _vue.createVNode)((0, _indexMjs.VScaleTransition), null, {
                                        default: ()=>[
                                                !props.loading ? icon && (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                                                    "key": icon,
                                                    "icon": icon,
                                                    "size": "x-small"
                                                }, null) : (0, _vue.createVNode)((0, _loaderMjs.LoaderSlot), {
                                                    "name": "v-switch",
                                                    "active": true,
                                                    "color": isValid.value === false ? undefined : loaderColor.value
                                                }, {
                                                    default: (slotProps)=>slots.loader ? slots.loader(slotProps) : (0, _vue.createVNode)((0, _indexMjs2.VProgressCircular), {
                                                            "active": slotProps.isActive,
                                                            "color": slotProps.color,
                                                            "indeterminate": true,
                                                            "size": "16",
                                                            "width": "2"
                                                        }, null)
                                                })
                                            ]
                                    })
                                ])
                            ]);
                        }
                    });
                }
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VSwitch.css":"6ebYU","../transitions/index.mjs":"oiH7Z","../VIcon/index.mjs":"2wJue","../VInput/VInput.mjs":"1hyGZ","../VProgressCircular/index.mjs":"2azsA","../VSelectionControl/VSelectionControl.mjs":"1j5Xu","../../composables/focus.mjs":"1bQxY","../../composables/loader.mjs":"dJ5WR","../../composables/proxiedModel.mjs":"bUF28","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"6ebYU":[function() {},{}],"4M9Nq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VSystemBar", ()=>(0, _vsystemBarMjs.VSystemBar));
var _vsystemBarMjs = require("./VSystemBar.mjs");

},{"./VSystemBar.mjs":"9nHgK","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9nHgK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVSystemBarProps", ()=>makeVSystemBarProps);
parcelHelpers.export(exports, "VSystemBar", ()=>VSystemBar);
var _vue = require("vue");
// Styles
var _vsystemBarCss = require("./VSystemBar.css");
// Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _layoutMjs = require("../../composables/layout.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _ssrBootMjs = require("../../composables/ssrBoot.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVSystemBarProps = (0, _indexMjs.propsFactory)({
    color: String,
    height: [
        Number,
        String
    ],
    window: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _layoutMjs.makeLayoutItemProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VSystemBar");
const VSystemBar = (0, _indexMjs.genericComponent)()({
    name: "VSystemBar",
    props: makeVSystemBarProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "color"));
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props);
        const { ssrBootStyles } = (0, _ssrBootMjs.useSsrBoot)();
        const height = (0, _vue.computed)(()=>props.height ?? (props.window ? 32 : 24));
        const { layoutItemStyles } = (0, _layoutMjs.useLayoutItem)({
            id: props.name,
            order: (0, _vue.computed)(()=>parseInt(props.order, 10)),
            position: (0, _vue.shallowRef)("top"),
            layoutSize: height,
            elementSize: height,
            active: (0, _vue.computed)(()=>true),
            absolute: (0, _vue.toRef)(props, "absolute")
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-system-bar",
                    {
                        "v-system-bar--window": props.window
                    },
                    themeClasses.value,
                    backgroundColorClasses.value,
                    elevationClasses.value,
                    roundedClasses.value,
                    props.class
                ],
                "style": [
                    backgroundColorStyles.value,
                    layoutItemStyles.value,
                    ssrBootStyles.value,
                    props.style
                ]
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VSystemBar.css":"aIU8w","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/elevation.mjs":"3BDEa","../../composables/layout.mjs":"fPMsf","../../composables/rounded.mjs":"ldhZ9","../../composables/ssrBoot.mjs":"b8ivf","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"aIU8w":[function() {},{}],"jisPV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTabs", ()=>(0, _vtabsMjs.VTabs));
parcelHelpers.export(exports, "VTab", ()=>(0, _vtabMjs.VTab));
var _vtabsMjs = require("./VTabs.mjs");
var _vtabMjs = require("./VTab.mjs");

},{"./VTabs.mjs":"eiOM7","./VTab.mjs":"dLtLY","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eiOM7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTabsProps", ()=>makeVTabsProps);
parcelHelpers.export(exports, "VTabs", ()=>VTabs);
var _vue = require("vue");
// Styles
var _vtabsCss = require("./VTabs.css");
// Components
var _vtabMjs = require("./VTab.mjs");
var _vslideGroupMjs = require("../VSlideGroup/VSlideGroup.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
var _sharedMjs = require("./shared.mjs");
function parseItems(items) {
    if (!items) return [];
    return items.map((item)=>{
        if (typeof item === "string") return {
            title: item,
            value: item
        };
        return item;
    });
}
const makeVTabsProps = (0, _indexMjs.propsFactory)({
    alignTabs: {
        type: String,
        default: "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
        type: Array,
        default: ()=>[]
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
        type: [
            Number,
            String
        ],
        default: undefined
    },
    hideSlider: Boolean,
    sliderColor: String,
    ...(0, _vslideGroupMjs.makeVSlideGroupProps)({
        mandatory: "force"
    }),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VTabs");
const VTabs = (0, _indexMjs.genericComponent)()({
    name: "VTabs",
    props: makeVTabsProps(),
    emits: {
        "update:modelValue": (v)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const parsedItems = (0, _vue.computed)(()=>parseItems(props.items));
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { backgroundColorClasses, backgroundColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "bgColor"));
        (0, _defaultsMjs.provideDefaults)({
            VTab: {
                color: (0, _vue.toRef)(props, "color"),
                direction: (0, _vue.toRef)(props, "direction"),
                stacked: (0, _vue.toRef)(props, "stacked"),
                fixed: (0, _vue.toRef)(props, "fixedTabs"),
                sliderColor: (0, _vue.toRef)(props, "sliderColor"),
                hideSlider: (0, _vue.toRef)(props, "hideSlider")
            }
        });
        (0, _indexMjs.useRender)(()=>{
            const [slideGroupProps] = (0, _vslideGroupMjs.VSlideGroup).filterProps(props);
            return (0, _vue.createVNode)((0, _vslideGroupMjs.VSlideGroup), (0, _vue.mergeProps)(slideGroupProps, {
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "class": [
                    "v-tabs",
                    `v-tabs--${props.direction}`,
                    `v-tabs--align-tabs-${props.alignTabs}`,
                    {
                        "v-tabs--fixed-tabs": props.fixedTabs,
                        "v-tabs--grow": props.grow,
                        "v-tabs--stacked": props.stacked
                    },
                    densityClasses.value,
                    backgroundColorClasses.value,
                    props.class
                ],
                "style": [
                    {
                        "--v-tabs-height": (0, _indexMjs.convertToUnit)(props.height)
                    },
                    backgroundColorStyles.value,
                    props.style
                ],
                "role": "tablist",
                "symbol": (0, _sharedMjs.VTabsSymbol)
            }), {
                default: ()=>[
                        slots.default ? slots.default() : parsedItems.value.map((item)=>(0, _vue.createVNode)((0, _vtabMjs.VTab), (0, _vue.mergeProps)(item, {
                                "key": item.title
                            }), null))
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VTabs.css":"9muI1","./VTab.mjs":"dLtLY","../VSlideGroup/VSlideGroup.mjs":"gMPfk","../../composables/color.mjs":"4pLYX","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/proxiedModel.mjs":"bUF28","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","./shared.mjs":"3nCHn","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"9muI1":[function() {},{}],"dLtLY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTabProps", ()=>makeVTabProps);
parcelHelpers.export(exports, "VTab", ()=>VTab);
var _vue = require("vue");
// Styles
var _vtabCss = require("./VTab.css");
// Components
var _vbtnMjs = require("../VBtn/VBtn.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs"); // Utilities
var _sharedMjs = require("./shared.mjs");
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVTabProps = (0, _indexMjs.propsFactory)({
    fixed: Boolean,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
        type: String,
        default: "horizontal"
    },
    ...(0, _indexMjs.omit)((0, _vbtnMjs.makeVBtnProps)({
        selectedClass: "v-tab--selected",
        variant: "text"
    }), [
        "active",
        "block",
        "flat",
        "location",
        "position",
        "symbol"
    ])
}, "VTab");
const VTab = (0, _indexMjs.genericComponent)()({
    name: "VTab",
    props: makeVTabProps(),
    setup (props, _ref) {
        let { slots, attrs } = _ref;
        const { textColorClasses: sliderColorClasses, textColorStyles: sliderColorStyles } = (0, _colorMjs.useTextColor)(props, "sliderColor");
        const isHorizontal = (0, _vue.computed)(()=>props.direction === "horizontal");
        const isSelected = (0, _vue.shallowRef)(false);
        const rootEl = (0, _vue.ref)();
        const sliderEl = (0, _vue.ref)();
        function updateSlider(_ref2) {
            let { value } = _ref2;
            isSelected.value = value;
            if (value) {
                const prevEl = rootEl.value?.$el.parentElement?.querySelector(".v-tab--selected .v-tab__slider");
                const nextEl = sliderEl.value;
                if (!prevEl || !nextEl) return;
                const color = getComputedStyle(prevEl).color;
                const prevBox = prevEl.getBoundingClientRect();
                const nextBox = nextEl.getBoundingClientRect();
                const xy = isHorizontal.value ? "x" : "y";
                const XY = isHorizontal.value ? "X" : "Y";
                const rightBottom = isHorizontal.value ? "right" : "bottom";
                const widthHeight = isHorizontal.value ? "width" : "height";
                const prevPos = prevBox[xy];
                const nextPos = nextBox[xy];
                const delta = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
                const origin = Math.sign(delta) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta) < 0 ? isHorizontal.value ? "left" : "top" : "center";
                const size = Math.abs(delta) + (Math.sign(delta) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
                const scale = size / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
                const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
                const sigma = 1.5;
                (0, _indexMjs.animate)(nextEl, {
                    backgroundColor: [
                        color,
                        "currentcolor"
                    ],
                    transform: [
                        `translate${XY}(${delta}px) scale${XY}(${initialScale})`,
                        `translate${XY}(${delta / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`,
                        "none"
                    ],
                    transformOrigin: Array(3).fill(origin)
                }, {
                    duration: 225,
                    easing: (0, _indexMjs.standardEasing)
                });
            }
        }
        (0, _indexMjs.useRender)(()=>{
            const [btnProps] = (0, _vbtnMjs.VBtn).filterProps(props);
            return (0, _vue.createVNode)((0, _vbtnMjs.VBtn), (0, _vue.mergeProps)({
                "symbol": (0, _sharedMjs.VTabsSymbol),
                "ref": rootEl,
                "class": [
                    "v-tab",
                    props.class
                ],
                "style": props.style,
                "tabindex": isSelected.value ? 0 : -1,
                "role": "tab",
                "aria-selected": String(isSelected.value),
                "active": false
            }, btnProps, attrs, {
                "block": props.fixed,
                "maxWidth": props.fixed ? 300 : undefined,
                "onGroup:selected": updateSlider
            }), {
                default: ()=>[
                        slots.default?.() ?? props.text,
                        !props.hideSlider && (0, _vue.createVNode)("div", {
                            "ref": sliderEl,
                            "class": [
                                "v-tab__slider",
                                sliderColorClasses.value
                            ],
                            "style": sliderColorStyles.value
                        }, null)
                    ]
            });
        });
        return {};
    }
});

},{"vue":"ff77s","./VTab.css":"dhCvH","../VBtn/VBtn.mjs":"ewnpF","../../composables/color.mjs":"4pLYX","./shared.mjs":"3nCHn","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dhCvH":[function() {},{}],"3nCHn":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTabsSymbol", ()=>VTabsSymbol);
const VTabsSymbol = Symbol.for("vuetify:v-tabs");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"4v7zA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTable", ()=>(0, _vtableMjs.VTable));
var _vtableMjs = require("./VTable.mjs");

},{"./VTable.mjs":"hBc8I","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"hBc8I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTableProps", ()=>makeVTableProps);
parcelHelpers.export(exports, "VTable", ()=>VTable);
var _vue = require("vue");
// Styles
var _vtableCss = require("./VTable.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVTableProps = (0, _indexMjs.propsFactory)({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [
        Number,
        String
    ],
    hover: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VTable");
const VTable = (0, _indexMjs.genericComponent)()({
    name: "VTable",
    props: makeVTableProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-table",
                    {
                        "v-table--fixed-height": !!props.height,
                        "v-table--fixed-header": props.fixedHeader,
                        "v-table--fixed-footer": props.fixedFooter,
                        "v-table--has-top": !!slots.top,
                        "v-table--has-bottom": !!slots.bottom,
                        "v-table--hover": props.hover
                    },
                    themeClasses.value,
                    densityClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        slots.top?.(),
                        slots.default ? (0, _vue.createVNode)("div", {
                            "class": "v-table__wrapper",
                            "style": {
                                height: (0, _indexMjs.convertToUnit)(props.height)
                            }
                        }, [
                            (0, _vue.createVNode)("table", null, [
                                slots.default()
                            ])
                        ]) : slots.wrapper?.(),
                        slots.bottom?.()
                    ]
            }));
        return {};
    }
});

},{"vue":"ff77s","./VTable.css":"8rpcu","../../composables/component.mjs":"jVHld","../../composables/density.mjs":"7cRh5","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8rpcu":[function() {},{}],"d0Cab":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTextarea", ()=>(0, _vtextareaMjs.VTextarea));
var _vtextareaMjs = require("./VTextarea.mjs");

},{"./VTextarea.mjs":"bADJD","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bADJD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTextareaProps", ()=>makeVTextareaProps);
parcelHelpers.export(exports, "VTextarea", ()=>VTextarea);
var _vue = require("vue");
// Styles
var _vtextareaCss = require("./VTextarea.css");
var _vtextFieldCss = require("../VTextField/VTextField.css");
// Components
var _vcounterMjs = require("../VCounter/VCounter.mjs");
var _indexMjs = require("../VField/index.mjs");
var _vfieldMjs = require("../VField/VField.mjs");
var _vinputMjs = require("../VInput/VInput.mjs"); // Composables
var _focusMjs = require("../../composables/focus.mjs");
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs"); // Directives
var _indexMjs1 = require("../../directives/intersect/index.mjs"); // Utilities
var _indexMjsDefault = parcelHelpers.interopDefault(_indexMjs1);
var _indexMjs2 = require("../../util/index.mjs"); // Types
const makeVTextareaProps = (0, _indexMjs2.propsFactory)({
    autoGrow: Boolean,
    autofocus: Boolean,
    counter: [
        Boolean,
        Number,
        String
    ],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    noResize: Boolean,
    rows: {
        type: [
            Number,
            String
        ],
        default: 5,
        validator: (v)=>!isNaN(parseFloat(v))
    },
    maxRows: {
        type: [
            Number,
            String
        ],
        validator: (v)=>!isNaN(parseFloat(v))
    },
    suffix: String,
    modelModifiers: Object,
    ...(0, _vinputMjs.makeVInputProps)(),
    ...(0, _vfieldMjs.makeVFieldProps)()
}, "VTextarea");
const VTextarea = (0, _indexMjs2.genericComponent)()({
    name: "VTextarea",
    directives: {
        Intersect: (0, _indexMjsDefault.default)
    },
    inheritAttrs: false,
    props: makeVTextareaProps(),
    emits: {
        "click:control": (e)=>true,
        "mousedown:control": (e)=>true,
        "update:focused": (focused)=>true,
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { attrs, emit, slots } = _ref;
        const model = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { isFocused, focus, blur } = (0, _focusMjs.useFocus)(props);
        const counterValue = (0, _vue.computed)(()=>{
            return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value || "").toString().length;
        });
        const max = (0, _vue.computed)(()=>{
            if (attrs.maxlength) return attrs.maxlength;
            if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string") return undefined;
            return props.counter;
        });
        function onIntersect(isIntersecting, entries) {
            if (!props.autofocus || !isIntersecting) return;
            entries[0].target?.focus?.();
        }
        const vInputRef = (0, _vue.ref)();
        const vFieldRef = (0, _vue.ref)();
        const controlHeight = (0, _vue.shallowRef)("");
        const textareaRef = (0, _vue.ref)();
        const isActive = (0, _vue.computed)(()=>props.persistentPlaceholder || isFocused.value || props.active);
        function onFocus() {
            if (textareaRef.value !== document.activeElement) textareaRef.value?.focus();
            if (!isFocused.value) focus();
        }
        function onControlClick(e) {
            onFocus();
            emit("click:control", e);
        }
        function onControlMousedown(e) {
            emit("mousedown:control", e);
        }
        function onClear(e) {
            e.stopPropagation();
            onFocus();
            (0, _vue.nextTick)(()=>{
                model.value = "";
                (0, _indexMjs2.callEvent)(props["onClick:clear"], e);
            });
        }
        function onInput(e) {
            const el = e.target;
            model.value = el.value;
            if (props.modelModifiers?.trim) {
                const caretPosition = [
                    el.selectionStart,
                    el.selectionEnd
                ];
                (0, _vue.nextTick)(()=>{
                    el.selectionStart = caretPosition[0];
                    el.selectionEnd = caretPosition[1];
                });
            }
        }
        const sizerRef = (0, _vue.ref)();
        const rows = (0, _vue.ref)(+props.rows);
        const isPlainOrUnderlined = (0, _vue.computed)(()=>[
                "plain",
                "underlined"
            ].includes(props.variant));
        (0, _vue.watchEffect)(()=>{
            if (!props.autoGrow) rows.value = +props.rows;
        });
        function calculateInputHeight() {
            if (!props.autoGrow) return;
            (0, _vue.nextTick)(()=>{
                if (!sizerRef.value || !vFieldRef.value) return;
                const style = getComputedStyle(sizerRef.value);
                const fieldStyle = getComputedStyle(vFieldRef.value.$el);
                const padding = parseFloat(style.getPropertyValue("--v-field-padding-top")) + parseFloat(style.getPropertyValue("--v-input-padding-top")) + parseFloat(style.getPropertyValue("--v-field-padding-bottom"));
                const height = sizerRef.value.scrollHeight;
                const lineHeight = parseFloat(style.lineHeight);
                const minHeight = Math.max(parseFloat(props.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
                const maxHeight = parseFloat(props.maxRows) * lineHeight + padding || Infinity;
                const newHeight = (0, _indexMjs2.clamp)(height ?? 0, minHeight, maxHeight);
                rows.value = Math.floor((newHeight - padding) / lineHeight);
                controlHeight.value = (0, _indexMjs2.convertToUnit)(newHeight);
            });
        }
        (0, _vue.onMounted)(calculateInputHeight);
        (0, _vue.watch)(model, calculateInputHeight);
        (0, _vue.watch)(()=>props.rows, calculateInputHeight);
        (0, _vue.watch)(()=>props.maxRows, calculateInputHeight);
        (0, _vue.watch)(()=>props.density, calculateInputHeight);
        let observer;
        (0, _vue.watch)(sizerRef, (val)=>{
            if (val) {
                observer = new ResizeObserver(calculateInputHeight);
                observer.observe(sizerRef.value);
            } else observer?.disconnect();
        });
        (0, _vue.onBeforeUnmount)(()=>{
            observer?.disconnect();
        });
        (0, _indexMjs2.useRender)(()=>{
            const hasCounter = !!(slots.counter || props.counter || props.counterValue);
            const hasDetails = !!(hasCounter || slots.details);
            const [rootAttrs, inputAttrs] = (0, _indexMjs2.filterInputAttrs)(attrs);
            const [{ modelValue: _, ...inputProps }] = (0, _vinputMjs.VInput).filterProps(props);
            const [fieldProps] = (0, _vfieldMjs.filterFieldProps)(props);
            return (0, _vue.createVNode)((0, _vinputMjs.VInput), (0, _vue.mergeProps)({
                "ref": vInputRef,
                "modelValue": model.value,
                "onUpdate:modelValue": ($event)=>model.value = $event,
                "class": [
                    "v-textarea v-text-field",
                    {
                        "v-textarea--prefixed": props.prefix,
                        "v-textarea--suffixed": props.suffix,
                        "v-text-field--prefixed": props.prefix,
                        "v-text-field--suffixed": props.suffix,
                        "v-textarea--auto-grow": props.autoGrow,
                        "v-textarea--no-resize": props.noResize || props.autoGrow,
                        "v-text-field--plain-underlined": isPlainOrUnderlined.value
                    },
                    props.class
                ],
                "style": props.style
            }, rootAttrs, inputProps, {
                "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
                "focused": isFocused.value
            }), {
                ...slots,
                default: (_ref2)=>{
                    let { isDisabled, isDirty, isReadonly, isValid } = _ref2;
                    return (0, _vue.createVNode)((0, _indexMjs.VField), (0, _vue.mergeProps)({
                        "ref": vFieldRef,
                        "style": {
                            "--v-textarea-control-height": controlHeight.value
                        },
                        "onClick": onControlClick,
                        "onMousedown": onControlMousedown,
                        "onClick:clear": onClear,
                        "onClick:prependInner": props["onClick:prependInner"],
                        "onClick:appendInner": props["onClick:appendInner"]
                    }, fieldProps, {
                        "active": isActive.value || isDirty.value,
                        "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
                        "dirty": isDirty.value || props.dirty,
                        "disabled": isDisabled.value,
                        "focused": isFocused.value,
                        "error": isValid.value === false
                    }), {
                        ...slots,
                        default: (_ref3)=>{
                            let { props: { class: fieldClass, ...slotProps } } = _ref3;
                            return (0, _vue.createVNode)((0, _vue.Fragment), null, [
                                props.prefix && (0, _vue.createVNode)("span", {
                                    "class": "v-text-field__prefix"
                                }, [
                                    props.prefix
                                ]),
                                (0, _vue.withDirectives)((0, _vue.createVNode)("textarea", (0, _vue.mergeProps)({
                                    "ref": textareaRef,
                                    "class": fieldClass,
                                    "value": model.value,
                                    "onInput": onInput,
                                    "autofocus": props.autofocus,
                                    "readonly": isReadonly.value,
                                    "disabled": isDisabled.value,
                                    "placeholder": props.placeholder,
                                    "rows": props.rows,
                                    "name": props.name,
                                    "onFocus": onFocus,
                                    "onBlur": blur
                                }, slotProps, inputAttrs), null), [
                                    [
                                        (0, _vue.resolveDirective)("intersect"),
                                        {
                                            handler: onIntersect
                                        },
                                        null,
                                        {
                                            once: true
                                        }
                                    ]
                                ]),
                                props.autoGrow && (0, _vue.withDirectives)((0, _vue.createVNode)("textarea", {
                                    "class": [
                                        fieldClass,
                                        "v-textarea__sizer"
                                    ],
                                    "id": `${slotProps.id}-sizer`,
                                    "onUpdate:modelValue": ($event)=>model.value = $event,
                                    "ref": sizerRef,
                                    "readonly": true,
                                    "aria-hidden": "true"
                                }, null), [
                                    [
                                        (0, _vue.vModelText),
                                        model.value
                                    ]
                                ]),
                                props.suffix && (0, _vue.createVNode)("span", {
                                    "class": "v-text-field__suffix"
                                }, [
                                    props.suffix
                                ])
                            ]);
                        }
                    });
                },
                details: hasDetails ? (slotProps)=>(0, _vue.createVNode)((0, _vue.Fragment), null, [
                        slots.details?.(slotProps),
                        hasCounter && (0, _vue.createVNode)((0, _vue.Fragment), null, [
                            (0, _vue.createVNode)("span", null, null),
                            (0, _vue.createVNode)((0, _vcounterMjs.VCounter), {
                                "active": props.persistentCounter || isFocused.value,
                                "value": counterValue.value,
                                "max": max.value
                            }, slots.counter)
                        ])
                    ]) : undefined
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, vInputRef, vFieldRef, textareaRef);
    }
});

},{"vue":"ff77s","./VTextarea.css":"c8XRw","../VTextField/VTextField.css":"dFHEd","../VCounter/VCounter.mjs":"16Uel","../VField/index.mjs":"b1DV7","../VField/VField.mjs":"2knTe","../VInput/VInput.mjs":"1hyGZ","../../composables/focus.mjs":"1bQxY","../../composables/forwardRefs.mjs":"h5grs","../../composables/proxiedModel.mjs":"bUF28","../../directives/intersect/index.mjs":"jD88I","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"c8XRw":[function() {},{}],"dFHEd":[function() {},{}],"5D2nH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VThemeProvider", ()=>(0, _vthemeProviderMjs.VThemeProvider));
var _vthemeProviderMjs = require("./VThemeProvider.mjs");

},{"./VThemeProvider.mjs":"cQ9u8","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"cQ9u8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVThemeProviderProps", ()=>makeVThemeProviderProps);
parcelHelpers.export(exports, "VThemeProvider", ()=>VThemeProvider);
var _vue = require("vue");
// Styles
var _vthemeProviderCss = require("./VThemeProvider.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVThemeProviderProps = (0, _indexMjs.propsFactory)({
    withBackground: Boolean,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _themeMjs.makeThemeProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VThemeProvider");
const VThemeProvider = (0, _indexMjs.genericComponent)()({
    name: "VThemeProvider",
    props: makeVThemeProviderProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        return ()=>{
            if (!props.withBackground) return slots.default?.();
            return (0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-theme-provider",
                    themeClasses.value,
                    props.class
                ],
                "style": props.style
            }, {
                default: ()=>[
                        slots.default?.()
                    ]
            });
        };
    }
});

},{"vue":"ff77s","./VThemeProvider.css":"kMr01","../../composables/component.mjs":"jVHld","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"kMr01":[function() {},{}],"ywN7N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTimeline", ()=>(0, _vtimelineMjs.VTimeline));
parcelHelpers.export(exports, "VTimelineItem", ()=>(0, _vtimelineItemMjs.VTimelineItem));
var _vtimelineMjs = require("./VTimeline.mjs");
var _vtimelineItemMjs = require("./VTimelineItem.mjs");

},{"./VTimeline.mjs":"2ufe9","./VTimelineItem.mjs":"cSc2T","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2ufe9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTimelineProps", ()=>makeVTimelineProps);
parcelHelpers.export(exports, "VTimeline", ()=>VTimeline);
var _vue = require("vue");
// Styles
var _vtimelineCss = require("./VTimeline.css");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _densityMjs = require("../../composables/density.mjs");
var _localeMjs = require("../../composables/locale.mjs");
var _tagMjs = require("../../composables/tag.mjs");
var _themeMjs = require("../../composables/theme.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVTimelineProps = (0, _indexMjs.propsFactory)({
    align: {
        type: String,
        default: "center",
        validator: (v)=>[
                "center",
                "start"
            ].includes(v)
    },
    direction: {
        type: String,
        default: "vertical",
        validator: (v)=>[
                "vertical",
                "horizontal"
            ].includes(v)
    },
    justify: {
        type: String,
        default: "auto",
        validator: (v)=>[
                "auto",
                "center"
            ].includes(v)
    },
    side: {
        type: String,
        validator: (v)=>v == null || [
                "start",
                "end"
            ].includes(v)
    },
    lineInset: {
        type: [
            String,
            Number
        ],
        default: 0
    },
    lineThickness: {
        type: [
            String,
            Number
        ],
        default: 2
    },
    lineColor: String,
    truncateLine: {
        type: String,
        validator: (v)=>[
                "start",
                "end",
                "both"
            ].includes(v)
    },
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _densityMjs.makeDensityProps)(),
    ...(0, _tagMjs.makeTagProps)(),
    ...(0, _themeMjs.makeThemeProps)()
}, "VTimeline");
const VTimeline = (0, _indexMjs.genericComponent)()({
    name: "VTimeline",
    props: makeVTimelineProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { themeClasses } = (0, _themeMjs.provideTheme)(props);
        const { densityClasses } = (0, _densityMjs.useDensity)(props);
        const { rtlClasses } = (0, _localeMjs.useRtl)();
        (0, _defaultsMjs.provideDefaults)({
            VTimelineDivider: {
                lineColor: (0, _vue.toRef)(props, "lineColor")
            },
            VTimelineItem: {
                density: (0, _vue.toRef)(props, "density"),
                lineInset: (0, _vue.toRef)(props, "lineInset")
            }
        });
        const sideClasses = (0, _vue.computed)(()=>{
            const side = props.side ? props.side : props.density !== "default" ? "end" : null;
            return side && `v-timeline--side-${side}`;
        });
        const truncateClasses = (0, _vue.computed)(()=>{
            const classes = [
                "v-timeline--truncate-line-start",
                "v-timeline--truncate-line-end"
            ];
            switch(props.truncateLine){
                case "both":
                    return classes;
                case "start":
                    return classes[0];
                case "end":
                    return classes[1];
                default:
                    return null;
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)(props.tag, {
                "class": [
                    "v-timeline",
                    `v-timeline--${props.direction}`,
                    `v-timeline--align-${props.align}`,
                    `v-timeline--justify-${props.justify}`,
                    truncateClasses.value,
                    {
                        "v-timeline--inset-line": !!props.lineInset
                    },
                    themeClasses.value,
                    densityClasses.value,
                    sideClasses.value,
                    rtlClasses.value,
                    props.class
                ],
                "style": [
                    {
                        "--v-timeline-line-thickness": (0, _indexMjs.convertToUnit)(props.lineThickness)
                    },
                    props.style
                ]
            }, slots));
        return {};
    }
});

},{"vue":"ff77s","./VTimeline.css":"8BkY9","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/density.mjs":"7cRh5","../../composables/locale.mjs":"4MZbL","../../composables/tag.mjs":"3KkML","../../composables/theme.mjs":"9LCgN","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8BkY9":[function() {},{}],"cSc2T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTimelineItemProps", ()=>makeVTimelineItemProps);
parcelHelpers.export(exports, "VTimelineItem", ()=>VTimelineItem);
var _vue = require("vue");
// Components
var _vtimelineDividerMjs = require("./VTimelineDivider.mjs"); // Composables
var _componentMjs = require("../../composables/component.mjs");
var _dimensionsMjs = require("../../composables/dimensions.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _sizeMjs = require("../../composables/size.mjs");
var _tagMjs = require("../../composables/tag.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs"); // Types
const makeVTimelineItemProps = (0, _indexMjs.propsFactory)({
    density: String,
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
        type: Boolean,
        default: undefined
    },
    icon: (0, _iconsMjs.IconValue),
    iconColor: String,
    lineInset: [
        Number,
        String
    ],
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _dimensionsMjs.makeDimensionProps)(),
    ...(0, _elevationMjs.makeElevationProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _tagMjs.makeTagProps)()
}, "VTimelineItem");
const VTimelineItem = (0, _indexMjs.genericComponent)()({
    name: "VTimelineItem",
    props: makeVTimelineItemProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { dimensionStyles } = (0, _dimensionsMjs.useDimension)(props);
        const dotSize = (0, _vue.shallowRef)(0);
        const dotRef = (0, _vue.ref)();
        (0, _vue.watch)(dotRef, (newValue)=>{
            if (!newValue) return;
            dotSize.value = newValue.$el.querySelector(".v-timeline-divider__dot")?.getBoundingClientRect().width ?? 0;
        }, {
            flush: "post"
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-timeline-item",
                    {
                        "v-timeline-item--fill-dot": props.fillDot
                    },
                    props.class
                ],
                "style": [
                    {
                        "--v-timeline-dot-size": (0, _indexMjs.convertToUnit)(dotSize.value),
                        "--v-timeline-line-inset": props.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${(0, _indexMjs.convertToUnit)(props.lineInset)})` : (0, _indexMjs.convertToUnit)(0)
                    },
                    props.style
                ]
            }, [
                (0, _vue.createVNode)("div", {
                    "class": "v-timeline-item__body",
                    "style": dimensionStyles.value
                }, [
                    slots.default?.()
                ]),
                (0, _vue.createVNode)((0, _vtimelineDividerMjs.VTimelineDivider), {
                    "ref": dotRef,
                    "hideDot": props.hideDot,
                    "icon": props.icon,
                    "iconColor": props.iconColor,
                    "size": props.size,
                    "elevation": props.elevation,
                    "dotColor": props.dotColor,
                    "fillDot": props.fillDot,
                    "rounded": props.rounded
                }, {
                    default: slots.icon
                }),
                props.density !== "compact" && (0, _vue.createVNode)("div", {
                    "class": "v-timeline-item__opposite"
                }, [
                    !props.hideOpposite && slots.opposite?.()
                ])
            ]));
        return {};
    }
});

},{"vue":"ff77s","./VTimelineDivider.mjs":"dSOBA","../../composables/component.mjs":"jVHld","../../composables/dimensions.mjs":"nAc7s","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/rounded.mjs":"ldhZ9","../../composables/size.mjs":"jtF5F","../../composables/tag.mjs":"3KkML","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"dSOBA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTimelineDividerProps", ()=>makeVTimelineDividerProps);
parcelHelpers.export(exports, "VTimelineDivider", ()=>VTimelineDivider);
var _vue = require("vue");
// Components
var _indexMjs = require("../VDefaultsProvider/index.mjs");
var _indexMjs1 = require("../VIcon/index.mjs"); // Composables
var _colorMjs = require("../../composables/color.mjs");
var _componentMjs = require("../../composables/component.mjs");
var _elevationMjs = require("../../composables/elevation.mjs");
var _iconsMjs = require("../../composables/icons.mjs");
var _roundedMjs = require("../../composables/rounded.mjs");
var _sizeMjs = require("../../composables/size.mjs"); // Utilities
var _indexMjs2 = require("../../util/index.mjs");
const makeVTimelineDividerProps = (0, _indexMjs2.propsFactory)({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    icon: (0, _iconsMjs.IconValue),
    iconColor: String,
    lineColor: String,
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _roundedMjs.makeRoundedProps)(),
    ...(0, _sizeMjs.makeSizeProps)(),
    ...(0, _elevationMjs.makeElevationProps)()
}, "VTimelineDivider");
const VTimelineDivider = (0, _indexMjs2.genericComponent)()({
    name: "VTimelineDivider",
    props: makeVTimelineDividerProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        const { sizeClasses, sizeStyles } = (0, _sizeMjs.useSize)(props, "v-timeline-divider__dot");
        const { backgroundColorStyles, backgroundColorClasses } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "dotColor"));
        const { roundedClasses } = (0, _roundedMjs.useRounded)(props, "v-timeline-divider__dot");
        const { elevationClasses } = (0, _elevationMjs.useElevation)(props);
        const { backgroundColorClasses: lineColorClasses, backgroundColorStyles: lineColorStyles } = (0, _colorMjs.useBackgroundColor)((0, _vue.toRef)(props, "lineColor"));
        (0, _indexMjs2.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-timeline-divider",
                    {
                        "v-timeline-divider--fill-dot": props.fillDot
                    },
                    props.class
                ],
                "style": props.style
            }, [
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-timeline-divider__before",
                        lineColorClasses.value
                    ],
                    "style": lineColorStyles.value
                }, null),
                !props.hideDot && (0, _vue.createVNode)("div", {
                    "key": "dot",
                    "class": [
                        "v-timeline-divider__dot",
                        elevationClasses.value,
                        roundedClasses.value,
                        sizeClasses.value
                    ],
                    "style": sizeStyles.value
                }, [
                    (0, _vue.createVNode)("div", {
                        "class": [
                            "v-timeline-divider__inner-dot",
                            backgroundColorClasses.value,
                            roundedClasses.value
                        ],
                        "style": backgroundColorStyles.value
                    }, [
                        !slots.default ? (0, _vue.createVNode)((0, _indexMjs1.VIcon), {
                            "key": "icon",
                            "color": props.iconColor,
                            "icon": props.icon,
                            "size": props.size
                        }, null) : (0, _vue.createVNode)((0, _indexMjs.VDefaultsProvider), {
                            "key": "icon-defaults",
                            "disabled": !props.icon,
                            "defaults": {
                                VIcon: {
                                    color: props.iconColor,
                                    icon: props.icon,
                                    size: props.size
                                }
                            }
                        }, slots.default)
                    ])
                ]),
                (0, _vue.createVNode)("div", {
                    "class": [
                        "v-timeline-divider__after",
                        lineColorClasses.value
                    ],
                    "style": lineColorStyles.value
                }, null)
            ]));
        return {};
    }
});

},{"vue":"ff77s","../VDefaultsProvider/index.mjs":"1OIgj","../VIcon/index.mjs":"2wJue","../../composables/color.mjs":"4pLYX","../../composables/component.mjs":"jVHld","../../composables/elevation.mjs":"3BDEa","../../composables/icons.mjs":"ezwoc","../../composables/rounded.mjs":"ldhZ9","../../composables/size.mjs":"jtF5F","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"8SqYH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VToolbar", ()=>(0, _vtoolbarMjs.VToolbar));
parcelHelpers.export(exports, "VToolbarTitle", ()=>(0, _vtoolbarTitleMjs.VToolbarTitle));
parcelHelpers.export(exports, "VToolbarItems", ()=>(0, _vtoolbarItemsMjs.VToolbarItems));
var _vtoolbarMjs = require("./VToolbar.mjs");
var _vtoolbarTitleMjs = require("./VToolbarTitle.mjs");
var _vtoolbarItemsMjs = require("./VToolbarItems.mjs");

},{"./VToolbar.mjs":"wCdRX","./VToolbarTitle.mjs":"i8vFv","./VToolbarItems.mjs":"5DXcZ","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5DXcZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVToolbarItemsProps", ()=>makeVToolbarItemsProps);
parcelHelpers.export(exports, "VToolbarItems", ()=>VToolbarItems);
var _vue = require("vue");
// Composables
var _componentMjs = require("../../composables/component.mjs");
var _defaultsMjs = require("../../composables/defaults.mjs");
var _variantMjs = require("../../composables/variant.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const makeVToolbarItemsProps = (0, _indexMjs.propsFactory)({
    ...(0, _componentMjs.makeComponentProps)(),
    ...(0, _variantMjs.makeVariantProps)({
        variant: "text"
    })
}, "VToolbarItems");
const VToolbarItems = (0, _indexMjs.genericComponent)()({
    name: "VToolbarItems",
    props: makeVToolbarItemsProps(),
    setup (props, _ref) {
        let { slots } = _ref;
        (0, _defaultsMjs.provideDefaults)({
            VBtn: {
                color: (0, _vue.toRef)(props, "color"),
                height: "inherit",
                variant: (0, _vue.toRef)(props, "variant")
            }
        });
        (0, _indexMjs.useRender)(()=>(0, _vue.createVNode)("div", {
                "class": [
                    "v-toolbar-items",
                    props.class
                ],
                "style": props.style
            }, [
                slots.default?.()
            ]));
        return {};
    }
});

},{"vue":"ff77s","../../composables/component.mjs":"jVHld","../../composables/defaults.mjs":"11B6w","../../composables/variant.mjs":"8A0hd","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2hfM9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VTooltip", ()=>(0, _vtooltipMjs.VTooltip));
var _vtooltipMjs = require("./VTooltip.mjs");

},{"./VTooltip.mjs":"2oxGm","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"2oxGm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeVTooltipProps", ()=>makeVTooltipProps);
parcelHelpers.export(exports, "VTooltip", ()=>VTooltip);
var _vue = require("vue");
// Styles
var _vtooltipCss = require("./VTooltip.css");
// Components
var _indexMjs = require("../VOverlay/index.mjs");
var _voverlayMjs = require("../VOverlay/VOverlay.mjs"); // Composables
var _forwardRefsMjs = require("../../composables/forwardRefs.mjs");
var _proxiedModelMjs = require("../../composables/proxiedModel.mjs");
var _scopeIdMjs = require("../../composables/scopeId.mjs"); // Utilities
var _indexMjs1 = require("../../util/index.mjs"); // Types
const makeVTooltipProps = (0, _indexMjs1.propsFactory)({
    id: String,
    text: String,
    ...(0, _indexMjs1.omit)((0, _voverlayMjs.makeVOverlayProps)({
        closeOnBack: false,
        location: "end",
        locationStrategy: "connected",
        eager: true,
        minWidth: 0,
        offset: 10,
        openOnClick: false,
        openOnHover: true,
        origin: "auto",
        scrim: false,
        scrollStrategy: "reposition",
        transition: false
    }), [
        "absolute",
        "persistent"
    ])
}, "VTooltip");
const VTooltip = (0, _indexMjs1.genericComponent)()({
    name: "VTooltip",
    props: makeVTooltipProps(),
    emits: {
        "update:modelValue": (value)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const isActive = (0, _proxiedModelMjs.useProxiedModel)(props, "modelValue");
        const { scopeId } = (0, _scopeIdMjs.useScopeId)();
        const uid = (0, _indexMjs1.getUid)();
        const id = (0, _vue.computed)(()=>props.id || `v-tooltip-${uid}`);
        const overlay = (0, _vue.ref)();
        const location = (0, _vue.computed)(()=>{
            return props.location.split(" ").length > 1 ? props.location : props.location + " center";
        });
        const origin = (0, _vue.computed)(()=>{
            return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
        });
        const transition = (0, _vue.computed)(()=>{
            if (props.transition) return props.transition;
            return isActive.value ? "scale-transition" : "fade-transition";
        });
        const activatorProps = (0, _vue.computed)(()=>(0, _vue.mergeProps)({
                "aria-describedby": id.value
            }, props.activatorProps));
        (0, _indexMjs1.useRender)(()=>{
            const [overlayProps] = (0, _indexMjs.VOverlay).filterProps(props);
            return (0, _vue.createVNode)((0, _indexMjs.VOverlay), (0, _vue.mergeProps)({
                "ref": overlay,
                "class": [
                    "v-tooltip",
                    props.class
                ],
                "style": props.style,
                "id": id.value
            }, overlayProps, {
                "modelValue": isActive.value,
                "onUpdate:modelValue": ($event)=>isActive.value = $event,
                "transition": transition.value,
                "absolute": true,
                "location": location.value,
                "origin": origin.value,
                "persistent": true,
                "role": "tooltip",
                "activatorProps": activatorProps.value,
                "_disableGlobalStack": true
            }, scopeId), {
                activator: slots.activator,
                default: function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                    return slots.default?.(...args) ?? props.text;
                }
            });
        });
        return (0, _forwardRefsMjs.forwardRefs)({}, overlay);
    }
});

},{"vue":"ff77s","./VTooltip.css":"26wIc","../VOverlay/index.mjs":"28W37","../VOverlay/VOverlay.mjs":"9nMvb","../../composables/forwardRefs.mjs":"h5grs","../../composables/proxiedModel.mjs":"bUF28","../../composables/scopeId.mjs":"78lmg","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"26wIc":[function() {},{}],"43TMr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VValidation", ()=>(0, _vvalidationMjs.VValidation));
var _vvalidationMjs = require("./VValidation.mjs");

},{"./VValidation.mjs":"27QQw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"27QQw":[function(require,module,exports) {
// Composables
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VValidation", ()=>VValidation);
var _validationMjs = require("../../composables/validation.mjs"); // Utilities
var _indexMjs = require("../../util/index.mjs");
const VValidation = (0, _indexMjs.genericComponent)()({
    name: "VValidation",
    props: (0, _validationMjs.makeValidationProps)(),
    emits: {
        "update:modelValue": (val)=>true
    },
    setup (props, _ref) {
        let { slots } = _ref;
        const validation = (0, _validationMjs.useValidation)(props, "validation");
        return ()=>slots.default?.(validation);
    }
});

},{"../../composables/validation.mjs":"1xYwD","../../util/index.mjs":"6uIWw","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"5nWwd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VWindow", ()=>(0, _vwindowMjs.VWindow));
parcelHelpers.export(exports, "VWindowItem", ()=>(0, _vwindowItemMjs.VWindowItem));
var _vwindowMjs = require("./VWindow.mjs");
var _vwindowItemMjs = require("./VWindowItem.mjs");

},{"./VWindow.mjs":"jFojd","./VWindowItem.mjs":"kFkAY","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"eAmda":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ClickOutside", ()=>(0, _indexMjs.ClickOutside)) // export { Color } from './color'
;
parcelHelpers.export(exports, "Intersect", ()=>(0, _indexMjs1.Intersect));
parcelHelpers.export(exports, "Mutate", ()=>(0, _indexMjs2.Mutate));
parcelHelpers.export(exports, "Resize", ()=>(0, _indexMjs3.Resize));
parcelHelpers.export(exports, "Ripple", ()=>(0, _indexMjs4.Ripple));
parcelHelpers.export(exports, "Scroll", ()=>(0, _indexMjs5.Scroll));
parcelHelpers.export(exports, "Touch", ()=>(0, _indexMjs6.Touch));
var _indexMjs = require("./click-outside/index.mjs");
var _indexMjs1 = require("./intersect/index.mjs");
var _indexMjs2 = require("./mutate/index.mjs");
var _indexMjs3 = require("./resize/index.mjs");
var _indexMjs4 = require("./ripple/index.mjs");
var _indexMjs5 = require("./scroll/index.mjs");
var _indexMjs6 = require("./touch/index.mjs");

},{"./click-outside/index.mjs":"gSpMV","./intersect/index.mjs":"jD88I","./mutate/index.mjs":"44I9S","./resize/index.mjs":"84yBx","./ripple/index.mjs":"fTBbe","./scroll/index.mjs":"ef52g","./touch/index.mjs":"aIkdf","@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"44I9S":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Mutate", ()=>Mutate);
function mounted(el, binding) {
    const modifiers = binding.modifiers || {};
    const value = binding.value;
    const { once, immediate, ...modifierKeys } = modifiers;
    const defaultValue = !Object.keys(modifierKeys).length;
    const { handler, options } = typeof value === "object" ? value : {
        handler: value,
        options: {
            attributes: modifierKeys?.attr ?? defaultValue,
            characterData: modifierKeys?.char ?? defaultValue,
            childList: modifierKeys?.child ?? defaultValue,
            subtree: modifierKeys?.sub ?? defaultValue
        }
    };
    const observer = new MutationObserver(function() {
        let mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        let observer = arguments.length > 1 ? arguments[1] : undefined;
        handler?.(mutations, observer);
        if (once) unmounted(el, binding);
    });
    if (immediate) handler?.([], observer);
    el._mutate = Object(el._mutate);
    el._mutate[binding.instance.$.uid] = {
        observer
    };
    observer.observe(el, options);
}
function unmounted(el, binding) {
    if (!el._mutate?.[binding.instance.$.uid]) return;
    el._mutate[binding.instance.$.uid].observer.disconnect();
    delete el._mutate[binding.instance.$.uid];
}
const Mutate = {
    mounted,
    unmounted
};
exports.default = Mutate;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"84yBx":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Resize", ()=>Resize);
function mounted(el, binding) {
    const handler = binding.value;
    const options = {
        passive: !binding.modifiers?.active
    };
    window.addEventListener("resize", handler, options);
    el._onResize = Object(el._onResize);
    el._onResize[binding.instance.$.uid] = {
        handler,
        options
    };
    if (!binding.modifiers?.quiet) handler();
}
function unmounted(el, binding) {
    if (!el._onResize?.[binding.instance.$.uid]) return;
    const { handler, options } = el._onResize[binding.instance.$.uid];
    window.removeEventListener("resize", handler, options);
    delete el._onResize[binding.instance.$.uid];
}
const Resize = {
    mounted,
    unmounted
};
exports.default = Resize;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"ef52g":[function(require,module,exports) {
// Types
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Scroll", ()=>Scroll);
function mounted(el, binding) {
    const { self = false } = binding.modifiers ?? {};
    const value = binding.value;
    const options = typeof value === "object" && value.options || {
        passive: true
    };
    const handler = typeof value === "function" || "handleEvent" in value ? value : value.handler;
    const target = self ? el : binding.arg ? document.querySelector(binding.arg) : window;
    if (!target) return;
    target.addEventListener("scroll", handler, options);
    el._onScroll = Object(el._onScroll);
    el._onScroll[binding.instance.$.uid] = {
        handler,
        options,
        // Don't reference self
        target: self ? undefined : target
    };
}
function unmounted(el, binding) {
    if (!el._onScroll?.[binding.instance.$.uid]) return;
    const { handler, options, target = el } = el._onScroll[binding.instance.$.uid];
    target.removeEventListener("scroll", handler, options);
    delete el._onScroll[binding.instance.$.uid];
}
function updated(el, binding) {
    if (binding.value === binding.oldValue) return;
    unmounted(el, binding);
    mounted(el, binding);
}
const Scroll = {
    mounted,
    unmounted,
    updated
};
exports.default = Scroll;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"j7FRh"}],"bfPBV":[function() {},{}]},["kbofY","57jqn"], "57jqn", "parcelRequiredcf9")

